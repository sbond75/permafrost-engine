../anim/anim.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../anim/anim.c:80:    for(int i = 0; i < data->num_anims; i++) {
../anim/anim.c:82:        const struct anim_clip *curr = &data->anims[i];
../anim/anim.c:83:        if(!strcmp(curr->name, name)) 
../anim/anim.c:95:    PFM_Mat4x4_MakeScale(sqt->scale.x, sqt->scale.y, sqt->scale.z, &scale);
../anim/anim.c:96:    PFM_Mat4x4_MakeTrans(sqt->trans.x, sqt->trans.y, sqt->trans.z, &trans);
../anim/anim.c:97:    PFM_Mat4x4_RotFromQuat(&sqt->quat_rotation, &rot);
../anim/anim.c:110:    /* Walk up the bone heirarchy, multiplying our bind transform matrix by the parent-relative
../anim/anim.c:113:     * origin of its' local space, this gives us the object-space position of this joint in the bind
../anim/anim.c:118:        struct joint *joint = &skel->joints[joint_idx];
../anim/anim.c:119:        struct SQT   *bind_sqt = &skel->bind_sqts[joint_idx];
../anim/anim.c:125:        joint_idx = joint->parent_idx;
../anim/anim.c:134:    struct anim_sample *sample = &ctx->active->samples[ctx->curr_frame];
../anim/anim.c:142:        struct joint *joint = &skel->joints[joint_idx];
../anim/anim.c:143:        struct SQT   *pose_sqt = &sample->local_joint_poses[joint_idx];
../anim/anim.c:149:        joint_idx = joint->parent_idx;
../anim/anim.c:162:    const struct anim_clip *clip = a_clip_for_name(ctx->data, name);
../anim/anim.c:165:    ctx->idle = clip;
../anim/anim.c:173:    const struct anim_clip *clip = a_clip_for_name(ctx->data, name);
../anim/anim.c:176:    ctx->active = clip;
../anim/anim.c:177:    ctx->mode = mode;
../anim/anim.c:178:    ctx->key_fps = key_fps;
../anim/anim.c:179:    ctx->curr_frame = 0;
../anim/anim.c:180:    ctx->curr_frame_start_ticks = SDL_GetTicks();
../anim/anim.c:191:        float frame_period_secs = 1.0f/ctx->key_fps;
../anim/anim.c:192:        float elapsed_secs = (curr_ticks - ctx->curr_frame_start_ticks)/1000.0f;
../anim/anim.c:196:            ctx->curr_frame = (ctx->curr_frame + 1) % ctx->active->num_frames;
../anim/anim.c:197:            ctx->curr_frame_start_ticks = curr_ticks;
../anim/anim.c:199:            if(ctx->curr_frame == ctx->active->num_frames - 1) {
../anim/anim.c:202:                if(ctx->mode == ANIM_MODE_ONCE) {
../anim/anim.c:207:            if(ctx->curr_frame == 0 && ctx->mode == ANIM_MODE_ONCE) {
../anim/anim.c:208:                A_SetActiveClip(uid, ctx->idle->name, ANIM_MODE_LOOP, ctx->key_fps);
../anim/anim.c:218:    const struct anim_data *data = ctx->data;
../anim/anim.c:220:    for(int j = 0; j < data->skel.num_joints; j++) {
../anim/anim.c:221:        a_make_pose_mat(uid, j, &data->skel, out_curr_pose + j);
../anim/anim.c:224:    *out_njoints = data->skel.num_joints;
../anim/anim.c:225:    *out_inv_bind_pose = data->skel.inv_bind_poses;
../anim/anim.c:231:    return &ctx->data->skel;
../anim/anim.c:237:    const struct anim_data *data = ctx->data;
../anim/anim.c:238:    size_t num_joints = data->skel.num_joints;
../anim/anim.c:242:     *  +---------------------------------+ <-- base
../anim/anim.c:244:     *  +---------------------------------+
../anim/anim.c:246:     *  +---------------------------------+
../anim/anim.c:248:     *  +---------------------------------+
../anim/anim.c:250:     *  +---------------------------------+
../anim/anim.c:259:    ret->num_joints = data->skel.num_joints;
../anim/anim.c:260:    ret->joints = (void*)(ret + 1);
../anim/anim.c:261:    memcpy(ret->joints, data->skel.joints, num_joints * sizeof(struct joint));
../anim/anim.c:263:    ret->bind_sqts = (void*)((char*)ret->joints + num_joints * sizeof(struct joint));
../anim/anim.c:264:    memcpy(ret->bind_sqts, data->skel.bind_sqts, num_joints * sizeof(struct SQT));
../anim/anim.c:266:    ret->inv_bind_poses = (void*)((char*)ret->bind_sqts + num_joints * sizeof(struct SQT));
../anim/anim.c:268:    for(int i = 0; i < ret->num_joints; i++) {
../anim/anim.c:273:        PFM_Mat4x4_Inverse(&pose_mat, &ret->inv_bind_poses[i]);
../anim/anim.c:281:    assert(skel->inv_bind_poses);
../anim/anim.c:283:    for(int i = 0; i < skel->num_joints; i++) {
../anim/anim.c:287:        PFM_Mat4x4_Inverse(&bind_mat, &skel->inv_bind_poses[i]);
../anim/anim.c:294:    return &ctx->active->samples[ctx->curr_frame].sample_aabb;
../anim/anim.c:300:    ctx->curr_frame_start_ticks += dt;
../anim/anim.c:306:    return ctx->idle->name;
../anim/anim.c:312:    return ctx->active->name;
../anim/anim.c:318:    if(idx >= ctx->data->num_anims)
../anim/anim.c:320:    return ctx->data->anims[0].name;
../anim/anim.c:326:    const struct anim_clip *clip = a_clip_for_name(ctx->data, name);
../anim/anim.c:335:    pf_snprintf(active.val.as_string, sizeof(active.val.as_string), "%s", ctx->active->name);
../anim/anim.c:339:    pf_snprintf(idle.val.as_string, sizeof(idle.val.as_string), "%s", ctx->idle->name);
../anim/anim.c:344:        .val.as_int = ctx->mode
../anim/anim.c:350:        .val.as_int = ctx->key_fps
../anim/anim.c:356:        .val.as_int = ctx->curr_frame
../anim/anim.c:362:        .val.as_int = SDL_GetTicks() - ctx->curr_frame_start_ticks
../anim/anim.c:376:    const struct anim_clip *active_clip = a_clip_for_name(ctx->data, attr.val.as_string);
../anim/anim.c:378:    ctx->active = active_clip;
../anim/anim.c:382:    const struct anim_clip *idle_clip = a_clip_for_name(ctx->data, attr.val.as_string);
../anim/anim.c:384:    ctx->idle = idle_clip;
../anim/anim.c:388:    ctx->mode = attr.val.as_int;
../anim/anim.c:392:    ctx->key_fps = attr.val.as_int;
../anim/anim.c:396:    ctx->curr_frame = attr.val.as_int;
../anim/anim.c:400:    ctx->curr_frame_start_ticks = SDL_GetTicks() - attr.val.as_int;
../anim/anim.c:419:    khiter_t k = kh_put(ctx, s_anim_ctx, ent->uid, &status);
../anim/anim.c:420:    if(status == -1 || status == 0)
../anim/anim.c:424:    ctx->data = ent->anim_private;
../anim/anim.c:426:    A_SetIdleClip(ent->uid, A_GetClip(ent->uid, 0), 24);
../anim/anim.c:432:    khiter_t k = kh_get(ctx, s_anim_ctx, ent->uid);
../anim/anim_asset_load.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../anim/anim_asset_load.c:57:    if(!sscanf(line, "j %d %s", &unfixed_idx, out->name))
../anim/anim_asset_load.c:59:    /* Convert to a 0 base index system; the root's parent_idx will be -1 */
../anim/anim_asset_load.c:60:    out->parent_idx = unfixed_idx - 1;
../anim/anim_asset_load.c:72:        &out_bind->scale.x, &out_bind->scale.y, &out_bind->scale.z))
../anim/anim_asset_load.c:76:    if(!sscanf(string, "%f/%f/%f/%f", &out_bind->quat_rotation.x, &out_bind->quat_rotation.y, 
../anim/anim_asset_load.c:77:        &out_bind->quat_rotation.z, &out_bind->quat_rotation.w))
../anim/anim_asset_load.c:82:        &out_bind->trans.x, &out_bind->trans.y, &out_bind->trans.z))
../anim/anim_asset_load.c:86:    if(!sscanf(string, "%f/%f/%f", &out->tip.x, &out->tip.y, &out->tip.z))
../anim/anim_asset_load.c:101:    if(!sscanf(line, "as %s %u", out->name, &out->num_frames))
../anim/anim_asset_load.c:104:    for(int f = 0; f < out->num_frames; f++) {
../anim/anim_asset_load.c:105:        for(int j = 0; j < header->num_joints; j++) {
../anim/anim_asset_load.c:108:            struct SQT *curr_joint_trans = &out->samples[f].local_joint_poses[j];
../anim/anim_asset_load.c:113:                &curr_joint_trans->scale.x,
../anim/anim_asset_load.c:114:                &curr_joint_trans->scale.y,
../anim/anim_asset_load.c:115:                &curr_joint_trans->scale.z,
../anim/anim_asset_load.c:116:                &curr_joint_trans->quat_rotation.x,
../anim/anim_asset_load.c:117:                &curr_joint_trans->quat_rotation.y,
../anim/anim_asset_load.c:118:                &curr_joint_trans->quat_rotation.z,
../anim/anim_asset_load.c:119:                &curr_joint_trans->quat_rotation.w,
../anim/anim_asset_load.c:120:                &curr_joint_trans->trans.x,
../anim/anim_asset_load.c:121:                &curr_joint_trans->trans.y,
../anim/anim_asset_load.c:122:                &curr_joint_trans->trans.z)) {
../anim/anim_asset_load.c:128:        if(!header->has_collision)
../anim/anim_asset_load.c:131:        if(!AL_ParseAABB(stream, &out->samples[f].sample_aabb))
../anim/anim_asset_load.c:147:    ret += header->num_joints * sizeof(struct SQT);
../anim/anim_asset_load.c:148:    ret += header->num_joints * sizeof(mat4x4_t);
../anim/anim_asset_load.c:149:    ret += header->num_joints * sizeof(struct joint);
../anim/anim_asset_load.c:150:    ret += header->num_as     * sizeof(struct anim_clip);
../anim/anim_asset_load.c:159:    for(unsigned as_idx  = 0; as_idx < header->num_as; as_idx++) {
../anim/anim_asset_load.c:161:        ret += header->frame_counts[as_idx] * 
../anim/anim_asset_load.c:162:               (sizeof(struct anim_sample) + header->num_joints * sizeof(struct SQT));
../anim/anim_asset_load.c:180: *  +---------------------------------+ <-- base
../anim/anim_asset_load.c:182: *  +---------------------------------+
../anim/anim_asset_load.c:184: *  +---------------------------------+
../anim/anim_asset_load.c:186: *  +---------------------------------+
../anim/anim_asset_load.c:188: *  +---------------------------------+
../anim/anim_asset_load.c:190: *  +---------------------------------+
../anim/anim_asset_load.c:193: *  +---------------------------------+
../anim/anim_asset_load.c:195: *  |    (stored in clip-major order) |
../anim/anim_asset_load.c:196: *  +---------------------------------+
../anim/anim_asset_load.c:206:    /*-----------------------------------------------------------
../anim/anim_asset_load.c:209:     *-----------------------------------------------------------
../anim/anim_asset_load.c:214:    ret->num_anims = header->num_as; 
../anim/anim_asset_load.c:215:    ret->skel.num_joints = header->num_joints;
../anim/anim_asset_load.c:217:    ret->skel.bind_sqts = (void*)unused_base;
../anim/anim_asset_load.c:218:    unused_base += sizeof(struct SQT) * header->num_joints;
../anim/anim_asset_load.c:220:    ret->skel.inv_bind_poses = (void*)unused_base;
../anim/anim_asset_load.c:221:    unused_base += sizeof(mat4x4_t) * header->num_joints;
../anim/anim_asset_load.c:223:    ret->skel.joints = (void*)unused_base;
../anim/anim_asset_load.c:224:    unused_base += sizeof(struct joint) * header->num_joints;
../anim/anim_asset_load.c:226:    ret->anims = (void*)unused_base;
../anim/anim_asset_load.c:227:    unused_base += sizeof(struct anim_clip) * header->num_as;
../anim/anim_asset_load.c:229:    for(int i = 0; i < header->num_as; i++) {
../anim/anim_asset_load.c:231:        ret->anims[i].samples = (void*)unused_base;
../anim/anim_asset_load.c:232:        unused_base += sizeof(struct anim_sample) * header->frame_counts[i];
../anim/anim_asset_load.c:235:    for(int i = 0; i < header->num_as; i++) {
../anim/anim_asset_load.c:237:        ret->anims[i].skel = &ret->skel;
../anim/anim_asset_load.c:238:        ret->anims[i].num_frames = header->frame_counts[i];
../anim/anim_asset_load.c:240:        for(int f = 0; f < header->frame_counts[i]; f++) {
../anim/anim_asset_load.c:242:            ret->anims[i].samples[f].local_joint_poses = (void*)unused_base;
../anim/anim_asset_load.c:243:            unused_base += sizeof(struct SQT) * header->num_joints;
../anim/anim_asset_load.c:247:    /*---------------------------------------------------------------
../anim/anim_asset_load.c:249:     *---------------------------------------------------------------
../anim/anim_asset_load.c:251:    for(int i = 0; i < header->num_joints; i++) {
../anim/anim_asset_load.c:253:        if(!al_read_joint(stream, &ret->skel.joints[i], &ret->skel.bind_sqts[i]))
../anim/anim_asset_load.c:257:    for(int i = 0; i < header->num_as; i++) {
../anim/anim_asset_load.c:259:        if(!al_read_anim_clip(stream, &ret->anims[i], header))
../anim/anim_asset_load.c:263:    A_PrepareInvBindMatrices(&ret->skel);
../anim/anim_asset_load.c:277:    for(int i = 0; i < priv->skel.num_joints; i++) {
../anim/anim_asset_load.c:279:        struct joint *j = &priv->skel.joints[i];
../anim/anim_asset_load.c:280:        struct SQT *bind = &priv->skel.bind_sqts[i];
../anim/anim_asset_load.c:283:        PFM_Quat_ToEuler(&bind->quat_rotation, &roll, &pitch, &yaw);
../anim/anim_asset_load.c:285:        fprintf(stream, "j %d %s ", j->parent_idx + 1, j->name); 
../anim/anim_asset_load.c:287:            bind->scale.x, bind->scale.y, bind->scale.z, 
../anim/anim_asset_load.c:289:            bind->trans.x, bind->trans.y, bind->trans.z,
../anim/anim_asset_load.c:290:            j->tip.x,      j->tip.y,      j->tip.z);
../anim/anim_asset_load.c:294:    for(int i = 0; i < priv->num_anims; i++) {
../anim/anim_asset_load.c:296:        struct anim_clip *ac = &priv->anims[i];
../anim/anim_asset_load.c:297:        fprintf(stream, "as %s %d\n", ac->name, ac->num_frames); 
../anim/anim_asset_load.c:299:        for(int f = 0; f < ac->num_frames; f++) {
../anim/anim_asset_load.c:300:            for(int j = 0; j < ac->skel->num_joints; j++) {
../anim/anim_asset_load.c:302:                struct SQT *sqt = &ac->samples[f].local_joint_poses[j]; 
../anim/anim_asset_load.c:305:                PFM_Quat_ToEuler(&sqt->quat_rotation, &roll, &pitch, &yaw);
../anim/anim_asset_load.c:309:                    sqt->scale.x, sqt->scale.y, sqt->scale.z,
../anim/anim_asset_load.c:311:                    sqt->trans.x, sqt->trans.y, sqt->trans.z);
../anim/anim_ctx.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../anim/anim_data.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../anim/anim_private.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../anim/anim_private.h:46: * pointed to by 'skel->inv_bind_poses' which is expected to be 
../anim/public/anim.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../anim/public/anim.h:61:/* ---------------------------------------------------------------------------
../anim/public/anim.h:63: * ---------------------------------------------------------------------------
../anim/public/anim.h:68:/* ---------------------------------------------------------------------------
../anim/public/anim.h:72: * ---------------------------------------------------------------------------
../anim/public/anim.h:77:/* ---------------------------------------------------------------------------
../anim/public/anim.h:79: * ---------------------------------------------------------------------------
../anim/public/anim.h:85:/* ---------------------------------------------------------------------------
../anim/public/anim.h:88: * ---------------------------------------------------------------------------
../anim/public/anim.h:92:/* ---------------------------------------------------------------------------
../anim/public/anim.h:98: * ---------------------------------------------------------------------------
../anim/public/anim.h:102:/* ---------------------------------------------------------------------------
../anim/public/anim.h:105: * ---------------------------------------------------------------------------
../anim/public/anim.h:109:/* ---------------------------------------------------------------------------
../anim/public/anim.h:112: * ---------------------------------------------------------------------------
../anim/public/anim.h:116:/* ---------------------------------------------------------------------------
../anim/public/anim.h:119: * ---------------------------------------------------------------------------
../anim/public/anim.h:123:/* ---------------------------------------------------------------------------
../anim/public/anim.h:126: * ---------------------------------------------------------------------------
../anim/public/anim.h:130:/* ---------------------------------------------------------------------------
../anim/public/anim.h:132: * ---------------------------------------------------------------------------
../anim/public/anim.h:136:/* ---------------------------------------------------------------------------
../anim/public/anim.h:138: * ---------------------------------------------------------------------------
../anim/public/anim.h:142:/* ---------------------------------------------------------------------------
../anim/public/anim.h:144: * ---------------------------------------------------------------------------
../anim/public/anim.h:148:/* ---------------------------------------------------------------------------
../anim/public/anim.h:150: * ---------------------------------------------------------------------------
../anim/public/anim.h:154:/* ---------------------------------------------------------------------------
../anim/public/anim.h:156: * ---------------------------------------------------------------------------
../anim/public/anim.h:161:/* ---------------------------------------------------------------------------
../anim/public/anim.h:163: * ---------------------------------------------------------------------------
../anim/public/anim.h:168:/* ---------------------------------------------------------------------------
../anim/public/anim.h:171: * ---------------------------------------------------------------------------
../anim/public/anim.h:179:/* ---------------------------------------------------------------------------
../anim/public/anim.h:182: * ---------------------------------------------------------------------------
../anim/public/anim.h:186:/* ---------------------------------------------------------------------------
../anim/public/anim.h:189: * ---------------------------------------------------------------------------
../anim/public/anim.h:193:/* ---------------------------------------------------------------------------
../anim/public/anim.h:195: * ---------------------------------------------------------------------------
../anim/public/skeleton.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../asset_load.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../asset_load.c:96:    if(!sscanf(line, "version %f", &out->version))
../asset_load.c:100:    if(!sscanf(line, "num_verts %d", &out->num_verts))
../asset_load.c:104:    if(!sscanf(line, "num_joints %d", &out->num_joints))
../asset_load.c:108:    if(!sscanf(line, "num_materials %d", &out->num_materials))
../asset_load.c:112:    if(!sscanf(line, "num_as %d", &out->num_as))
../asset_load.c:115:    if(out->num_as > MAX_ANIM_SETS)
../asset_load.c:127:    for(int i = 0; i < out->num_as; i++) {
../asset_load.c:133:        if(!sscanf(string, "%d", &out->frame_counts[i]))
../asset_load.c:141:    out->has_collision = tmp;
../asset_load.c:154:    if(!sscanf(line, "version %f", &out->version))
../asset_load.c:158:    if(!sscanf(line, "num_materials %d", &out->num_materials))
../asset_load.c:162:    if(!sscanf(line, "num_rows %d", &out->num_rows))
../asset_load.c:166:    if(!sscanf(line, "num_cols %d", &out->num_cols))
../asset_load.c:198:    out->ent_flags = 0;
../asset_load.c:199:    out->render_private = R_AL_PrivFromStream(abs_basedir, &header, stream);
../asset_load.c:200:    if(!out->render_private)
../asset_load.c:203:    out->anim_private = A_AL_PrivFromStream(&header, stream);
../asset_load.c:204:    if(!out->anim_private)
../asset_load.c:208:        out->ent_flags |= ENTITY_FLAG_ANIMATED;
../asset_load.c:216:    if(!AL_ParseAABB(stream, &out->aabb))
../asset_load.c:219:    out->basedir = pf_strdup(basedir);
../asset_load.c:220:    out->filename = pf_strdup(pfobj_name);
../asset_load.c:224:    assert(put_ret != -1 && put_ret != 0);
../asset_load.c:251:    ret->flags = 0;
../asset_load.c:252:    ret->name = pf_strdup(name);
../asset_load.c:253:    ret->filename = pf_strdup(pfobj_name);
../asset_load.c:254:    ret->basedir = pf_strdup(base_path);
../asset_load.c:256:    if(!ret->name || !ret->filename || !ret->basedir)
../asset_load.c:262:    ret->flags |= res.ent_flags;
../asset_load.c:263:    ret->render_private = res.render_private;
../asset_load.c:264:    ret->anim_private = res.anim_private;
../asset_load.c:265:    ret->identity_aabb = res.aabb;
../asset_load.c:266:    ret->uid = uid;
../asset_load.c:273:    PF_FREE(ret->basedir);
../asset_load.c:274:    PF_FREE(ret->filename);
../asset_load.c:275:    PF_FREE(ret->name);
../asset_load.c:286:    pf_snprintf(old_pfobj_path, sizeof(old_pfobj_path), "%s/%s/%s", g_basepath, ent->basedir, ent->filename);
../asset_load.c:289:    if(!al_get_resource(old_pfobj_path, ent->basedir, ent->filename, &old_res))
../asset_load.c:300:    if(ent->flags & ENTITY_FLAG_ANIMATED) {
../asset_load.c:303:    ent->flags &= ~old_res.ent_flags;
../asset_load.c:305:    PF_FREE(ent->basedir);
../asset_load.c:306:    PF_FREE(ent->filename);
../asset_load.c:307:    ent->basedir = newdir;
../asset_load.c:308:    ent->filename = newobj;
../asset_load.c:310:    ent->render_private = new_res.render_private;
../asset_load.c:311:    ent->anim_private = new_res.anim_private;
../asset_load.c:312:    ent->identity_aabb = new_res.aabb;
../asset_load.c:314:    ent->flags |= new_res.ent_flags;
../asset_load.c:315:    if(ent->flags & ENTITY_FLAG_ANIMATED) {
../asset_load.c:329:    PF_FREE(entity->basedir);
../asset_load.c:330:    PF_FREE(entity->filename);
../asset_load.c:331:    PF_FREE(entity->name);
../asset_load.c:434:            /* nuke the carriage return before the newline - to give a consistent 
../asset_load.c:436:            if(idx && outbuff[idx-1] == '\r') {
../asset_load.c:437:                outbuff[idx-1] = '\n';
../asset_load.c:445:    }while(idx < MAX_LINE_LEN-1);
../asset_load.c:455:    if(!sscanf(line, " x_bounds %f %f", &out->x_min, &out->x_max))
../asset_load.c:459:    if(!sscanf(line, " y_bounds %f %f", &out->y_min, &out->y_max))
../asset_load.c:463:    if(!sscanf(line, " z_bounds %f %f", &out->z_min, &out->z_max))
../asset_load.c:508:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->center };
../asset_load.c:511:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->axes[0] };
../asset_load.c:513:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->axes[1] };
../asset_load.c:515:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->axes[2] };
../asset_load.c:518:    curr = (struct attr){.type = TYPE_FLOAT, .val.as_float = obb->half_lengths[0] };
../asset_load.c:520:    curr = (struct attr){.type = TYPE_FLOAT, .val.as_float = obb->half_lengths[1] };
../asset_load.c:522:    curr = (struct attr){.type = TYPE_FLOAT, .val.as_float = obb->half_lengths[2] };
../asset_load.c:525:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[0] };
../asset_load.c:527:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[1] };
../asset_load.c:529:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[2] };
../asset_load.c:531:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[3] };
../asset_load.c:533:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[4] };
../asset_load.c:535:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[5] };
../asset_load.c:537:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[6] };
../asset_load.c:539:    curr = (struct attr){.type = TYPE_VEC3, .val.as_vec3 = obb->corners[7] };
../asset_load.c:551:    out->center = attr.val.as_vec3;
../asset_load.c:555:    out->axes[0] = attr.val.as_vec3;
../asset_load.c:559:    out->axes[1] = attr.val.as_vec3;
../asset_load.c:563:    out->axes[2] = attr.val.as_vec3;
../asset_load.c:567:    out->half_lengths[0] = attr.val.as_float;
../asset_load.c:571:    out->half_lengths[1] = attr.val.as_float;
../asset_load.c:575:    out->half_lengths[2] = attr.val.as_float;
../asset_load.c:579:    out->corners[0] = attr.val.as_vec3;
../asset_load.c:583:    out->corners[1] = attr.val.as_vec3;
../asset_load.c:587:    out->corners[2] = attr.val.as_vec3;
../asset_load.c:591:    out->corners[3] = attr.val.as_vec3;
../asset_load.c:595:    out->corners[4] = attr.val.as_vec3;
../asset_load.c:599:    out->corners[5] = attr.val.as_vec3;
../asset_load.c:603:    out->corners[6] = attr.val.as_vec3;
../asset_load.c:607:    out->corners[7] = attr.val.as_vec3;
../asset_load.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../asset_load.h:51:        buff[MAX_LINE_LEN - 1] = '\0';                  \
../audio/al_assert.h:56:#define AL_ASSERT_OK() /* no-op */
../audio/al_audio.c:109:    ALenum format = -1;
../audio/al_audio.c:144:    out->buffer = buffer;
../audio/al_audio.c:145:    out->format = format;
../audio/al_audio.c:151:    alDeleteBuffers(1, &buff->buffer);
../audio/al_audio.c:214:        name[strlen(name) - strlen(".wav")] = '\0';
../audio/al_audio.c:224:        if(status == -1) {
../audio/al_audio.c:237:    if(val->type != ST_TYPE_FLOAT)
../audio/al_audio.c:239:    if(val->as_float < 0.0f || val->as_float > 1.0f)
../audio/al_audio.c:246:    s_master_volume = val->as_float;
../audio/al_audio.c:253:    s_music_volume = val->as_float;
../audio/al_audio.c:260:    return (val->type == ST_TYPE_BOOL);
../audio/al_audio.c:265:    s_mute_on_focus_loss = val->as_bool;
../audio/al_audio.c:270:    if(val->type != ST_TYPE_INT)
../audio/al_audio.c:272:    if(val->as_int < 0 || val->as_int > MUSIC_MODE_SHUFFLE)
../audio/al_audio.c:279:    s_music_mode = val->as_int;
../audio/al_audio.c:354:    switch(event->event) {
../audio/al_audio.c:396:    int curr_idx = -1;
../audio/al_audio.c:416:            tracks[curr_idx] = tracks[--ntracks];
../audio/al_effect.c:98:    return (a->uid == b->uid);
../audio/al_effect.c:105:    return (effa->uid - effb->uid);
../audio/al_effect.c:120:        vec2_t xz_pos = (vec2_t){curr->pos.x, curr->pos.z};
../audio/al_effect.c:124:        if(SDL_TICKS_PASSED(SDL_GetTicks(), curr->end_tick))
../audio/al_effect.c:143:    alGetSourcei(effect->source, AL_SOURCE_STATE, &state);
../audio/al_effect.c:147:    uint32_t elapsed = curr - effect->start_tick;
../audio/al_effect.c:148:    uint32_t total = effect->end_tick - effect->start_tick;
../audio/al_effect.c:151:    alGetSourcei(effect->source, AL_BUFFER, &buffer);
../audio/al_effect.c:155:    sample_offset = MIN(sample_offset, nsamples-1);
../audio/al_effect.c:156:    alSourcei(effect->source, AL_SAMPLE_OFFSET, sample_offset);
../audio/al_effect.c:169:    qsort(curr->array, n, sizeof(struct al_effect), compare_effects);
../audio/al_effect.c:170:    qsort(prev->array, m, sizeof(struct al_effect), compare_effects);
../audio/al_effect.c:179:        if(curr->array[i].uid < prev->array[j].uid) {
../audio/al_effect.c:180:            vec_effect_push(added, curr->array[i]);
../audio/al_effect.c:182:        }else if(prev->array[j].uid < curr->array[i].uid) {
../audio/al_effect.c:183:            vec_effect_push(removed, prev->array[j]);
../audio/al_effect.c:192:        vec_effect_push(added, curr->array[i]);
../audio/al_effect.c:197:        vec_effect_push(removed, prev->array[j]);
../audio/al_effect.c:219:        alSourcef(curr->source, AL_GAIN, s_effect_volume);
../audio/al_effect.c:220:        alSourcePlay(curr->source);
../audio/al_effect.c:221:        /* We couldn't play the source - possibly due to hitting 
../audio/al_effect.c:227:            alSourceStop(curr->source);
../audio/al_effect.c:236:        alSourceStop(curr->source);
../audio/al_effect.c:237:        alSourceRewind(curr->source);
../audio/al_effect.c:264:    float xmin = center.x - (res.tile_w * res.chunk_w * X_COORDS_PER_TILE) / 2.0f;
../audio/al_effect.c:266:    float zmin = center.z - (res.tile_h * res.chunk_h * Z_COORDS_PER_TILE) / 2.0f;
../audio/al_effect.c:279:    for(int i = vec_size(&s_effects)-1; i >= 0; i--) {
../audio/al_effect.c:285:        if(idx != -1)
../audio/al_effect.c:300:    if(val->type != ST_TYPE_FLOAT)
../audio/al_effect.c:302:    if(val->as_float < 0.0f || val->as_float > 10.0f)
../audio/al_effect.c:309:    s_effect_volume = val->as_float;
../audio/al_effect.c:313:        alSourcef(curr->source, AL_GAIN, s_effect_volume);
../audio/al_effect.c:358:    alGetSourcei(effect->source, AL_BUFFER, &buffer);
../audio/al_effect.c:367:        .val.as_int = effect->uid
../audio/al_effect.c:373:        .val.as_vec3 = effect->pos
../audio/al_effect.c:378:    alGetSourcei(effect->source, AL_SAMPLE_OFFSET, &offset);
../audio/al_effect.c:386:    alGetSourcei(effect->source, AL_SOURCE_STATE, &state);
../audio/al_effect.c:459:        uint32_t start_tick = SDL_GetTicks() - elapsed * 1000;
../audio/al_effect.c:493:    const float min = -1024.0;
../audio/al_effect.c:524:        alSourceStop(curr->source);
../audio/al_effect.c:529:        alDeleteSources(1, &curr->source);
../audio/al_effect.c:578:        alSourcePause(curr->source);
../audio/al_effect.c:586:        alSourcePlay(curr->source);
../audio/al_effect.c:587:        curr->start_tick += dt;
../audio/al_effect.c:588:        curr->end_tick += dt;
../audio/al_effect.c:596:        alSourceStop(curr->source);
../audio/al_effect.c:600:        alDeleteSources(1, &curr->source);
../cam_control.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../cam_control.c:135:    switch(e->key.keysym.scancode) {
../cam_control.c:137:        ctx->front_pressed_tick = curr_tick;
../cam_control.c:138:        ctx->front_state = KEY_PRESSED;
../cam_control.c:141:        ctx->left_pressed_tick = curr_tick;
../cam_control.c:142:        ctx->left_state = KEY_PRESSED;
../cam_control.c:145:        ctx->back_pressed_tick = curr_tick;
../cam_control.c:146:        ctx->back_state = KEY_PRESSED;
../cam_control.c:149:        ctx->right_pressed_tick = curr_tick;
../cam_control.c:150:        ctx->right_state = KEY_PRESSED;
../cam_control.c:165:    switch(e->key.keysym.scancode) {
../cam_control.c:167:        ctx->front_released_tick = curr_tick;
../cam_control.c:168:        ctx->front_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:171:        ctx->left_released_tick = curr_tick;
../cam_control.c:172:        ctx->left_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:175:        ctx->back_released_tick = curr_tick;
../cam_control.c:176:        ctx->back_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:179:        ctx->right_released_tick = curr_tick;
../cam_control.c:180:        ctx->right_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:191:    Camera_ChangeDirection(cam, e->motion.xrel, e->motion.yrel);
../cam_control.c:200:    if((ctx->front_state == KEY_RELEASED_NO_TIMEOUT)
../cam_control.c:201:    && (curr_tick - ctx->front_released_tick > KEYUP_TICKS_TIMEOUT))
../cam_control.c:202:        ctx->front_state = KEY_RELEASED;
../cam_control.c:204:    if(ctx->left_state == KEY_RELEASED_NO_TIMEOUT
../cam_control.c:205:    && curr_tick - ctx->left_released_tick > KEYUP_TICKS_TIMEOUT)
../cam_control.c:206:        ctx->left_state = KEY_RELEASED;
../cam_control.c:208:    if(ctx->back_state == KEY_RELEASED_NO_TIMEOUT
../cam_control.c:209:    && curr_tick - ctx->back_released_tick > KEYUP_TICKS_TIMEOUT)
../cam_control.c:210:        ctx->back_state = KEY_RELEASED;
../cam_control.c:212:    if(ctx->right_state == KEY_RELEASED_NO_TIMEOUT
../cam_control.c:213:    && curr_tick - ctx->right_released_tick > KEYUP_TICKS_TIMEOUT)
../cam_control.c:214:        ctx->right_state = KEY_RELEASED;
../cam_control.c:218:    PFM_Vec3_Scale(&front, -1.0f, &back);
../cam_control.c:221:    vec3_t xz = (vec3_t){front.z, 0.0f, -front.x};
../cam_control.c:227:    PFM_Vec3_Scale(&left, -1.0f, &right);
../cam_control.c:231:    if(ctx->front_state != KEY_RELEASED) PFM_Vec3_Add(&dir, &front, &dir);
../cam_control.c:232:    if(ctx->left_state != KEY_RELEASED)  PFM_Vec3_Add(&dir, &left, &dir);
../cam_control.c:233:    if(ctx->back_state != KEY_RELEASED)  PFM_Vec3_Add(&dir, &back, &dir);
../cam_control.c:234:    if(ctx->right_state != KEY_RELEASED) PFM_Vec3_Add(&dir, &right, &dir);
../cam_control.c:248:    ctx->scroll_up    = (e->y == 0);
../cam_control.c:249:    ctx->scroll_down  = (e->y == height - 1);
../cam_control.c:250:    ctx->scroll_left  = (e->x == 0);
../cam_control.c:251:    ctx->scroll_right = (e->x == width - 1);
../cam_control.c:259:    if(ctx->scroll_up || ctx->scroll_down || ctx->scroll_left || ctx->scroll_right)
../cam_control.c:262:    if(e->button.button == SDL_BUTTON_LEFT)
../cam_control.c:263:        ctx->pan_disabled = true;
../cam_control.c:271:    if(e->button.button == SDL_BUTTON_LEFT)
../cam_control.c:272:        ctx->pan_disabled = false;
../cam_control.c:284:    switch(e->key.keysym.scancode) {
../cam_control.c:286:        ctx->front_pressed_tick = curr_tick;
../cam_control.c:287:        ctx->front_state = KEY_PRESSED;
../cam_control.c:290:        ctx->left_pressed_tick = curr_tick;
../cam_control.c:291:        ctx->left_state = KEY_PRESSED;
../cam_control.c:294:        ctx->back_pressed_tick = curr_tick;
../cam_control.c:295:        ctx->back_state = KEY_PRESSED;
../cam_control.c:298:        ctx->right_pressed_tick = curr_tick;
../cam_control.c:299:        ctx->right_state = KEY_PRESSED;
../cam_control.c:314:    switch(e->key.keysym.scancode) {
../cam_control.c:316:        ctx->front_released_tick = curr_tick;
../cam_control.c:317:        ctx->front_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:320:        ctx->left_released_tick = curr_tick;
../cam_control.c:321:        ctx->left_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:324:        ctx->back_released_tick = curr_tick;
../cam_control.c:325:        ctx->back_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:328:        ctx->right_released_tick = curr_tick;
../cam_control.c:329:        ctx->right_state = KEY_RELEASED_NO_TIMEOUT;
../cam_control.c:341:    if((ctx->front_state == KEY_RELEASED_NO_TIMEOUT)
../cam_control.c:342:    && (curr_tick - ctx->front_released_tick > KEYUP_TICKS_TIMEOUT))
../cam_control.c:343:        ctx->front_state = KEY_RELEASED;
../cam_control.c:345:    if(ctx->left_state == KEY_RELEASED_NO_TIMEOUT
../cam_control.c:346:    && curr_tick - ctx->left_released_tick > KEYUP_TICKS_TIMEOUT)
../cam_control.c:347:        ctx->left_state = KEY_RELEASED;
../cam_control.c:349:    if(ctx->back_state == KEY_RELEASED_NO_TIMEOUT
../cam_control.c:350:    && curr_tick - ctx->back_released_tick > KEYUP_TICKS_TIMEOUT)
../cam_control.c:351:        ctx->back_state = KEY_RELEASED;
../cam_control.c:353:    if(ctx->right_state == KEY_RELEASED_NO_TIMEOUT
../cam_control.c:354:    && curr_tick - ctx->right_released_tick > KEYUP_TICKS_TIMEOUT)
../cam_control.c:355:        ctx->right_state = KEY_RELEASED;
../cam_control.c:364:     *  cos -ve  | cos +ve
../cam_control.c:366:     * 180* <----+----> 0*
../cam_control.c:368:     *  sin -ve  | sin -ve
../cam_control.c:369:     *  cos -ve  | cos +ve
../cam_control.c:374:     *         -Z
../cam_control.c:377:     *   +X <---+---> -X
../cam_control.c:388:    vec3_t up    = (vec3_t){  1.0f * cos(DEG_TO_RAD(yaw)), 0.0f, -1.0f * sin(DEG_TO_RAD(yaw)) };
../cam_control.c:390:    vec3_t down  = (vec3_t){-up.x, up.y, -up.z};
../cam_control.c:391:    vec3_t right = (vec3_t){-left.x, left.y, -left.z};
../cam_control.c:393:    assert(!(ctx->scroll_left && ctx->scroll_right));
../cam_control.c:394:    assert(!(ctx->scroll_up && ctx->scroll_down));
../cam_control.c:398:    if(!ctx->pan_disabled) {
../cam_control.c:400:        if(ctx->scroll_left || ctx->left_state != KEY_RELEASED) 
../cam_control.c:402:        if(ctx->scroll_right || ctx->right_state != KEY_RELEASED) 
../cam_control.c:404:        if(ctx->scroll_up || ctx->front_state != KEY_RELEASED) 
../cam_control.c:406:        if(ctx->scroll_down || ctx->back_state != KEY_RELEASED) 
../cam_control.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../camera.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../camera.c:86:    return (cam->pos.x <= cam->bounds.x && cam->pos.x >= cam->bounds.x - cam->bounds.w)
../camera.c:87:        && (cam->pos.z >= cam->bounds.z && cam->pos.z <= cam->bounds.z + cam->bounds.h);
../camera.c:93:    cam->pos.x = MIN(cam->pos.x, cam->bounds.x);
../camera.c:94:    cam->pos.x = MAX(cam->pos.x, cam->bounds.x - cam->bounds.w);
../camera.c:96:    cam->pos.z = MAX(cam->pos.z, cam->bounds.z);
../camera.c:97:    cam->pos.z = MIN(cam->pos.z, cam->bounds.z + cam->bounds.h);
../camera.c:120:    cam->pos = pos; 
../camera.c:121:    if(cam->bounded) {
../camera.c:124:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:130:    cam->front = dir;
../camera.c:133:    vec3_t xz = (vec3_t){cam->front.z, 0.0f, -cam->front.x};
../camera.c:134:    PFM_Vec3_Cross(&cam->front, &xz, &cam->up);
../camera.c:135:    PFM_Vec3_Normal(&cam->up, &cam->up);
../camera.c:137:    cam->pitch = -RAD_TO_DEG(asin(-dir.y));
../camera.c:138:    cam->yaw = -RAD_TO_DEG(atan2(dir.x, dir.z));
../camera.c:143:    return cam->front;
../camera.c:148:    cam->pitch = pitch;
../camera.c:149:    cam->yaw = yaw;
../camera.c:152:    front.x = cos(DEG_TO_RAD(cam->yaw)) * cos(DEG_TO_RAD(cam->pitch));
../camera.c:153:    front.y = sin(DEG_TO_RAD(cam->pitch));
../camera.c:154:    front.z = sin(DEG_TO_RAD(cam->yaw)) * cos(DEG_TO_RAD(cam->pitch)) * -1;
../camera.c:155:    PFM_Vec3_Normal(&front, &cam->front);
../camera.c:158:    vec3_t xz = (vec3_t){cam->front.z, 0.0f, -cam->front.x};
../camera.c:159:    PFM_Vec3_Cross(&cam->front, &xz, &cam->up);
../camera.c:160:    PFM_Vec3_Normal(&cam->up, &cam->up);
../camera.c:165:    cam->speed = speed;
../camera.c:170:    cam->sensitivity = sensitivity;
../camera.c:175:    return cam->speed;
../camera.c:180:    return cam->sensitivity;
../camera.c:185:    return cam->yaw;
../camera.c:190:    return cam->pitch;
../camera.c:195:    return cam->pos.y;
../camera.c:200:    return cam->pos;
../camera.c:208:    if(!cam->prev_frame_ts)
../camera.c:209:        cam->prev_frame_ts = SDL_GetTicks();
../camera.c:212:    tdelta = curr - cam->prev_frame_ts;
../camera.c:214:    PFM_Vec3_Cross(&cam->front, &cam->up, &left);
../camera.c:217:    PFM_Vec3_Scale(&left, tdelta * cam->speed, &vdelta);
../camera.c:218:    PFM_Vec3_Add(&cam->pos, &vdelta, &cam->pos);
../camera.c:220:    if(cam->bounded) {
../camera.c:223:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:231:    if(!cam->prev_frame_ts)
../camera.c:232:        cam->prev_frame_ts = SDL_GetTicks();
../camera.c:235:    tdelta = curr - cam->prev_frame_ts;
../camera.c:237:    PFM_Vec3_Cross(&cam->front, &cam->up, &left);
../camera.c:240:    PFM_Vec3_Scale(&left, tdelta * cam->speed, &vdelta);
../camera.c:241:    PFM_Vec3_Sub(&cam->pos, &vdelta, &cam->pos);
../camera.c:243:    if(cam->bounded) {
../camera.c:246:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:254:    if(!cam->prev_frame_ts)
../camera.c:255:        cam->prev_frame_ts = SDL_GetTicks();
../camera.c:258:    tdelta = curr - cam->prev_frame_ts;
../camera.c:260:    PFM_Vec3_Scale(&cam->front, tdelta * cam->speed, &vdelta);
../camera.c:261:    PFM_Vec3_Add(&cam->pos, &vdelta, &cam->pos);
../camera.c:263:    if(cam->bounded) {
../camera.c:266:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:274:    if(!cam->prev_frame_ts)
../camera.c:275:        cam->prev_frame_ts = SDL_GetTicks();
../camera.c:278:    tdelta = curr - cam->prev_frame_ts;
../camera.c:280:    PFM_Vec3_Scale(&cam->front, tdelta * cam->speed, &vdelta);
../camera.c:281:    PFM_Vec3_Sub(&cam->pos, &vdelta, &cam->pos);
../camera.c:283:    if(cam->bounded) {
../camera.c:286:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:294:    if(!cam->prev_frame_ts)
../camera.c:295:        cam->prev_frame_ts = SDL_GetTicks();
../camera.c:304:    tdelta = curr - cam->prev_frame_ts;
../camera.c:306:    PFM_Vec3_Scale(&dir, tdelta * cam->speed, &vdelta);
../camera.c:307:    PFM_Vec3_Add(&cam->pos, &vdelta, &cam->pos);
../camera.c:309:    if(cam->bounded) {
../camera.c:312:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:317:    float sdx = dx * cam->sensitivity; 
../camera.c:318:    float sdy = dy * cam->sensitivity;
../camera.c:320:    cam->yaw   += sdx;
../camera.c:321:    cam->pitch -= sdy;
../camera.c:323:    cam->pitch = cam->pitch <  89.0f ? cam->pitch :  89.0f;
../camera.c:324:    cam->pitch = cam->pitch > -89.0f ? cam->pitch : -89.0f;
../camera.c:327:    front.x = cos(DEG_TO_RAD(cam->yaw)) * cos(DEG_TO_RAD(cam->pitch));
../camera.c:328:    front.y = sin(DEG_TO_RAD(cam->pitch));
../camera.c:329:    front.z = sin(DEG_TO_RAD(cam->yaw)) * cos(DEG_TO_RAD(cam->pitch)) * -1;
../camera.c:330:    PFM_Vec3_Normal(&front, &cam->front);
../camera.c:333:    vec3_t xz = (vec3_t){cam->front.z, 0.0f, -cam->front.x};
../camera.c:334:    PFM_Vec3_Cross(&cam->front, &xz, &cam->up);
../camera.c:335:    PFM_Vec3_Normal(&cam->up, &cam->up);
../camera.c:344:    PFM_Vec3_Add(&cam->pos, &cam->front, &target);
../camera.c:345:    PFM_Mat4x4_MakeLookAt(&cam->pos, &target, &cam->up, &view);
../camera.c:352:            R_PushArg(&cam->pos, sizeof(cam->pos)),
../camera.c:368:    cam->prev_frame_ts = SDL_GetTicks();
../camera.c:377:    PFM_Vec3_Add(&cam->pos, &cam->front, &target);
../camera.c:378:    PFM_Mat4x4_MakeLookAt(&cam->pos, &target, &cam->up, &view);
../camera.c:385:            R_PushArg(&cam->pos, sizeof(cam->pos)),
../camera.c:398:    cam->prev_frame_ts = SDL_GetTicks();
../camera.c:403:    cam->bounded = true;
../camera.c:404:    cam->bounds = box;
../camera.c:406:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:411:    cam->bounded = false;
../camera.c:413:    assert(!cam->bounded || camera_pos_in_bounds(cam));
../camera.c:418:    return cam->bounded;
../camera.c:424:    PFM_Vec3_Add((vec3_t*)&cam->pos, (vec3_t*)&cam->front, &target);
../camera.c:425:    PFM_Mat4x4_MakeLookAt((vec3_t*)&cam->pos, &target, (vec3_t*)&cam->up, out);
../camera.c:441:    C_MakeFrustum(cam->pos, cam->up, cam->front, aspect_ratio, CAM_FOV_RAD, 
../camera.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../config.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../config.h:56:/* This is the half-width of the light source's frustum, in OpenGL coordinates.
../config.h:57: * Increasing the FOV results in lower-quality shadows for the same shadow map 
../cursor.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../cursor.c:168:    bool bot = (mouse_y == height - 1);
../cursor.c:170:    bool right = (mouse_x == width - 1);
../cursor.c:236:        if(!curr->path 
../cursor.c:237:        || !Cursor_LoadBMP(i, curr->path, curr->hot_x, curr->hot_y)) {
../cursor.c:239:            curr->cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
../cursor.c:240:            if(!curr->cursor)
../cursor.c:268:        SDL_FreeSurface(curr->surface);
../cursor.c:269:        SDL_FreeCursor(curr->cursor);
../cursor.c:270:        curr->surface = NULL;
../cursor.c:271:        curr->cursor = NULL;
../cursor.c:299:    SDL_FreeSurface(curr->surface);
../cursor.c:300:    SDL_FreeCursor(curr->cursor);
../cursor.c:302:    curr->cursor = cursor;
../cursor.c:303:    curr->surface = surface;
../cursor.c:304:    curr->hot_x = hotx;
../cursor.c:305:    curr->hot_y = hoty;
../cursor.c:306:    pf_snprintf(curr->path, sizeof(curr->path), path);
../cursor.c:340:    if(status == -1)
../cursor.c:359:    SDL_SetCursor(entry->cursor);
../cursor.c:368:    s_rts_pointer = curr->cursor;
../cursor.c:382:    s_rts_pointer = entry->cursor;
../cursor.c:471:        if(!strlen(curr->path))
../cursor.c:483:        pf_snprintf(path.val.as_string, sizeof(path.val.as_string), curr->path);
../cursor.c:488:            .val.as_int = curr->hot_x
../cursor.c:494:            .val.as_int = curr->hot_y
../cursor.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../entity.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../entity.c:107:        if(status == -1)
../entity.c:124:        if(status == -1)
../entity.c:132:    return (status != -1);
../entity.c:157:    /* Cache all the params - the entity can die on us */
../entity.c:158:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../entity.c:159:    float radius = G_GetSelectionRadius(ent->uid);
../entity.c:162:    uint32_t uid = ent->uid;
../entity.c:163:    uint32_t flags = ent->flags;
../entity.c:176:        elapsed = curr - start;
../entity.c:184:        pos = G_Pos_GetXZ(ent->uid);
../entity.c:221:    vec3_t start_pos = G_Pos_Get(darg.ent->uid);
../entity.c:222:    uint32_t uid = darg.ent->uid;
../entity.c:237:    darg.ent->flags |= ENTITY_FLAG_TRANSLUCENT;
../entity.c:255:        uint32_t curr_long =  (curr - start) / 250;
../entity.c:256:        elapsed = curr - start;
../entity.c:265:        float pc = (elapsed - (prev_long * 250)) / 250;
../entity.c:267:            start_pos.x + (curr_shift.x * pc + prev_shift.x * (1.0f - pc)) / 2.0f, 
../entity.c:268:            start_pos.y - (elapsed / duration) * height,
../entity.c:269:            start_pos.z + (curr_shift.y * pc + prev_shift.y * (1.0f - pc)) / 2.0f,
../entity.c:292:    vec3_t pos = G_Pos_Get(ent->uid);
../entity.c:293:    vec3_t scale = Entity_GetScale(ent->uid);
../entity.c:294:    quat_t rot = Entity_GetRot(ent->uid);
../entity.c:317:    if((ent->flags & ENTITY_FLAG_ANIMATED) && !identity) {
../entity.c:318:        aabb = A_GetCurrPoseAABB(ent->uid);
../entity.c:320:        aabb = &ent->identity_aabb;
../entity.c:324:        {aabb->x_min, aabb->y_min, aabb->z_min, 1.0f},
../entity.c:325:        {aabb->x_min, aabb->y_min, aabb->z_max, 1.0f},
../entity.c:326:        {aabb->x_min, aabb->y_max, aabb->z_min, 1.0f},
../entity.c:327:        {aabb->x_min, aabb->y_max, aabb->z_max, 1.0f},
../entity.c:328:        {aabb->x_max, aabb->y_min, aabb->z_min, 1.0f},
../entity.c:329:        {aabb->x_max, aabb->y_min, aabb->z_max, 1.0f},
../entity.c:330:        {aabb->x_max, aabb->y_max, aabb->z_min, 1.0f},
../entity.c:331:        {aabb->x_max, aabb->y_max, aabb->z_max, 1.0f},
../entity.c:335:        (aabb->x_min + aabb->x_max) / 2.0f,
../entity.c:336:        (aabb->y_min + aabb->y_max) / 2.0f,
../entity.c:337:        (aabb->z_min + aabb->z_max) / 2.0f,
../entity.c:347:        out->corners[i] = (vec3_t){
../entity.c:356:    out->center = (vec3_t){
../entity.c:362:    vec3_t scale = Entity_GetScale(ent->uid);
../entity.c:363:    out->half_lengths[0] = (aabb->x_max - aabb->x_min) / 2.0f * scale.x;
../entity.c:364:    out->half_lengths[1] = (aabb->y_max - aabb->y_min) / 2.0f * scale.y;
../entity.c:365:    out->half_lengths[2] = (aabb->z_max - aabb->z_min) / 2.0f * scale.z;
../entity.c:368:    PFM_Vec3_Sub(&out->corners[4], &out->corners[0], &axis0);
../entity.c:369:    PFM_Vec3_Sub(&out->corners[2], &out->corners[0], &axis1);
../entity.c:370:    PFM_Vec3_Sub(&out->corners[1], &out->corners[0], &axis2);
../entity.c:372:    PFM_Vec3_Normal(&axis0, &out->axes[0]);
../entity.c:373:    PFM_Vec3_Normal(&axis1, &out->axes[1]);
../entity.c:374:    PFM_Vec3_Normal(&axis2, &out->axes[2]);
../entity.c:386:    const struct aabb *aabb = &ent->identity_aabb;
../entity.c:388:        (aabb->x_min + aabb->x_max) / 2.0f,
../entity.c:389:        aabb->y_max,
../entity.c:390:        (aabb->z_min + aabb->z_max) / 2.0f,
../entity.c:410:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../entity.c:420:    Entity_SetRot(ent->uid, rot);
../entity.c:445:    float screen_y = screenh - ((ndc.y + 1.0f) * screenh/2.0f);
../entity.c:455:    vec2_t apos = G_Pos_GetXZ(a->uid);
../entity.c:456:    vec2_t bpos = G_Pos_GetXZ(b->uid);
../entity.c:471:    if(!tl || tl->ntags == MAX_TAGS)
../entity.c:480:    tl->tags[tl->ntags++] = str;
../entity.c:491:    for(int i = 0; i < tl->ntags; i++) {
../entity.c:492:        if(0 == strcmp(tl->tags[i], tag)) {
../entity.c:493:            tl->tags[i] = tl->tags[--tl->ntags];
../entity.c:516:    for(int i = 0; i < tl->ntags; i++) {
../entity.c:517:        tag_remove_entity(tl->tags[i], uid);
../entity.c:519:    tl->ntags = 0;
../entity.c:545:    size_t ret = MIN(tl->ntags, maxout);
../entity.c:546:    memcpy(out, tl->tags, ret * sizeof(char*));
../entity.c:553:     * call later - by the time we return from it, we will have copied the data.
../entity.c:567:    float radius = G_GetSelectionRadius(ent->uid);
../entity.c:637:        assert(status != -1);
../entity.c:656:        assert(status != -1);
../entity.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../entity.h:76:    struct aabb  identity_aabb; /* Bind-pose AABB */
../entity.h:120:/* Coarse-grained test that can give false positives. Use the check to get
../event.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../event.c:73: * which are not associated with any entity. This is the maximum 32-bit 
../event.c:86:#define STR(_event) [_event - EVENT_UPDATE_START] = #_event
../event.c:160:    if(a->type != b->type)
../event.c:163:    if(a->type == HANDLER_TYPE_SCRIPT) {
../event.c:164:        return S_ObjectsEqual(a->handler.as_script_callable, b->handler.as_script_callable);
../event.c:166:        return a->handler.as_function == b->handler.as_function;
../event.c:172:    if(a->type != b->type)
../event.c:175:    if(a->type == HANDLER_TYPE_SCRIPT) {
../event.c:176:        return a->handler.as_script_callable == b->handler.as_script_callable;
../event.c:178:        return a->handler.as_function == b->handler.as_function;
../event.c:214:        if(idx != -1)
../event.c:235:    if(idx == -1)
../event.c:326:            if(idx != -1)
../event.c:477:        for(int i = vec_size(&curr)-1; i >= 0; i--) {
../event.c:664:    if(event - EVENT_UPDATE_START >= sizeof(s_event_str_table)/sizeof(const char *))
../event.c:666:    return s_event_str_table[event - EVENT_UPDATE_START];
../event.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../event.h:47:     * +-----------------+-----------------------------------------------+
../event.h:49:     * +-----------------+-----------------------------------------------+
../event.h:50:     * | 0x0-0xffff      | SDL events                                    |
../event.h:51:     * +-----------------+-----------------------------------------------+
../event.h:52:     * | 0x10000-0x1ffff | Engine-generated events                       |
../event.h:53:     * +-----------------+-----------------------------------------------+
../event.h:54:     * | 0x20000-0x2ffff | Script-generated events                       |
../event.h:55:     * +-----------------+-----------------------------------------------+
../game/builder.c:104:    assert(ent->flags & ENTITY_FLAG_BUILDER);
../game/builder.c:106:    khiter_t k = kh_put(state, s_entity_state_table, ent->uid, &ret);
../game/builder.c:107:    assert(ret != -1 && ret != 0);
../game/builder.c:113:    assert(ent->flags & ENTITY_FLAG_BUILDER);
../game/builder.c:115:    khiter_t k = kh_get(state, s_entity_state_table, ent->uid);
../game/builder.c:127:    assert(bs->state == STATE_BUILDING);
../game/builder.c:132:    bs->state = STATE_NOT_BUILDING;
../game/builder.c:142:    if(bs->state == STATE_BUILDING) {
../game/builder.c:146:    bs->state = STATE_NOT_BUILDING;
../game/builder.c:147:    bs->target_uid = UID_NONE;
../game/builder.c:158:    struct entity *target = G_EntityForUID(bs->target_uid);
../game/builder.c:159:    if(!target || (target->flags & ENTITY_FLAG_ZOMBIE)) {
../game/builder.c:164:    if(!(target->flags & ENTITY_FLAG_COMBATABLE)) {
../game/builder.c:171:    int hp = MIN(G_Combat_GetCurrentHP(target) + bs->build_speed, max_hp);
../game/builder.c:195:    assert(bs->target_uid != UID_NONE);
../game/builder.c:196:    struct entity *target = G_EntityForUID(bs->target_uid);
../game/builder.c:200:        bs->state = STATE_NOT_BUILDING;
../game/builder.c:201:        bs->target_uid = UID_NONE;
../game/builder.c:208:            E_Entity_Notify(EVENT_BUILDING_FOUNDED, target->uid, NULL, ES_ENGINE);
../game/builder.c:210:            bs->state = STATE_NOT_BUILDING;
../game/builder.c:211:            bs->target_uid = UID_NONE;
../game/builder.c:218:    && G_StorageSite_IsSaturated(target->uid)) {
../game/builder.c:223:        if(ent->flags & ENTITY_FLAG_HARVESTER) {
../game/builder.c:224:            G_Harvester_Stop(ent->uid);
../game/builder.c:227:        bs->state = STATE_NOT_BUILDING;
../game/builder.c:231:    bs->state = STATE_BUILDING; 
../game/builder.c:240:    SDL_MouseButtonEvent *mouse_event = &(((SDL_Event*)event)->button);
../game/builder.c:243:    bool right = (mouse_event->button == SDL_BUTTON_RIGHT);
../game/builder.c:244:    bool left = (mouse_event->button == SDL_BUTTON_LEFT);
../game/builder.c:251:    if(S_UI_MouseOverWindow(mouse_event->x, mouse_event->y))
../game/builder.c:264:    if(!target || !(target->flags & ENTITY_FLAG_BUILDING) || !G_Building_NeedsRepair(target))
../game/builder.c:277:        if(!(curr->flags & ENTITY_FLAG_BUILDER))
../game/builder.c:280:        struct builderstate *bs = builderstate_get(curr->uid);
../game/builder.c:283:        finish_building(bs, curr->uid);
../game/builder.c:319:    struct builderstate *bs = builderstate_get(builder->uid);
../game/builder.c:322:    if(!(building->flags & ENTITY_FLAG_BUILDING))
../game/builder.c:325:    E_Entity_Unregister(EVENT_MOTION_END, builder->uid, on_motion_end);
../game/builder.c:326:    E_Entity_Unregister(EVENT_MOTION_START, builder->uid, on_motion_begin);
../game/builder.c:327:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, builder->uid, on_build_anim_finished);
../game/builder.c:329:    bs->state = STATE_MOVING_TO_TARGET;
../game/builder.c:330:    bs->target_uid = building->uid;
../game/builder.c:331:    E_Entity_Notify(EVENT_BUILD_TARGET_ACQUIRED, builder->uid, building, ES_ENGINE);
../game/builder.c:334:        on_motion_end((void*)((uintptr_t)builder->uid), NULL);
../game/builder.c:337:        E_Entity_Register(EVENT_MOTION_END, builder->uid, on_motion_end, (void*)((uintptr_t)builder->uid), G_RUNNING);
../game/builder.c:345:    assert(builderstate_get(ent->uid) == NULL);
../game/builder.c:346:    assert(ent->flags & ENTITY_FLAG_BUILDER);
../game/builder.c:357:    if(!(ent->flags & ENTITY_FLAG_BUILDER))
../game/builder.c:359:    E_Entity_Unregister(EVENT_MOTION_END, ent->uid, on_motion_end);
../game/builder.c:360:    E_Entity_Unregister(EVENT_MOTION_START, ent->uid, on_motion_begin);
../game/builder.c:361:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_build_anim_finished);
../game/builder.c:367:    struct builderstate *bs = builderstate_get(ent->uid);
../game/builder.c:369:    bs->build_speed = speed;
../game/builder.c:374:    struct builderstate *bs = builderstate_get(ent->uid);
../game/builder.c:376:    return bs->build_speed;
../game/builder.c:402:    if(first->flags & ENTITY_FLAG_BUILDER 
../game/builder.c:403:    && hovered->flags & ENTITY_FLAG_BUILDING
../game/builder.c:434:    if(!(first->flags & ENTITY_FLAG_BUILDER))
../game/builder.c:437:    if(G_GetFactionID(hovered->uid) != G_GetFactionID(first->uid))
../game/builder.c:440:    if(hovered->flags & ENTITY_FLAG_BUILDING
../game/builder.c:524:        bs->state = state;
../game/builder.c:525:        bs->build_speed = speed;
../game/builder.c:526:        bs->target_uid = target;
../game/building.c:76:#define MARKER_OBJ          "build-site-marker.pfobj"
../game/building.c:78:#define CENTER_MARKER_OBJ   "build-site.pfobj"
../game/building.c:187:    assert(ent->flags & ENTITY_FLAG_BUILDING);
../game/building.c:189:    khiter_t k = kh_put(state, s_entity_state_table, ent->uid, &ret);
../game/building.c:190:    assert(ret != -1 && ret != 0);
../game/building.c:196:    assert(ent->flags & ENTITY_FLAG_BUILDING);
../game/building.c:198:    khiter_t k = kh_get(state, s_entity_state_table, ent->uid);
../game/building.c:202:        kh_destroy(int, bs->required);
../game/building.c:203:        vec_uid_destroy(&bs->markers);
../game/building.c:230:    return (((uint64_t)td->chunk_r << 48)
../game/building.c:231:          | ((uint64_t)td->chunk_c << 32)
../game/building.c:232:          | ((uint64_t)td->tile_r  << 16)
../game/building.c:233:          | ((uint64_t)td->tile_c  <<  0));
../game/building.c:247:        abox.x - abox.width / 2.0f,
../game/building.c:251:        bbox.x - bbox.width / 2.0f,
../game/building.c:270:    if(fabs(acenter.z - bcenter.z) > EPSILON) {
../game/building.c:271:        Entity_SetRot(ent->uid, (quat_t){ 0, 1.0 / sqrt(2.0), 0, 1.0 / sqrt(2.0) });
../game/building.c:273:    Entity_SetScale(ent->uid, (vec3_t){1.0, 1.5f, 1.0f});
../game/building.c:276:    vec_uid_push(&bs->markers, ent->uid);
../game/building.c:281:    vec3_t pos = G_Pos_Get(ent->uid);
../game/building.c:288:    Entity_SetScale(marker->uid, (vec3_t){2.5, 2.5f, 2.5f});
../game/building.c:290:    vec_uid_push(&bs->markers, marker->uid);
../game/building.c:317:            {-1,  0},
../game/building.c:319:            { 0, -1},
../game/building.c:340:    for(int i = 0; i < vec_size(&bs->markers); i++) {
../game/building.c:341:        struct entity *tofree = G_EntityForUID(vec_AT(&bs->markers, i));
../game/building.c:363:    if(status == -1)
../game/building.c:445:    assert(buildstate_get(ent->uid) == NULL);
../game/building.c:446:    assert(ent->flags & ENTITY_FLAG_BUILDING);
../game/building.c:447:    assert(!(ent->flags & ENTITY_FLAG_MOVABLE));
../game/building.c:455:        .is_storage_site = !!(ent->flags & ENTITY_FLAG_STORAGE_SITE)
../game/building.c:465:    ent->flags |= ENTITY_FLAG_TRANSLUCENT;
../game/building.c:466:    ent->flags &= ~ENTITY_FLAG_SELECTABLE;
../game/building.c:469:        ent->flags |= ENTITY_FLAG_STORAGE_SITE;
../game/building.c:479:    if(!(ent->flags & ENTITY_FLAG_BUILDING))
../game/building.c:482:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:485:    if(bs->state >= BUILDING_STATE_FOUNDED && bs->blocking) {
../game/building.c:486:        M_NavBlockersDecrefOBB(s_map, G_GetFactionID(ent->uid), &bs->obb);
../game/building.c:489:    struct entity *progress = G_EntityForUID(bs->progress_model);
../game/building.c:495:    E_Entity_Unregister(EVENT_STORAGE_SITE_AMOUNT_CHANGED, ent->uid, on_amount_changed);
../game/building.c:502:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:505:    if(bs->state != BUILDING_STATE_PLACEMENT)
../game/building.c:508:    bs->state = BUILDING_STATE_MARKED;
../game/building.c:514:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:517:    if(bs->state != BUILDING_STATE_MARKED)
../game/building.c:524:    struct entity *progress = AL_EntityFromPFObj(ent->basedir, ent->filename, ent->name, Entity_NewUID());
../game/building.c:527:        progress->flags |= ENTITY_FLAG_TRANSLUCENT;
../game/building.c:528:        Entity_SetScale(progress->uid, Entity_GetScale(ent->uid));
../game/building.c:529:        Entity_SetRot(progress->uid, Entity_GetRot(ent->uid));
../game/building.c:531:        G_AddEntity(progress, G_Pos_Get(ent->uid));
../game/building.c:532:        bs->progress_model = progress->uid;
../game/building.c:535:    if(ent->flags & ENTITY_FLAG_COMBATABLE) {
../game/building.c:541:    ent->flags &= ~ENTITY_FLAG_TRANSLUCENT;
../game/building.c:542:    ent->flags |= ENTITY_FLAG_SELECTABLE;
../game/building.c:543:    ent->flags |= ENTITY_FLAG_INVISIBLE;
../game/building.c:546:    bs->state = BUILDING_STATE_FOUNDED;
../game/building.c:548:    bs->blocking = blocking;
../game/building.c:549:    if(bs->blocking) {
../game/building.c:550:        M_NavBlockersIncrefOBB(s_map, G_GetFactionID(ent->uid), &obb);
../game/building.c:551:        bs->obb = obb;
../game/building.c:556:    kh_foreach(bs->required, key, amount, {
../game/building.c:558:        G_StorageSite_SetAltDesired(ent->uid, key, amount);
../game/building.c:561:    E_Entity_Register(EVENT_STORAGE_SITE_AMOUNT_CHANGED, ent->uid, on_amount_changed, 
../game/building.c:562:        (void*)((uintptr_t)ent->uid), G_RUNNING);
../game/building.c:568:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:571:    if(bs->state != BUILDING_STATE_FOUNDED)
../game/building.c:574:    bs->state = BUILDING_STATE_SUPPLIED;
../game/building.c:575:    E_Entity_Unregister(EVENT_STORAGE_SITE_AMOUNT_CHANGED, ent->uid, on_amount_changed);
../game/building.c:583:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:586:    if(bs->state != BUILDING_STATE_SUPPLIED)
../game/building.c:590:    if(!bs->is_storage_site) {
../game/building.c:592:        ent->flags &= ~ENTITY_FLAG_STORAGE_SITE;
../game/building.c:595:    struct entity *progress = G_EntityForUID(bs->progress_model);
../game/building.c:602:    bs->state = BUILDING_STATE_COMPLETED;
../game/building.c:603:    bs->progress_model = UID_NONE;
../game/building.c:604:    ent->flags &= ~ENTITY_FLAG_INVISIBLE;
../game/building.c:606:    float old = G_GetVisionRange(ent->uid);
../game/building.c:607:    vec2_t xz_pos = G_Pos_GetXZ(ent->uid);
../game/building.c:609:    G_SetVisionRange(ent->uid, bs->vision_range);
../game/building.c:610:    E_Entity_Notify(EVENT_BUILDING_COMPLETED, ent->uid, NULL, ES_ENGINE);
../game/building.c:626:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:628:    return (bs->state >= BUILDING_STATE_FOUNDED);
../game/building.c:633:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:635:    return (bs->state >= BUILDING_STATE_SUPPLIED);
../game/building.c:640:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:642:    return (bs->state >= BUILDING_STATE_COMPLETED);
../game/building.c:647:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:649:    bs->vision_range = vision_range;
../game/building.c:652:    if(bs->state < BUILDING_STATE_COMPLETED)
../game/building.c:655:    G_SetVisionRange(ent->uid, bs->vision_range);
../game/building.c:660:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:662:    return bs->vision_range;
../game/building.c:667:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:671:    struct entity *pent = G_EntityForUID(bs->progress_model);
../game/building.c:679:    vec3_t pos = G_Pos_Get(pent->uid);
../game/building.c:682:    pos.y = map_height - (height * (1.0f - frac_done));
../game/building.c:684:    bs->frac_done = frac_done;
../game/building.c:689:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:696:    if(!bs->blocking)
../game/building.c:699:    M_NavBlockersDecrefOBB(s_map, G_GetFactionID(ent->uid), &bs->obb);
../game/building.c:700:    Entity_CurrentOBB(ent, &bs->obb, true);
../game/building.c:701:    M_NavBlockersIncrefOBB(s_map, G_GetFactionID(ent->uid), &bs->obb);
../game/building.c:706:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:713:    if(!bs->blocking)
../game/building.c:716:    M_NavBlockersDecrefOBB(s_map, oldfac, &bs->obb);
../game/building.c:717:    M_NavBlockersIncrefOBB(s_map, newfac, &bs->obb);
../game/building.c:722:    struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:725:    if(bs->state < BUILDING_STATE_FOUNDED)
../game/building.c:727:    if(bs->state < BUILDING_STATE_COMPLETED)
../game/building.c:730:    if(!(ent->flags & ENTITY_FLAG_COMBATABLE))
../game/building.c:748:    bstate_get_key(bs->required, rname, &ret);
../game/building.c:761:    kh_foreach(bs->required, key, amount, {
../game/building.c:776:    return bstate_set_key(bs->required, rname, req);
../game/building.c:815:            .val.as_int = (ent->flags & ENTITY_FLAG_COMBATABLE) ? G_Combat_GetCurrentHP(ent) : 0
../game/building.c:904:        CHK_TRUE_RET(ent->flags & ENTITY_FLAG_BUILDING);
../game/building.c:906:        struct buildstate *bs = buildstate_get(ent->uid);
../game/building.c:908:        bs->vision_range = vis_range;
../game/building.c:909:        bs->is_storage_site = is_storage_site;
../game/building.c:929:        CHK_TRUE_RET(AL_LoadOBB(stream, &bs->obb));
../game/building.c:957:        if(ent->flags & ENTITY_FLAG_COMBATABLE) {
../game/clearpath.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../game/clearpath.c:38: *         Multi-Agent Simulation
../game/clearpath.c:41: *         (http://gamma.cs.unc.edu/HRVO/HRVO-T-RO.pdf)
../game/clearpath.c:119:    right = (vec2_t){-ent_to_nb.z, ent_to_nb.x};
../game/clearpath.c:128:    assert(fabs(PFM_Vec2_Len(out_xz_right) - 1.0f) < EPSILON);
../game/clearpath.c:132:    assert(fabs(PFM_Vec2_Len(out_xz_left) - 1.0f) < EPSILON);
../game/clearpath.c:169:    float det = (centerline.x * ent.xz_vel.y) - (centerline.y * ent.xz_vel.x);
../game/clearpath.c:178:    }else if(det < -EPSILON) { /* the entity velocity is right of the RVO centerline */
../game/clearpath.c:230:        assert(fabs(PFM_Vec2_Len(&vo_lr_pairs[i + 0].dir) - 1.0f) < EPSILON);
../game/clearpath.c:238:        float left_det = (point_to_test.z * left_dir_x) - (point_to_test.x * left_dir_z);
../game/clearpath.c:244:        assert(fabs(PFM_Vec2_Len(&vo_lr_pairs[i + 1].dir) - 1.0f) < EPSILON);
../game/clearpath.c:251:        float right_det = (point_to_test.z * right_dir_x) - (point_to_test.x * right_dir_z);
../game/clearpath.c:252:        bool right_of_vo = (right_det > -EPSILON);
../game/clearpath.c:327:        assert(fabs(PFM_Vec2_Len(&rays[i].dir) - 1.0f) < EPSILON);
../game/clearpath.c:369:    float max_dist = -INFINITY;
../game/clearpath.c:371:    int del_idx = -1;
../game/clearpath.c:382:            PFM_Vec2_Sub(&xz_pos, &ent->xz_pos, &diff);
../game/clearpath.c:391:    if(max_dist > -INFINITY) {
../game/clearpath.c:392:        assert(del_idx != -1);
../game/clearpath.c:448:            R_PushArg(&cpent->xz_pos, sizeof(cpent->xz_pos)),
../game/clearpath.c:460:        cpent->xz_pos.x, 
../game/clearpath.c:461:        M_HeightAtPoint(map, cpent->xz_pos) + 5.0f, 
../game/clearpath.c:462:        cpent->xz_pos.z
../game/clearpath.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../game/combat.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/combat.c:82: *(enter atk range)+--[STATE_NOT_IN_COMBAT]<---------------------------+
../game/combat.c:85: *                 |  [STATE_MOVING_TO_TARGET]<-+                      |
../game/combat.c:88: *                 |    |              +--------+----------------------+
../game/combat.c:90: *                 +->[STATE_TURNING_TO_TARGET]<--+<---------------------+
../game/combat.c:98: *                 +----+                         |                      |
../game/combat.c:102: *   (not animated)|  [STATE_ATTACK_ANIM_PLAYING]-+                      |
../game/combat.c:104: *                 +->[STATE_ATTACKING]----------------------------------+
../game/combat.c:114:    float base_armour_pc;   /* Percentage of damage blocked. Valid range: [0.0 - 1.0] */
../game/combat.c:190:    assert(ent->flags & ENTITY_FLAG_COMBATABLE);
../game/combat.c:193:    khiter_t k = kh_put(state, s_entity_state_table, ent->uid, &ret);
../game/combat.c:194:    assert(ret != -1 && ret != 0);
../game/combat.c:200:    assert(ent->flags & ENTITY_FLAG_COMBATABLE);
../game/combat.c:202:    khiter_t k = kh_get(state, s_entity_state_table, ent->uid);
../game/combat.c:215:    if(idx == -1)
../game/combat.c:232:    if(G_GetFactionID(a->uid) == G_GetFactionID(b->uid))
../game/combat.c:236:    bool result = G_GetDiplomacyState(G_GetFactionID(a->uid), G_GetFactionID(b->uid), &ds);
../game/combat.c:271:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../game/combat.c:293:    for(int dr = -binrange; dr <= binrange; dr++) {
../game/combat.c:294:    for(int dc = -binrange; dc <= binrange; dc++) {
../game/combat.c:299:        if(enemies_in_bin(G_GetFactionID(ent->uid), binres, bin))
../game/combat.c:307:    const struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:308:    assert(cs->stance != COMBAT_STANCE_HOLD_POSITION);
../game/combat.c:309:    if(cs->stats.attack_range == 0.0f) {
../game/combat.c:313:            G_Pos_GetXZ(ent->uid), G_Pos_GetXZ(target->uid))) {
../game/combat.c:317:            G_Move_SetEnterRange(ent, target, cs->stats.attack_range);
../game/combat.c:331:    const struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:332:    if(cs->stats.attack_range == 0.0f) {
../game/combat.c:336:    vec2_t xz_src = G_Pos_GetXZ(ent->uid);
../game/combat.c:337:    vec2_t xz_dst = G_Pos_GetXZ(target->uid);
../game/combat.c:341:    return (PFM_Vec2_Len(&delta) <= cs->stats.attack_range);
../game/combat.c:350:    if(!(curr->flags & ENTITY_FLAG_COMBATABLE))
../game/combat.c:352:    if((curr->flags & ENTITY_FLAG_BUILDING) && !G_Building_IsFounded(curr))
../game/combat.c:357:    struct combatstate *cs = combatstate_get(curr->uid);
../game/combat.c:359:    if(cs->state == STATE_DEATH_ANIM_PLAYING)
../game/combat.c:376:    float angle_rad = atan2(dir.z, dir.x) - M_PI/2.0f;
../game/combat.c:387:    vec2_t ent_pos_xz = G_Pos_GetXZ(ent->uid);
../game/combat.c:388:    vec2_t tar_pos_xz = G_Pos_GetXZ(target->uid);
../game/combat.c:394:        return Entity_GetRot(ent->uid);
../game/combat.c:398:    quat_t curr = Entity_GetRot(ent->uid);
../game/combat.c:404:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:407:    if(!cs->move_cmd_interrupted 
../game/combat.c:408:    && G_Move_GetDest(ent, &cs->move_cmd_xz, &cs->move_cmd_attacking)) {
../game/combat.c:409:        cs->move_cmd_interrupted = true; 
../game/combat.c:413:    if(!(ent->flags & ENTITY_FLAG_MOVABLE)) {
../game/combat.c:414:        cs->state = STATE_CAN_ATTACK;
../game/combat.c:418:        cs->state = STATE_TURNING_TO_TARGET;
../game/combat.c:426:    self->flags |= ENTITY_FLAG_INVISIBLE;
../game/combat.c:427:    E_Entity_Notify(EVENT_ENTITY_DISAPPEARED, self->uid, NULL, ES_ENGINE);
../game/combat.c:434:    if(ent->flags & ENTITY_FLAG_SELECTABLE) {
../game/combat.c:436:        ent->flags &= ~ENTITY_FLAG_SELECTABLE;
../game/combat.c:439:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_attack_anim_finish);
../game/combat.c:441:    E_Entity_Notify(EVENT_ENTITY_DEATH, ent->uid, NULL, ES_ENGINE);
../game/combat.c:444:    if(ent->flags & ENTITY_FLAG_ANIMATED && !(ent->flags & ENTITY_FLAG_BUILDING)) {
../game/combat.c:446:        struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:447:        cs->state = STATE_DEATH_ANIM_PLAYING;
../game/combat.c:448:        E_Entity_Register(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_death_anim_finish, ent, G_RUNNING);
../game/combat.c:459:    struct combatstate *cs = combatstate_get(self->uid);
../game/combat.c:460:    struct combatstate *target_cs = combatstate_get(cs->target_uid);
../game/combat.c:462:    float dmg = G_Combat_GetBaseDamage(self) * (1.0f - G_Combat_GetBaseArmour(target));
../game/combat.c:463:    target_cs->current_hp = MAX(0, target_cs->current_hp - dmg);
../game/combat.c:465:    if(target_cs->current_hp == 0 && target_cs->stats.max_hp > 0) {
../game/combat.c:476:    struct combatstate *cs = combatstate_get(self->uid);
../game/combat.c:480:    if(!P_Projectile_VelocityForTarget(ent_pos, target_pos, cs->pd.speed, &vel)) {
../game/combat.c:486:    P_Projectile_Add(ent_pos, vel, self->uid, G_GetFactionID(self->uid), 
../game/combat.c:487:        ent_dmg, PROJ_ONLY_HIT_COMBATABLE | PROJ_ONLY_HIT_ENEMIES, cs->pd);
../game/combat.c:494:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, self->uid, on_death_anim_finish);
../game/combat.c:500:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:502:    cs->state = STATE_CAN_ATTACK;
../game/combat.c:504:    struct entity *target = G_EntityForUID(cs->target_uid);
../game/combat.c:505:    if(!target || (target->flags & ENTITY_FLAG_ZOMBIE)) {
../game/combat.c:509:    struct combatstate *target_cs = combatstate_get(cs->target_uid);
../game/combat.c:511:    if(target_cs->state == STATE_DEATH_ANIM_PLAYING) {
../game/combat.c:516:    quat_t ent_rot = Entity_GetRot(ent->uid);
../game/combat.c:520:    if(cs->stats.attack_range > 0.0f) {
../game/combat.c:527:        E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:543:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, self->uid, on_attack_anim_finish);
../game/combat.c:550:    || !(ent->flags & ENTITY_FLAG_COMBATABLE) /* zombie or stray target */
../game/combat.c:551:    || combatstate_get(ent->uid)->state == STATE_DEATH_ANIM_PLAYING) /* dying */
../game/combat.c:559:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:564:        assert(cs->stance == COMBAT_STANCE_AGGRESSIVE 
../game/combat.c:565:            || cs->stance == COMBAT_STANCE_HOLD_POSITION);
../game/combat.c:567:        cs->target_uid = enemy->uid;
../game/combat.c:572:    if(cs->stance == COMBAT_STANCE_AGGRESSIVE && (ent->flags & ENTITY_FLAG_MOVABLE)) {
../game/combat.c:574:        cs->target_uid = enemy->uid;
../game/combat.c:575:        cs->state = STATE_MOVING_TO_TARGET;
../game/combat.c:577:        if(!cs->move_cmd_interrupted 
../game/combat.c:578:        && G_Move_GetDest(ent, &cs->move_cmd_xz, &cs->move_cmd_attacking)) {
../game/combat.c:579:            cs->move_cmd_interrupted = true; 
../game/combat.c:587:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:589:    cs->state = STATE_NOT_IN_COMBAT; 
../game/combat.c:591:    if(!(ent->flags & ENTITY_FLAG_MOVABLE))
../game/combat.c:594:    if(cs->move_cmd_interrupted) {
../game/combat.c:595:        G_Move_SetDest(ent, cs->move_cmd_xz, cs->move_cmd_attacking);
../game/combat.c:596:        cs->move_cmd_interrupted = false;
../game/combat.c:612:        assert(ent->flags & ENTITY_FLAG_COMBATABLE);
../game/combat.c:614:        switch(curr->state) {
../game/combat.c:617:            if(curr->stance == COMBAT_STANCE_NO_ENGAGEMENT)
../game/combat.c:620:            if(ent->flags & ENTITY_FLAG_BUILDING && !G_Building_IsCompleted(ent))
../game/combat.c:638:            assert(ent->flags & ENTITY_FLAG_MOVABLE);
../game/combat.c:648:            if(enemy->uid != curr->target_uid) {
../game/combat.c:649:                curr->target_uid = enemy->uid;
../game/combat.c:660:            assert(ent->flags & ENTITY_FLAG_MOVABLE);
../game/combat.c:662:            struct entity *target = G_EntityForUID(curr->target_uid);
../game/combat.c:663:            if(!target || !(target->flags & ENTITY_FLAG_COMBATABLE)) {
../game/combat.c:665:                curr->state = STATE_NOT_IN_COMBAT;
../game/combat.c:666:                curr->sticky = false;
../game/combat.c:678:                curr->state = STATE_NOT_IN_COMBAT;
../game/combat.c:679:                curr->sticky = false;
../game/combat.c:690:            /* We approached the target, but it slipped away from us. Re-engage. */
../game/combat.c:698:            const struct entity *target = G_EntityForUID(curr->target_uid);
../game/combat.c:700:            /* Our target could have 'died' or gotten out of combat range - check this first. */
../game/combat.c:703:                if(curr->sticky) {
../game/combat.c:705:                    assert(curr->stance != COMBAT_STANCE_HOLD_POSITION);
../game/combat.c:708:                        E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:710:                        curr->state = STATE_MOVING_TO_TARGET_LOCKED;
../game/combat.c:713:                        curr->sticky = false;
../game/combat.c:720:                    E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:725:                if(curr->stance == COMBAT_STANCE_HOLD_POSITION && !entity_can_attack(ent, enemy)) {
../game/combat.c:726:                    E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:731:                E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:737:            if(ent->flags & ENTITY_FLAG_ANIMATED) {
../game/combat.c:738:                curr->state = STATE_ATTACK_ANIM_PLAYING;
../game/combat.c:739:                E_Entity_Register(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_attack_anim_finish, ent, G_RUNNING);
../game/combat.c:741:                curr->state = STATE_ATTACKING;
../game/combat.c:742:                curr->attack_start_tick = SDL_GetTicks();
../game/combat.c:749:            const struct entity *target = G_EntityForUID(curr->target_uid);
../game/combat.c:757:                curr->state = STATE_CAN_ATTACK;
../game/combat.c:758:                E_Entity_Notify(EVENT_ATTACK_START, ent->uid, NULL, ES_ENGINE);
../game/combat.c:766:            if(!SDL_TICKS_PASSED(ticks, curr->attack_start_tick + period))
../game/combat.c:774:            /* No-op */
../game/combat.c:785:    SDL_MouseButtonEvent *mouse_event = &(((SDL_Event*)event)->button);
../game/combat.c:788:    bool right = (mouse_event->button == SDL_BUTTON_RIGHT);
../game/combat.c:789:    bool left = (mouse_event->button == SDL_BUTTON_LEFT);
../game/combat.c:794:    if(S_UI_MouseOverWindow(mouse_event->x, mouse_event->y))
../game/combat.c:816:    if(!target || !(target->flags & ENTITY_FLAG_COMBATABLE) || !enemies(first, target))
../game/combat.c:822:        if(!(curr->flags & ENTITY_FLAG_COMBATABLE))
../game/combat.c:903:        struct rect bounds = (struct rect){ss_pos.x - 75, ss_pos.y + 5, 150, 16};
../game/combat.c:965:    struct entity *target = G_EntityForUID(hit->ent_uid);
../game/combat.c:970:    float dmg = hit->cookie * (1.0f - G_Combat_GetBaseArmour(target));
../game/combat.c:971:    struct combatstate *cs = combatstate_get(hit->ent_uid);
../game/combat.c:972:    cs->current_hp = MAX(0, cs->current_hp - dmg);
../game/combat.c:974:    if(cs->current_hp == 0 && cs->stats.max_hp > 0) {
../game/combat.c:1029:    assert(combatstate_get(ent->uid) == NULL);
../game/combat.c:1030:    assert(ent->flags & ENTITY_FLAG_COMBATABLE);
../game/combat.c:1046:    if(!(ent->flags & ENTITY_FLAG_COMBATABLE))
../game/combat.c:1049:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1052:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_attack_anim_finish);
../game/combat.c:1053:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_death_anim_finish);
../game/combat.c:1055:    if(cs->state == STATE_ATTACK_ANIM_PLAYING
../game/combat.c:1056:    || cs->state == STATE_CAN_ATTACK) {
../game/combat.c:1057:        E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:1060:    PF_FREE(cs->pd.basedir);
../game/combat.c:1061:    PF_FREE(cs->pd.pfobj);
../game/combat.c:1069:    assert(ent->flags & ENTITY_FLAG_COMBATABLE);
../game/combat.c:1070:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1073:    if(stance == cs->stance)
../game/combat.c:1081:    && (cs->state == STATE_MOVING_TO_TARGET || cs->state == STATE_MOVING_TO_TARGET_LOCKED)) {
../game/combat.c:1084:        cs->state = STATE_NOT_IN_COMBAT;
../game/combat.c:1085:        cs->move_cmd_interrupted = false;
../game/combat.c:1088:    cs->stance = stance;
../game/combat.c:1094:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1096:        cs->move_cmd_interrupted = false;
../game/combat.c:1121:    if(!(first->flags & ENTITY_FLAG_COMBATABLE))
../game/combat.c:1127:    if(G_GetFactionID(first->uid) == G_GetFactionID(hovered->uid))
../game/combat.c:1130:    if((hovered->flags & ENTITY_FLAG_MARKER) || (hovered->flags & ENTITY_FLAG_ZOMBIE))
../game/combat.c:1133:    bool can_target = (hovered->flags & ENTITY_FLAG_MOVABLE) && !(hovered->flags & ENTITY_FLAG_RESOURCE);
../game/combat.c:1134:    if(!(hovered->flags & ENTITY_FLAG_COMBATABLE) && !can_target)
../game/combat.c:1137:    if(!(hovered->flags & ENTITY_FLAG_COMBATABLE) && can_target)
../game/combat.c:1149:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1153:    cs->stance = COMBAT_STANCE_AGGRESSIVE;
../game/combat.c:1155:    if(ent->flags & ENTITY_FLAG_MOVABLE) {
../game/combat.c:1157:        cs->sticky = true;
../game/combat.c:1158:        cs->target_uid = target->uid;
../game/combat.c:1159:        cs->state = STATE_MOVING_TO_TARGET_LOCKED;
../game/combat.c:1160:        cs->move_cmd_interrupted = false;
../game/combat.c:1166:        cs->sticky = true;
../game/combat.c:1167:        cs->target_uid = target->uid;
../game/combat.c:1168:        cs->state = STATE_CAN_ATTACK;
../game/combat.c:1174:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1178:    E_Entity_Unregister(EVENT_ANIM_CYCLE_FINISHED, ent->uid, on_attack_anim_finish);
../game/combat.c:1180:    if(cs->state == STATE_ATTACK_ANIM_PLAYING
../game/combat.c:1181:    || cs->state == STATE_CAN_ATTACK) {
../game/combat.c:1182:        E_Entity_Notify(EVENT_ATTACK_END, ent->uid, NULL, ES_ENGINE);
../game/combat.c:1185:    cs->state = STATE_NOT_IN_COMBAT;
../game/combat.c:1187:    if(cs->move_cmd_interrupted) {
../game/combat.c:1188:        G_Move_SetDest(ent, cs->move_cmd_xz, cs->move_cmd_attacking);
../game/combat.c:1189:        cs->move_cmd_interrupted = false;
../game/combat.c:1195:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../game/combat.c:1211:        vec2_t enemy_pos = G_Pos_GetXZ(ents[i]->uid);
../game/combat.c:1230:        if(curr->state != STATE_ATTACKING)
../game/combat.c:1232:        curr->attack_start_tick += delta;
../game/combat.c:1276:    s_fac_refcnts[faction_id][idx]--;
../game/combat.c:1290:    return (cs->state == STATE_DEATH_ANIM_PLAYING);
../game/combat.c:1295:    assert(ent->flags & ENTITY_FLAG_COMBATABLE);
../game/combat.c:1297:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1299:    return cs->current_hp;
../game/combat.c:1304:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1306:    cs->stats.base_armour_pc = armour_pc;
../game/combat.c:1311:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1313:    return cs->stats.base_armour_pc;
../game/combat.c:1318:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1320:    cs->stats.base_dmg = dmg;
../game/combat.c:1325:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1327:    return cs->stats.base_dmg;
../game/combat.c:1332:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1334:    cs->current_hp = MIN(hp, cs->stats.max_hp);
../game/combat.c:1339:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1341:    cs->stats.max_hp = hp;
../game/combat.c:1346:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1348:    return cs->stats.max_hp;
../game/combat.c:1353:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1355:    cs->stats.attack_range = range;
../game/combat.c:1360:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1363:    PF_FREE(cs->pd.basedir);
../game/combat.c:1364:    PF_FREE(cs->pd.pfobj);
../game/combat.c:1366:    cs->pd = (struct proj_desc) {
../game/combat.c:1367:        pf_strdup(pd->basedir),
../game/combat.c:1368:        pf_strdup(pd->pfobj),
../game/combat.c:1369:        pd->scale,
../game/combat.c:1370:        pd->speed,
../game/combat.c:1376:    struct combatstate *cs = combatstate_get(ent->uid);
../game/combat.c:1378:    return cs->stats.attack_range;
../game/combat.c:1447:            .val.as_int = curr_ticks - curr.attack_start_tick
../game/combat.c:1487:            .val.as_int = curr_ent->uid
../game/combat.c:1521:        cs->stance = attr.val.as_int;
../game/combat.c:1525:        cs->state = attr.val.as_int;
../game/combat.c:1529:        cs->sticky = attr.val.as_bool;
../game/combat.c:1531:        if(cs->state == STATE_ATTACK_ANIM_PLAYING) {
../game/combat.c:1539:        cs->target_uid = attr.val.as_int;
../game/combat.c:1543:        cs->move_cmd_interrupted = attr.val.as_bool;
../game/combat.c:1547:        cs->move_cmd_attacking = attr.val.as_bool;
../game/combat.c:1551:        cs->move_cmd_xz = attr.val.as_vec2;
../game/combat.c:1555:        cs->attack_start_tick = curr_ticks - attr.val.as_int;
../game/combat.c:1559:        cs->pd.basedir = pf_strdup(attr.val.as_string);
../game/combat.c:1563:        cs->pd.pfobj = pf_strdup(attr.val.as_string);
../game/combat.c:1567:        cs->pd.scale = attr.val.as_vec3;
../game/combat.c:1571:        cs->pd.speed = attr.val.as_float;
../game/combat.c:1587:        if(ent->flags & ENTITY_FLAG_ANIMATED) {
../game/combat.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/faction.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/fog_of_war.c:85:/* Holds a 32-bit value for every tile of the map. The chunks are stored in row-major
../game/fog_of_war.c:86: * order. Within a chunk, the tiles are in row-major order. Each 32-bit value encodes
../game/fog_of_war.c:87: * a 2-bit faction state for up to 16 factions. */
../game/fog_of_war.c:147:    for(int dr = -1; dr <= 1; dr++) {
../game/fog_of_war.c:148:    for(int dc = -1; dc <= 1; dc++) {
../game/fog_of_war.c:170:        box.x - box.width / 2.0f,
../game/fog_of_war.c:179:    return (M_Tile_BaseHeight(tile) - ref_height > 1);
../game/fog_of_war.c:191:    if(M_Tile_RelativeDesc(res, &left,  -1, 0)
../game/fog_of_war.c:199:    if(M_Tile_RelativeDesc(res, &top, 0, -1)
../game/fog_of_war.c:231:    int dy = -abs(slope.raw[1] * 1000);
../game/fog_of_war.c:232:    int sx = slope.raw[0] > 0.0f ? 1 : -1;
../game/fog_of_war.c:233:    int sy = slope.raw[1] < 0.0f ? 1 : -1;
../game/fog_of_war.c:266:    *out_dr = br - ar;
../game/fog_of_war.c:267:    *out_dc = bc - ac;
../game/fog_of_war.c:290:    /* Declare a byte for every tile within a box having a half-length of 'radius' 
../game/fog_of_war.c:293:     * byte corresponding to the origin-most tile. */
../game/fog_of_war.c:459:    if(setting.as_int == -1)
../game/fog_of_war.c:523:    fog_update_visible(faction_id, xz_pos, radius, -1);
../game/fog_of_war.c:538:        update_tile(faction_id, tds[i], -1);
../game/fog_of_war.c:554:        update_tile(faction_id, tds[i], -1);
../game/fog_of_war.c:651:        float square_x = CLAMP(-(((float)c) / res.tile_w) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../game/fog_of_war.c:652:        float square_z = CLAMP( (((float)r) / res.tile_h) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../game/fog_of_war.c:656:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../game/fog_of_war.c:657:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../game/fog_of_war.c:699:    unsigned char *visbuff = stalloc(&G_GetSimWS()->args, size);
../game/fog_of_war.c:751:        assert(status != -1 && status != 0);
../game/game.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../game/game.c:120:        res.as_vec2.y - (size + 2*MINIMAP_BORDER_WIDTH) / cos(M_PI/4.0f)/2 - PAD,
../game/game.c:126:    Camera_SetPitchAndYaw(cam, -(90.0f - CAM_TILT_UP_DEGREES), 90.0f + 45.0f);
../game/game.c:164:    vec3_t pos = Camera_GetPos(in->cam);
../game/game.c:165:    vec3_t dir = Camera_GetDir(in->cam);
../game/game.c:171:            R_PushArg(&in->light_pos, sizeof(in->light_pos)),
../game/game.c:177:    if(in->map) {
../game/game.c:178:        M_RenderVisibleMap(in->map, in->cam, true, RENDER_PASS_DEPTH);
../game/game.c:190:    for(int i = 0; i < vec_size(&in->light_vis_anim); i++) {
../game/game.c:192:        struct ent_anim_rstate *curr = &vec_AT(&in->light_vis_anim, i);
../game/game.c:195:        PFM_Mat4x4_Inverse(&curr->model, &model);
../game/game.c:202:                (void*)curr->inv_bind_pose, 
../game/game.c:203:                R_PushArg(curr->curr_pose, sizeof(curr->curr_pose)),
../game/game.c:205:                R_PushArg(&curr->njoints, sizeof(curr->njoints)),
../game/game.c:213:                curr->render_private,
../game/game.c:214:                R_PushArg(&curr->model, sizeof(curr->model)),
../game/game.c:219:    for(int i = 0; i < vec_size(&in->light_vis_stat); i++) {
../game/game.c:221:        struct ent_stat_rstate *curr = &vec_AT(&in->light_vis_stat, i);
../game/game.c:226:                curr->render_private,
../game/game.c:227:                R_PushArg(&curr->model, sizeof(curr->model)),
../game/game.c:238:    if(in->map) {
../game/game.c:239:        M_RenderVisibleMap(in->map, in->cam, in->shadows, RENDER_PASS_REGULAR);
../game/game.c:251:    for(int i = 0; i < vec_size(&in->cam_vis_anim); i++) {
../game/game.c:253:        struct ent_anim_rstate *curr = &vec_AT(&in->cam_vis_anim, i);
../game/game.c:256:        PFM_Mat4x4_Inverse(&curr->model, &model);
../game/game.c:263:                (void*)curr->inv_bind_pose, 
../game/game.c:264:                R_PushArg(curr->curr_pose, sizeof(curr->curr_pose)),
../game/game.c:266:                R_PushArg(&curr->njoints, sizeof(curr->njoints)),
../game/game.c:274:                curr->render_private,
../game/game.c:275:                R_PushArg(&curr->model, sizeof(curr->model)),
../game/game.c:276:                R_PushArg(&curr->translucent, sizeof(curr->translucent)),
../game/game.c:281:    for(int i = 0; i < vec_size(&in->cam_vis_stat); i++) {
../game/game.c:283:        struct ent_stat_rstate *curr = &vec_AT(&in->cam_vis_stat, i);
../game/game.c:288:                curr->render_private,
../game/game.c:289:                R_PushArg(&curr->model, sizeof(curr->model)),
../game/game.c:290:                R_PushArg(&curr->translucent, sizeof(curr->translucent)),
../game/game.c:319:        if(!(curr->flags & ENTITY_FLAG_COMBATABLE))
../game/game.c:321:        if((curr->flags & ENTITY_FLAG_BUILDING) && !G_Building_IsFounded(curr))
../game/game.c:356:        while(j > 0 && vec_AT(inout, j - 1).translucent && !vec_AT(inout, j).translucent) {
../game/game.c:358:            struct ent_stat_rstate tmp = vec_AT(inout, j - 1);
../game/game.c:359:            vec_AT(inout, j - 1) = vec_AT(inout, j);
../game/game.c:361:            j--;
../game/game.c:372:        while(j > 0 && vec_AT(inout, j - 1).translucent && !vec_AT(inout, j).translucent) {
../game/game.c:374:            struct ent_anim_rstate tmp = vec_AT(inout, j - 1);
../game/game.c:375:            vec_AT(inout, j - 1) = vec_AT(inout, j);
../game/game.c:377:            j--;
../game/game.c:394:        if(curr->flags & ENTITY_FLAG_INVISIBLE)
../game/game.c:400:        if(curr->flags & ENTITY_FLAG_ANIMATED) {
../game/game.c:403:                .render_private = curr->render_private, 
../game/game.c:405:                .translucent = curr->flags & ENTITY_FLAG_TRANSLUCENT
../game/game.c:407:            A_GetRenderState(curr->uid, &rstate.njoints, rstate.curr_pose, &rstate.inv_bind_pose);
../game/game.c:413:                M_Tile_DescForPoint2D(res, M_GetPos(s_gs.map), G_Pos_GetXZ(curr->uid), &td);
../game/game.c:417:                .render_private = curr->render_private, 
../game/game.c:419:                .translucent = curr->flags & ENTITY_FLAG_TRANSLUCENT,
../game/game.c:438:    out->cam = s_gs.active_cam;
../game/game.c:439:    out->map = s_gs.prev_tick_map;
../game/game.c:440:    out->shadows = shadows_setting.as_bool;
../game/game.c:441:    out->light_pos = s_gs.light_pos;
../game/game.c:443:    vec_rstat_init(&out->cam_vis_stat);
../game/game.c:444:    vec_ranim_init(&out->cam_vis_anim);
../game/game.c:446:    vec_rstat_init(&out->light_vis_stat);
../game/game.c:447:    vec_ranim_init(&out->light_vis_anim);
../game/game.c:449:    g_make_draw_list(s_gs.visible, &out->cam_vis_stat, &out->cam_vis_anim);
../game/game.c:450:    g_make_draw_list(s_gs.light_visible, &out->light_vis_stat, &out->light_vis_anim);
../game/game.c:457:    vec_rstat_destroy(&rinput->cam_vis_stat);
../game/game.c:458:    vec_ranim_destroy(&rinput->cam_vis_anim);
../game/game.c:460:    vec_rstat_destroy(&rinput->light_vis_stat);
../game/game.c:461:    vec_ranim_destroy(&rinput->light_vis_anim);
../game/game.c:468:    ret->cam = R_PushArg(in.cam, g_sizeof_camera);
../game/game.c:471:        ret->cam_vis_stat.array = R_PushArg(in.cam_vis_stat.array, in.cam_vis_stat.size * sizeof(struct ent_stat_rstate));
../game/game.c:474:        ret->cam_vis_anim.array = R_PushArg(in.cam_vis_anim.array, in.cam_vis_anim.size * sizeof(struct ent_anim_rstate));
../game/game.c:478:        ret->light_vis_stat.array = R_PushArg(in.light_vis_stat.array, in.light_vis_stat.size * sizeof(struct ent_stat_rstate));
../game/game.c:481:        ret->light_vis_anim.array = R_PushArg(in.light_vis_anim.array, in.light_vis_anim.size * sizeof(struct ent_anim_rstate));
../game/game.c:489:    return (new_val->type == ST_TYPE_BOOL);
../game/game.c:494:    if(new_val->type != ST_TYPE_INT)
../game/game.c:496:    if(new_val->as_int < 0 || new_val->as_int >= NAV_LAYER_MAX)
../game/game.c:503:    if(new_val->type != ST_TYPE_INT)
../game/game.c:505:    if(new_val->as_int < 0 || new_val->as_int > HB_MODE_NEVER)
../game/game.c:512:    if(new_val->type != ST_TYPE_INT)
../game/game.c:514:    return (new_val->as_int >= -1 && new_val->as_int <= MAX_FACTIONS);
../game/game.c:519:    if(new_val->type != ST_TYPE_INT)
../game/game.c:521:    if(new_val->as_int < 0)
../game/game.c:528:    bool on = new_val->as_bool;
../game/game.c:546:                curr->render_private,
../game/game.c:562:        if(!(curr->flags & ENTITY_FLAG_ANIMATED))
../game/game.c:564:        if(curr->flags & ENTITY_FLAG_MARKER)
../game/game.c:577:        if(!(curr->flags & ENTITY_FLAG_ANIMATED))
../game/game.c:579:        if(curr->flags & ENTITY_FLAG_MARKER)
../game/game.c:587:        CHK_TRUE_RET(A_SaveState(stream, curr->uid));
../game/game.c:613:        CHK_TRUE_RET(A_LoadState(stream, ent->uid));
../game/game.c:637:    return -1;
../game/game.c:658:    if(ent->flags & ENTITY_FLAG_MARKER)
../game/game.c:661:    if(!(ent->flags & ENTITY_FLAG_MOVABLE)
../game/game.c:662:    ||  (ent->flags & ENTITY_FLAG_RESOURCE)
../game/game.c:663:    ||  (ent->flags & ENTITY_FLAG_BUILDING)) {
../game/game.c:664:        return G_Fog_ObjExplored(playermask, ent->uid, obb);
../game/game.c:750:        uint32_t delta = curr_tick - s_gs.ss_change_tick;
../game/game.c:754:            if(!(curr->flags & ENTITY_FLAG_ANIMATED))
../game/game.c:756:            A_AddTimeDelta(curr->uid, delta);
../game/game.c:961:            .as_int = -1 /* -1 for none, else the faction ID to show vision for */
../game/game.c:1008:        && !(curr->flags & (ENTITY_FLAG_MOVABLE | ENTITY_FLAG_BUILDING)))
../game/game.c:1013:        vec3_t norm_color = color_map[G_GetFactionID(curr->uid)];
../game/game.c:1161:        if(curr->flags & ENTITY_FLAG_MARKER)
../game/game.c:1332:        if(!(curr->flags & ENTITY_FLAG_COLLISION))
../game/game.c:1334:        if(curr->flags & ENTITY_FLAG_MOVABLE)
../game/game.c:1336:        if(curr->flags & ENTITY_FLAG_BUILDING)
../game/game.c:1338:        if(curr->flags & ENTITY_FLAG_RESOURCE)
../game/game.c:1445:            if(vis || !(curr->flags & ENTITY_FLAG_MOVABLE)) {
../game/game.c:1506:        vec2_t curr_pos = G_Pos_GetXZ(curr->uid);
../game/game.c:1509:        if(curr->flags & ENTITY_FLAG_BUILDING) {
../game/game.c:1525:            float sel_radius = G_GetSelectionRadius(curr->uid);
../game/game.c:1562:    if(in->shadows) {
../game/game.c:1572:    assert(!(ent->flags & ENTITY_FLAG_BUILDING) || !(ent->flags & ENTITY_FLAG_BUILDER));
../game/game.c:1577:    k = kh_put(entity, s_gs.active, ent->uid, &ret);
../game/game.c:1578:    if(ret == -1 || ret == 0)
../game/game.c:1582:    k = kh_put(faction, s_gs.ent_faction_map, ent->uid, &ret);
../game/game.c:1583:    if(ret == -1 || ret == 0)
../game/game.c:1587:    k = kh_put(range, s_gs.ent_visrange_map, ent->uid, &ret);
../game/game.c:1588:    if(ret == -1 || ret == 0)
../game/game.c:1592:    k = kh_put(range, s_gs.selection_radiuses, ent->uid, &ret);
../game/game.c:1593:    if(ret == -1 || ret == 0)
../game/game.c:1599:    if(ent->flags & ENTITY_FLAG_ANIMATED)
../game/game.c:1602:    if(ent->flags & ENTITY_FLAG_STORAGE_SITE)
../game/game.c:1605:    if(ent->flags & ENTITY_FLAG_BUILDING)
../game/game.c:1608:    if(ent->flags & ENTITY_FLAG_BUILDER)
../game/game.c:1611:    if(ent->flags & ENTITY_FLAG_COMBATABLE)
../game/game.c:1614:    if(ent->flags & ENTITY_FLAG_RESOURCE)
../game/game.c:1617:    if(ent->flags & ENTITY_FLAG_HARVESTER)
../game/game.c:1618:        G_Harvester_AddEntity(ent->uid);
../game/game.c:1620:    if(ent->flags & ENTITY_FLAG_MOVABLE) {
../game/game.c:1622:        k = kh_put(entity, s_gs.dynamic, ent->uid, &ret);
../game/game.c:1623:        assert(ret != -1 && ret != 0);
../game/game.c:1636:    khiter_t k = kh_get(entity, s_gs.active, ent->uid);
../game/game.c:1641:    if(ent->flags & ENTITY_FLAG_MOVABLE) {
../game/game.c:1642:        k = kh_get(entity, s_gs.dynamic, ent->uid);
../game/game.c:1648:    if(idx != -1) {
../game/game.c:1654:    if(idx != -1) {
../game/game.c:1664:    G_Harvester_RemoveEntity(ent->uid);
../game/game.c:1667:    G_Region_RemoveEnt(ent->uid);
../game/game.c:1668:    G_Pos_Delete(ent->uid);
../game/game.c:1669:    Entity_Remove(ent->uid);
../game/game.c:1671:    k = kh_get(faction, s_gs.ent_faction_map, ent->uid);
../game/game.c:1675:    k = kh_get(range, s_gs.ent_visrange_map, ent->uid);
../game/game.c:1679:    k = kh_get(range, s_gs.selection_radiuses, ent->uid);
../game/game.c:1691:    if(ent->flags & ENTITY_FLAG_COMBATABLE) {
../game/game.c:1695:    if(ent->flags & ENTITY_FLAG_HARVESTER) {
../game/game.c:1696:        G_Harvester_Stop(ent->uid);
../game/game.c:1697:        G_Harvester_ClearQueuedCmd(ent->uid);
../game/game.c:1699:    if(stop_move && (ent->flags & ENTITY_FLAG_MOVABLE)) {
../game/game.c:1702:    if(ent->flags & ENTITY_FLAG_BUILDER) {
../game/game.c:1703:        G_Builder_Stop(ent->uid);
../game/game.c:1706:    E_Entity_Notify(EVENT_ENTITY_STOP, ent->uid, NULL, ES_ENGINE);
../game/game.c:2013:        xz_ground_pos.x - cos(DEG_TO_RAD(Camera_GetYaw(s_gs.active_cam))) * offset_mag,
../game/game.c:2101:    if(ent->flags & ENTITY_FLAG_SELECTABLE)
../game/game.c:2104:    if(ent->flags & ENTITY_FLAG_MOVABLE) {
../game/game.c:2105:        khiter_t k = kh_get(entity, s_gs.dynamic, ent->uid);
../game/game.c:2114:    G_Harvester_RemoveEntity(ent->uid);
../game/game.c:2118:    G_SetVisionRange(ent->uid, 0.0f);
../game/game.c:2119:    G_Region_RemoveEnt(ent->uid);
../game/game.c:2120:    Entity_ClearTags(ent->uid);
../game/game.c:2122:    ent->flags &= ~ENTITY_FLAG_SELECTABLE;
../game/game.c:2123:    ent->flags &= ~ENTITY_FLAG_COLLISION;
../game/game.c:2124:    ent->flags &= ~ENTITY_FLAG_ANIMATED;
../game/game.c:2125:    ent->flags &= ~ENTITY_FLAG_COMBATABLE;
../game/game.c:2126:    ent->flags &= ~ENTITY_FLAG_BUILDING;
../game/game.c:2127:    ent->flags &= ~ENTITY_FLAG_MOVABLE;
../game/game.c:2128:    ent->flags &= ~ENTITY_FLAG_BUILDER;
../game/game.c:2129:    ent->flags &= ~ENTITY_FLAG_HARVESTER;
../game/game.c:2130:    ent->flags &= ~ENTITY_FLAG_RESOURCE;
../game/game.c:2131:    ent->flags &= ~ENTITY_FLAG_STORAGE_SITE;
../game/game.c:2133:    ent->flags |= ENTITY_FLAG_ZOMBIE;
../game/game.c:2136:        ent->flags |= ENTITY_FLAG_INVISIBLE;
../game/game.c:2153:    return (ent->flags & ENTITY_FLAG_ZOMBIE);
../game/game.c:2240:    if(ent->flags & ENTITY_FLAG_HARVESTER) {
../game/game.c:2241:        G_Harvester_ClearQueuedCmd(ent->uid);
../game/game.c:2243:    if(ent->flags & ENTITY_FLAG_COMBATABLE) {
../game/game_private.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/gamestate.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../game/gamestate.h:53:    /*-------------------------------------------------------------------------
../game/gamestate.h:55:     *-------------------------------------------------------------------------
../game/gamestate.h:58:    /*-------------------------------------------------------------------------
../game/gamestate.h:60:     *-------------------------------------------------------------------------
../game/gamestate.h:63:    /*-------------------------------------------------------------------------
../game/gamestate.h:65:     *-------------------------------------------------------------------------
../game/gamestate.h:68:    /*-------------------------------------------------------------------------
../game/gamestate.h:70:     *-------------------------------------------------------------------------
../game/gamestate.h:73:    /*-------------------------------------------------------------------------
../game/gamestate.h:74:     * Boolean to disable rendering of healthbars. Overrides the user-modifiable
../game/gamestate.h:76:     *-------------------------------------------------------------------------
../game/gamestate.h:79:    /*-------------------------------------------------------------------------
../game/gamestate.h:81:     *-------------------------------------------------------------------------
../game/gamestate.h:84:    /*-------------------------------------------------------------------------
../game/gamestate.h:86:     *-------------------------------------------------------------------------
../game/gamestate.h:89:    /*-------------------------------------------------------------------------
../game/gamestate.h:91:     *-------------------------------------------------------------------------
../game/gamestate.h:94:    /*-------------------------------------------------------------------------
../game/gamestate.h:96:     *-------------------------------------------------------------------------
../game/gamestate.h:99:    /*-------------------------------------------------------------------------
../game/gamestate.h:102:     *-------------------------------------------------------------------------
../game/gamestate.h:105:    /*-------------------------------------------------------------------------
../game/gamestate.h:108:     *-------------------------------------------------------------------------
../game/gamestate.h:111:    /*-------------------------------------------------------------------------
../game/gamestate.h:114:     *-------------------------------------------------------------------------
../game/gamestate.h:117:    /*-------------------------------------------------------------------------
../game/gamestate.h:118:     * Up-to-date set of all non-static entities. (Subset of 'active' set). 
../game/gamestate.h:120:     *-------------------------------------------------------------------------
../game/gamestate.h:123:    /*-------------------------------------------------------------------------
../game/gamestate.h:126:     *-------------------------------------------------------------------------
../game/gamestate.h:129:    /*-------------------------------------------------------------------------
../game/gamestate.h:132:     *-------------------------------------------------------------------------
../game/gamestate.h:135:    /*-------------------------------------------------------------------------
../game/gamestate.h:136:     * Cache of current-frame OBBs for visible entities.
../game/gamestate.h:137:     *-------------------------------------------------------------------------
../game/gamestate.h:140:    /*-------------------------------------------------------------------------
../game/gamestate.h:143:     *-------------------------------------------------------------------------
../game/gamestate.h:147:    /*-------------------------------------------------------------------------
../game/gamestate.h:150:     *-------------------------------------------------------------------------
../game/gamestate.h:153:    /*-------------------------------------------------------------------------
../game/gamestate.h:157:     *-------------------------------------------------------------------------
../game/gamestate.h:161:    /*-------------------------------------------------------------------------
../game/gamestate.h:165:     *-------------------------------------------------------------------------
../game/gamestate.h:168:    /*-------------------------------------------------------------------------
../game/gamestate.h:171:     *-------------------------------------------------------------------------
../game/harvester.c:111:    float       accum;            /* How much we gathered - only integer amounts are taken */ 
../game/harvester.c:240:    if(status == -1 || status == 0)
../game/harvester.c:255:    vec_name_destroy(&hs->priority);
../game/harvester.c:256:    kh_destroy(float, hs->gather_speeds);
../game/harvester.c:257:    kh_destroy(int, hs->max_carry);
../game/harvester.c:258:    kh_destroy(int, hs->curr_carry);
../game/harvester.c:263:    vec_name_init_alloc(&hs->priority, prealloc, pfree);
../game/harvester.c:264:    if(!vec_name_resize(&hs->priority, sizeof(buff_t) / sizeof(char*)))
../game/harvester.c:267:    hs->gather_speeds = kh_init(float);
../game/harvester.c:268:    hs->max_carry = kh_init(int);
../game/harvester.c:269:    hs->curr_carry = kh_init(int);
../game/harvester.c:271:    if(!hs->gather_speeds || !hs->max_carry || !hs->curr_carry) {
../game/harvester.c:277:    hs->ss_uid = UID_NONE;
../game/harvester.c:278:    hs->res_uid = UID_NONE;
../game/harvester.c:279:    hs->res_last_pos = (vec2_t){0};
../game/harvester.c:280:    hs->res_name = NULL;
../game/harvester.c:281:    hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:282:    hs->drop_off_only = false;
../game/harvester.c:283:    hs->accum = 0.0f;
../game/harvester.c:284:    hs->strategy = TRANSPORT_STRATEGY_NEAREST;
../game/harvester.c:285:    hs->queued.cmd = CMD_NONE;
../game/harvester.c:286:    hs->transport_src_uid = UID_NONE;
../game/harvester.c:287:    hs->transport_dest_uid = UID_NONE;
../game/harvester.c:305:    if(status == -1) {
../game/harvester.c:341:    if(status == -1) {
../game/harvester.c:371:    int idx = vec_name_indexof(&hs->priority, name, compare_keys);
../game/harvester.c:372:    if(idx == -1)
../game/harvester.c:374:    vec_name_del(&hs->priority, idx);
../game/harvester.c:379:    int idx = vec_name_indexof(&hs->priority, name, compare_keys);
../game/harvester.c:380:    if(idx != -1)
../game/harvester.c:383:    for(idx = 0; idx < vec_size(&hs->priority); idx++) {
../game/harvester.c:384:        if(strcmp(vec_AT(&hs->priority, idx), name) > 0)
../game/harvester.c:388:    if(idx < vec_size(&hs->priority)) {
../game/harvester.c:389:        if(!vec_name_resize(&hs->priority, vec_size(&hs->priority) + 1))
../game/harvester.c:392:        memmove(hs->priority.array + idx + 1, hs->priority.array + idx, 
../game/harvester.c:393:            sizeof(const char*) * (vec_size(&hs->priority) - idx));
../game/harvester.c:395:        hs->priority.array[idx] = name;
../game/harvester.c:396:        hs->priority.size++;
../game/harvester.c:399:        vec_name_push(&hs->priority, name);
../game/harvester.c:406:    struct hstate *hs = hstate_get(sarg->ent->uid);
../game/harvester.c:408:    if(!(curr->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:410:    if(G_GetFactionID(sarg->ent->uid) != G_GetFactionID(curr->uid))
../game/harvester.c:413:    int stored = G_StorageSite_GetCurr(curr->uid, sarg->rname);
../game/harvester.c:414:    int cap = ss_capacity(curr->uid, sarg->rname);
../game/harvester.c:427:    struct hstate *hs = hstate_get(sarg->ent->uid);
../game/harvester.c:429:    if(!(curr->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:431:    if(G_GetFactionID(sarg->ent->uid) != G_GetFactionID(curr->uid))
../game/harvester.c:433:    if(curr == sarg->ent)
../game/harvester.c:435:    if(G_StorageSite_GetDoNotTake(curr->uid))
../game/harvester.c:438:    /* Don't get resources from build sites - this prevents builders 
../game/harvester.c:439:     * from 'stealing' resources back-and-forth from two nearby 
../game/harvester.c:441:    if((curr->flags & ENTITY_FLAG_BUILDING) && !G_Building_IsSupplied(curr))
../game/harvester.c:444:    int stored = G_StorageSite_GetCurr(curr->uid, sarg->rname);
../game/harvester.c:445:    int cap = ss_capacity(curr->uid, sarg->rname);
../game/harvester.c:446:    int desired = ss_desired(curr->uid, sarg->rname);
../game/harvester.c:448:    if(sarg->strat == TRANSPORT_STRATEGY_EXCESS && (desired >= stored))
../game/harvester.c:461:    if(!(curr->flags & ENTITY_FLAG_RESOURCE))
../game/harvester.c:463:    if((curr->flags & ENTITY_FLAG_BUILDING) && !G_Building_IsCompleted(curr))
../game/harvester.c:465:    if(strcmp(name, G_Resource_GetName(curr->uid)))
../game/harvester.c:472:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../game/harvester.c:479:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../game/harvester.c:492:    vec2_t pos = G_Pos_GetXZ(ent->uid);
../game/harvester.c:504:    hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:505:    hs->res_uid = UID_NONE;
../game/harvester.c:506:    hs->res_last_pos = (vec2_t){0};
../game/harvester.c:507:    hs->res_name = NULL;
../game/harvester.c:508:    hs->accum = 0.0f;
../game/harvester.c:518:    kh_foreach(hs->curr_carry, key, curr, {
../game/harvester.c:527:    struct hstate *hs = hstate_get(ent->uid);
../game/harvester.c:530:    hs->state = STATE_HARVESTING_SEEK_STORAGE;
../game/harvester.c:531:    hs->ss_uid = ss->uid;
../game/harvester.c:533:    E_Entity_Register(EVENT_MOTION_END, ent->uid, on_arrive_at_storage, 
../game/harvester.c:534:        (void*)((uintptr_t)ent->uid), G_RUNNING);
../game/harvester.c:535:    E_Entity_Register(EVENT_ORDER_ISSUED, ent->uid, on_motion_begin_travel, 
../game/harvester.c:536:        (void*)((uintptr_t)ent->uid), G_RUNNING);
../game/harvester.c:538:    E_Entity_Notify(EVENT_STORAGE_TARGET_ACQUIRED, ent->uid, ss, ES_ENGINE);
../game/harvester.c:544:    struct hstate *hs = hstate_get(ent->uid);
../game/harvester.c:547:    if(!G_Harvester_GetCurrTotalCarry(ent->uid)) {
../game/harvester.c:548:        hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:554:        hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:572:    struct hstate *hs = hstate_get(ent->uid);
../game/harvester.c:573:    const char *rname = hs->res_name;
../game/harvester.c:575:    finish_harvesting(hs, ent->uid);
../game/harvester.c:581:    struct entity *resource = (hs->res_uid != UID_NONE) ? G_EntityForUID(hs->res_uid) : NULL;
../game/harvester.c:582:    if(resource && (resource->flags & ENTITY_FLAG_ZOMBIE)) {
../game/harvester.c:586:        resource = G_Pos_NearestWithPred(hs->res_last_pos, valid_resource, 
../game/harvester.c:594:    struct hstate *hs = hstate_get(ent->uid);
../game/harvester.c:597:    int cmd = hs->queued.cmd;
../game/harvester.c:598:    uint32_t arg = hs->queued.uid_arg;
../game/harvester.c:599:    hs->queued.cmd = CMD_NONE;
../game/harvester.c:618:        if((ent->flags & ENTITY_FLAG_BUILDER) && building) {
../game/harvester.c:633:    hs->drop_off_only = false;
../game/harvester.c:638:    struct hstate *hs = hstate_get(ent->uid);
../game/harvester.c:640:    return nearest_storage_site_source(storage, rname, hs->strategy);
../game/harvester.c:645:    hs->transport_dest_uid = UID_NONE;
../game/harvester.c:646:    hs->transport_src_uid = UID_NONE;
../game/harvester.c:647:    hs->res_name = NULL;
../game/harvester.c:648:    hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:659:    struct entity *target = G_EntityForUID(hs->res_uid);
../game/harvester.c:660:    if(!target || (target->flags & ENTITY_FLAG_ZOMBIE)) {
../game/harvester.c:667:    const char *rname = G_Resource_GetName(target->uid);
../game/harvester.c:668:    int resource_left = G_Resource_GetAmount(target->uid);
../game/harvester.c:671:    int gathered = hs->accum + gather_speed;
../game/harvester.c:672:    hs->accum += gather_speed;
../game/harvester.c:677:    hs->accum = 0;
../game/harvester.c:683:    resource_left = MAX(0, resource_left - (new_carry - old_carry));
../game/harvester.c:685:    G_Resource_SetAmount(target->uid, resource_left);
../game/harvester.c:690:        E_Entity_Notify(EVENT_RESOURCE_EXHAUSTED, target->uid, NULL, ES_ENGINE);
../game/harvester.c:717:    assert(hs->state == STATE_HARVESTING
../game/harvester.c:718:        || hs->state == STATE_TRANSPORT_HARVESTING);
../game/harvester.c:729:    assert(hs->state == STATE_HARVESTING_SEEK_RESOURCE
../game/harvester.c:730:        || hs->state == STATE_HARVESTING_SEEK_STORAGE
../game/harvester.c:731:        || hs->state == STATE_TRANSPORT_GETTING
../game/harvester.c:732:        || hs->state == STATE_TRANSPORT_PUTTING
../game/harvester.c:733:        || hs->state == STATE_TRANSPORT_SEEK_RESOURCE);
../game/harvester.c:760:    assert(hs->res_uid != UID_NONE);
../game/harvester.c:761:    struct entity *target = G_EntityForUID(hs->res_uid);
../game/harvester.c:764:    || (target->flags & ENTITY_FLAG_ZOMBIE)
../game/harvester.c:768:        entity_try_gather_nearest(ent, hs->res_name);
../game/harvester.c:772:    if(G_Harvester_GetCurrCarry(uid, hs->res_name) == G_Harvester_GetMaxCarry(uid, hs->res_name)) {
../game/harvester.c:780:    hs->state = STATE_HARVESTING; 
../game/harvester.c:800:    assert(hs->ss_uid != UID_NONE);
../game/harvester.c:801:    struct entity *target = G_EntityForUID(hs->ss_uid);
../game/harvester.c:804:    || !(target->flags & ENTITY_FLAG_STORAGE_SITE)
../game/harvester.c:815:    int cap = ss_capacity(target->uid, rname);
../game/harvester.c:816:    int curr = G_StorageSite_GetCurr(target->uid, rname);
../game/harvester.c:817:    int left = cap - curr;
../game/harvester.c:820:        E_Entity_Notify(EVENT_RESOURCE_DROPPED_OFF, ent->uid, NULL, ES_ENGINE);
../game/harvester.c:828:        if(resource && !hs->drop_off_only) {
../game/harvester.c:831:            hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:832:            hs->ss_uid = UID_NONE;
../game/harvester.c:833:            hs->res_name = NULL;
../game/harvester.c:839:        G_Harvester_SetCurrCarry(uid, rname, carry - left);
../game/harvester.c:859:    struct entity *src = G_EntityForUID(hs->transport_src_uid);
../game/harvester.c:862:    || !(src->flags & ENTITY_FLAG_STORAGE_SITE)
../game/harvester.c:864:    || G_StorageSite_GetDoNotTake(src->uid)) {
../game/harvester.c:868:        struct entity *dest = G_EntityForUID(hs->transport_dest_uid);
../game/harvester.c:871:        /* If the destination is still there, re-try */
../game/harvester.c:878:    int store_cap = ss_capacity(src->uid, hs->res_name);
../game/harvester.c:879:    int store_curr = G_StorageSite_GetCurr(src->uid, hs->res_name);
../game/harvester.c:880:    int desired = ss_desired(src->uid, hs->res_name);
../game/harvester.c:881:    int excess = store_curr - desired;
../game/harvester.c:883:    int max_carry = G_Harvester_GetMaxCarry(uid, hs->res_name);
../game/harvester.c:884:    int curr_carry = G_Harvester_GetCurrCarry(uid, hs->res_name);
../game/harvester.c:885:    int carry_cap = max_carry - curr_carry;
../game/harvester.c:890:    switch(hs->strategy) {
../game/harvester.c:895:        if(src == nearest_storage_site_source(ent, hs->res_name, hs->strategy)) {
../game/harvester.c:910:    G_Harvester_SetCurrCarry(uid, hs->res_name, curr_carry + take);
../game/harvester.c:911:    G_StorageSite_SetCurr(src, hs->res_name, store_curr - take);
../game/harvester.c:917:    struct entity *dest = G_EntityForUID(hs->transport_dest_uid);
../game/harvester.c:920:        hs->transport_dest_uid = UID_NONE;
../game/harvester.c:921:        hs->transport_src_uid = UID_NONE;
../game/harvester.c:922:        hs->res_name = NULL;
../game/harvester.c:923:        hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:933:        struct entity *newsrc = transport_source(ent, dest, hs->res_name);
../game/harvester.c:941:            hs->transport_src_uid = newsrc->uid;
../game/harvester.c:948:        hs->transport_dest_uid = UID_NONE;
../game/harvester.c:949:        hs->transport_src_uid = UID_NONE;
../game/harvester.c:950:        hs->res_name = NULL;
../game/harvester.c:951:        hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:963:    hs->state = STATE_TRANSPORT_PUTTING;
../game/harvester.c:980:    struct entity *dest = G_EntityForUID(hs->transport_dest_uid);
../game/harvester.c:983:    || !(dest->flags & ENTITY_FLAG_STORAGE_SITE)
../game/harvester.c:994:    int cap = ss_capacity(dest->uid, rname);
../game/harvester.c:995:    int curr = G_StorageSite_GetCurr(dest->uid, rname);
../game/harvester.c:996:    int left = cap - curr;
../game/harvester.c:999:        E_Entity_Notify(EVENT_RESOURCE_DROPPED_OFF, ent->uid, NULL, ES_ENGINE);
../game/harvester.c:1008:        G_Harvester_SetCurrCarry(uid, rname, carry - left);
../game/harvester.c:1022:    if(!target || !(target->flags & ENTITY_FLAG_RESOURCE))
../game/harvester.c:1024:    if((target->flags & ENTITY_FLAG_BUILDING) && !G_Building_IsCompleted(target))
../game/harvester.c:1030:    const char *rname = G_Resource_GetName(target->uid);
../game/harvester.c:1038:        if(!(curr->flags & ENTITY_FLAG_HARVESTER))
../game/harvester.c:1041:        if(G_Harvester_GetMaxCarry(curr->uid, rname) == 0
../game/harvester.c:1042:        || G_Harvester_GetGatherSpeed(curr->uid, rname) == 0.0f)
../game/harvester.c:1045:        struct hstate *hs = hstate_get(curr->uid);
../game/harvester.c:1065:    if(!target || !(target->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:1078:        if(!(curr->flags & ENTITY_FLAG_HARVESTER))
../game/harvester.c:1081:        struct hstate *hs = hstate_get(curr->uid);
../game/harvester.c:1084:        if(G_Harvester_GetCurrTotalCarry(curr->uid) > 0)
../game/harvester.c:1104:    if(!target || !(target->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:1117:        if(!(curr->flags & ENTITY_FLAG_HARVESTER))
../game/harvester.c:1120:        struct hstate *hs = hstate_get(curr->uid);
../game/harvester.c:1123:        if(G_Harvester_GetCurrTotalCarry(curr->uid) == 0)
../game/harvester.c:1143:    if(!target || !(target->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:1156:        if(!(curr->flags & ENTITY_FLAG_HARVESTER))
../game/harvester.c:1159:        struct hstate *hs = hstate_get(curr->uid);
../game/harvester.c:1175:    SDL_MouseButtonEvent *mouse_event = &(((SDL_Event*)event)->button);
../game/harvester.c:1178:    bool right = (mouse_event->button == SDL_BUTTON_RIGHT);
../game/harvester.c:1179:    bool left = (mouse_event->button == SDL_BUTTON_LEFT);
../game/harvester.c:1194:    if(S_UI_MouseOverWindow(mouse_event->x, mouse_event->y))
../game/harvester.c:1228:    for(int i = 0; i < vec_size(&hs->priority); i++) {
../game/harvester.c:1230:        const char *rname = vec_AT(&hs->priority, i);
../game/harvester.c:1231:        int desired = ss_desired(target->uid, rname);
../game/harvester.c:1232:        int stored = G_StorageSite_GetCurr(target->uid, rname);
../game/harvester.c:1245:    for(int i = 0; i < vec_size(&hs->priority); i++) {
../game/harvester.c:1247:        const char *rname = vec_AT(&hs->priority, i);
../game/harvester.c:1248:        int stored = G_StorageSite_GetCurr(target->uid, rname);
../game/harvester.c:1261:    hstate_get_key_float(hs->gather_speeds, rname, &speed);
../game/harvester.c:1276:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1278:    hs->res_uid = newtarget->uid;
../game/harvester.c:1279:    hs->res_last_pos = G_Pos_GetXZ(newtarget->uid);
../game/harvester.c:1280:    hs->res_name = rname;
../game/harvester.c:1283:        on_arrive_at_resource_source((void*)((uintptr_t)harvester->uid), NULL);
../game/harvester.c:1285:        E_Entity_Register(EVENT_MOTION_END, harvester->uid, on_arrive_at_resource_source, 
../game/harvester.c:1286:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1287:        E_Entity_Register(EVENT_ORDER_ISSUED, harvester->uid, on_motion_begin_travel, 
../game/harvester.c:1288:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1307:    struct entity *dest = G_EntityForUID(hs->transport_dest_uid);
../game/harvester.c:1310:        hs->transport_dest_uid = UID_NONE;
../game/harvester.c:1311:        hs->transport_src_uid = UID_NONE;
../game/harvester.c:1312:        hs->res_name = NULL;
../game/harvester.c:1313:        hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:1317:    assert(hs->res_uid != UID_NONE);
../game/harvester.c:1318:    struct entity *target = G_EntityForUID(hs->res_uid);
../game/harvester.c:1321:    || (target->flags & ENTITY_FLAG_ZOMBIE)
../game/harvester.c:1325:        entity_try_gather_nearest_source(ent, hs->res_name, dest);
../game/harvester.c:1329:    if(G_Harvester_GetCurrCarry(uid, hs->res_name) == G_Harvester_GetMaxCarry(uid, hs->res_name)) {
../game/harvester.c:1338:        hs->state = STATE_TRANSPORT_PUTTING;
../game/harvester.c:1344:    hs->state = STATE_TRANSPORT_HARVESTING; 
../game/harvester.c:1357:    struct entity *dest = G_EntityForUID(hs->transport_dest_uid);
../game/harvester.c:1361:        hs->transport_dest_uid = UID_NONE;
../game/harvester.c:1362:        hs->transport_src_uid = UID_NONE;
../game/harvester.c:1366:    struct entity *target = G_EntityForUID(hs->res_uid);
../game/harvester.c:1367:    if(!target || (target->flags & ENTITY_FLAG_ZOMBIE)) {
../game/harvester.c:1370:        const char *rname = hs->res_name;
../game/harvester.c:1371:        finish_harvesting(hs, ent->uid);
../game/harvester.c:1376:    const char *rname = G_Resource_GetName(target->uid);
../game/harvester.c:1377:    int resource_left = G_Resource_GetAmount(target->uid);
../game/harvester.c:1380:    int gathered = hs->accum + gather_speed;
../game/harvester.c:1381:    hs->accum += gather_speed;
../game/harvester.c:1386:    hs->accum = 0;
../game/harvester.c:1392:    resource_left = MAX(0, resource_left - (new_carry - old_carry));
../game/harvester.c:1394:    G_Resource_SetAmount(target->uid, resource_left);
../game/harvester.c:1399:        E_Entity_Notify(EVENT_RESOURCE_EXHAUSTED, target->uid, NULL, ES_ENGINE);
../game/harvester.c:1403:            const char *rname = hs->res_name;
../game/harvester.c:1404:            finish_harvesting(hs, ent->uid);
../game/harvester.c:1412:        finish_harvesting(hs, ent->uid);
../game/harvester.c:1413:        hs->transport_dest_uid = UID_NONE;
../game/harvester.c:1414:        hs->transport_src_uid = UID_NONE;
../game/harvester.c:1432:        hs->state = STATE_TRANSPORT_PUTTING;
../game/harvester.c:1439:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1445:    vec2_t pos = G_Pos_GetXZ(harvester->uid);
../game/harvester.c:1453:    hs->state = STATE_TRANSPORT_SEEK_RESOURCE;
../game/harvester.c:1454:    hs->transport_dest_uid = storage->uid;
../game/harvester.c:1455:    hs->res_uid = resource->uid;
../game/harvester.c:1456:    hs->res_last_pos = G_Pos_GetXZ(resource->uid);
../game/harvester.c:1457:    hs->res_name = G_Resource_GetName(resource->uid);
../game/harvester.c:1458:    E_Entity_Notify(EVENT_HARVEST_TARGET_ACQUIRED, harvester->uid, resource, ES_ENGINE);
../game/harvester.c:1461:        on_arrive_at_resource_source((void*)((uintptr_t)harvester->uid), NULL);
../game/harvester.c:1463:        E_Entity_Register(EVENT_MOTION_END, harvester->uid, on_arrive_at_resource_source, 
../game/harvester.c:1464:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1465:        E_Entity_Register(EVENT_ORDER_ISSUED, harvester->uid, on_motion_begin_travel, 
../game/harvester.c:1466:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1535:    return hstate_set_key_float(hs->gather_speeds, rname, speed);
../game/harvester.c:1544:    hstate_get_key_float(hs->gather_speeds, rname, &ret);
../game/harvester.c:1562:    return hstate_set_key_int(hs->max_carry, rname, max);
../game/harvester.c:1571:    hstate_get_key_int(hs->max_carry, rname, &ret);
../game/harvester.c:1579:    return hstate_set_key_int(hs->curr_carry, rname, curr);
../game/harvester.c:1588:    hstate_get_key_int(hs->curr_carry, rname, &ret);
../game/harvester.c:1596:    kh_clear(int, hs->curr_carry);
../game/harvester.c:1598:    if(hs->state == STATE_HARVESTING_SEEK_STORAGE 
../game/harvester.c:1599:    || hs->state == STATE_TRANSPORT_PUTTING) {
../game/harvester.c:1603:        hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:1611:    hs->strategy = strat;
../game/harvester.c:1618:    return hs->strategy;
../game/harvester.c:1630:    int idx = vec_name_indexof(&hs->priority, key, compare_keys);
../game/harvester.c:1631:    if(idx == -1)
../game/harvester.c:1636:    const char *tmp = vec_AT(&hs->priority, idx - 1);
../game/harvester.c:1637:    vec_AT(&hs->priority, idx - 1) = key;
../game/harvester.c:1638:    vec_AT(&hs->priority, idx) = tmp;
../game/harvester.c:1652:    int idx = vec_name_indexof(&hs->priority, key, compare_keys);
../game/harvester.c:1653:    if(idx == -1)
../game/harvester.c:1655:    if(idx == vec_size(&hs->priority) - 1)
../game/harvester.c:1658:    const char *tmp = vec_AT(&hs->priority, idx + 1);
../game/harvester.c:1659:    vec_AT(&hs->priority, idx + 1) = key;
../game/harvester.c:1660:    vec_AT(&hs->priority, idx) = tmp;
../game/harvester.c:1669:    size_t ret = MIN(maxout, vec_size(&hs->priority));
../game/harvester.c:1671:    memcpy(out, hs->priority.array, ret * sizeof(const char*));
../game/harvester.c:1685:    kh_foreach(hs->curr_carry, key, curr, {
../game/harvester.c:1726:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1729:    if(!(resource->flags & ENTITY_FLAG_RESOURCE))
../game/harvester.c:1731:    if((resource->flags & ENTITY_FLAG_BUILDING) && !G_Building_IsCompleted(resource))
../game/harvester.c:1734:    if(G_Harvester_GetCurrTotalCarry(harvester->uid)) {
../game/harvester.c:1737:        if(strcmp(carryname, G_Resource_GetName(resource->uid))) {
../game/harvester.c:1740:            hs->queued.cmd = CMD_GATHER;
../game/harvester.c:1741:            hs->queued.uid_arg = resource->uid;
../game/harvester.c:1748:    hs->state = STATE_HARVESTING_SEEK_RESOURCE;
../game/harvester.c:1749:    hs->res_uid = resource->uid;
../game/harvester.c:1750:    hs->res_last_pos = G_Pos_GetXZ(resource->uid);
../game/harvester.c:1751:    hs->res_name = G_Resource_GetName(resource->uid);
../game/harvester.c:1752:    E_Entity_Notify(EVENT_HARVEST_TARGET_ACQUIRED, harvester->uid, resource, ES_ENGINE);
../game/harvester.c:1755:        on_arrive_at_resource((void*)((uintptr_t)harvester->uid), NULL);
../game/harvester.c:1757:        E_Entity_Register(EVENT_MOTION_END, harvester->uid, on_arrive_at_resource, 
../game/harvester.c:1758:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1759:        E_Entity_Register(EVENT_ORDER_ISSUED, harvester->uid, on_motion_begin_travel, 
../game/harvester.c:1760:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1769:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1772:    if(!(storage->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:1775:    if(G_Harvester_GetCurrTotalCarry(harvester->uid) == 0)
../game/harvester.c:1778:    G_Harvester_Stop(harvester->uid);
../game/harvester.c:1779:    hs->drop_off_only = true;
../game/harvester.c:1786:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1789:    if(!(storage->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:1792:    if(G_Harvester_GetCurrTotalCarry(harvester->uid) > 0)
../game/harvester.c:1799:    G_Harvester_Stop(harvester->uid);
../game/harvester.c:1800:    hs->state = STATE_TRANSPORT_GETTING;
../game/harvester.c:1801:    hs->transport_dest_uid = UID_NONE;
../game/harvester.c:1802:    hs->transport_src_uid = storage->uid;
../game/harvester.c:1803:    hs->res_name = rname;
../game/harvester.c:1804:    E_Entity_Notify(EVENT_TRANSPORT_TARGET_ACQUIRED, harvester->uid, storage, ES_ENGINE);
../game/harvester.c:1807:        on_arrive_at_transport_source((void*)((uintptr_t)harvester->uid), NULL);
../game/harvester.c:1809:        E_Entity_Register(EVENT_MOTION_END, harvester->uid, on_arrive_at_transport_source, 
../game/harvester.c:1810:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1811:        E_Entity_Register(EVENT_ORDER_ISSUED, harvester->uid, on_motion_begin_travel, 
../game/harvester.c:1812:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1821:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1824:    if(!(storage->flags & ENTITY_FLAG_STORAGE_SITE))
../game/harvester.c:1827:    if(hs->queued.cmd != CMD_NONE) {
../game/harvester.c:1832:    if(G_Harvester_GetCurrTotalCarry(harvester->uid)) {
../game/harvester.c:1836:        if(!G_StorageSite_Desires(target->uid, carryname)) {
../game/harvester.c:1844:        hs->queued.cmd = CMD_TRANSPORT;
../game/harvester.c:1845:        hs->queued.uid_arg = storage->uid;
../game/harvester.c:1854:    if(hs->strategy == TRANSPORT_STRATEGY_GATHERING
../game/harvester.c:1863:    G_Harvester_Stop(harvester->uid);
../game/harvester.c:1864:    hs->state = STATE_TRANSPORT_GETTING;
../game/harvester.c:1865:    hs->transport_dest_uid = storage->uid;
../game/harvester.c:1866:    hs->transport_src_uid = src->uid;
../game/harvester.c:1867:    hs->res_name = rname;
../game/harvester.c:1868:    E_Entity_Notify(EVENT_TRANSPORT_TARGET_ACQUIRED, harvester->uid, storage, ES_ENGINE);
../game/harvester.c:1871:        on_arrive_at_transport_source((void*)((uintptr_t)harvester->uid), NULL);
../game/harvester.c:1873:        E_Entity_Register(EVENT_MOTION_END, harvester->uid, on_arrive_at_transport_source, 
../game/harvester.c:1874:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1875:        E_Entity_Register(EVENT_ORDER_ISSUED, harvester->uid, on_motion_begin_travel, 
../game/harvester.c:1876:            (void*)((uintptr_t)harvester->uid), G_RUNNING);
../game/harvester.c:1885:    struct hstate *hs = hstate_get(harvester->uid);
../game/harvester.c:1888:    if(G_Harvester_GetCurrTotalCarry(harvester->uid)
../game/harvester.c:1889:    && !G_StorageSite_Desires(building->uid, carried_resource_name(hs))) {
../game/harvester.c:1894:        hs->queued.cmd = CMD_SUPPLY;
../game/harvester.c:1895:        hs->queued.uid_arg = building->uid;
../game/harvester.c:1905:    hs->queued.cmd = CMD_BUILD;
../game/harvester.c:1906:    hs->queued.uid_arg = building->uid;
../game/harvester.c:1915:    if(hs->state == STATE_HARVESTING) {
../game/harvester.c:1918:    hs->state = STATE_NOT_HARVESTING;
../game/harvester.c:1936:    hs->queued.cmd = CMD_NONE;
../game/harvester.c:1937:    hs->queued.uid_arg = UID_NONE;
../game/harvester.c:1961:    if(first->flags & ENTITY_FLAG_HARVESTER && hovered->flags & ENTITY_FLAG_RESOURCE)
../game/harvester.c:1976:    if((hovered->flags & ENTITY_FLAG_BUILDING)
../game/harvester.c:1995:    if(!(first->flags & ENTITY_FLAG_HARVESTER))
../game/harvester.c:1998:    if(hovered->flags & ENTITY_FLAG_RESOURCE
../game/harvester.c:1999:    && G_Harvester_GetGatherSpeed(first->uid, G_Resource_GetName(hovered->uid)) > 0)
../game/harvester.c:2002:    if(G_GetFactionID(hovered->uid) != G_GetFactionID(first->uid))
../game/harvester.c:2005:    if(hovered->flags & ENTITY_FLAG_STORAGE_SITE
../game/harvester.c:2006:    && G_Harvester_GetCurrTotalCarry(first->uid) > 0)
../game/harvester.c:2009:    if(hovered->flags & ENTITY_FLAG_STORAGE_SITE)
../game/harvester.c:2021:    if(!(hovered->flags & ENTITY_FLAG_RESOURCE))
../game/harvester.c:2024:    const char *name = G_Resource_GetCursor(hovered->uid);
../game/harvester.c:2230:        hs->state = attr.val.as_int;
../game/harvester.c:2232:        switch(hs->state) {
../game/harvester.c:2283:        hs->strategy = attr.val.as_int;
../game/harvester.c:2287:        hs->ss_uid = attr.val.as_int;
../game/harvester.c:2291:        hs->res_uid = attr.val.as_int;
../game/harvester.c:2295:        hs->res_last_pos = attr.val.as_vec2;
../game/harvester.c:2306:            hs->res_name = key;
../game/harvester.c:2367:        vec_name_reset(&hs->priority);
../game/harvester.c:2375:            vec_name_push(&hs->priority, key);
../game/harvester.c:2380:        hs->drop_off_only = attr.val.as_bool;
../game/harvester.c:2384:        hs->accum = attr.val.as_float;
../game/harvester.c:2388:        hs->queued.cmd = attr.val.as_int;
../game/harvester.c:2392:        hs->queued.uid_arg = attr.val.as_int;
../game/harvester.c:2396:        hs->transport_src_uid = attr.val.as_int;
../game/harvester.c:2400:        hs->transport_dest_uid = attr.val.as_int;
../game/movement.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/movement.c:73:#define SIGNUM(x)    (((x) > 0) - ((x) < 0))
../game/movement.c:152:     * threshold again - this is to prevent 'toggling' at a boundary where we switch 
../game/movement.c:264:    khiter_t k = kh_get(state, s_entity_state_table, ent->uid);
../game/movement.c:273:    if((k = kh_get(entity, flock->ents, ent->uid)) != kh_end(flock->ents))
../game/movement.c:274:        kh_del(entity, flock->ents, k);
../game/movement.c:280:    khiter_t k = kh_put(entity, flock->ents, ent->uid, &ret);
../game/movement.c:281:    assert(ret != -1 && ret != 0);
../game/movement.c:282:    kh_value(flock->ents, k) = (struct entity*)ent;
../game/movement.c:287:    khiter_t k = kh_get(entity, flock->ents, ent->uid);
../game/movement.c:288:    if(k != kh_end(flock->ents))
../game/movement.c:309:        if(curr_flock->dest_id == id)
../game/movement.c:317:    M_NavBlockersIncref(G_Pos_GetXZ(ent->uid), G_GetSelectionRadius(ent->uid), G_GetFactionID(ent->uid), s_map);
../game/movement.c:320:    assert(!ms->blocking);
../game/movement.c:322:    ms->blocking = true;
../game/movement.c:323:    ms->last_stop_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:324:    ms->last_stop_radius = G_GetSelectionRadius(ent->uid);
../game/movement.c:330:    assert(ms->blocking);
../game/movement.c:332:    M_NavBlockersDecref(ms->last_stop_pos, ms->last_stop_radius, G_GetFactionID(ent->uid), s_map);
../game/movement.c:333:    ms->blocking = false;
../game/movement.c:338:    if(!(ent->flags & ENTITY_FLAG_MOVABLE))
../game/movement.c:342:    if(ms->max_speed == 0.0f)
../game/movement.c:350:    return ((*a)->uid == (*b)->uid);
../game/movement.c:364:    return (ms->state == STATE_ARRIVED || ms->state == STATE_WAITING);
../game/movement.c:372:    E_Entity_Notify(EVENT_MOTION_END, ent->uid, NULL, ES_ENGINE);
../game/movement.c:373:    if(ent->flags & ENTITY_FLAG_COMBATABLE
../game/movement.c:374:    && (ms->state != STATE_TURNING)) {
../game/movement.c:379:        ms->wait_prev = ms->state;
../game/movement.c:380:        ms->wait_ticks_left = WAIT_TICKS;
../game/movement.c:383:    ms->state = newstate;
../game/movement.c:384:    ms->velocity = (vec2_t){0.0f, 0.0f};
../game/movement.c:385:    ms->vnew = (vec2_t){0.0f, 0.0f};
../game/movement.c:397:    assert(idx != -1);
../game/movement.c:400:    E_Entity_Unregister(EVENT_ANIM_FINISHED, ent->uid, on_marker_anim_finish);
../game/movement.c:411:        if(desc.chunk_r == curr->chunk_r && desc.chunk_c == curr->chunk_c) 
../game/movement.c:423:    for(int i = vec_size(&s_flocks)-1; i >= 0; i--) {
../game/movement.c:428:        if(kh_size(curr_flock->ents) == 0) {
../game/movement.c:429:            kh_destroy(entity, curr_flock->ents);
../game/movement.c:442:        vec2_t xz_pos = G_Pos_GetXZ(curr->uid);
../game/movement.c:475:    vec2_t first_ent_pos_xz = G_Pos_GetXZ(first->uid);
../game/movement.c:506:            E_Entity_Notify(EVENT_MOTION_START, curr_ent->uid, NULL, ES_ENGINE);
../game/movement.c:510:        ms->state = STATE_MOVING;
../game/movement.c:513:    /* The flow fields will be computed on-demand during the next movement update tick */
../game/movement.c:516:        new_flock.dest_id = M_NavDestIDForPosAttacking(s_map, target_xz, layer, G_GetFactionID(first->uid));
../game/movement.c:564:    vec2_t ent_xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:571:    kh_foreach(flock->ents, key, curr, {
../game/movement.c:578:        vec2_t curr_xz_pos = G_Pos_GetXZ(curr->uid);
../game/movement.c:581:        if(PFM_Vec2_Len(&diff) <= G_GetSelectionRadius(ent->uid) + G_GetSelectionRadius(curr->uid) + ADJACENCY_SEP_DIST)
../game/movement.c:590:    struct entity *ent = attack ? AL_EntityFromPFObj("assets/models/arrow", "arrow-red.pfobj", "__move_marker__", uid) 
../game/movement.c:591:                                : AL_EntityFromPFObj("assets/models/arrow", "arrow-green.pfobj", "__move_marker__", uid);
../game/movement.c:595:    ent->flags |= ENTITY_FLAG_MARKER;
../game/movement.c:598:    Entity_SetScale(ent->uid, (vec3_t){2.0f, 2.0f, 2.0f});
../game/movement.c:599:    E_Entity_Register(EVENT_ANIM_FINISHED, ent->uid, on_marker_anim_finish, ent, G_RUNNING);
../game/movement.c:600:    A_SetActiveClip(ent->uid, "Converge", ANIM_MODE_ONCE, 48);
../game/movement.c:607:    SDL_MouseButtonEvent *mouse_event = &(((SDL_Event*)event)->button);
../game/movement.c:610:    bool attack = s_attack_on_lclick && (mouse_event->button == SDL_BUTTON_LEFT);
../game/movement.c:611:    bool move = s_move_on_lclick ? mouse_event->button == SDL_BUTTON_LEFT
../game/movement.c:612:                                 : mouse_event->button == SDL_BUTTON_RIGHT;
../game/movement.c:623:    if(S_UI_MouseOverWindow(mouse_event->x, mouse_event->y))
../game/movement.c:626:    if((mouse_event->button == SDL_BUTTON_RIGHT) && targeting)
../game/movement.c:653:        if(!(curr->flags & ENTITY_FLAG_MOVABLE))
../game/movement.c:657:        E_Entity_Notify(EVENT_MOVE_ISSUED, curr->uid, NULL, ES_ENGINE);
../game/movement.c:661:        if(curr->flags & ENTITY_FLAG_COMBATABLE) {
../game/movement.c:705:                s_state_str[ms->state], ms->velocity.x, ms->velocity.z);
../game/movement.c:712:            switch(ms->state) {
../game/movement.c:716:                M_NavRenderVisiblePathFlowField(s_map, cam, flock->dest_id);
../game/movement.c:720:                struct entity *target = G_EntityForUID(ms->surround_target_uid);
../game/movement.c:724:                if(ms->using_surround_field) {
../game/movement.c:728:                    M_NavRenderVisiblePathFlowField(s_map, cam, flock->dest_id);
../game/movement.c:738:                M_NavRenderVisibleEnemySeekField(s_map, cam, Entity_NavLayer(ent), G_GetFactionID(ent->uid));
../game/movement.c:796:    float angle_rad = atan2(velocity.raw[1], velocity.raw[0]) - M_PI/2.0f;
../game/movement.c:808:    vec2_t pos_xz = G_Pos_GetXZ(ent->uid);
../game/movement.c:811:    switch(ms->state) {
../game/movement.c:816:        return M_NavDesiredEnemySeekVelocity(s_map, Entity_NavLayer(ent), pos_xz, G_GetFactionID(ent->uid));
../game/movement.c:820:        const struct entity *target = G_EntityForUID(ms->surround_target_uid);
../game/movement.c:822:            return M_NavDesiredPointSeekVelocity(s_map, fl->dest_id, pos_xz, fl->target_xz);
../game/movement.c:825:        vec2_t target_pos_xz = G_Pos_GetXZ(ms->surround_target_uid);
../game/movement.c:826:        float dx = fabs(target_pos_xz.x - pos_xz.x);
../game/movement.c:827:        float dz = fabs(target_pos_xz.z - pos_xz.z);
../game/movement.c:829:        if(!ms->using_surround_field) {
../game/movement.c:831:                ms->using_surround_field = true;
../game/movement.c:835:                ms->using_surround_field = true;
../game/movement.c:839:        if(ms->using_surround_field) {
../game/movement.c:841:                pos_xz, target, G_GetFactionID(ent->uid));
../game/movement.c:843:            return M_NavDesiredPointSeekVelocity(s_map, fl->dest_id, pos_xz, fl->target_xz);
../game/movement.c:849:        return M_NavDesiredPointSeekVelocity(s_map, fl->dest_id, pos_xz, fl->target_xz);
../game/movement.c:861:    vec2_t pos_xz = G_Pos_GetXZ(ent->uid);
../game/movement.c:865:    PFM_Vec2_Scale(&desired_velocity, ms->max_speed / MOVE_TICK_RES, &desired_velocity);
../game/movement.c:867:    PFM_Vec2_Sub(&desired_velocity, &ms->velocity, &ret);
../game/movement.c:880:    vec2_t pos_xz = G_Pos_GetXZ(ent->uid);
../game/movement.c:891:        PFM_Vec2_Scale(&desired_velocity, ms->max_speed / MOVE_TICK_RES, &desired_velocity);
../game/movement.c:899:        PFM_Vec2_Scale(&ms->vdes, ms->max_speed / MOVE_TICK_RES, &desired_velocity);
../game/movement.c:902:    PFM_Vec2_Sub(&desired_velocity, &ms->velocity, &ret);
../game/movement.c:910:    vec2_t pos_xz = G_Pos_GetXZ(ent->uid);
../game/movement.c:916:    PFM_Vec2_Scale(&ms->vdes, ms->max_speed / MOVE_TICK_RES, &desired_velocity);
../game/movement.c:917:    PFM_Vec2_Sub(&desired_velocity, &ms->velocity, &ret);
../game/movement.c:933:    kh_foreach(flock->ents, key, curr, {
../game/movement.c:939:        vec2_t ent_xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:940:        vec2_t curr_xz_pos = G_Pos_GetXZ(curr->uid);
../game/movement.c:948:            if(PFM_Vec2_Len(&ms->velocity) < EPSILON)
../game/movement.c:951:            PFM_Vec2_Add(&ret, &ms->velocity, &ret);
../game/movement.c:963:    PFM_Vec2_Sub(&ret, &ms->velocity, &ret);
../game/movement.c:974:    vec2_t ent_xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:980:    kh_foreach(flock->ents, key, curr, {
../game/movement.c:986:        vec2_t curr_xz_pos = G_Pos_GetXZ(curr->uid);
../game/movement.c:989:        float t = (PFM_Vec2_Len(&diff) - COHESION_NEIGHBOUR_RADIUS*0.75) / COHESION_NEIGHBOUR_RADIUS;
../game/movement.c:990:        float scale = exp(-6.0f * t);
../game/movement.c:1013:    int num_near = G_Pos_EntsInCircle(G_Pos_GetXZ(ent->uid), 
../game/movement.c:1021:        if(!(curr->flags & ENTITY_FLAG_MOVABLE))
../game/movement.c:1025:        vec2_t ent_xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:1026:        vec2_t curr_xz_pos = G_Pos_GetXZ(curr->uid);
../game/movement.c:1028:        float radius = G_GetSelectionRadius(ent->uid) + G_GetSelectionRadius(curr->uid) + buffer_dist;
../game/movement.c:1035:        float t = (PFM_Vec2_Len(&diff) - radius*0.85) / PFM_Vec2_Len(&diff);
../game/movement.c:1036:        float scale = exp(-20.0f * t);
../game/movement.c:1045:    PFM_Vec2_Scale(&ret, -1.0f, &ret);
../game/movement.c:1055:    vec2_t arrive = arrive_force_point(ent, flock->dest_id, flock->target_xz);
../game/movement.c:1095:    vec2_t xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:1109:    vec2_t left =  (vec2_t){G_Pos_Get(ent->uid).x + nt_dims.x, G_Pos_Get(ent->uid).z};
../game/movement.c:1110:    vec2_t right = (vec2_t){G_Pos_Get(ent->uid).x - nt_dims.x, G_Pos_Get(ent->uid).z};
../game/movement.c:1111:    vec2_t top =   (vec2_t){G_Pos_Get(ent->uid).x, G_Pos_Get(ent->uid).z + nt_dims.z};
../game/movement.c:1112:    vec2_t bot =   (vec2_t){G_Pos_Get(ent->uid).x, G_Pos_Get(ent->uid).z - nt_dims.z};
../game/movement.c:1114:    if(inout_force->x > 0 
../game/movement.c:1116:        inout_force->x = 0.0f;
../game/movement.c:1118:    if(inout_force->x < 0 
../game/movement.c:1120:        inout_force->x = 0.0f;
../game/movement.c:1122:    if(inout_force->z > 0 
../game/movement.c:1124:        inout_force->z = 0.0f;
../game/movement.c:1126:    if(inout_force->z < 0 
../game/movement.c:1128:        inout_force->z = 0.0f;
../game/movement.c:1142:        case 2: steer_force = arrive_force_point(ent, flock->dest_id, flock->target_xz); break;
../game/movement.c:1153:    PFM_Vec2_Add(&ms->velocity, &accel, &new_vel);
../game/movement.c:1154:    vec2_truncate(&new_vel, ms->max_speed / MOVE_TICK_RES);
../game/movement.c:1169:    PFM_Vec2_Add(&ms->velocity, &accel, &new_vel);
../game/movement.c:1170:    vec2_truncate(&new_vel, ms->max_speed / MOVE_TICK_RES);
../game/movement.c:1177:    assert(ms->vel_hist >= 0 && ms->vel_hist_idx < VEL_HIST_LEN);
../game/movement.c:1178:    ms->vel_hist[ms->vel_hist_idx] = vnew;
../game/movement.c:1179:    ms->vel_hist_idx = ((ms->vel_hist_idx+1) % VEL_HIST_LEN);
../game/movement.c:1187:        PFM_Vec2_Add(&ret, (vec2_t*)&ms->vel_hist[i], &ret); 
../game/movement.c:1200:        vec2_t term = ms->vel_hist[i];
../game/movement.c:1201:        PFM_Vec2_Scale(&term, VEL_HIST_LEN-i, &term);
../game/movement.c:1203:        denom += (VEL_HIST_LEN-i);
../game/movement.c:1224:        ms->velocity = new_vel;
../game/movement.c:1232:            Entity_SetRot(ent->uid, dir_quat_from_velocity(wma));
../game/movement.c:1235:        ms->velocity = (vec2_t){0.0f, 0.0f}; 
../game/movement.c:1240:     * pathable terrain to non-pathable terrain, but an this violation is possible by 
../game/movement.c:1243:    if(!M_NavPositionPathable(s_map, layer, G_Pos_GetXZ(ent->uid)))
../game/movement.c:1246:    switch(ms->state) {
../game/movement.c:1250:        vec2_t xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:1254:        PFM_Vec2_Sub((vec2_t*)&flock->target_xz, &xz_pos, &diff_to_target);
../game/movement.c:1255:        float arrive_thresh = G_GetSelectionRadius(ent->uid) * 1.5f;
../game/movement.c:1259:            && M_NavIsMaximallyClose(s_map, layer, xz_pos, flock->target_xz, arrive_thresh))) {
../game/movement.c:1265:        struct entity *adjacent[kh_size(flock->ents)];
../game/movement.c:1274:            if(adj_ms->state == STATE_ARRIVED) {
../game/movement.c:1288:         * the entity any closer to its' goal. Stop and wait, re-requesting the  path 
../game/movement.c:1291:        if(PFM_Vec2_Len(&ms->vdes) < EPSILON) {
../game/movement.c:1301:        if(PFM_Vec2_Len(&ms->vdes) < EPSILON) {
../game/movement.c:1309:        struct entity *target = G_EntityForUID(ms->surround_target_uid);
../game/movement.c:1321:        vec2_t target_pos = G_Pos_GetXZ(ms->surround_target_uid);
../game/movement.c:1322:        vec2_t dest = ms->surround_nearest_prev;
../game/movement.c:1325:        PFM_Vec2_Sub(&target_pos, &ms->surround_target_prev, &delta);
../game/movement.c:1326:        if(PFM_Vec2_Len(&delta) > EPSILON || PFM_Vec2_Len(&ms->velocity) < EPSILON) {
../game/movement.c:1329:                G_Pos_GetXZ(ent->uid), target, &dest);
../game/movement.c:1341:        PFM_Vec2_Sub(&flock->target_xz, &dest, &diff);
../game/movement.c:1342:        ms->surround_target_prev = target_pos;
../game/movement.c:1343:        ms->surround_nearest_prev = dest;
../game/movement.c:1347:            ms->state = STATE_SURROUND_ENTITY;
../game/movement.c:1351:        if(PFM_Vec2_Len(&ms->vdes) < EPSILON) {
../game/movement.c:1358:        struct entity *target = G_EntityForUID(ms->surround_target_uid);
../game/movement.c:1364:        vec2_t xz_pos = G_Pos_GetXZ(ent->uid);
../game/movement.c:1365:        vec2_t xz_target = G_Pos_GetXZ(ms->surround_target_uid);
../game/movement.c:1370:        if(PFM_Vec2_Len(&delta) <= ms->target_range
../game/movement.c:1379:        PFM_Vec2_Sub(&xz_target, &ms->target_prev_pos, &target_delta);
../game/movement.c:1383:            ms->state = STATE_ENTER_ENTITY_RANGE;
../game/movement.c:1384:            ms->target_prev_pos = xz_target;
../game/movement.c:1392:        quat_t ent_rot = Entity_GetRot(ent->uid);
../game/movement.c:1393:        float angle_diff = PFM_Quat_PitchDiff(&ent_rot, &ms->target_dir);
../game/movement.c:1403:        float turn_deg = MIN(MAX_TURN_RATE, fabs(degrees)) * -SIGNUM(degrees);
../game/movement.c:1414:        Entity_SetRot(ent->uid, final);
../game/movement.c:1420:        assert(ms->wait_ticks_left > 0);
../game/movement.c:1421:        ms->wait_ticks_left--;
../game/movement.c:1422:        if(ms->wait_ticks_left == 0) {
../game/movement.c:1424:            assert(ms->wait_prev == STATE_MOVING 
../game/movement.c:1425:                || ms->wait_prev == STATE_SEEK_ENEMIES
../game/movement.c:1426:                || ms->wait_prev == STATE_SURROUND_ENTITY);
../game/movement.c:1429:            E_Entity_Notify(EVENT_MOTION_START, ent->uid, NULL, ES_ENGINE);
../game/movement.c:1430:            ms->state = ms->wait_prev;
../game/movement.c:1453:    int num_near = G_Pos_EntsInCircle(G_Pos_GetXZ(ent->uid), 
../game/movement.c:1459:        if(curr->uid == ent->uid)
../game/movement.c:1462:        if(!(curr->flags & ENTITY_FLAG_MOVABLE))
../game/movement.c:1465:        if(G_GetSelectionRadius(curr->uid) == 0.0f)
../game/movement.c:1471:        vec2_t curr_xz_pos = G_Pos_GetXZ(curr->uid);
../game/movement.c:1474:            .xz_vel = ms->velocity,
../game/movement.c:1475:            .radius = G_GetSelectionRadius(curr->uid)
../game/movement.c:1492:    for(int i = vec_size(&s_flocks)-1; i >= 0; i--) {
../game/movement.c:1501:            if(ms->state != STATE_ARRIVED) {
../game/movement.c:1531:    /* no-op */
../game/movement.c:1541:        vec2_t new_vel = G_ClearPath_NewVelocity(in->ent, in->ent_uid, 
../game/movement.c:1542:            in->ent_des_v, in->dyn_neighbs, in->stat_neighbs, in->save_debug);
../game/movement.c:1543:        out->ent_uid = in->ent_uid;
../game/movement.c:1544:        out->ent_vel = new_vel;
../game/movement.c:1553:    for(int i = cp_arg->begin_idx; i <= cp_arg->end_idx; i++) {
../game/movement.c:1558:        vec2_t new_vel = G_ClearPath_NewVelocity(in->ent, in->ent_uid, 
../game/movement.c:1559:            in->ent_des_v, in->dyn_neighbs, in->stat_neighbs, in->save_debug);
../game/movement.c:1560:        out->ent_uid = in->ent_uid;
../game/movement.c:1561:        out->ent_vel = new_vel;
../game/movement.c:1597:        ms->vnew = s_cp_work.out[i].ent_vel;
../game/movement.c:1598:        update_vel_hist(ms, ms->vnew);
../game/movement.c:1601:        PFM_Vec2_Sub(&ms->vnew, &ms->velocity, &vel_diff);
../game/movement.c:1603:        PFM_Vec2_Add(&ms->velocity, &vel_diff, &ms->vnew);
../game/movement.c:1604:        vec2_truncate(&ms->vnew, ms->max_speed / MOVE_TICK_RES);
../game/movement.c:1654:        arg->begin_idx = nitems * i;
../game/movement.c:1655:        arg->end_idx = MIN(nitems * (i + 1) - 1, s_cp_work.nwork-1);
../game/movement.c:1662:            clearpath_work(arg->begin_idx, arg->end_idx);
../game/movement.c:1688:        vec2_t vpref = (vec2_t){-1,-1};
../game/movement.c:1689:        ms->vdes = ent_desired_velocity(curr);
../game/movement.c:1691:        switch(ms->state) {
../game/movement.c:1703:        assert(vpref.x != -1 || vpref.z != -1);
../game/movement.c:1706:            .xz_pos = G_Pos_GetXZ(curr->uid),
../game/movement.c:1707:            .xz_vel = ms->velocity,
../game/movement.c:1708:            .radius = G_GetSelectionRadius(curr->uid)
../game/movement.c:1775:        E_Entity_Unregister(EVENT_ANIM_FINISHED, vec_AT(&s_move_markers, i)->uid, on_marker_anim_finish);
../game/movement.c:1801:    khiter_t k = kh_put(state, s_entity_state_table, ent->uid, &ret);
../game/movement.c:1802:    assert(ret != -1 && ret != 0);
../game/movement.c:1810:    khiter_t k = kh_get(state, s_entity_state_table, ent->uid);
../game/movement.c:1831:    ms->state = STATE_ARRIVED;
../game/movement.c:1839:    *out_xz = fl->target_xz;
../game/movement.c:1840:    *out_attack = N_DestIDIsAttacking(fl->dest_id);
../game/movement.c:1848:    if(ms->state != STATE_SURROUND_ENTITY)
../game/movement.c:1850:    *out_uid = ms->surround_target_uid;
../game/movement.c:1859:    return (ms->state == STATE_ARRIVED);
../game/movement.c:1865:    dest_xz = M_NavClosestReachableDest(s_map, layer, G_Pos_GetXZ(ent->uid), dest_xz);
../game/movement.c:1869:     * right flow fields will be computed on-demand during the
../game/movement.c:1874:        dest_id = M_NavDestIDForPosAttacking(s_map, dest_xz, layer, G_GetFactionID(ent->uid));
../game/movement.c:1893:            E_Entity_Notify(EVENT_MOTION_START, ent->uid, NULL, ES_ENGINE);
../game/movement.c:1895:        ms->state = STATE_MOVING;
../game/movement.c:1917:        E_Entity_Notify(EVENT_MOTION_START, ent->uid, NULL, ES_ENGINE);
../game/movement.c:1920:    ms->state = STATE_TURNING;
../game/movement.c:1921:    ms->target_dir = target;
../game/movement.c:1929:    vec2_t xz_src = G_Pos_GetXZ(ent->uid);
../game/movement.c:1930:    vec2_t xz_dst = G_Pos_GetXZ(target->uid);
../game/movement.c:1931:    range = MAX(0.0f, range - G_GetSelectionRadius(ent->uid));
../game/movement.c:1943:    ms->state = STATE_ENTER_ENTITY_RANGE;
../game/movement.c:1944:    ms->surround_target_uid = target->uid;
../game/movement.c:1945:    ms->target_prev_pos = xz_dst;
../game/movement.c:1946:    ms->target_range = range;
../game/movement.c:1970:        E_Entity_Notify(EVENT_MOTION_START, ent->uid, NULL, ES_ENGINE);
../game/movement.c:1973:    ms->state = STATE_SEEK_ENEMIES;
../game/movement.c:1983:    vec2_t pos = G_Pos_GetXZ(target->uid);
../game/movement.c:1986:    assert(!ms->blocking);
../game/movement.c:1987:    ms->state = STATE_SURROUND_ENTITY;
../game/movement.c:1988:    ms->surround_target_uid = target->uid;
../game/movement.c:1989:    ms->using_surround_field = false;
../game/movement.c:1998:    if(!ms->blocking)
../game/movement.c:2001:    M_NavBlockersDecref(ms->last_stop_pos, ms->last_stop_radius, G_GetFactionID(ent->uid), s_map);
../game/movement.c:2002:    M_NavBlockersIncref(pos, ms->last_stop_radius, G_GetFactionID(ent->uid), s_map);
../game/movement.c:2003:    ms->last_stop_pos = pos;
../game/movement.c:2012:    if(!ms->blocking)
../game/movement.c:2015:    M_NavBlockersDecref(ms->last_stop_pos, ms->last_stop_radius, oldfac, s_map);
../game/movement.c:2016:    M_NavBlockersIncref(ms->last_stop_pos, ms->last_stop_radius, newfac, s_map);
../game/movement.c:2025:    if(!ms->blocking)
../game/movement.c:2028:    M_NavBlockersDecref(ms->last_stop_pos, ms->last_stop_radius, G_GetFactionID(ent->uid), s_map);
../game/movement.c:2029:    M_NavBlockersIncref(ms->last_stop_pos, sel_radius, G_GetFactionID(ent->uid), s_map);
../game/movement.c:2030:    ms->last_stop_radius = sel_radius;
../game/movement.c:2054:    *out = ms->max_speed;
../game/movement.c:2064:    ms->max_speed = speed;
../game/movement.c:2089:            .val.as_int = kh_size(curr_flock->ents)
../game/movement.c:2097:        kh_foreach(curr_flock->ents, uid, curr_ent, {
../game/movement.c:2108:            .val.as_vec2 = curr_flock->target_xz
../game/movement.c:2114:            .val.as_int = curr_flock->dest_id
../game/movement.c:2315:        ms->state = attr.val.as_int;
../game/movement.c:2319:        ms->max_speed = attr.val.as_float;
../game/movement.c:2323:        ms->vdes = attr.val.as_vec2;
../game/movement.c:2327:        ms->velocity = attr.val.as_vec2;
../game/movement.c:2333:        assert(ms->blocking);
../game/movement.c:2342:        ms->wait_prev = attr.val.as_int;
../game/movement.c:2346:        ms->wait_ticks_left = attr.val.as_int;
../game/movement.c:2352:            ms->vel_hist[i] = attr.val.as_vec2;
../game/movement.c:2357:        ms->vel_hist_idx = attr.val.as_int;
../game/movement.c:2361:        ms->surround_target_uid = attr.val.as_int;
../game/movement.c:2365:        ms->surround_target_prev = attr.val.as_vec2;
../game/movement.c:2369:        ms->surround_nearest_prev = attr.val.as_vec2;
../game/movement.c:2373:        ms->using_surround_field = attr.val.as_bool;
../game/movement.c:2377:        ms->target_prev_pos = attr.val.as_vec2;
../game/movement.c:2381:        ms->target_range = attr.val.as_float;
../game/movement.c:2385:        ms->target_dir = attr.val.as_quat;
../game/movement.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/position.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../game/position.c:99:    khiter_t k = kh_get(pos, s_postable, ent->uid);
../game/position.c:101:    float vrange = G_GetVisionRange(ent->uid);
../game/position.c:105:        bool ret = qt_ent_delete(&s_postree, old_pos.x, old_pos.z, ent->uid);
../game/position.c:108:        G_Combat_RemoveRef(G_GetFactionID(ent->uid), (vec2_t){old_pos.x, old_pos.z});
../game/position.c:109:        G_Region_RemoveRef(ent->uid, (vec2_t){old_pos.x, old_pos.z});
../game/position.c:110:        G_Fog_RemoveVision((vec2_t){old_pos.x, old_pos.z}, G_GetFactionID(ent->uid), vrange);
../game/position.c:113:    if(!qt_ent_insert(&s_postree, pos.x, pos.z, ent->uid))
../game/position.c:118:        kh_put(pos, s_postable, ent->uid, &ret); 
../game/position.c:119:        if(ret == -1) {
../game/position.c:120:            qt_ent_delete(&s_postree, pos.x, pos.z, ent->uid);
../game/position.c:123:        k = kh_get(pos, s_postable, ent->uid);
../game/position.c:130:    G_Combat_AddRef(G_GetFactionID(ent->uid), (vec2_t){pos.x, pos.z});
../game/position.c:131:    G_Region_AddRef(ent->uid, (vec2_t){pos.x, pos.z});
../game/position.c:134:    G_Fog_AddVision((vec2_t){pos.x, pos.z}, G_GetFactionID(ent->uid), vrange);
../game/position.c:187:    float xmin = center.x - (res.tile_w * res.chunk_w * X_COORDS_PER_TILE) / 2.0f;
../game/position.c:189:    float zmin = center.z - (res.tile_h * res.chunk_h * Z_COORDS_PER_TILE) / 2.0f;
../game/position.c:264:        ent_ids[i] = (uint32_t)-1;
../game/position.c:271:        assert(ent_ids[i] != (uint32_t)-1);
../game/position.c:296:    const float qt_len = MAX(s_postree.xmax - s_postree.xmin, s_postree.ymax - s_postree.ymin);
../game/position.c:319:            vec2_t delta, can_pos_xz = G_Pos_GetXZ(curr->uid);
../game/position.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../game/public/game.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../game/public/game.h:287:/* GAME FOG-OF-WAR                                                           */
../game/region.c:104: * making a poor man's 2-level tree */
../game/region.c:119:    switch(reg->type) {
../game/region.c:121:        return C_CircleRectIntersection(reg->pos, reg->radius, chunk);
../game/region.c:125:            reg->pos.x + reg->xlen/2.0,
../game/region.c:126:            reg->pos.z - reg->zlen/2.0,
../game/region.c:127:            reg->xlen,
../game/region.c:128:            reg->zlen
../game/region.c:150:    return (uida - uidb);
../game/region.c:161:    switch(reg->type) {
../game/region.c:163:        delta = ceil(reg->radius / chunklen);
../game/region.c:166:        delta = MAX(ceil(reg->xlen/2.0f / chunklen), ceil(reg->zlen/2.0f / chunklen));
../game/region.c:172:    if(!M_Tile_DescForPoint2D(res, M_GetPos(s_map), reg->pos, &td))
../game/region.c:175:    for(int dr = -delta; dr <= delta; dr++) {
../game/region.c:176:    for(int dc = -delta; dc <= delta; dc++) {
../game/region.c:190:            if(idx != -1) {
../game/region.c:215:    if(status == -1)
../game/region.c:225:    switch(reg->type) {
../game/region.c:227:        return C_PointInsideCircle2D(point, reg->pos, reg->radius);
../game/region.c:231:            (vec2_t){reg->pos.x + reg->xlen/2.0f, reg->pos.z - reg->zlen/2.0f},
../game/region.c:232:            (vec2_t){reg->pos.x - reg->xlen/2.0f, reg->pos.z - reg->zlen/2.0f},
../game/region.c:233:            (vec2_t){reg->pos.x - reg->xlen/2.0f, reg->pos.z + reg->zlen/2.0f},
../game/region.c:234:            (vec2_t){reg->pos.x + reg->xlen/2.0f, reg->pos.z + reg->zlen/2.0f},
../game/region.c:282:        int idx = vec_uid_indexof(&regs[i]->curr_ents, uid, compare_uids);
../game/region.c:283:        if(idx == -1)
../game/region.c:285:        vec_uid_del(&regs[i]->curr_ents, idx);
../game/region.c:295:    if(!ent || (ent->flags & (ENTITY_FLAG_ZOMBIE | ENTITY_FLAG_MARKER)))
../game/region.c:304:        int idx = vec_uid_indexof(&regs[i]->curr_ents, uid, compare_uids);
../game/region.c:305:        if(idx != -1)
../game/region.c:308:        vec_uid_push(&regs[i]->curr_ents, uid);
../game/region.c:318:    switch(reg->type) {
../game/region.c:320:        nents = G_Pos_EntsInCircle(reg->pos, reg->radius, ents, ARR_SIZE(ents));
../game/region.c:324:        vec2_t xz_min = (vec2_t){reg->pos.x - reg->xlen/2.0f, reg->pos.z - reg->zlen/2.0f};
../game/region.c:325:        vec2_t xz_max = (vec2_t){reg->pos.x + reg->xlen/2.0f, reg->pos.z + reg->zlen/2.0f};
../game/region.c:332:    vec_uid_reset(&reg->curr_ents);
../game/region.c:334:        if(ents[i]->flags & ENTITY_FLAG_MARKER)
../game/region.c:336:        if(ents[i]->flags & ENTITY_FLAG_ZOMBIE)
../game/region.c:338:        vec_uid_push(&reg->curr_ents, ents[i]->uid);
../game/region.c:365:    float screen_y = height - ((ndc.y + 1.0f) * height/2.0f);
../game/region.c:371:    size_t n = reg->curr_ents.size;
../game/region.c:372:    size_t m = reg->prev_ents.size;
../game/region.c:374:    qsort(reg->curr_ents.array, n, sizeof(uint32_t), compare_uint32s);
../game/region.c:375:    qsort(reg->prev_ents.array, m, sizeof(uint32_t), compare_uint32s);
../game/region.c:383:        if(reg->curr_ents.array[i] < reg->prev_ents.array[j]) {
../game/region.c:388:            uint32_t uid = reg->curr_ents.array[i];
../game/region.c:395:        }else if(reg->prev_ents.array[j] < reg->curr_ents.array[i]) {
../game/region.c:400:            uint32_t uid = reg->prev_ents.array[j];
../game/region.c:419:        uint32_t uid = reg->curr_ents.array[i];
../game/region.c:432:        uint32_t uid = reg->prev_ents.array[j];
../game/region.c:444:    vec_uid_reset(&reg->prev_ents);
../game/region.c:445:    vec_uid_copy(&reg->prev_ents, &reg->curr_ents);
../game/region.c:485:                (vec2_t){reg.pos.x + reg.xlen/2.0f, reg.pos.z - reg.zlen/2.0f},
../game/region.c:486:                (vec2_t){reg.pos.x - reg.xlen/2.0f, reg.pos.z - reg.zlen/2.0f},
../game/region.c:487:                (vec2_t){reg.pos.x - reg.xlen/2.0f, reg.pos.z + reg.zlen/2.0f},
../game/region.c:510:        struct rect bounds = (struct rect){ss_pos.x - len/2.0, ss_pos.y, len, 16};
../game/region.c:632:    for(int i = 0; i < vec_size(&reg->curr_ents); i++) {
../game/region.c:637:        uint32_t uid = vec_AT(&reg->curr_ents, i);
../game/region.c:664:    PFM_Vec2_Sub(&reg->pos, &pos, &delta);
../game/region.c:669:    reg->pos = pos;
../game/region.c:715:    for(int i = 0; i < vec_size(&reg->curr_ents); i++) {
../game/region.c:717:        struct entity *ent = G_EntityForUID(vec_AT(&reg->curr_ents, i));
../game/region.c:735:    for(int i = 0; i < vec_size(&reg->curr_ents); i++) {
../game/region.c:736:        uint32_t curr = vec_AT(&reg->curr_ents, i);
../game/region.c:836:    switch(reg->type) {
../game/region.c:838:        G_Fog_ExploreRectangle(reg->pos, faction_id, reg->xlen/2.0f, reg->zlen/2.0f);
../game/region.c:841:        G_Fog_ExploreCircle(reg->pos, faction_id, reg->radius);
../game/region.c:857:    switch(reg->type) {
../game/region.c:859:        *out = G_Fog_CircleExplored(player_mask, reg->pos, reg->radius);
../game/region.c:862:        *out = G_Fog_RectExplored(player_mask, reg->pos, reg->xlen/2.0f, reg->zlen/2.0f);
../game/region.c:1043:        reg->shown = shown.val.as_bool;
../game/region.c:1054:            vec_uid_push(&reg->curr_ents, curr.val.as_int);
../game/region.c:1066:            vec_uid_push(&reg->prev_ents, curr.val.as_int);
../game/resource.c:94:    if(status == -1 || status == 0)
../game/resource.c:151:        .blocking_pos = G_Pos_GetXZ(ent->uid),
../game/resource.c:152:        .blocking_radius = G_GetSelectionRadius(ent->uid),
../game/resource.c:155:    if(!rstate_set(ent->uid, rs))
../game/resource.c:158:    if(!(ent->flags & ENTITY_FLAG_BUILDING)) {
../game/resource.c:159:        M_NavBlockersIncref(rs.blocking_pos, rs.blocking_radius, G_GetFactionID(ent->uid), s_map);
../game/resource.c:166:    struct rstate *rs = rstate_get(ent->uid);
../game/resource.c:170:    if(!(ent->flags & ENTITY_FLAG_BUILDING)) {
../game/resource.c:171:        M_NavBlockersDecref(rs->blocking_pos, rs->blocking_radius, G_GetFactionID(ent->uid), s_map);
../game/resource.c:174:    rstate_remove(ent->uid);
../game/resource.c:179:    struct rstate *rs = rstate_get(ent->uid);
../game/resource.c:183:    if(!(ent->flags & ENTITY_FLAG_BUILDING)) {
../game/resource.c:184:        M_NavBlockersDecref(rs->blocking_pos, rs->blocking_radius, G_GetFactionID(ent->uid), s_map);
../game/resource.c:185:        rs->blocking_pos = G_Pos_GetXZ(ent->uid);
../game/resource.c:186:        M_NavBlockersIncref(rs->blocking_pos, rs->blocking_radius, G_GetFactionID(ent->uid), s_map);
../game/resource.c:192:    struct rstate *rs = rstate_get(ent->uid);
../game/resource.c:196:    if(!(ent->flags & ENTITY_FLAG_BUILDING)) {
../game/resource.c:197:        M_NavBlockersDecref(rs->blocking_pos, rs->blocking_radius, oldfac, s_map);
../game/resource.c:198:        M_NavBlockersIncref(rs->blocking_pos, rs->blocking_radius, newfac, s_map);
../game/resource.c:204:    struct rstate *rs = rstate_get(ent->uid);
../game/resource.c:208:    if(!(ent->flags & ENTITY_FLAG_BUILDING)) {
../game/resource.c:209:        M_NavBlockersDecref(rs->blocking_pos, rs->blocking_radius, G_GetFactionID(ent->uid), s_map);
../game/resource.c:210:        rs->blocking_radius = radius;
../game/resource.c:211:        M_NavBlockersIncref(rs->blocking_pos, rs->blocking_radius, G_GetFactionID(ent->uid), s_map);
../game/resource.c:219:    return rs->amount;
../game/resource.c:226:    if(rs->amount != amount) {
../game/resource.c:229:    rs->amount = amount;
../game/resource.c:236:    return rs->name;
../game/resource.c:248:    rs->name = key;
../game/resource.c:257:    return rs->cursor;
../game/resource.c:269:    rs->cursor = key;
../game/selection.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/selection.c:71: * [start] ---> [MOUSE_SEL_UP] ---> [MOUSE_SEL_DOWN] ---> [MOUSE_SEL_RELEASED]
../game/selection.c:74: *                   +--------------------------------------------+
../game/selection.c:77: * re-calculate the current selection.
../game/selection.c:114:    SDL_MouseButtonEvent *mouse_event = &(((SDL_Event*)event)->button);
../game/selection.c:116:    if(mouse_event->button != SDL_BUTTON_LEFT)
../game/selection.c:122:    if(S_UI_MouseOverWindow(mouse_event->x, mouse_event->y))
../game/selection.c:133:    if(mouse_event->x == 0 || mouse_event->x == w-1
../game/selection.c:134:    || mouse_event->y == 0 || mouse_event->y == h-1)
../game/selection.c:138:    s_ctx.mouse_down_coord = (vec2_t){mouse_event->x, mouse_event->y};
../game/selection.c:151:    SDL_MouseButtonEvent *mouse_event = &(((SDL_Event*)event)->button);
../game/selection.c:153:    s_ctx.mouse_up_coord = (vec2_t){mouse_event->x, mouse_event->y};
../game/selection.c:154:    s_ctx.num_clicks = mouse_event->clicks;
../game/selection.c:165:    vec2_t signed_size = (vec2_t){mouse_x - s_ctx.mouse_down_coord.x, mouse_y - s_ctx.mouse_down_coord.y};
../game/selection.c:186:    vec3_t ndc = (vec3_t){-1.0f + 2.0*(mouse_coords.raw[0]/(float)w),
../game/selection.c:187:                           1.0f - 2.0*(mouse_coords.raw[1]/(float)h),
../game/selection.c:209:    out->near = cam_frust.near;
../game/selection.c:210:    out->far = cam_frust.far;
../game/selection.c:219:    out->ntl = sel_unproject_mouse_coords(cam, corners[0], -1.0f);
../game/selection.c:220:    out->nbl = sel_unproject_mouse_coords(cam, corners[1], -1.0f);
../game/selection.c:221:    out->ntr = sel_unproject_mouse_coords(cam, corners[2], -1.0f);
../game/selection.c:222:    out->nbr = sel_unproject_mouse_coords(cam, corners[3], -1.0f);
../game/selection.c:224:    out->ftl = sel_unproject_mouse_coords(cam, corners[0], 1.0f);
../game/selection.c:225:    out->fbl = sel_unproject_mouse_coords(cam, corners[1], 1.0f);
../game/selection.c:226:    out->ftr = sel_unproject_mouse_coords(cam, corners[2], 1.0f);
../game/selection.c:227:    out->fbr = sel_unproject_mouse_coords(cam, corners[3], 1.0f);
../game/selection.c:230:    PFM_Vec3_Sub(&out->ftl, &out->ntl, &tl_dir);
../game/selection.c:231:    PFM_Vec3_Sub(&out->fbl, &out->nbl, &bl_dir);
../game/selection.c:232:    PFM_Vec3_Sub(&out->ftr, &out->ntr, &tr_dir);
../game/selection.c:233:    PFM_Vec3_Sub(&out->fbr, &out->nbr, &br_dir);
../game/selection.c:241:    PFM_Vec3_Sub(&out->ntl, &out->nbl, &up);
../game/selection.c:243:    PFM_Vec3_Sub(&out->ntl, &out->ntr, &left);
../game/selection.c:246:    out->top.point = out->ntl;
../game/selection.c:247:    PFM_Vec3_Cross(&tl_dir, &left, &out->top.normal);
../game/selection.c:248:    PFM_Vec3_Normal(&out->top.normal, &out->top.normal);
../game/selection.c:250:    out->bot.point = out->nbr;
../game/selection.c:251:    PFM_Vec3_Cross(&left, &bl_dir, &out->bot.normal);
../game/selection.c:252:    PFM_Vec3_Normal(&out->bot.normal, &out->bot.normal);
../game/selection.c:254:    out->right.point = out->ntr;
../game/selection.c:255:    PFM_Vec3_Cross(&tr_dir, &up, &out->right.normal);
../game/selection.c:256:    PFM_Vec3_Normal(&out->right.normal, &out->right.normal);
../game/selection.c:258:    out->left.point = out->nbl;
../game/selection.c:259:    PFM_Vec3_Cross(&up, &tl_dir, &out->left.normal);
../game/selection.c:260:    PFM_Vec3_Normal(&out->left.normal, &out->left.normal);
../game/selection.c:283:    vec3_t ray_origin = sel_unproject_mouse_coords(cam, (vec2_t){mouse_x, mouse_y}, -1.0f);
../game/selection.c:295:        if(G_EntityIsZombie(vec_AT(visible, i)->uid))
../game/selection.c:303:                s_hovered_uid = vec_AT(visible, i)->uid;
../game/selection.c:346:        if(!(curr->flags & ENTITY_FLAG_BUILDING)) {
../game/selection.c:356:    for(int i = vec_size(&s_selected)-1; i >= 0; i--) {
../game/selection.c:359:        if(curr->flags & ENTITY_FLAG_BUILDING) {
../game/selection.c:367: * 1) If there is at least one player-controllable entity in the selection set,
../game/selection.c:368: *    leave only player-controllable entities.
../game/selection.c:385:        assert(fac_mask & (0x1 << G_GetFactionID(curr->uid)));
../game/selection.c:387:        if(controllable[G_GetFactionID(curr->uid)]) {
../game/selection.c:392:        if(allied_to_player_controllabe(controllable, fac_mask, G_GetFactionID(curr->uid))) {
../game/selection.c:406:    for(int i = vec_size(&s_selected)-1; i >= 0; i--) {
../game/selection.c:409:        if(has_player && !controllable[G_GetFactionID(curr->uid)]) {
../game/selection.c:415:              && !allied_to_player_controllabe(controllable, fac_mask, G_GetFactionID(curr->uid))) {
../game/selection.c:428:        if(idx == -1) {
../game/selection.c:433:        if(idx != -1) {
../game/selection.c:482: * (ex. if the player is left-clicking on an empty part of the map), the previous selection is kept. */
../game/selection.c:507:        if(hovered && (hovered->flags & ENTITY_FLAG_SELECTABLE)) {
../game/selection.c:513:            /* A double-click selects all units of the same 'type' as the hovered unit */
../game/selection.c:520:                    if(!(curr->flags & ENTITY_FLAG_SELECTABLE))
../game/selection.c:522:                    uint64_t curr_id = S_ScriptTypeID(curr->uid);
../game/selection.c:541:            if(!(vec_AT(visible, i)->flags & ENTITY_FLAG_SELECTABLE))
../game/selection.c:579:    assert(ent->flags & ENTITY_FLAG_SELECTABLE);
../game/selection.c:582:    if(idx == -1) {
../game/selection.c:591:    if(!(ent->flags & ENTITY_FLAG_SELECTABLE))
../game/selection.c:595:    if(idx != -1) {
../game/selection.c:612:        if(!(ent->flags & ENTITY_FLAG_SELECTABLE))
../game/selection.c:644:            .val.as_int = vec_AT(&s_selected, i)->uid
../game/selection.c:698:    return (idx != -1);
../game/selection.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/storage_site.c:175:    if(status == -1 || status == 0)
../game/storage_site.c:190:    kh_destroy(int, hs->capacity);
../game/storage_site.c:191:    kh_destroy(int, hs->curr);
../game/storage_site.c:192:    kh_destroy(int, hs->desired);
../game/storage_site.c:194:    kh_destroy(int, hs->alt_capacity);
../game/storage_site.c:195:    kh_destroy(int, hs->alt_desired);
../game/storage_site.c:200:    hs->capacity = kh_init(int);
../game/storage_site.c:201:    hs->curr = kh_init(int);
../game/storage_site.c:202:    hs->desired = kh_init(int);
../game/storage_site.c:203:    hs->alt_capacity = kh_init(int);
../game/storage_site.c:204:    hs->alt_desired = kh_init(int);
../game/storage_site.c:206:    if(!hs->capacity || !hs->curr || !hs->desired
../game/storage_site.c:207:    || !hs->alt_capacity || !hs->alt_desired) {
../game/storage_site.c:213:    hs->last_change = (struct ss_delta_event){0};
../game/storage_site.c:214:    hs->use_alt = false;
../game/storage_site.c:215:    hs->do_not_take = false;
../game/storage_site.c:232:    khash_t(int) *table = (hs->use_alt) ? hs->alt_capacity : hs->capacity;
../game/storage_site.c:260:    if(status == -1)
../game/storage_site.c:297:    if(status == -1)
../game/storage_site.c:321:    if(status == -1)
../game/storage_site.c:332:    ss_state_get_key(ss->capacity, rname, &cap);
../game/storage_site.c:333:    ss_state_get_key(ss->desired, rname, &desired);
../game/storage_site.c:337:    ss_state_set_key(ss->desired, rname, desired);
../game/storage_site.c:356:    nk_style_push_style_item(ctx, &ctx->style.window.fixed_background, s_bg_style);
../game/storage_site.c:357:    nk_style_push_color(ctx, &ctx->style.window.border_color, s_border_clr);
../game/storage_site.c:381:        const vec2_t pos = (vec2_t){ss_pos.x - width/2, ss_pos.y + 20};
../game/storage_site.c:470:    out->r = attr.val.as_int;
../game/storage_site.c:474:    out->g = attr.val.as_int;
../game/storage_site.c:478:    out->b = attr.val.as_int;
../game/storage_site.c:482:    out->a = attr.val.as_int;
../game/storage_site.c:597:    if(val->type != ST_TYPE_INT)
../game/storage_site.c:599:    if(val->as_int < 0 || val->as_int > SS_UI_SHOW_NEVER)
../game/storage_site.c:619:            for(--i; i; i--)
../game/storage_site.c:627:            for(--i; i; i--)
../game/storage_site.c:699:    if(!ss_state_set(ent->uid, ss))
../game/storage_site.c:706:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:713:    kh_foreach(ss->curr, key, amount, {
../game/storage_site.c:714:        update_res_delta(key, -amount, G_GetFactionID(ent->uid));
../game/storage_site.c:717:    khash_t(int) *cap = ss->use_alt ? ss->alt_capacity : ss->capacity;
../game/storage_site.c:719:        update_cap_delta(key, -amount, G_GetFactionID(ent->uid));
../game/storage_site.c:723:    ss_state_remove(ent->uid);
../game/storage_site.c:733:    khash_t(int) *table = ss->use_alt ? ss->alt_capacity : ss->capacity;
../game/storage_site.c:745:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:749:    ss_state_get_key(ss->curr, rname, &prev);
../game/storage_site.c:750:    int delta = max - prev;
../game/storage_site.c:752:    if(!ss->use_alt) {
../game/storage_site.c:753:        update_cap_delta(rname, delta, G_GetFactionID(ent->uid));
../game/storage_site.c:756:    bool ret = ss_state_set_key(ss->capacity, rname, max);
../game/storage_site.c:767:    khash_t(int) *table = (ss->use_alt) ? ss->alt_capacity : ss->capacity;
../game/storage_site.c:774:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:778:    khash_t(int) *table = (ss->use_alt) ? ss->alt_capacity : ss->capacity;
../game/storage_site.c:787:    ss_state_get_key(ss->curr, rname, &prev);
../game/storage_site.c:788:    int delta = curr - prev;
../game/storage_site.c:789:    update_res_delta(rname, delta, G_GetFactionID(ent->uid));
../game/storage_site.c:792:        ss->last_change = (struct ss_delta_event){
../game/storage_site.c:796:        E_Entity_Notify(EVENT_STORAGE_SITE_AMOUNT_CHANGED, ent->uid, &ss->last_change, ES_ENGINE);
../game/storage_site.c:799:    return ss_state_set_key(ss->curr, rname, curr);
../game/storage_site.c:808:    ss_state_get_key(ss->curr, rname, &ret);
../game/storage_site.c:816:    bool ret = ss_state_set_key(ss->desired, rname, des);
../game/storage_site.c:827:    ss_state_get_key(ss->desired, rname, &ret);
../game/storage_site.c:894:    return ss->do_not_take;
../game/storage_site.c:901:    ss->do_not_take = on;
../game/storage_site.c:906:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:909:    if(use == ss->use_alt)
../game/storage_site.c:916:        kh_foreach(ss->capacity, key, amount, {
../game/storage_site.c:917:            update_cap_delta(key, -amount, G_GetFactionID(ent->uid));
../game/storage_site.c:919:        kh_foreach(ss->alt_capacity, key, amount, {
../game/storage_site.c:920:            update_cap_delta(key, amount, G_GetFactionID(ent->uid));
../game/storage_site.c:923:        kh_foreach(ss->alt_capacity, key, amount, {
../game/storage_site.c:924:            update_cap_delta(key, -amount, G_GetFactionID(ent->uid));
../game/storage_site.c:926:        kh_foreach(ss->capacity, key, amount, {
../game/storage_site.c:927:            update_cap_delta(key, amount, G_GetFactionID(ent->uid));
../game/storage_site.c:930:    ss->use_alt = use;
../game/storage_site.c:937:    return ss->use_alt;
../game/storage_site.c:942:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:945:    if(ss->use_alt) {
../game/storage_site.c:949:        kh_foreach(ss->alt_capacity, key, amount, {
../game/storage_site.c:950:            update_cap_delta(key, -amount, G_GetFactionID(ent->uid));
../game/storage_site.c:954:    kh_clear(int, ss->alt_capacity);
../game/storage_site.c:955:    kh_clear(int, ss->alt_desired);
../game/storage_site.c:960:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:966:    kh_foreach(ss->alt_capacity, key, amount, {
../game/storage_site.c:967:        update_cap_delta(key, -amount, G_GetFactionID(ent->uid));
../game/storage_site.c:970:    kh_clear(int, ss->curr);
../game/storage_site.c:975:    struct ss_state *ss = ss_state_get(ent->uid);
../game/storage_site.c:979:    ss_state_get_key(ss->curr, rname, &prev);
../game/storage_site.c:980:    int delta = max - prev;
../game/storage_site.c:982:    if(ss->use_alt) {
../game/storage_site.c:983:        update_cap_delta(rname, delta, G_GetFactionID(ent->uid));
../game/storage_site.c:986:    bool ret = ss_state_set_key(ss->alt_capacity, rname, max);
../game/storage_site.c:997:    ss_state_get_key(ss->alt_capacity, rname, &ret);
../game/storage_site.c:1005:    bool ret = ss_state_set_key(ss->alt_desired, rname, des);
../game/storage_site.c:1016:    ss_state_get_key(ss->alt_desired, rname, &ret);
../game/storage_site.c:1029:    khash_t(int) *cap = ss->use_alt ? ss->alt_capacity : ss->capacity;
../game/storage_site.c:1031:        update_cap_delta(key, -amount, oldfac);
../game/storage_site.c:1035:    kh_foreach(ss->curr, key, amount, {
../game/storage_site.c:1036:        update_res_delta(key, -amount, oldfac);
../game/storage_site.c:1045:    khash_t(int) *des = ss->use_alt ? ss->alt_desired  : ss->desired;
../game/storage_site.c:1051:    ss_state_get_key(ss->curr, rname, &rcurr);
../game/storage_site.c:1260:        ss->use_alt = attr.val.as_bool;
../game/storage_site.c:1354:        ss->do_not_take = attr.val.as_bool;
../game/timer_events.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../game/timer_events.c:64:    s_error += (TIMER_INTERVAL - interval);
../game/timer_events.c:70:    s_error -= intpart;
../game/timer_events.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../glHacks.h:3://  permafrost-engine
../glHacks.h:36:// SDL/src/video/SDL_sysvideo.h from SDL version 2.0.14 (tag release-2.0.14 in https://github.com/libsdl-org/SDL )
../glHacks.h:90:struct SDL_WindowData_impl // SDL/src/video/cocoa/SDL_cocoawindow.h from SDL version 2.0.14 (tag release-2.0.14 in https://github.com/libsdl-org/SDL )
../glHacks.h:112://    if(class_addMethod(c, orig, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))) // Returns: "YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name)." ( https://developer.apple.com/documentation/objectivec/1418901-class_addmethod?language=objc )
../glHacks.h:124://    if(class_addMethod(c, orig, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))) // Returns: "YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name)." ( https://developer.apple.com/documentation/objectivec/1418901-class_addmethod?language=objc )
../glHacks.h:138:#include <CoreFoundation/CoreFoundation.h> // "CFString is toll-free bridged with its Cocoa Foundation counterpart, NSString. This means that the Core Foundation type is interchangeable in function or method calls with the bridged Foundation object. Therefore, in a method where you see an NSString * parameter, you can pass in a CFStringRef, and in a function where you see a CFStringRef parameter, you can pass in an NSString instance. This also applies to concrete subclasses of NSString. See Toll-Free Bridged Types for more information on toll-free bridging." ( https://developer.apple.com/documentation/corefoundation/cfstring?language=objc )
../glHacks.h:140:// https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring?language=objc
../glHacks.h:143:// https://developer.apple.com/documentation/foundation/1395294-nsselectorfromstring?language=objc
../glHacks.h:148://// https://www.mikeash.com/pyblog/objc_msgsends-new-prototype.html
../glHacks.h:152://     - (void)explicitUpdate
../lib/SDL_vec_rwops.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/SDL_vec_rwops.c:45:#define VEC(rwops)          ((vec_uchar_t*)((rwops)->hidden.unknown.data1))
../lib/SDL_vec_rwops.c:46:#define SEEK_IDX(rwops)     ((uintptr_t)((rwops)->hidden.unknown.data2))
../lib/SDL_vec_rwops.c:55:    assert(ctx->type == SDL_RWOPS_VEC);
../lib/SDL_vec_rwops.c:61:    assert(ctx->type == SDL_RWOPS_VEC);
../lib/SDL_vec_rwops.c:64:        ctx->hidden.unknown.data2 = (void*)offset;
../lib/SDL_vec_rwops.c:67:        ctx->hidden.unknown.data2 = (void*)(SEEK_IDX(ctx) + offset);
../lib/SDL_vec_rwops.c:70:        ctx->hidden.unknown.data2 = (void*)(rw_vec_size(ctx)-1 + offset);
../lib/SDL_vec_rwops.c:80:    assert(ctx->type == SDL_RWOPS_VEC);
../lib/SDL_vec_rwops.c:93:    ctx->hidden.unknown.data2 = (void*)(SEEK_IDX(ctx) + size * num);
../lib/SDL_vec_rwops.c:99:    assert(ctx->type == SDL_RWOPS_VEC);
../lib/SDL_vec_rwops.c:108:    ctx->hidden.unknown.data2 = (void*)(SEEK_IDX(ctx) + size * num);
../lib/SDL_vec_rwops.c:114:    assert(ctx->type == SDL_RWOPS_VEC);
../lib/SDL_vec_rwops.c:115:    vec_uchar_destroy(ctx->hidden.unknown.data1);
../lib/SDL_vec_rwops.c:130:    ret->size = rw_vec_size;
../lib/SDL_vec_rwops.c:131:    ret->seek = rw_vec_seek;
../lib/SDL_vec_rwops.c:132:    ret->read = rw_vec_read;
../lib/SDL_vec_rwops.c:133:    ret->write = rw_vec_write;
../lib/SDL_vec_rwops.c:134:    ret->close = rw_vec_close;
../lib/SDL_vec_rwops.c:135:    ret->type = SDL_RWOPS_VEC;
../lib/SDL_vec_rwops.c:137:    ret->hidden.unknown.data1 = ret + 1;
../lib/SDL_vec_rwops.c:139:    ret->hidden.unknown.data2 = (void*)0; /* This is the seek index */
../lib/SDL_vec_rwops.c:146:    return (const char*)VEC(ctx)->array;
../lib/attr.c:62:        strncpy(out->key, token, sizeof(out->key)); 
../lib/attr.c:63:        out->key[sizeof(out->key)-1] = '\0';
../lib/attr.c:74:        out->type = TYPE_STRING;
../lib/attr.c:77:        pf_snprintf(out->val.as_string, sizeof(out->val.as_string), "%s", token);
../lib/attr.c:81:        out->type = TYPE_QUAT;
../lib/attr.c:84:            &out->val.as_quat.x, &out->val.as_quat.y, &out->val.as_quat.z, &out->val.as_quat.w))
../lib/attr.c:89:        out->type = TYPE_VEC2;
../lib/attr.c:92:            &out->val.as_vec2.x, &out->val.as_vec2.y))
../lib/attr.c:97:        out->type = TYPE_VEC3;
../lib/attr.c:100:            &out->val.as_vec3.x, &out->val.as_vec3.y, &out->val.as_vec3.z))
../lib/attr.c:105:        out->type = TYPE_BOOL;
../lib/attr.c:113:        out->val.as_bool = tmp;
../lib/attr.c:117:        out->type = TYPE_FLOAT;
../lib/attr.c:120:        if(!sscanf(token, "%f", &out->val.as_float))
../lib/attr.c:125:        out->type = TYPE_INT;
../lib/attr.c:128:        if(!sscanf(token, "%d", &out->val.as_int))
../lib/attr.c:148:    switch(in->type) {
../lib/attr.c:151:        CHK_TRUE(SDL_RWwrite(stream, in->val.as_string, strlen(in->val.as_string), 1), fail); 
../lib/attr.c:156:        pf_snprintf(buff, sizeof(buff), "%.6f", in->val.as_float);
../lib/attr.c:165:        pf_snprintf(buff, sizeof(buff), "%d", in->val.as_int);
../lib/attr.c:175:            in->val.as_vec2.x, in->val.as_vec2.y);
../lib/attr.c:185:            in->val.as_vec3.x, in->val.as_vec3.y, in->val.as_vec3.z);
../lib/attr.c:195:            in->val.as_quat.x, in->val.as_quat.y, in->val.as_quat.z, in->val.as_quat.w);
../lib/attr.c:204:        pf_snprintf(buff, sizeof(buff), "%d", (int)in->val.as_bool);
../lib/debug_malloc.c:49:#define ALIGNED(val, align) (((val) + ((align) - 1)) & ~((align) - 1))
../lib/debug_malloc.c:50:#define HEADER(ptr)         (((intmax_t*)(ptr))    - 3)
../lib/debug_malloc.c:54: * the glibc allocator functions (simply compile the functions - the 
../lib/debug_malloc.c:58: * of overwrites/underwrites. Careful with adding code here - it must both 
../lib/debug_malloc.c:59: * be threadsafe and not make use of 'malloc' - not an easy task.
../lib/debug_malloc.c:61: * Relink with the '-lmcheck' linker flag to also force some additional 
../lib/debug_malloc.c:69: * of memory, but extremely handy in catching use-after-free bugs.
../lib/debug_malloc.c:72: * number of allowed per-process virtual mappings. This can be done 
../lib/debug_malloc.c:75: *     sysctl -w vm.max_map_count=xxxxxx
../lib/debug_malloc.c:128:/* The footer location may not necessarily be aligned, so write it byte-by-byte */
../lib/debug_malloc.c:152:    intmax_t *header = mmap((void*)s_page_base, newsize, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
../lib/debug_malloc.c:155:    if(header == (void*)-1) {
../lib/debug_malloc.c:168:    write_footer(((char*)header) + newsize - sizeof(intmax_t));
../lib/debug_malloc.c:190:        intmax_t *newheader = mmap((void*)s_page_base, newsize, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
../lib/debug_malloc.c:193:        if(newheader == (void*)-1) {
../lib/debug_malloc.c:210:        write_footer(((char*)newheader) + newsize - sizeof(intmax_t));
../lib/debug_malloc.c:239:    char *allocd = mmap((void*)s_page_base, asize, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
../lib/debug_malloc.c:242:    if(allocd == (void*)-1) {
../lib/debug_malloc.c:255:    *((intmax_t*)(ret - 3 * sizeof(intmax_t))) = size;
../lib/debug_malloc.c:256:    *((intmax_t*)(ret - 2 * sizeof(intmax_t))) = (uintptr_t)allocd;
../lib/debug_malloc.c:257:    *((intmax_t*)(ret - 1 * sizeof(intmax_t))) = 0xDEADBEEF;
../lib/debug_malloc.c:273:        return -ENOMEM;
../lib/nk_file_browser.c:60:#define DEFAULT_FOLDER_ICON     "assets/icons/folder-icon.png"
../lib/nk_file_browser.c:61:#define DEFAULT_FILE_ICON       "assets/icons/file-icon.png"
../lib/nk_file_browser.c:62:#define DEFAULT_HOME_ICON       "assets/icons/home-icon.png"
../lib/nk_file_browser.c:63:#define DEFAULT_DESKTOP_ICON    "assets/icons/desktop-icon.png"
../lib/nk_file_browser.c:64:#define DEFAULT_DISK_ICON       "assets/icons/hard-drive-icon.png"
../lib/nk_file_browser.c:93:    wdir[wlen - 1] = '/';
../lib/nk_file_browser.c:178:        pf_snprintf(out[ret], NK_MAX_PATH_LEN, "%s/Desktop", out[ret-1]);
../lib/nk_file_browser.c:200:        pf_strlcpy(names[ret], cpath, len-1);
../lib/nk_file_browser.c:234:            files[nfiles].is_dir = (entry->d_type == DT_DIR);
../lib/nk_file_browser.c:235:            pf_strlcpy(files[nfiles].name, entry->d_name, NK_MAX_PATH_LEN);
../lib/nk_file_browser.c:264:        home = getpwuid(getuid())->pw_dir;
../lib/nk_file_browser.c:290:        pf_snprintf(out[ret], NK_MAX_PATH_LEN, "%s/Desktop", out[ret-1]);
../lib/nk_file_browser.c:310:    float spacing_x = ctx->style.window.spacing.x;
../lib/nk_file_browser.c:311:    ctx->style.window.spacing.x = 0;
../lib/nk_file_browser.c:313:    char *d = state->directory;
../lib/nk_file_browser.c:338:    ctx->style.window.spacing.x = spacing_x;
../lib/nk_file_browser.c:343:    if(a->is_dir && !b->is_dir)
../lib/nk_file_browser.c:344:        return -1;
../lib/nk_file_browser.c:346:    if(!a->is_dir && b->is_dir)
../lib/nk_file_browser.c:349:    return strcmp(a->name, b->name);
../lib/nk_file_browser.c:358:        while(j > 0 && files_compare(&files[j - 1], &files[j]) > 0) {
../lib/nk_file_browser.c:360:            struct file tmp = files[j - 1];
../lib/nk_file_browser.c:361:            files[j - 1] = files[j];
../lib/nk_file_browser.c:363:            j--;
../lib/nk_file_browser.c:383:    float height = total_space.h - ctx->style.window.spacing.y 
../lib/nk_file_browser.c:384:        - fb_selector_rows(state->directory) * (SELECTOR_BAR_HEIGHT + ctx->style.window.spacing.y);
../lib/nk_file_browser.c:387:    struct file *files = fb_get_list(state->directory, &nfiles);
../lib/nk_file_browser.c:396:    pf_snprintf(list_name, sizeof(list_name), "%s.List", state->name);
../lib/nk_file_browser.c:398:    int sel_idx = -1;
../lib/nk_file_browser.c:404:            int sel = (0 == strcmp(state->selected, files[i].name));
../lib/nk_file_browser.c:414:                pf_strlcpy(state->selected, files[i].name, sizeof(state->selected));
../lib/nk_file_browser.c:422:        pf_snprintf(newpath_rel, sizeof(newpath_rel), "%s/%s", state->directory, files[sel_idx].name);
../lib/nk_file_browser.c:425:        pf_strlcpy(state->directory, newpath_abs, sizeof(state->directory));
../lib/nk_file_browser.c:426:        state->selected[0] = '\0';
../lib/nk_file_browser.c:446:            pf_strlcpy(state->directory, paths[i], sizeof(state->directory));
../lib/nk_file_browser.c:447:            state->selected[0] = '\0';
../lib/nk_file_browser.c:459:    fb_realpath(state->directory, abs);
../lib/nk_file_browser.c:460:    pf_strlcpy(state->directory, abs, sizeof(state->directory));
../lib/nk_file_browser.c:462:    nk_group_begin(ctx, state->name, state->flags);
../lib/nk_file_browser.c:466:        nk_layout_row(ctx, NK_DYNAMIC, total_space.h - ctx->style.window.group_padding.y * 2, 2, ratio);
../lib/nk_file_browser.c:469:        pf_snprintf(left_name, sizeof(left_name), "%s.Left", state->name);
../lib/nk_file_browser.c:478:        pf_snprintf(right_name, sizeof(right_name), "%s.Right", state->name);
../lib/pf_malloc.c:61:#define MEM_MEMBLOCK(mem)               ((struct memblock*)((char*)(mem) - ALIGNED(sizeof(struct memblock))))
../lib/pf_malloc.c:63:#define CAN_COALESE_WITH_NEXT(mblock)   ((mblock)->next && (mblock)->next->free)
../lib/pf_malloc.c:64:#define CAN_COALESE_WITH_PREV(mblock)   ((mblock)->prev && (mblock)->prev->free)
../lib/pf_malloc.c:66:#define ALIGNED(size)                   (((size) + (sizeof(intmax_t) - 1)) & ~(sizeof(intmax_t) - 1))
../lib/pf_malloc.c:73:    struct memblock *next, *prev; /* Doubly-linked list of adjacent blocks used for coalesing */
../lib/pf_malloc.c:87:    size_t pad = (alignment - (val % alignment)) % alignment;
../lib/pf_malloc.c:94:    aval = aval == val ? aval : aval - alignment;
../lib/pf_malloc.c:100:    heap->blocks[i] = heap->blocks[heap->nblocks--];
../lib/pf_malloc.c:105:        bool hasleft = left <= heap->nblocks;
../lib/pf_malloc.c:106:        bool hasright = right <= heap->nblocks;
../lib/pf_malloc.c:115:            max = heap->blocks[left]->size > heap->blocks[right]->size ? left : right;
../lib/pf_malloc.c:118:        if(heap->blocks[max]->size > heap->blocks[curr]->size) {
../lib/pf_malloc.c:119:            SWAP_PTRS(heap->blocks[max], heap->blocks[curr]);
../lib/pf_malloc.c:120:            SWAP(heap->blocks[max]->index, heap->blocks[curr]->index);
../lib/pf_malloc.c:130:    heap->blocks[++heap->nblocks] = new;
../lib/pf_malloc.c:131:    new->index = heap->nblocks;
../lib/pf_malloc.c:133:    unsigned parent, curr = heap->nblocks;
../lib/pf_malloc.c:136:        if(heap->blocks[parent]->size < heap->blocks[curr]->size) {
../lib/pf_malloc.c:137:            SWAP_PTRS(heap->blocks[parent], heap->blocks[curr]);
../lib/pf_malloc.c:138:            SWAP(heap->blocks[parent]->index, heap->blocks[curr]->index);
../lib/pf_malloc.c:148:    struct memblock *top = heap->blocks[i]; 
../lib/pf_malloc.c:153:        + (top->size - newsize - ALIGNED(sizeof(struct memblock)))
../lib/pf_malloc.c:155:    new->size = newsize;
../lib/pf_malloc.c:156:    new->offset = top->offset + (top->size - newsize);
../lib/pf_malloc.c:157:    new->free = false;
../lib/pf_malloc.c:158:    top->size -= (ALIGNED(sizeof(struct memblock)) + newsize);
../lib/pf_malloc.c:160:    /* Re-insert the block we just resized into the heap */
../lib/pf_malloc.c:164:    new->prev = top;
../lib/pf_malloc.c:165:    new->next = top->next;
../lib/pf_malloc.c:166:    top->next = new;
../lib/pf_malloc.c:174:    struct memblock *first = heap->blocks[ifirst];
../lib/pf_malloc.c:175:    struct memblock *next = heap->blocks[inext];
../lib/pf_malloc.c:177:    struct memblock *pre = first->prev;
../lib/pf_malloc.c:178:    struct memblock *post = next->next;
../lib/pf_malloc.c:180:    first->size += (ALIGNED(sizeof(struct memblock)) + next->size);
../lib/pf_malloc.c:182:    first->prev = pre;
../lib/pf_malloc.c:183:    first->next = post;
../lib/pf_malloc.c:189:    struct memblock *top = heap->blocks[i]; 
../lib/pf_malloc.c:193:    new->size = newsize + (top->offset + (top->size - newsize)) % newalign;
../lib/pf_malloc.c:194:    new->offset = align_down(top->offset + (top->size - newsize), newalign);
../lib/pf_malloc.c:195:    new->free = false;
../lib/pf_malloc.c:196:    top->size = new->offset - top->offset;
../lib/pf_malloc.c:198:    /* Re-insert the block we just resized into the heap */
../lib/pf_malloc.c:202:    new->prev = top;
../lib/pf_malloc.c:203:    new->next = top->next;
../lib/pf_malloc.c:204:    top->next = new;
../lib/pf_malloc.c:212:    struct memblock *first = heap->blocks[ifirst];
../lib/pf_malloc.c:213:    struct memblock *next = heap->blocks[inext];
../lib/pf_malloc.c:215:    struct memblock *pre = first->prev;
../lib/pf_malloc.c:216:    struct memblock *post = next->next;
../lib/pf_malloc.c:218:    first->size += next->size;
../lib/pf_malloc.c:220:    first->prev = pre;
../lib/pf_malloc.c:221:    first->next = post;
../lib/pf_malloc.c:227:    int high = heap->nblocks;
../lib/pf_malloc.c:230:    while(heap->blocks[mid]->offset != offset) {
../lib/pf_malloc.c:232:        if(heap->blocks[mid]->offset > offset) {
../lib/pf_malloc.c:233:            high = mid - 1;
../lib/pf_malloc.c:240:    return heap->blocks[mid];
../lib/pf_malloc.c:254:    head->size = ALIGNED(size) - ALIGNED(sizeof(struct memheap)) - ALIGNED(sizeof(struct memblock));
../lib/pf_malloc.c:255:    head->offset = ALIGNED(sizeof(struct memheap)) + ALIGNED(sizeof(struct memblock));
../lib/pf_malloc.c:256:    head->free = true;
../lib/pf_malloc.c:257:    head->next = NULL;
../lib/pf_malloc.c:258:    head->prev = NULL;
../lib/pf_malloc.c:260:    heap->blocks[1] = head;
../lib/pf_malloc.c:261:    heap->nblocks = 1;
../lib/pf_malloc.c:268:    struct memblock *top = heap->blocks[1];
../lib/pf_malloc.c:270:    if(!top->free || size > top->size || heap->nblocks == MAX_HEAP_SZ) {
../lib/pf_malloc.c:274:    if(top->size - size <= ALIGNED(sizeof(struct memblock))) {
../lib/pf_malloc.c:275:        top->free = false;
../lib/pf_malloc.c:288:        mem->free = true;
../lib/pf_malloc.c:289:        heap_coalese_blocks(heap, mem->index, mem->next->index);
../lib/pf_malloc.c:292:        mem->prev->free = true;
../lib/pf_malloc.c:293:        heap_coalese_blocks(heap, mem->prev->index, mem->index);
../lib/pf_malloc.c:305:    head->size = size;
../lib/pf_malloc.c:306:    head->offset = 0;
../lib/pf_malloc.c:307:    head->free = true;
../lib/pf_malloc.c:308:    head->next = NULL;
../lib/pf_malloc.c:309:    head->prev = NULL;
../lib/pf_malloc.c:311:    heap->blocks[1] = head;
../lib/pf_malloc.c:312:    heap->nblocks = 1;
../lib/pf_malloc.c:324:    struct memblock *top = heap->blocks[1];
../lib/pf_malloc.c:326:    if(!top->free || size > top->size || heap->nblocks == MAX_HEAP_SZ) {
../lib/pf_malloc.c:327:        return -1;
../lib/pf_malloc.c:330:    if(top->size == size) {
../lib/pf_malloc.c:331:        top->free = false;
../lib/pf_malloc.c:332:        return top->offset;
../lib/pf_malloc.c:335:    return meta_split_block_aligned(heap, 1, size, sizeof(intmax_t))->offset;
../lib/pf_malloc.c:341:    struct memblock *top = heap->blocks[1];
../lib/pf_malloc.c:343:    if(!top->free || heap->nblocks == MAX_HEAP_SZ) {
../lib/pf_malloc.c:344:        return -1;
../lib/pf_malloc.c:347:    size_t pad = align(top->offset, alignment) - top->offset;
../lib/pf_malloc.c:348:    if(top->size + pad < size) {
../lib/pf_malloc.c:349:        return -1;
../lib/pf_malloc.c:352:    if(top->size + pad == size) {
../lib/pf_malloc.c:353:        top->free = false;
../lib/pf_malloc.c:354:        top->offset += pad;
../lib/pf_malloc.c:355:        if(top->prev)
../lib/pf_malloc.c:356:            top->prev->size += pad;
../lib/pf_malloc.c:357:        return top->offset;
../lib/pf_malloc.c:360:    int ret = meta_split_block_aligned(heap, 1, size, alignment)->offset;
../lib/pf_malloc.c:370:        mem->free = true;
../lib/pf_malloc.c:371:        meta_coalese_blocks(heap, mem->index, mem->next->index);
../lib/pf_malloc.c:374:        mem->prev->free = true;
../lib/pf_malloc.c:375:        meta_coalese_blocks(heap, mem->prev->index, mem->index);
../lib/pf_string.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/pf_string.c:90:    assert(ret[len-1] == '\0');
../lib/pf_string.c:100:    size_t ret = (srclen > size-1) ? size-1 : srclen;
../lib/pf_string.c:115:    str[size-1] = '\0';
../lib/pf_string.c:127:    return (0 == strcmp(str + (slen - elen), end));
../lib/pf_string.c:136:    if(dstlen >= size-1)
../lib/pf_string.c:138:    size_t left = size - 1 - dstlen;
../lib/public/SDL_vec_rwops.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/public/khash.h:49:  2013-05-02 (0.2.8):
../lib/public/khash.h:62:  2011-12-29 (0.2.7):
../lib/public/khash.h:66:  2011-09-16 (0.2.6):
../lib/public/khash.h:71:       - http://code.google.com/p/ulib/
../lib/public/khash.h:72:       - http://nothings.org/computer/judy/
../lib/public/khash.h:76:      is more robust to certain non-random input.
../lib/public/khash.h:79:      function is more robust to certain non-random input.
../lib/public/khash.h:81:  2011-02-14 (0.2.5):
../lib/public/khash.h:85:  2009-09-26 (0.2.4):
../lib/public/khash.h:89:  2008-09-19 (0.2.3):
../lib/public/khash.h:94:  2008-09-11 (0.2.2):
../lib/public/khash.h:98:  2008-09-10 (0.2.1):
../lib/public/khash.h:103:  2008-09-02 (0.2.0):
../lib/public/khash.h:107:  2008-08-31 (0.1.2):
../lib/public/khash.h:111:  2008-08-31 (0.1.1):
../lib/public/khash.h:176:#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
../lib/public/khash.h:223:            kfree((void *)h->keys); kfree(h->flags);                                            \
../lib/public/khash.h:224:            kfree((void *)h->vals);                                                             \
../lib/public/khash.h:231:        if (h && h->flags) {                                                                    \
../lib/public/khash.h:232:            memset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t));               \
../lib/public/khash.h:233:            h->size = h->n_occupied = 0;                                                        \
../lib/public/khash.h:239:        if (h->n_buckets) {                                                                     \
../lib/public/khash.h:241:            mask = h->n_buckets - 1;                                                            \
../lib/public/khash.h:244:            while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i)                       \
../lib/public/khash.h:245:                || !__hash_equal(h->keys[i], key))) {                                           \
../lib/public/khash.h:248:                    return h->n_buckets;                                                        \
../lib/public/khash.h:250:            return __ac_iseither(h->flags, i)? h->n_buckets : i;                                \
../lib/public/khash.h:264:            if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5))                    \
../lib/public/khash.h:269:                    return -1;                                                                  \
../lib/public/khash.h:271:                if (h->n_buckets < new_n_buckets) { /* expand */                                \
../lib/public/khash.h:272:                    khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys,                     \
../lib/public/khash.h:276:                        return -1;                                                              \
../lib/public/khash.h:278:                    h->keys = new_keys;                                                         \
../lib/public/khash.h:280:                        khval_t *new_vals = (khval_t*)krealloc((void *)h->vals,                 \
../lib/public/khash.h:284:                            return -1;                                                          \
../lib/public/khash.h:286:                        h->vals = new_vals;                                                     \
../lib/public/khash.h:292:            for (j = 0; j != h->n_buckets; ++j) {                                               \
../lib/public/khash.h:293:                if (__ac_iseither(h->flags, j) == 0) {                                          \
../lib/public/khash.h:294:                    khkey_t key = h->keys[j];                                                   \
../lib/public/khash.h:297:                    new_mask = new_n_buckets - 1;                                               \
../lib/public/khash.h:299:                        val = h->vals[j];                                                       \
../lib/public/khash.h:300:                    __ac_set_isdel_true(h->flags, j);                                           \
../lib/public/khash.h:301:                    while (1) { /* kick-out process; sort of like in Cuckoo hashing */          \
../lib/public/khash.h:308:                        if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) {              \
../lib/public/khash.h:310:                            khkey_t tmp = h->keys[i];                                           \
../lib/public/khash.h:311:                            h->keys[i] = key;                                                   \
../lib/public/khash.h:314:                                khval_t tmp = h->vals[i];                                       \
../lib/public/khash.h:315:                                h->vals[i] = val;                                               \
../lib/public/khash.h:319:                            __ac_set_isdel_true(h->flags, i);                                   \
../lib/public/khash.h:321:                            h->keys[i] = key;                                                   \
../lib/public/khash.h:322:                            if (kh_is_map) h->vals[i] = val;                                    \
../lib/public/khash.h:328:            if (h->n_buckets > new_n_buckets) { /* shrink the hash table */                     \
../lib/public/khash.h:329:                h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
../lib/public/khash.h:330:                if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals,                    \
../lib/public/khash.h:333:            kfree(h->flags); /* free the working space */                                       \
../lib/public/khash.h:334:            h->flags = new_flags;                                                               \
../lib/public/khash.h:335:            h->n_buckets = new_n_buckets;                                                       \
../lib/public/khash.h:336:            h->n_occupied = h->size;                                                            \
../lib/public/khash.h:337:            h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5);                   \
../lib/public/khash.h:345:        if (h->n_occupied >= h->upper_bound) { /* update the hash table */                      \
../lib/public/khash.h:346:            if (h->n_buckets > (h->size<<1)) { /* clear "deleted" elements */                   \
../lib/public/khash.h:347:                if (kh_resize_##name(h, h->n_buckets - 1) < 0) {                                \
../lib/public/khash.h:348:                    *ret = -1;                                                                  \
../lib/public/khash.h:349:                    return h->n_buckets;                                                        \
../lib/public/khash.h:351:            } else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
../lib/public/khash.h:352:                *ret = -1;                                                                      \
../lib/public/khash.h:353:                return h->n_buckets;                                                            \
../lib/public/khash.h:357:        khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0;                            \
../lib/public/khash.h:358:        x = site = h->n_buckets;                                                                \
../lib/public/khash.h:361:        if (__ac_isempty(h->flags, i))                                                          \
../lib/public/khash.h:365:            while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i)                       \
../lib/public/khash.h:366:                || !__hash_equal(h->keys[i], key))) {                                           \
../lib/public/khash.h:368:                if (__ac_isdel(h->flags, i))                                                    \
../lib/public/khash.h:376:            if (x == h->n_buckets) {                                                            \
../lib/public/khash.h:377:                if (__ac_isempty(h->flags, i) && site != h->n_buckets)                          \
../lib/public/khash.h:384:        if (__ac_isempty(h->flags, x)) { /* not present at all */                               \
../lib/public/khash.h:385:            h->keys[x] = key;                                                                   \
../lib/public/khash.h:386:            __ac_set_isboth_false(h->flags, x);                                                 \
../lib/public/khash.h:387:            ++h->size; ++h->n_occupied;                                                         \
../lib/public/khash.h:389:        } else if (__ac_isdel(h->flags, x)) { /* deleted */                                     \
../lib/public/khash.h:390:            h->keys[x] = key;                                                                   \
../lib/public/khash.h:391:            __ac_set_isboth_false(h->flags, x);                                                 \
../lib/public/khash.h:392:            ++h->size;                                                                          \
../lib/public/khash.h:395:            *ret = 0; /* Don't touch h->keys[x] if present and not deleted */                   \
../lib/public/khash.h:401:        if (x != h->n_buckets && !__ac_iseither(h->flags, x)) {                                 \
../lib/public/khash.h:402:            __ac_set_isdel_true(h->flags, x);                                                   \
../lib/public/khash.h:403:            --h->size;                                                                          \
../lib/public/khash.h:413:        ret->flags = (khint32_t*)kmalloc(__ac_fsize(h->n_buckets) * sizeof(khint32_t));         \
../lib/public/khash.h:414:        ret->keys = (khkey_t*)kmalloc(h->n_buckets * sizeof(khkey_t));                          \
../lib/public/khash.h:415:        ret->vals = (khval_t*)kmalloc(h->n_buckets * sizeof(khval_t));                          \
../lib/public/khash.h:416:        if(!ret->flags || !ret->keys || !ret->vals) {                                           \
../lib/public/khash.h:417:            kfree(ret->flags);                                                                  \
../lib/public/khash.h:418:            kfree(ret->keys);                                                                   \
../lib/public/khash.h:419:            kfree(ret->vals);                                                                   \
../lib/public/khash.h:423:        kmemcpy(ret->flags, h->flags, __ac_fsize(h->n_buckets) * sizeof(khint32_t));            \
../lib/public/khash.h:424:        kmemcpy(ret->keys, h->keys, h->n_buckets * sizeof(khkey_t));                            \
../lib/public/khash.h:425:        kmemcpy(ret->vals, h->vals, h->n_buckets * sizeof(khval_t));                            \
../lib/public/khash.h:441:/* --- BEGIN OF HASH FUNCTIONS --- */
../lib/public/khash.h:454:  @abstract     64-bit integer hash function
../lib/public/khash.h:460:  @abstract     64-bit integer comparison function
../lib/public/khash.h:471:    if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
../lib/public/khash.h:497:/* --- END OF HASH FUNCTIONS --- */
../lib/public/khash.h:545:  @param  r     Extra return code: -1 if the operation failed;
../lib/public/khash.h:576:#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))
../lib/public/khash.h:584:#define kh_key(h, x) ((h)->keys[x])
../lib/public/khash.h:593:#define kh_val(h, x) ((h)->vals[x])
../lib/public/khash.h:598:#define kh_value(h, x) ((h)->vals[x])
../lib/public/khash.h:612:#define kh_end(h) ((h)->n_buckets)
../lib/public/khash.h:619:#define kh_size(h) ((h)->size)
../lib/public/khash.h:626:#define kh_n_buckets(h) ((h)->n_buckets)
../lib/public/khash.h:682:  @abstract     Instantiate a hash map containing 64-bit integer keys
../lib/public/khash.h:689:  @abstract     Instantiate a hash map containing 64-bit integer keys
../lib/public/lru_cache.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/public/lru_cache.h:83:        for(curr = (_lru)->ilru_head; curr; curr = next_curr) {                                 \
../lib/public/lru_cache.h:84:            curr_node = mp_##name##_entry(&((_lru)->node_pool), curr);                          \
../lib/public/lru_cache.h:85:            next_curr = curr_node->next;                                                        \
../lib/public/lru_cache.h:87:            _key = curr_node->key;                                                              \
../lib/public/lru_cache.h:88:            _val = curr_node->entry;                                                            \
../lib/public/lru_cache.h:122:        if(ref == lru->ilru_head)                                                               \
../lib/public/lru_cache.h:125:        lru_node(name) *node = mp_##name##_entry(&lru->node_pool, ref);                         \
../lib/public/lru_cache.h:126:        lru_node(name) *prev = node->prev ? mp_##name##_entry(&lru->node_pool, node->prev)      \
../lib/public/lru_cache.h:128:        lru_node(name) *next = node->next ? mp_##name##_entry(&lru->node_pool, node->next)      \
../lib/public/lru_cache.h:130:        lru_node(name) *old_head = mp_##name##_entry(&lru->node_pool, lru->ilru_head);          \
../lib/public/lru_cache.h:131:        mp_ref_t old_tail_prev = mp_##name##_entry(&lru->node_pool, lru->ilru_tail)->prev;      \
../lib/public/lru_cache.h:135:            prev->next = node->next;                                                            \
../lib/public/lru_cache.h:137:            next->prev = node->prev;                                                            \
../lib/public/lru_cache.h:140:        old_head->prev = ref;                                                                   \
../lib/public/lru_cache.h:141:        node->next = lru->ilru_head;                                                            \
../lib/public/lru_cache.h:142:        node->prev = 0;                                                                         \
../lib/public/lru_cache.h:143:        lru->ilru_head = ref;                                                                   \
../lib/public/lru_cache.h:146:        if(ref == lru->ilru_tail) {                                                             \
../lib/public/lru_cache.h:147:            lru->ilru_tail = old_tail_prev;                                                     \
../lib/public/lru_cache.h:148:            mp_##name##_entry(&lru->node_pool, old_tail_prev)->next = 0;                        \
../lib/public/lru_cache.h:156:        lru->key_node_table = kh_init(name);                                                    \
../lib/public/lru_cache.h:157:        if(!lru->key_node_table)                                                                \
../lib/public/lru_cache.h:159:        kh_resize(name, lru->key_node_table, capacity);                                         \
../lib/public/lru_cache.h:161:        mp_##name##_init(&lru->node_pool, false);                                               \
../lib/public/lru_cache.h:162:        if(!mp_##name##_reserve(&lru->node_pool, capacity)) {                                   \
../lib/public/lru_cache.h:163:            kh_destroy(name, lru->key_node_table);                                              \
../lib/public/lru_cache.h:166:        lru->capacity = capacity;                                                               \
../lib/public/lru_cache.h:167:        lru->on_evict = on_evict;                                                               \
../lib/public/lru_cache.h:174:        kh_destroy(name, lru->key_node_table);                                                  \
../lib/public/lru_cache.h:175:        mp_##name##_destroy(&lru->node_pool);                                                   \
../lib/public/lru_cache.h:183:        kh_foreach(lru->key_node_table, key, curr, {                                            \
../lib/public/lru_cache.h:186:            if(!lru->on_evict)                                                                  \
../lib/public/lru_cache.h:188:            lru_node(name) *vict = &lru->node_pool.pool[curr].entry;                            \
../lib/public/lru_cache.h:189:            lru->on_evict(&vict->entry);                                                        \
../lib/public/lru_cache.h:192:        kh_clear(name, lru->key_node_table);                                                    \
../lib/public/lru_cache.h:193:        mp_##name##_clear(&lru->node_pool);                                                     \
../lib/public/lru_cache.h:194:        lru->ilru_head = 0;                                                                     \
../lib/public/lru_cache.h:195:        lru->ilru_tail = 0;                                                                     \
../lib/public/lru_cache.h:196:        lru->used = 0;                                                                          \
../lib/public/lru_cache.h:202:        if((k = kh_get(name, lru->key_node_table, key)) == kh_end(lru->key_node_table))         \
../lib/public/lru_cache.h:205:        mp_ref_t ref = kh_val(lru->key_node_table, k);                                          \
../lib/public/lru_cache.h:206:        lru_node(name) *mpn = mp_##name##_entry(&lru->node_pool, ref);                          \
../lib/public/lru_cache.h:208:        *out = mpn->entry;                                                                      \
../lib/public/lru_cache.h:216:        if((k = kh_get(name, lru->key_node_table, key)) == kh_end(lru->key_node_table))         \
../lib/public/lru_cache.h:219:        mp_ref_t ref = kh_val(lru->key_node_table, k);                                          \
../lib/public/lru_cache.h:220:        lru_node(name) *mpn = mp_##name##_entry(&lru->node_pool, ref);                          \
../lib/public/lru_cache.h:223:        return &mpn->entry;                                                                     \
../lib/public/lru_cache.h:234:        if((k = kh_get(name, lru->key_node_table, key)) == kh_end(lru->key_node_table)) {       \
../lib/public/lru_cache.h:239:            if(lru->used == 0) {                                                                \
../lib/public/lru_cache.h:241:                new_ref = mp_##name##_alloc(&lru->node_pool);                                   \
../lib/public/lru_cache.h:242:                new_node = mp_##name##_entry(&lru->node_pool, new_ref);                         \
../lib/public/lru_cache.h:243:                new_node->prev = 0;                                                             \
../lib/public/lru_cache.h:244:                new_node->next = 0;                                                             \
../lib/public/lru_cache.h:245:                lru->ilru_head = lru->ilru_tail = new_ref;                                      \
../lib/public/lru_cache.h:246:                ++(lru->used);                                                                  \
../lib/public/lru_cache.h:248:            }else if(lru->used == lru->capacity) {                                              \
../lib/public/lru_cache.h:250:                lru_node(name) *vict = mp_##name##_entry(&lru->node_pool, lru->ilru_tail);      \
../lib/public/lru_cache.h:251:                if(lru->on_evict) {                                                             \
../lib/public/lru_cache.h:252:                    lru->on_evict(&vict->entry);                                                \
../lib/public/lru_cache.h:256:                k = kh_get(name, lru->key_node_table, vict->key);                               \
../lib/public/lru_cache.h:257:                kh_del(name, lru->key_node_table, k);                                           \
../lib/public/lru_cache.h:259:                new_ref = lru->ilru_tail;                                                       \
../lib/public/lru_cache.h:265:                new_ref = mp_##name##_alloc(&lru->node_pool);                                   \
../lib/public/lru_cache.h:266:                new_node = mp_##name##_entry(&lru->node_pool, new_ref);                         \
../lib/public/lru_cache.h:267:                lru_node(name) *old_head = mp_##name##_entry(&lru->node_pool, lru->ilru_head);  \
../lib/public/lru_cache.h:269:                new_node->prev = 0;                                                             \
../lib/public/lru_cache.h:270:                new_node->next = lru->ilru_head;                                                \
../lib/public/lru_cache.h:271:                lru->ilru_head = new_ref;                                                       \
../lib/public/lru_cache.h:272:                old_head->prev = new_ref;                                                       \
../lib/public/lru_cache.h:273:                ++(lru->used);                                                                  \
../lib/public/lru_cache.h:277:            new_node->entry = *in;                                                              \
../lib/public/lru_cache.h:278:            new_node->key = key;                                                                \
../lib/public/lru_cache.h:281:            k = kh_put(name, lru->key_node_table, key, &ret);                                   \
../lib/public/lru_cache.h:282:            kh_value(lru->key_node_table, k) = new_ref;                                         \
../lib/public/lru_cache.h:285:            /* There is an existing entry for this key - overwrite it and reference it */       \
../lib/public/lru_cache.h:287:            mp_ref_t ref = kh_val(lru->key_node_table, k);                                      \
../lib/public/lru_cache.h:288:            lru_node(name) *mpn = mp_##name##_entry(&lru->node_pool, ref);                      \
../lib/public/lru_cache.h:290:            if(lru->on_evict) {                                                                 \
../lib/public/lru_cache.h:291:                lru->on_evict(&mpn->entry);                                                     \
../lib/public/lru_cache.h:294:            mpn->entry = *in;                                                                   \
../lib/public/lru_cache.h:302:        if((k = kh_get(name, lru->key_node_table, key)) == kh_end(lru->key_node_table))         \
../lib/public/lru_cache.h:305:        mp_ref_t ref = kh_val(lru->key_node_table, k);                                          \
../lib/public/lru_cache.h:306:        lru_node(name) *mpn = mp_##name##_entry(&lru->node_pool, ref);                          \
../lib/public/lru_cache.h:307:        if(mpn->prev)                                                                           \
../lib/public/lru_cache.h:308:            mp_##name##_entry(&lru->node_pool, mpn->prev)->next = mpn->next;                    \
../lib/public/lru_cache.h:309:        if(mpn->next)                                                                           \
../lib/public/lru_cache.h:310:            mp_##name##_entry(&lru->node_pool, mpn->next)->prev = mpn->prev;                    \
../lib/public/lru_cache.h:312:        if(lru->ilru_head == ref)                                                               \
../lib/public/lru_cache.h:313:            lru->ilru_head = mpn->next;                                                         \
../lib/public/lru_cache.h:314:        if(lru->ilru_tail == ref)                                                               \
../lib/public/lru_cache.h:315:            lru->ilru_tail = mpn->prev;                                                         \
../lib/public/lru_cache.h:317:        --(lru->used);                                                                          \
../lib/public/lru_cache.h:318:        kh_del(name, lru->key_node_table, k);                                                   \
../lib/public/lru_cache.h:319:        mp_##name##_free(&lru->node_pool, ref);                                                 \
../lib/public/mpool.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/public/mpool.h:94:        mp->can_grow = can_grow;                                                                \
../lib/public/mpool.h:99:        size_t old_cap = mp->capacity;                                                          \
../lib/public/mpool.h:103:        mp_##name##_node_t *new_entry = realloc(mp->pool,                                       \
../lib/public/mpool.h:114:            /* Skip the first node - index 0 is used as NULL */                                 \
../lib/public/mpool.h:115:            mp->ifree_head = 1;                                                                 \
../lib/public/mpool.h:118:            new_entry[new_cap].inext_free = mp->ifree_head;                                     \
../lib/public/mpool.h:119:            mp->ifree_head = old_cap + 1;                                                       \
../lib/public/mpool.h:122:        mp->pool = new_entry;                                                                   \
../lib/public/mpool.h:123:        mp->capacity = new_cap;                                                                 \
../lib/public/mpool.h:129:        free(mp->pool);                                                                         \
../lib/public/mpool.h:135:        if(mp->num_allocd == mp->capacity) {                                                    \
../lib/public/mpool.h:136:            if(!mp->can_grow)                                                                   \
../lib/public/mpool.h:138:            if(!mp_##name##_reserve(mp, mp->capacity ? mp->capacity * 2 : 32))                  \
../lib/public/mpool.h:142:        assert(mp->ifree_head > 0);                                                             \
../lib/public/mpool.h:143:        mp_ref_t ret = mp->ifree_head;                                                          \
../lib/public/mpool.h:145:        mp->ifree_head = mp->pool[mp->ifree_head].inext_free;                                   \
../lib/public/mpool.h:146:        ++mp->num_allocd;                                                                       \
../lib/public/mpool.h:154:        assert(mp->num_allocd > 0);                                                             \
../lib/public/mpool.h:155:        assert(ref <= mp->capacity);                                                            \
../lib/public/mpool.h:157:        mp->pool[ref].inext_free = mp->ifree_head;                                              \
../lib/public/mpool.h:158:        mp->ifree_head = ref;                                                                   \
../lib/public/mpool.h:159:        --mp->num_allocd;                                                                       \
../lib/public/mpool.h:164:        return &mp->pool[ref].entry;                                                            \
../lib/public/mpool.h:169:        if(mp->capacity == 0)                                                                   \
../lib/public/mpool.h:171:        mp->num_allocd = 0;                                                                     \
../lib/public/mpool.h:172:        mp->ifree_head = 1;                                                                     \
../lib/public/mpool.h:174:        for(int i = 1; i < mp->capacity; ++i) {                                                 \
../lib/public/mpool.h:175:            mp->pool[i].inext_free = i + 1;                                                     \
../lib/public/mpool.h:177:        mp->pool[mp->capacity].inext_free = 0;                                                  \
../lib/public/mpool.h:183:            - offsetof(mp_##name##_node_t, entry) - (uintptr_t)mp->pool;                        \
../lib/public/mpool.h:184:        assert(diff % sizeof(mp->pool[0]) == 0);                                                \
../lib/public/mpool.h:185:        return diff / sizeof(mp->pool[0]);                                                      \
../lib/public/mpool_allocator.h:90:        mpa->chunks = malloc(sizeof(mp_##name##_t));                                            \
../lib/public/mpool_allocator.h:91:        if(!mpa->chunks)                                                                        \
../lib/public/mpool_allocator.h:94:        mp_##name##_init(mpa->chunks, false);                                                   \
../lib/public/mpool_allocator.h:95:        if(!mp_##name##_reserve(mpa->chunks, chunk_size))                                       \
../lib/public/mpool_allocator.h:98:        mpa->chunk_size = chunk_size;                                                           \
../lib/public/mpool_allocator.h:99:        mpa->max_chunks = max_chunks;                                                           \
../lib/public/mpool_allocator.h:100:        mpa->num_chunks = 1;                                                                    \
../lib/public/mpool_allocator.h:101:        mpa->first_free_chunk = 0;                                                              \
../lib/public/mpool_allocator.h:102:        mpa->capacity = chunk_size;                                                             \
../lib/public/mpool_allocator.h:103:        mpa->size = 0;                                                                          \
../lib/public/mpool_allocator.h:109:        while(mpa->capacity < new_cap) {                                                        \
../lib/public/mpool_allocator.h:111:            if(mpa->max_chunks != 0 && mpa->num_chunks == mpa->max_chunks)                      \
../lib/public/mpool_allocator.h:113:            mp_##name##_t *newchunks = realloc(mpa->chunks,                                     \
../lib/public/mpool_allocator.h:114:                (mpa->num_chunks + 1) * sizeof(mp_##name##_t));                                 \
../lib/public/mpool_allocator.h:117:            mp_##name##_init(newchunks + mpa->num_chunks, false);                               \
../lib/public/mpool_allocator.h:118:            if(!mp_##name##_reserve(newchunks + mpa->num_chunks, mpa->chunk_size))              \
../lib/public/mpool_allocator.h:120:            mpa->chunks = newchunks;                                                            \
../lib/public/mpool_allocator.h:121:            mpa->num_chunks += 1;                                                               \
../lib/public/mpool_allocator.h:122:            mpa->capacity += mpa->chunk_size;                                                   \
../lib/public/mpool_allocator.h:129:        for(int i = 0; i < mpa->num_chunks; i++) {                                              \
../lib/public/mpool_allocator.h:130:            mp_##name##_destroy(&mpa->chunks[i]);                                               \
../lib/public/mpool_allocator.h:132:        free(mpa->chunks);                                                                      \
../lib/public/mpool_allocator.h:138:        if(mpa->capacity == mpa->size) {                                                        \
../lib/public/mpool_allocator.h:139:            if(!mpa_##name##_reserve(mpa, mpa->capacity + mpa->chunk_size))                     \
../lib/public/mpool_allocator.h:141:            mpa->first_free_chunk = mpa->num_chunks - 1;                                        \
../lib/public/mpool_allocator.h:144:        mp_##name##_t *pool = &mpa->chunks[mpa->first_free_chunk];                              \
../lib/public/mpool_allocator.h:145:        while(pool->num_allocd == pool->capacity) {                                             \
../lib/public/mpool_allocator.h:146:            mpa->first_free_chunk++;                                                            \
../lib/public/mpool_allocator.h:147:            pool = &mpa->chunks[mpa->first_free_chunk];                                         \
../lib/public/mpool_allocator.h:151:        assert(ref > 0 && ref <= mpa->chunk_size);                                              \
../lib/public/mpool_allocator.h:152:        mpa->size++;                                                                            \
../lib/public/mpool_allocator.h:163:        for(int i = 0; i < mpa->num_chunks; i++) {                                              \
../lib/public/mpool_allocator.h:164:            mp_##name##_t *pool = &mpa->chunks[i];                                              \
../lib/public/mpool_allocator.h:165:            uintptr_t base = (uintptr_t)(pool->pool + 1);                                       \
../lib/public/mpool_allocator.h:166:            uintptr_t limit = (uintptr_t)(pool->pool + pool->capacity + 1);                     \
../lib/public/mpool_allocator.h:170:                assert(ref > 0 && ref <= mpa->chunk_size);                                      \
../lib/public/mpool_allocator.h:172:                mpa->size--;                                                                    \
../lib/public/mpool_allocator.h:174:                if(i < mpa->first_free_chunk) {                                                 \
../lib/public/mpool_allocator.h:175:                    mpa->first_free_chunk = i;                                                  \
../lib/public/mpool_allocator.h:184:        for(int i = 0; i < mpa->num_chunks; i++) {                                              \
../lib/public/mpool_allocator.h:185:            mp_##name##_clear(&mpa->chunks[i]);                                                 \
../lib/public/mpool_allocator.h:187:        mpa->size = 0;                                                                          \
../lib/public/mpool_allocator.h:188:        mpa->first_free_chunk = 0;                                                              \
../lib/public/nuklear.h:3:/// ![](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)
../lib/public/nuklear.h:39:/// - Graphical user interface toolkit
../lib/public/nuklear.h:40:/// - Single header library
../lib/public/nuklear.h:41:/// - Written in C89 (a.k.a. ANSI C or ISO C90)
../lib/public/nuklear.h:42:/// - Small codebase (~18kLOC)
../lib/public/nuklear.h:43:/// - Focus on portability, efficiency and simplicity
../lib/public/nuklear.h:44:/// - No dependencies (not even the standard library if not wanted)
../lib/public/nuklear.h:45:/// - Fully skinnable and customizable
../lib/public/nuklear.h:46:/// - Low memory footprint with total memory control if needed or wanted
../lib/public/nuklear.h:47:/// - UTF-8 support
../lib/public/nuklear.h:48:/// - No global or hidden state
../lib/public/nuklear.h:49:/// - Customizable library modules (you can compile and use only what you need)
../lib/public/nuklear.h:50:/// - Optional font baker and vertex buffer output
../lib/public/nuklear.h:53:/// - Absolutely no platform dependent code
../lib/public/nuklear.h:54:/// - Memory management control ranging from/to
../lib/public/nuklear.h:55:///     - Ease of use by allocating everything from standard library
../lib/public/nuklear.h:56:///     - Control every byte of memory inside the library
../lib/public/nuklear.h:57:/// - Font handling control ranging from/to
../lib/public/nuklear.h:58:///     - Use your own font implementation for everything
../lib/public/nuklear.h:59:///     - Use this libraries internal font baking and handling API
../lib/public/nuklear.h:60:/// - Drawing output control ranging from/to
../lib/public/nuklear.h:61:///     - Simple shapes for more high level APIs which already have drawing capabilities
../lib/public/nuklear.h:62:///     - Hardware accessible anti-aliased vertex buffer output
../lib/public/nuklear.h:63:/// - Customizable colors and properties ranging from/to
../lib/public/nuklear.h:64:///     - Simple changes to color by filling a simple color table
../lib/public/nuklear.h:65:///     - Complete control with ability to use skinning to decorate widgets
../lib/public/nuklear.h:66:/// - Bendable UI library with widget ranging from/to
../lib/public/nuklear.h:67:///     - Basic widgets like buttons, checkboxes, slider, ...
../lib/public/nuklear.h:68:///     - Advanced widget like abstract comboboxes, contextual menus,...
../lib/public/nuklear.h:69:/// - Compile time configuration to only compile what you need
../lib/public/nuklear.h:70:///     - Subset which can be used if you do not want to link or use the standard library
../lib/public/nuklear.h:71:/// - Can be easily modified to only update on user input instead of frame updates
../lib/public/nuklear.h:96:/// --------------------------------|------------------------------------------
../lib/public/nuklear.h:113:///     - NK_INCLUDE_DEFAULT_ALLOCATOR
../lib/public/nuklear.h:114:///     - NK_INCLUDE_STANDARD_IO
../lib/public/nuklear.h:115:///     - NK_INCLUDE_STANDARD_VARARGS
../lib/public/nuklear.h:119:///     - NK_INCLUDE_FIXED_TYPES
../lib/public/nuklear.h:120:///     - NK_INCLUDE_DEFAULT_ALLOCATOR
../lib/public/nuklear.h:121:///     - NK_INCLUDE_STANDARD_VARARGS
../lib/public/nuklear.h:122:///     - NK_INCLUDE_VERTEX_BUFFER_OUTPUT
../lib/public/nuklear.h:123:///     - NK_INCLUDE_FONT_BAKING
../lib/public/nuklear.h:124:///     - NK_INCLUDE_DEFAULT_FONT
../lib/public/nuklear.h:125:///     - NK_INCLUDE_STANDARD_VARARGS
../lib/public/nuklear.h:126:///     - NK_INCLUDE_COMMAND_USERDATA
../lib/public/nuklear.h:127:///     - NK_UINT_DRAW_INDEX
../lib/public/nuklear.h:131:/// --------------------------------|---------------------------------------
../lib/public/nuklear.h:138:///     - NK_MAX_NUMBER_BUFFER
../lib/public/nuklear.h:139:///     - NK_BUFFER_DEFAULT_INITIAL_SIZE
../lib/public/nuklear.h:140:///     - NK_INPUT_MAX
../lib/public/nuklear.h:144:/// ------------|---------------------------------------------------------------
../lib/public/nuklear.h:157:///     - NK_ASSERT
../lib/public/nuklear.h:161:///     - NK_ASSERT
../lib/public/nuklear.h:165:///     - NK_MEMSET
../lib/public/nuklear.h:166:///     - NK_MEMCPY
../lib/public/nuklear.h:167:///     - NK_SQRT
../lib/public/nuklear.h:168:///     - NK_SIN
../lib/public/nuklear.h:169:///     - NK_COS
../lib/public/nuklear.h:170:///     - NK_STRTOD
../lib/public/nuklear.h:171:///     - NK_DTOA
../lib/public/nuklear.h:172:///     - NK_VSNPRINTF
../lib/public/nuklear.h:211:/// ![](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)
../lib/public/nuklear.h:233:#define NK_UNDEFINED (-1.0f)
../lib/public/nuklear.h:291:  #define NK_STATIC_ASSERT(exp) typedef char NK_UNIQUE_NAME(_dummy_array)[(exp)?1:-1]
../lib/public/nuklear.h:548:/// --------------------|-------------------------------------------------------
../lib/public/nuklear.h:567:/// ------------|---------------------------------------------------------------
../lib/public/nuklear.h:591:/// ------------|--------------------------------------------------------------
../lib/public/nuklear.h:610:/// ------------|---------------------------------------------------------------
../lib/public/nuklear.h:628:/// ------------|---------------------------------------------------------------
../lib/public/nuklear.h:647:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:660:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:673:/// ------------|--------------------------------------------------------------
../lib/public/nuklear.h:709:/// Both event- or state-based input handling are supported by this API
../lib/public/nuklear.h:734:/// --------------------|-------------------------------------------------------
../lib/public/nuklear.h:741:/// __nk_input_glyph__  | Adds a single multi-byte UTF-8 character into an internal text buffer
../lib/public/nuklear.h:796:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:808:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:810:/// __x__       | Must hold an integer describing the current mouse cursor x-position
../lib/public/nuklear.h:811:/// __y__       | Must hold an integer describing the current mouse cursor y-position
../lib/public/nuklear.h:822:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:836:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:839:/// __x__       | Must contain an integer describing mouse cursor x-position on click up/down
../lib/public/nuklear.h:840:/// __y__       | Must contain an integer describing mouse cursor y-position on click up/down
../lib/public/nuklear.h:854:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:856:/// __val__     | vector with both X- as well as Y-scroll value
../lib/public/nuklear.h:872:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:878:/// Converts an encoded unicode rune into UTF-8 and copies the result into an
../lib/public/nuklear.h:889:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:891:/// __g__       | UTF-32 unicode codepoint
../lib/public/nuklear.h:895:/// Converts a unicode rune into UTF-8 and copies the result
../lib/public/nuklear.h:905:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:907:/// __rune__    | UTF-32 unicode codepoint
../lib/public/nuklear.h:919:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:949:///     switch (cmd->type) {
../lib/public/nuklear.h:986:///     switch (cmd->type) {
../lib/public/nuklear.h:1025:///     switch (cmd->type) {
../lib/public/nuklear.h:1071:///             switch (cmd->type) {
../lib/public/nuklear.h:1121:/// cfg.null = dev->null;
../lib/public/nuklear.h:1132:/// if (!cmd->elem_count) continue;
../lib/public/nuklear.h:1142:/// --------------------|-------------------------------------------------------
../lib/public/nuklear.h:1166:    enum nk_anti_aliasing line_AA; /* line anti-aliasing flag can be turned off if you are tight on memory */
../lib/public/nuklear.h:1167:    enum nk_anti_aliasing shape_AA; /* shape anti-aliasing flag can be turned off if you are tight on memory */
../lib/public/nuklear.h:1185:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1199:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1214:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1234:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1244:/// --------------------------------|-----------------------------------------------------------
../lib/public/nuklear.h:1260:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1275:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1290:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1306:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1398:/// ------------------------------------|----------------------------------------
../lib/public/nuklear.h:1410:/// nk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed window
../lib/public/nuklear.h:1411:/// nk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
../lib/public/nuklear.h:1412:/// nk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
../lib/public/nuklear.h:1413:/// nk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed window
../lib/public/nuklear.h:1438:/// ----------------------------|----------------------------------------
../lib/public/nuklear.h:1448:/// NK_WINDOW_SCALE_LEFT        | Puts window scaler in the left-bottom corner instead right-bottom
../lib/public/nuklear.h:1453:/// ----------------|-----------------------------------------------------------
../lib/public/nuklear.h:1480:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1504:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1525:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1537:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1555:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1571:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1587:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1603:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1619:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1637:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1644:/// Returns the position and size of the currently visible and non-clipped space
../lib/public/nuklear.h:1655:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1663:/// Returns the upper left position of the currently visible and non-clipped
../lib/public/nuklear.h:1674:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1683:/// non-clipped space inside the currently processed window.
../lib/public/nuklear.h:1693:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1701:/// Returns the size of the currently visible and non-clipped space inside the
../lib/public/nuklear.h:1712:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1730:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1746:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1761:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1774:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1789:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1803:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1817:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1831:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1846:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1859:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1872:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1885:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1898:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1910:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1922:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1935:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1949:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:1962:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2021:///     widget_width = (window_width - padding - spacing) * (1/colum_count)
../lib/public/nuklear.h:2213:/// ----------------------------------------|------------------------------------
../lib/public/nuklear.h:2253:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2265:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2276:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2289:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2305:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2320:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2334:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2348:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2360:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2371:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2385:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2397:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2409:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2421:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2433:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2444:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2458:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2470:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2481:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2494:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2508:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2522:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2536:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2605:///     switch (cmd->type) {
../lib/public/nuklear.h:2621:/// --------------------------------|-------------------------------------------
../lib/public/nuklear.h:2624:/// nk_group_end                    | Ends a group. Should only be called if nk_group_begin returned non-zero
../lib/public/nuklear.h:2625:/// nk_group_scrolled_offset_begin  | Start a new group with manual separated handling of scrollbar x- and y-offset
../lib/public/nuklear.h:2627:/// nk_group_scrolled_end           | Ends a group with manual scrollbar handling. Should only be called if nk_group_begin returned non-zero
../lib/public/nuklear.h:2636:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2651:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2667:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2679:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2681:/// __x_offset__| Scrollbar x-offset to offset all widgets inside the group horizontally.
../lib/public/nuklear.h:2682:/// __y_offset__| Scrollbar y-offset to offset all widgets inside the group vertically
../lib/public/nuklear.h:2697:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2699:/// __off__     | Both x- and y- scroll offset. Allows for manual scrollbar control
../lib/public/nuklear.h:2713:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2768:/// ----------------------------|-------------------------------------------
../lib/public/nuklear.h:2783:/// ----------------|----------------------------------------
../lib/public/nuklear.h:2785:/// NK_TREE_TAB     | Non-highighted tree header closer to tree representations
../lib/public/nuklear.h:2800:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2816:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2834:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2859:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2878:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2897:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2917:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2928:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2944:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:2961:/// ------------|-----------------------------------------------------------
../lib/public/nuklear.h:3215:///     switch (cmd->type) {
../lib/public/nuklear.h:3232:/// --------------------|-------------------------------------------
../lib/public/nuklear.h:3252:/// --------------------|-----------------------------------------------------------
../lib/public/nuklear.h:3273:/// --------------------|-----------------------------------------------------------
../lib/public/nuklear.h:3294:/// --------------------|-----------------------------------------------------------
../lib/public/nuklear.h:3315:/// --------------------|-----------------------------------------------------------
../lib/public/nuklear.h:3338:/// --------------------|-----------------------------------------------------------
../lib/public/nuklear.h:3361:/// --------------------|-----------------------------------------------------------
../lib/public/nuklear.h:3625:/* color (conversion nuklear --> user) */
../lib/public/nuklear.h:3700: *                                  UTF-8
../lib/public/nuklear.h:3720:    --------------------------------------------------------------
../lib/public/nuklear.h:3747:    --------------------------------------------------------------
../lib/public/nuklear.h:3787:    ------------------------------------
../lib/public/nuklear.h:3837:        nk_init_default(&ctx, &font->handle);
../lib/public/nuklear.h:3892:    NK_COORD_UV, /* texture coordinates inside font glyphs are clamped between 0-1 */
../lib/public/nuklear.h:3927:    /* rasterize at hight quality for sub-pixel position */
../lib/public/nuklear.h:4025:/*  A basic (double)-buffer with linear allocation and resetting as only
../lib/public/nuklear.h:4308:            struct nk_input *input = &ctx->input;
../lib/public/nuklear.h:5447: *      nk_style_push_style_item(ctx, &ctx->style.button.normal, nk_style_item_color(nk_rgb(255,0,0)));
../lib/public/nuklear.h:5448: *      nk_style_push_style_item(ctx, &ctx->style.button.hover, nk_style_item_color(nk_rgb(255,0,0)));
../lib/public/nuklear.h:5449: *      nk_style_push_style_item(ctx, &ctx->style.button.active, nk_style_item_color(nk_rgb(255,0,0)));
../lib/public/nuklear.h:5450: *      nk_style_push_vec2(ctx, &cx->style.button.padding, nk_vec2(2,2));
../lib/public/nuklear.h:5624:#define NK_ABS(a) (((a) < 0) ? -(a) : (a))
../lib/public/nuklear.h:5633:#define nk_vec2_sub(a, b) nk_vec2((a).x - (b).x, (a).y - (b).y)
../lib/public/nuklear.h:5651:# define NK_PTR_TO_UINT(x) ((nk_size)(((char*)x)-(char*)0))
../lib/public/nuklear.h:5661:    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x) + (mask-1)) & ~(mask-1))))
../lib/public/nuklear.h:5663:    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x)) & ~(mask-1))))
../lib/public/nuklear.h:5665:#define NK_OFFSETOF(st,m) ((nk_ptr)&(((st*)0)->m))
../lib/public/nuklear.h:5667:    (type*)((void*)((char*)(1 ? (ptr): &((type*)0)->member) - NK_OFFSETOF(type, member)))
../lib/public/nuklear.h:5678:    diff = sizeof(Big) - sizeof(T), value = nk_helper<Big, diff>::value};};
../lib/public/nuklear.h:5683:#define NK_ALIGNOF(t) ((char*)(&((struct {char c; t _h;}*)0)->_h) - (char*)0)
../lib/public/nuklear.h:5743:#define NK_DEFAULT (-1)
../lib/public/nuklear.h:5761:#define NK_SCHAR_MIN (-127)
../lib/public/nuklear.h:5765:#define NK_SSHORT_MIN (-32767)
../lib/public/nuklear.h:5769:#define NK_SINT_MIN (-2147483647)
../lib/public/nuklear.h:5787:NK_GLOBAL const struct nk_rect nk_null_rect = {-8192.0f, -8192.0f, 16384, 16384};
../lib/public/nuklear.h:5886:/* page-element */
../lib/public/nuklear.h:5983:/* color-picker */
../lib/public/nuklear.h:6043:    ----
../lib/public/nuklear.h:6051:    -----------
../lib/public/nuklear.h:6057:    www.lolengine.net/blog/2011/12/21/better-function-approximations.
../lib/public/nuklear.h:6071:    conv.i = 0x5f375A84 - (conv.i >> 1);
../lib/public/nuklear.h:6072:    conv.f = conv.f * (threehalfs - (x2 * conv.f * conv.f));
../lib/public/nuklear.h:6083:    NK_STORAGE const float a0 = +1.91059300966915117e-31f;
../lib/public/nuklear.h:6085:    NK_STORAGE const float a2 = -1.21276126894734565e-2f;
../lib/public/nuklear.h:6086:    NK_STORAGE const float a3 = -1.38078780785773762e-1f;
../lib/public/nuklear.h:6087:    NK_STORAGE const float a4 = -2.67353392911981221e-2f;
../lib/public/nuklear.h:6088:    NK_STORAGE const float a5 = +2.08026600266304389e-2f;
../lib/public/nuklear.h:6089:    NK_STORAGE const float a6 = -3.03996055049204407e-3f;
../lib/public/nuklear.h:6090:    NK_STORAGE const float a7 = +1.38235642404333740e-4f;
../lib/public/nuklear.h:6097:    NK_STORAGE const float a1 = -3.81919947353040024e-2f;
../lib/public/nuklear.h:6098:    NK_STORAGE const float a2 = -3.94382342128062756e-1f;
../lib/public/nuklear.h:6099:    NK_STORAGE const float a3 = -1.18134036025221444e-1f;
../lib/public/nuklear.h:6100:    NK_STORAGE const float a4 = +1.07123798512170878e-1f;
../lib/public/nuklear.h:6101:    NK_STORAGE const float a5 = -1.86637164165180873e-2f;
../lib/public/nuklear.h:6102:    NK_STORAGE const float a6 = +9.90140908664079833e-4f;
../lib/public/nuklear.h:6103:    NK_STORAGE const float a7 = -5.23022132118824778e-14f;
../lib/public/nuklear.h:6109:    v--;
../lib/public/nuklear.h:6124:    n = (plus) ? n : -n;
../lib/public/nuklear.h:6136:    x = (double)((int)x - ((x < 0.0) ? 1 : 0));
../lib/public/nuklear.h:6142:    x = (float)((int)x - ((x < 0.0f) ? 1 : 0));
../lib/public/nuklear.h:6153:        float r = x - (float)t;
../lib/public/nuklear.h:6165:    ret = (neg) ? (int)-n : (int)n;
../lib/public/nuklear.h:6170:    if (neg) exp = -exp;
../lib/public/nuklear.h:6233:    res.w = r.w - 2 * amount;
../lib/public/nuklear.h:6234:    res.h = r.h - 2 * amount;
../lib/public/nuklear.h:6243:    r.w -= 2 * pad.x;
../lib/public/nuklear.h:6244:    r.h -= 2 * pad.y;
../lib/public/nuklear.h:6278:    clip->x = NK_MAX(a->x, x0);
../lib/public/nuklear.h:6279:    clip->y = NK_MAX(a->y, y0);
../lib/public/nuklear.h:6280:    clip->w = NK_MIN(a->x + a->w, x1) - clip->x;
../lib/public/nuklear.h:6281:    clip->h = NK_MIN(a->y + a->h, y1) - clip->y;
../lib/public/nuklear.h:6282:    clip->w = NK_MAX(0, clip->w);
../lib/public/nuklear.h:6283:    clip->h = NK_MAX(0, clip->h);
../lib/public/nuklear.h:6295:    r.w = r.w - 2 * pad_x;
../lib/public/nuklear.h:6296:    r.h = r.h - 2 * pad_y;
../lib/public/nuklear.h:6336:NK_LIB int nk_to_upper(int c) {return (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c;}
../lib/public/nuklear.h:6337:NK_LIB int nk_to_lower(int c) {return (c >= 'A' && c <= 'Z') ? (c - ('a' + 'A')) : c;}
../lib/public/nuklear.h:6350:    #define nk_wmask (nk_wsize-1)
../lib/public/nuklear.h:6352:    #define NK_TLOOP1(s) do { s; } while (--t)
../lib/public/nuklear.h:6360:                t = nk_wsize - (t & nk_wmask);
../lib/public/nuklear.h:6361:            length -= t;
../lib/public/nuklear.h:6378:            length -= t;
../lib/public/nuklear.h:6379:            NK_TLOOP1(*--dst = *--src);
../lib/public/nuklear.h:6382:        NK_TLOOP(src -= nk_wsize; dst -= nk_wsize;
../lib/public/nuklear.h:6385:        NK_TLOOP(*--dst = *--src);
../lib/public/nuklear.h:6400:    #define nk_wmask (nk_wsize - 1)
../lib/public/nuklear.h:6406:        c = (c << 8) | c; /* at least 16-bits  */
../lib/public/nuklear.h:6408:            c = (c << 16) | c; /* at least 32-bits*/
../lib/public/nuklear.h:6414:        while (size--) *dst++ = (nk_byte)c0;
../lib/public/nuklear.h:6420:        t = nk_wsize -t;
../lib/public/nuklear.h:6421:        size -= t;
../lib/public/nuklear.h:6424:        } while (--t != 0);
../lib/public/nuklear.h:6432:    } while (--t != 0);
../lib/public/nuklear.h:6439:        } while (--t != 0);
../lib/public/nuklear.h:6472:    if (*p == '-') {
../lib/public/nuklear.h:6473:        neg = -1;
../lib/public/nuklear.h:6477:        value = value * 10 + (int) (*p - '0');
../lib/public/nuklear.h:6498:    if (*p == '-') {
../lib/public/nuklear.h:6499:        neg = -1.0;
../lib/public/nuklear.h:6504:        value = value * 10.0 + (double) (*p - '0');
../lib/public/nuklear.h:6511:            value = value + (double) (*p - '0') * m;
../lib/public/nuklear.h:6518:        if (*p == '-') {
../lib/public/nuklear.h:6527:            pow = pow * 10 + (int) (*p - '0');
../lib/public/nuklear.h:6557:        d = c1 - c2;
../lib/public/nuklear.h:6560:                d += ('a' - 'A');
../lib/public/nuklear.h:6564:                d -= ('a' - 'A');
../lib/public/nuklear.h:6567:            return ((d >= 0) << 1) - 1;
../lib/public/nuklear.h:6580:        if (!n--) return 0;
../lib/public/nuklear.h:6582:        d = c1 - c2;
../lib/public/nuklear.h:6585:                d += ('a' - 'A');
../lib/public/nuklear.h:6589:                d -= ('a' - 'A');
../lib/public/nuklear.h:6592:            return ((d >= 0) << 1) - 1;
../lib/public/nuklear.h:6651:    #define NK_LEADING_LETTER_PENALTY (-3)
../lib/public/nuklear.h:6653:    #define NK_MAX_LEADING_LETTER_PENALTY (-9)
../lib/public/nuklear.h:6655:    #define NK_UNMATCHED_LETTER_PENALTY (-1)
../lib/public/nuklear.h:6699:                int count = (int)(&str[str_iter] - str);
../lib/public/nuklear.h:6780:    return (int)(c - string);
../lib/public/nuklear.h:6791:        s[i] = s[len - 1 - i];
../lib/public/nuklear.h:6792:        s[len -1 - i] = t;
../lib/public/nuklear.h:6805:        s[i++] = '-';
../lib/public/nuklear.h:6806:        n = -n;
../lib/public/nuklear.h:6813:    if (s[0] == '-')
../lib/public/nuklear.h:6836:    if (neg) n = -n;
../lib/public/nuklear.h:6840:    useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
../lib/public/nuklear.h:6841:    if (neg) *(c++) = '-';
../lib/public/nuklear.h:6846:           m -= 1;
../lib/public/nuklear.h:6861:            n -= ((double)digit * weight);
../lib/public/nuklear.h:6866:        m--;
../lib/public/nuklear.h:6876:            *(c++) = '-';
../lib/public/nuklear.h:6877:            m1 = -m1;
../lib/public/nuklear.h:6885:        c -= m;
../lib/public/nuklear.h:6886:        for (i = 0, j = m-1; i<j; i++, j--) {
../lib/public/nuklear.h:6923:    int result = -1;
../lib/public/nuklear.h:6930:        /* copy all non-format characters */
../lib/public/nuklear.h:6938:            if (*iter == '-') flag |= NK_ARG_FLAG_LEFT;
../lib/public/nuklear.h:6953:                width = -1;
../lib/public/nuklear.h:6971:                    precision = -1;
../lib/public/nuklear.h:7002:            if (str == buf) return -1;
../lib/public/nuklear.h:7034:            padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);
../lib/public/nuklear.h:7036:                padding = NK_MAX(padding-1, 0);
../lib/public/nuklear.h:7040:                while (padding-- > 0 && (len < buf_size)) {
../lib/public/nuklear.h:7057:                num_print--;
../lib/public/nuklear.h:7067:                while ((padding-- > 0) && (len < buf_size))
../lib/public/nuklear.h:7102:            padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);
../lib/public/nuklear.h:7104:                padding = NK_MAX(padding-1, 0);
../lib/public/nuklear.h:7108:                while ((padding-- > 0) && (len < buf_size)) {
../lib/public/nuklear.h:7129:                num_print--;
../lib/public/nuklear.h:7135:                    buf[len++] = number_buffer[num_len-1];
../lib/public/nuklear.h:7136:                num_len--;
../lib/public/nuklear.h:7141:                while ((padding-- > 0) && (len < buf_size))
../lib/public/nuklear.h:7162:            prefix = (*num_iter == '.')?(int)(num_iter - number_buffer)+1:0;
../lib/public/nuklear.h:7163:            padding = NK_MAX(cur_width - (prefix + NK_MIN(cur_precision, num_len - prefix)) , 0);
../lib/public/nuklear.h:7165:                padding = NK_MAX(padding-1, 0);
../lib/public/nuklear.h:7169:                while (padding-- > 0 && (len < buf_size)) {
../lib/public/nuklear.h:7204:                while ((padding-- > 0) && (len < buf_size))
../lib/public/nuklear.h:7213:    buf[(len >= buf_size)?(buf_size-1):len] = 0;
../lib/public/nuklear.h:7214:    result = (len >= buf_size)?-1:len;
../lib/public/nuklear.h:7221:    int result = -1;
../lib/public/nuklear.h:7227:    result = (result >= buf_size) ? -1: result;
../lib/public/nuklear.h:7228:    buf[buf_size-1] = 0;
../lib/public/nuklear.h:7238:    /* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/
../lib/public/nuklear.h:7239:    #define NK_ROTL(x,r) ((x) << (r) | ((x) >> (32 - r)))
../lib/public/nuklear.h:7323:    buf = (char*)alloc->alloc(alloc->userdata,0, *siz);
../lib/public/nuklear.h:7356:        s = font->width(font->userdata, font->height, text, len);
../lib/public/nuklear.h:7369:        glyph_len = nk_utf_decode(&text[len], &unicode, text_len - len);
../lib/public/nuklear.h:7400:    glyph_width = font->width(font->userdata, font->height, begin, glyph_len);
../lib/public/nuklear.h:7413:            glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len-text_len);
../lib/public/nuklear.h:7420:            glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len-text_len);
../lib/public/nuklear.h:7427:        glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len-text_len);
../lib/public/nuklear.h:7428:        glyph_width = font->width(font->userdata, font->height, begin+text_len, glyph_len);
../lib/public/nuklear.h:7460:            i += ((p[len] - 'a') + 10);
../lib/public/nuklear.h:7462:            i += ((p[len] - 'A') + 10);
../lib/public/nuklear.h:7463:        else i += (p[len] - '0');
../lib/public/nuklear.h:7505:    #define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))
../lib/public/nuklear.h:7520:    #define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))
../lib/public/nuklear.h:7666:    f = h - (float)i;
../lib/public/nuklear.h:7667:    p = v * (1.0f - s);
../lib/public/nuklear.h:7668:    q = v * (1.0f - (s * f));
../lib/public/nuklear.h:7669:    t = v * (1.0f - s * (1.0f - f));
../lib/public/nuklear.h:7761:        K = -1.f;
../lib/public/nuklear.h:7765:        K = -2.f/6.0f - K;
../lib/public/nuklear.h:7767:    chroma = in.r - ((in.g < in.b) ? in.g: in.b);
../lib/public/nuklear.h:7768:    *out_h = NK_ABS(K + (in.g - in.b)/(6.0f * chroma + 1e-20f));
../lib/public/nuklear.h:7769:    *out_s = chroma / (in.r + 1e-20f);
../lib/public/nuklear.h:7864: *                              UTF-8
../lib/public/nuklear.h:7935:    for (i = len - 1; i != 0; --i) {
../lib/public/nuklear.h:7961:        glyph_len = nk_utf_decode(text + src_len, &unicode, text_len - src_len);
../lib/public/nuklear.h:7997:        glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
../lib/public/nuklear.h:8047:    b->type = NK_BUFFER_DYNAMIC;
../lib/public/nuklear.h:8048:    b->memory.ptr = a->alloc(a->userdata,0, initial_size);
../lib/public/nuklear.h:8049:    b->memory.size = initial_size;
../lib/public/nuklear.h:8050:    b->size = initial_size;
../lib/public/nuklear.h:8051:    b->grow_factor = 2.0f;
../lib/public/nuklear.h:8052:    b->pool = *a;
../lib/public/nuklear.h:8063:    b->type = NK_BUFFER_FIXED;
../lib/public/nuklear.h:8064:    b->memory.ptr = m;
../lib/public/nuklear.h:8065:    b->memory.size = size;
../lib/public/nuklear.h:8066:    b->size = size;
../lib/public/nuklear.h:8080:            *alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
../lib/public/nuklear.h:8089:            *alignment = (nk_size)((nk_byte*)unaligned - (nk_byte*)memory);
../lib/public/nuklear.h:8106:    if (!b || !size || !b->pool.alloc || !b->pool.free)
../lib/public/nuklear.h:8109:    buffer_size = b->memory.size;
../lib/public/nuklear.h:8110:    temp = b->pool.alloc(b->pool.userdata, b->memory.ptr, capacity);
../lib/public/nuklear.h:8115:    if (temp != b->memory.ptr) {
../lib/public/nuklear.h:8116:        NK_MEMCPY(temp, b->memory.ptr, buffer_size);
../lib/public/nuklear.h:8117:        b->pool.free(b->pool.userdata, b->memory.ptr);
../lib/public/nuklear.h:8120:    if (b->size == buffer_size) {
../lib/public/nuklear.h:8122:        b->size = capacity;
../lib/public/nuklear.h:8128:        back_size = buffer_size - b->size;
../lib/public/nuklear.h:8129:        dst = nk_ptr_add(void, temp, capacity - back_size);
../lib/public/nuklear.h:8130:        src = nk_ptr_add(void, temp, b->size);
../lib/public/nuklear.h:8132:        b->size = capacity - back_size;
../lib/public/nuklear.h:8148:    b->needed += size;
../lib/public/nuklear.h:8152:        unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
../lib/public/nuklear.h:8153:    else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
../lib/public/nuklear.h:8158:        full = ((b->allocated + size + alignment) > b->size);
../lib/public/nuklear.h:8159:    else full = ((b->size - NK_MIN(b->size,(size + alignment))) <= b->allocated);
../lib/public/nuklear.h:8163:        if (b->type != NK_BUFFER_DYNAMIC)
../lib/public/nuklear.h:8165:        NK_ASSERT(b->pool.alloc && b->pool.free);
../lib/public/nuklear.h:8166:        if (b->type != NK_BUFFER_DYNAMIC || !b->pool.alloc || !b->pool.free)
../lib/public/nuklear.h:8170:        capacity = (nk_size)((float)b->memory.size * b->grow_factor);
../lib/public/nuklear.h:8171:        capacity = NK_MAX(capacity, nk_round_up_pow2((nk_uint)(b->allocated + size)));
../lib/public/nuklear.h:8172:        b->memory.ptr = nk_buffer_realloc(b, capacity, &b->memory.size);
../lib/public/nuklear.h:8173:        if (!b->memory.ptr) return 0;
../lib/public/nuklear.h:8177:            unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
../lib/public/nuklear.h:8178:        else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
../lib/public/nuklear.h:8182:        b->allocated += size + alignment;
../lib/public/nuklear.h:8183:    else b->size -= (size + alignment);
../lib/public/nuklear.h:8184:    b->needed += alignment;
../lib/public/nuklear.h:8185:    b->calls++;
../lib/public/nuklear.h:8201:    buffer->marker[type].active = nk_true;
../lib/public/nuklear.h:8203:        buffer->marker[type].offset = buffer->size;
../lib/public/nuklear.h:8204:    else buffer->marker[type].offset = buffer->allocated;
../lib/public/nuklear.h:8213:        buffer->needed -= (buffer->memory.size - buffer->marker[type].offset);
../lib/public/nuklear.h:8214:        if (buffer->marker[type].active)
../lib/public/nuklear.h:8215:            buffer->size = buffer->marker[type].offset;
../lib/public/nuklear.h:8216:        else buffer->size = buffer->memory.size;
../lib/public/nuklear.h:8217:        buffer->marker[type].active = nk_false;
../lib/public/nuklear.h:8220:        buffer->needed -= (buffer->allocated - buffer->marker[type].offset);
../lib/public/nuklear.h:8221:        if (buffer->marker[type].active)
../lib/public/nuklear.h:8222:            buffer->allocated = buffer->marker[type].offset;
../lib/public/nuklear.h:8223:        else buffer->allocated = 0;
../lib/public/nuklear.h:8224:        buffer->marker[type].active = nk_false;
../lib/public/nuklear.h:8232:    b->allocated = 0;
../lib/public/nuklear.h:8233:    b->size = b->memory.size;
../lib/public/nuklear.h:8234:    b->calls = 0;
../lib/public/nuklear.h:8235:    b->needed = 0;
../lib/public/nuklear.h:8241:    if (!b || !b->memory.ptr) return;
../lib/public/nuklear.h:8242:    if (b->type == NK_BUFFER_FIXED) return;
../lib/public/nuklear.h:8243:    if (!b->pool.free) return;
../lib/public/nuklear.h:8244:    NK_ASSERT(b->pool.free);
../lib/public/nuklear.h:8245:    b->pool.free(b->pool.userdata, b->memory.ptr);
../lib/public/nuklear.h:8253:    s->allocated = b->allocated;
../lib/public/nuklear.h:8254:    s->size =  b->memory.size;
../lib/public/nuklear.h:8255:    s->needed = b->needed;
../lib/public/nuklear.h:8256:    s->memory = b->memory.ptr;
../lib/public/nuklear.h:8257:    s->calls = b->calls;
../lib/public/nuklear.h:8264:    return buffer->memory.ptr;
../lib/public/nuklear.h:8271:    return buffer->memory.ptr;
../lib/public/nuklear.h:8278:    return buffer->memory.size;
../lib/public/nuklear.h:8298:    nk_buffer_init(&str->buffer, &alloc, 32);
../lib/public/nuklear.h:8299:    str->len = 0;
../lib/public/nuklear.h:8306:    nk_buffer_init(&str->buffer, alloc, size);
../lib/public/nuklear.h:8307:    str->len = 0;
../lib/public/nuklear.h:8312:    nk_buffer_init_fixed(&str->buffer, memory, size);
../lib/public/nuklear.h:8313:    str->len = 0;
../lib/public/nuklear.h:8322:    mem = (char*)nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);
../lib/public/nuklear.h:8325:    s->len += nk_utf_len(str, len);
../lib/public/nuklear.h:8407:    if (!s || !str || !len || (nk_size)pos > s->buffer.allocated) return 0;
../lib/public/nuklear.h:8408:    if ((s->buffer.allocated + (nk_size)len >= s->buffer.memory.size) &&
../lib/public/nuklear.h:8409:        (s->buffer.type == NK_BUFFER_FIXED)) return 0;
../lib/public/nuklear.h:8411:    copylen = (int)s->buffer.allocated - pos;
../lib/public/nuklear.h:8416:    mem = nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);
../lib/public/nuklear.h:8420:    NK_ASSERT(((int)pos + (int)len + ((int)copylen - 1)) >= 0);
../lib/public/nuklear.h:8421:    NK_ASSERT(((int)pos + ((int)copylen - 1)) >= 0);
../lib/public/nuklear.h:8422:    dst = nk_ptr_add(char, s->buffer.memory.ptr, pos + len + (copylen - 1));
../lib/public/nuklear.h:8423:    src = nk_ptr_add(char, s->buffer.memory.ptr, pos + (copylen-1));
../lib/public/nuklear.h:8424:    for (i = 0; i < copylen; ++i) *dst-- = *src--;
../lib/public/nuklear.h:8425:    mem = nk_ptr_add(void, s->buffer.memory.ptr, pos);
../lib/public/nuklear.h:8427:    s->len = nk_utf_len((char *)s->buffer.memory.ptr, (int)s->buffer.allocated);
../lib/public/nuklear.h:8443:    if (!str->len)
../lib/public/nuklear.h:8447:    return nk_str_insert_at_char(str, (int)(begin - buffer), cstr, len);
../lib/public/nuklear.h:8529:    if (!s || len < 0 || (nk_size)len > s->buffer.allocated) return;
../lib/public/nuklear.h:8530:    NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);
../lib/public/nuklear.h:8531:    s->buffer.allocated -= (nk_size)len;
../lib/public/nuklear.h:8532:    s->len = nk_utf_len((char *)s->buffer.memory.ptr, (int)s->buffer.allocated);
../lib/public/nuklear.h:8545:    if (len >= str->len) {
../lib/public/nuklear.h:8546:        str->len = 0;
../lib/public/nuklear.h:8550:    index = str->len - len;
../lib/public/nuklear.h:8552:    end = (const char*)str->buffer.memory.ptr + str->buffer.allocated;
../lib/public/nuklear.h:8553:    nk_str_remove_chars(str, (int)(end-begin)+1);
../lib/public/nuklear.h:8559:    if (!s || !len || (nk_size)pos > s->buffer.allocated ||
../lib/public/nuklear.h:8560:        (nk_size)(pos + len) > s->buffer.allocated) return;
../lib/public/nuklear.h:8562:    if ((nk_size)(pos + len) < s->buffer.allocated) {
../lib/public/nuklear.h:8564:        char *dst = nk_ptr_add(char, s->buffer.memory.ptr, pos);
../lib/public/nuklear.h:8565:        char *src = nk_ptr_add(char, s->buffer.memory.ptr, pos + len);
../lib/public/nuklear.h:8566:        NK_MEMCPY(dst, src, s->buffer.allocated - (nk_size)(pos + len));
../lib/public/nuklear.h:8567:        NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);
../lib/public/nuklear.h:8568:        s->buffer.allocated -= (nk_size)len;
../lib/public/nuklear.h:8570:    s->len = nk_utf_len((char *)s->buffer.memory.ptr, (int)s->buffer.allocated);
../lib/public/nuklear.h:8582:    NK_ASSERT(s->len >= pos + len);
../lib/public/nuklear.h:8583:    if (s->len < pos + len)
../lib/public/nuklear.h:8584:        len = NK_CLAMP(0, (s->len - pos), s->len);
../lib/public/nuklear.h:8587:    temp = (char *)s->buffer.memory.ptr;
../lib/public/nuklear.h:8590:    s->buffer.memory.ptr = begin;
../lib/public/nuklear.h:8592:    s->buffer.memory.ptr = temp;
../lib/public/nuklear.h:8594:    nk_str_delete_chars(s, (int)(begin - temp), (int)(end - begin));
../lib/public/nuklear.h:8600:    if (!s || pos > (int)s->buffer.allocated) return 0;
../lib/public/nuklear.h:8601:    return nk_ptr_add(char, s->buffer.memory.ptr, pos);
../lib/public/nuklear.h:8623:    text = (char*)str->buffer.memory.ptr;
../lib/public/nuklear.h:8624:    text_len = (int)str->buffer.allocated;
../lib/public/nuklear.h:8634:        glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
../lib/public/nuklear.h:8643:    if (!s || pos > (int)s->buffer.allocated) return 0;
../lib/public/nuklear.h:8644:    return nk_ptr_add(char, s->buffer.memory.ptr, pos);
../lib/public/nuklear.h:8666:    text = (char*)str->buffer.memory.ptr;
../lib/public/nuklear.h:8667:    text_len = (int)str->buffer.allocated;
../lib/public/nuklear.h:8677:        glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
../lib/public/nuklear.h:8694:    if (!s || !s->len || !s->buffer.allocated) return 0;
../lib/public/nuklear.h:8695:    return (char*)s->buffer.memory.ptr;
../lib/public/nuklear.h:8701:    if (!s || !s->len || !s->buffer.allocated) return 0;
../lib/public/nuklear.h:8702:    return (const char*)s->buffer.memory.ptr;
../lib/public/nuklear.h:8708:    if (!s || !s->len || !s->buffer.allocated) return 0;
../lib/public/nuklear.h:8709:    return s->len;
../lib/public/nuklear.h:8715:    if (!s || !s->len || !s->buffer.allocated) return 0;
../lib/public/nuklear.h:8716:    return (int)s->buffer.allocated;
../lib/public/nuklear.h:8722:    nk_buffer_clear(&str->buffer);
../lib/public/nuklear.h:8723:    str->len = 0;
../lib/public/nuklear.h:8729:    nk_buffer_free(&str->buffer);
../lib/public/nuklear.h:8730:    str->len = 0;
../lib/public/nuklear.h:8749:    cb->base = b;
../lib/public/nuklear.h:8750:    cb->use_clipping = (int)clip;
../lib/public/nuklear.h:8751:    cb->begin = b->allocated;
../lib/public/nuklear.h:8752:    cb->end = b->allocated;
../lib/public/nuklear.h:8753:    cb->last = b->allocated;
../lib/public/nuklear.h:8760:    b->begin = 0;
../lib/public/nuklear.h:8761:    b->end = 0;
../lib/public/nuklear.h:8762:    b->last = 0;
../lib/public/nuklear.h:8763:    b->clip = nk_null_rect;
../lib/public/nuklear.h:8765:    b->userdata.ptr = 0;
../lib/public/nuklear.h:8779:    NK_ASSERT(b->base);
../lib/public/nuklear.h:8781:    cmd = (struct nk_command*)nk_buffer_alloc(b->base,NK_BUFFER_FRONT,size,align);
../lib/public/nuklear.h:8785:    b->last = (nk_size)((nk_byte*)cmd - (nk_byte*)b->base->memory.ptr);
../lib/public/nuklear.h:8788:    alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
../lib/public/nuklear.h:8793:    cmd->type = t;
../lib/public/nuklear.h:8794:    cmd->next = b->base->allocated + alignment;
../lib/public/nuklear.h:8796:    cmd->userdata = b->userdata;
../lib/public/nuklear.h:8798:    b->end = cmd->next;
../lib/public/nuklear.h:8808:    b->clip.x = r.x;
../lib/public/nuklear.h:8809:    b->clip.y = r.y;
../lib/public/nuklear.h:8810:    b->clip.w = r.w;
../lib/public/nuklear.h:8811:    b->clip.h = r.h;
../lib/public/nuklear.h:8816:    cmd->x = (short)r.x;
../lib/public/nuklear.h:8817:    cmd->y = (short)r.y;
../lib/public/nuklear.h:8818:    cmd->w = (unsigned short)NK_MAX(0, r.w);
../lib/public/nuklear.h:8819:    cmd->h = (unsigned short)NK_MAX(0, r.h);
../lib/public/nuklear.h:8831:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:8832:    cmd->begin.x = (short)x0;
../lib/public/nuklear.h:8833:    cmd->begin.y = (short)y0;
../lib/public/nuklear.h:8834:    cmd->end.x = (short)x1;
../lib/public/nuklear.h:8835:    cmd->end.y = (short)y1;
../lib/public/nuklear.h:8836:    cmd->color = c;
../lib/public/nuklear.h:8850:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:8851:    cmd->begin.x = (short)ax;
../lib/public/nuklear.h:8852:    cmd->begin.y = (short)ay;
../lib/public/nuklear.h:8853:    cmd->ctrl[0].x = (short)ctrl0x;
../lib/public/nuklear.h:8854:    cmd->ctrl[0].y = (short)ctrl0y;
../lib/public/nuklear.h:8855:    cmd->ctrl[1].x = (short)ctrl1x;
../lib/public/nuklear.h:8856:    cmd->ctrl[1].y = (short)ctrl1y;
../lib/public/nuklear.h:8857:    cmd->end.x = (short)bx;
../lib/public/nuklear.h:8858:    cmd->end.y = (short)by;
../lib/public/nuklear.h:8859:    cmd->color = col;
../lib/public/nuklear.h:8868:    if (b->use_clipping) {
../lib/public/nuklear.h:8869:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:8871:            clip->x, clip->y, clip->w, clip->h)) return;
../lib/public/nuklear.h:8876:    cmd->rounding = (unsigned short)rounding;
../lib/public/nuklear.h:8877:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:8878:    cmd->x = (short)rect.x;
../lib/public/nuklear.h:8879:    cmd->y = (short)rect.y;
../lib/public/nuklear.h:8880:    cmd->w = (unsigned short)NK_MAX(0, rect.w);
../lib/public/nuklear.h:8881:    cmd->h = (unsigned short)NK_MAX(0, rect.h);
../lib/public/nuklear.h:8882:    cmd->color = c;
../lib/public/nuklear.h:8891:    if (b->use_clipping) {
../lib/public/nuklear.h:8892:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:8894:            clip->x, clip->y, clip->w, clip->h)) return;
../lib/public/nuklear.h:8900:    cmd->rounding = (unsigned short)rounding;
../lib/public/nuklear.h:8901:    cmd->x = (short)rect.x;
../lib/public/nuklear.h:8902:    cmd->y = (short)rect.y;
../lib/public/nuklear.h:8903:    cmd->w = (unsigned short)NK_MAX(0, rect.w);
../lib/public/nuklear.h:8904:    cmd->h = (unsigned short)NK_MAX(0, rect.h);
../lib/public/nuklear.h:8905:    cmd->color = c;
../lib/public/nuklear.h:8915:    if (b->use_clipping) {
../lib/public/nuklear.h:8916:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:8918:            clip->x, clip->y, clip->w, clip->h)) return;
../lib/public/nuklear.h:8924:    cmd->x = (short)rect.x;
../lib/public/nuklear.h:8925:    cmd->y = (short)rect.y;
../lib/public/nuklear.h:8926:    cmd->w = (unsigned short)NK_MAX(0, rect.w);
../lib/public/nuklear.h:8927:    cmd->h = (unsigned short)NK_MAX(0, rect.h);
../lib/public/nuklear.h:8928:    cmd->left = left;
../lib/public/nuklear.h:8929:    cmd->top = top;
../lib/public/nuklear.h:8930:    cmd->right = right;
../lib/public/nuklear.h:8931:    cmd->bottom = bottom;
../lib/public/nuklear.h:8939:    if (b->use_clipping) {
../lib/public/nuklear.h:8940:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:8941:        if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
../lib/public/nuklear.h:8948:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:8949:    cmd->x = (short)r.x;
../lib/public/nuklear.h:8950:    cmd->y = (short)r.y;
../lib/public/nuklear.h:8951:    cmd->w = (unsigned short)NK_MAX(r.w, 0);
../lib/public/nuklear.h:8952:    cmd->h = (unsigned short)NK_MAX(r.h, 0);
../lib/public/nuklear.h:8953:    cmd->color = c;
../lib/public/nuklear.h:8961:    if (b->use_clipping) {
../lib/public/nuklear.h:8962:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:8963:        if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
../lib/public/nuklear.h:8970:    cmd->x = (short)r.x;
../lib/public/nuklear.h:8971:    cmd->y = (short)r.y;
../lib/public/nuklear.h:8972:    cmd->w = (unsigned short)NK_MAX(r.w, 0);
../lib/public/nuklear.h:8973:    cmd->h = (unsigned short)NK_MAX(r.h, 0);
../lib/public/nuklear.h:8974:    cmd->color = c;
../lib/public/nuklear.h:8985:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:8986:    cmd->cx = (short)cx;
../lib/public/nuklear.h:8987:    cmd->cy = (short)cy;
../lib/public/nuklear.h:8988:    cmd->r = (unsigned short)radius;
../lib/public/nuklear.h:8989:    cmd->a[0] = a_min;
../lib/public/nuklear.h:8990:    cmd->a[1] = a_max;
../lib/public/nuklear.h:8991:    cmd->color = c;
../lib/public/nuklear.h:9003:    cmd->cx = (short)cx;
../lib/public/nuklear.h:9004:    cmd->cy = (short)cy;
../lib/public/nuklear.h:9005:    cmd->r = (unsigned short)radius;
../lib/public/nuklear.h:9006:    cmd->a[0] = a_min;
../lib/public/nuklear.h:9007:    cmd->a[1] = a_max;
../lib/public/nuklear.h:9008:    cmd->color = c;
../lib/public/nuklear.h:9017:    if (b->use_clipping) {
../lib/public/nuklear.h:9018:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:9019:        if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
../lib/public/nuklear.h:9020:            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
../lib/public/nuklear.h:9021:            !NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
../lib/public/nuklear.h:9028:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:9029:    cmd->a.x = (short)x0;
../lib/public/nuklear.h:9030:    cmd->a.y = (short)y0;
../lib/public/nuklear.h:9031:    cmd->b.x = (short)x1;
../lib/public/nuklear.h:9032:    cmd->b.y = (short)y1;
../lib/public/nuklear.h:9033:    cmd->c.x = (short)x2;
../lib/public/nuklear.h:9034:    cmd->c.y = (short)y2;
../lib/public/nuklear.h:9035:    cmd->color = c;
../lib/public/nuklear.h:9045:    if (b->use_clipping) {
../lib/public/nuklear.h:9046:        const struct nk_rect *clip = &b->clip;
../lib/public/nuklear.h:9047:        if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
../lib/public/nuklear.h:9048:            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
../lib/public/nuklear.h:9049:            !NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
../lib/public/nuklear.h:9056:    cmd->a.x = (short)x0;
../lib/public/nuklear.h:9057:    cmd->a.y = (short)y0;
../lib/public/nuklear.h:9058:    cmd->b.x = (short)x1;
../lib/public/nuklear.h:9059:    cmd->b.y = (short)y1;
../lib/public/nuklear.h:9060:    cmd->c.x = (short)x2;
../lib/public/nuklear.h:9061:    cmd->c.y = (short)y2;
../lib/public/nuklear.h:9062:    cmd->color = c;
../lib/public/nuklear.h:9077:    cmd->color = col;
../lib/public/nuklear.h:9078:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:9079:    cmd->point_count = (unsigned short)point_count;
../lib/public/nuklear.h:9081:        cmd->points[i].x = (short)points[i*2];
../lib/public/nuklear.h:9082:        cmd->points[i].y = (short)points[i*2+1];
../lib/public/nuklear.h:9099:    cmd->color = col;
../lib/public/nuklear.h:9100:    cmd->point_count = (unsigned short)point_count;
../lib/public/nuklear.h:9102:        cmd->points[i].x = (short)points[i*2+0];
../lib/public/nuklear.h:9103:        cmd->points[i].y = (short)points[i*2+1];
../lib/public/nuklear.h:9119:    cmd->color = col;
../lib/public/nuklear.h:9120:    cmd->point_count = (unsigned short)point_count;
../lib/public/nuklear.h:9121:    cmd->line_thickness = (unsigned short)line_thickness;
../lib/public/nuklear.h:9123:        cmd->points[i].x = (short)points[i*2];
../lib/public/nuklear.h:9124:        cmd->points[i].y = (short)points[i*2+1];
../lib/public/nuklear.h:9134:    if (b->use_clipping) {
../lib/public/nuklear.h:9135:        const struct nk_rect *c = &b->clip;
../lib/public/nuklear.h:9136:        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
../lib/public/nuklear.h:9143:    cmd->x = (short)r.x;
../lib/public/nuklear.h:9144:    cmd->y = (short)r.y;
../lib/public/nuklear.h:9145:    cmd->w = (unsigned short)NK_MAX(0, r.w);
../lib/public/nuklear.h:9146:    cmd->h = (unsigned short)NK_MAX(0, r.h);
../lib/public/nuklear.h:9147:    cmd->img = *img;
../lib/public/nuklear.h:9148:    cmd->col = col;
../lib/public/nuklear.h:9157:    if (b->use_clipping) {
../lib/public/nuklear.h:9158:        const struct nk_rect *c = &b->clip;
../lib/public/nuklear.h:9159:        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
../lib/public/nuklear.h:9166:    cmd->x = (short)r.x;
../lib/public/nuklear.h:9167:    cmd->y = (short)r.y;
../lib/public/nuklear.h:9168:    cmd->w = (unsigned short)NK_MAX(0, r.w);
../lib/public/nuklear.h:9169:    cmd->h = (unsigned short)NK_MAX(0, r.h);
../lib/public/nuklear.h:9170:    cmd->callback_data = usr;
../lib/public/nuklear.h:9171:    cmd->callback = cb;
../lib/public/nuklear.h:9184:    if (b->use_clipping) {
../lib/public/nuklear.h:9185:        const struct nk_rect *c = &b->clip;
../lib/public/nuklear.h:9186:        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
../lib/public/nuklear.h:9191:    text_width = font->width(font->userdata, font->height, string, length);
../lib/public/nuklear.h:9202:    cmd->x = (short)r.x;
../lib/public/nuklear.h:9203:    cmd->y = (short)r.y;
../lib/public/nuklear.h:9204:    cmd->w = (unsigned short)r.w;
../lib/public/nuklear.h:9205:    cmd->h = (unsigned short)r.h;
../lib/public/nuklear.h:9206:    cmd->background = bg;
../lib/public/nuklear.h:9207:    cmd->foreground = fg;
../lib/public/nuklear.h:9208:    cmd->font = font;
../lib/public/nuklear.h:9209:    cmd->length = length;
../lib/public/nuklear.h:9210:    cmd->height = font->height;
../lib/public/nuklear.h:9211:    NK_MEMCPY(cmd->string, string, (nk_size)length);
../lib/public/nuklear.h:9212:    cmd->string[length] = '\0';
../lib/public/nuklear.h:9232:    for (i = 0; i < NK_LEN(list->circle_vtx); ++i) {
../lib/public/nuklear.h:9233:        const float a = ((float)i / (float)NK_LEN(list->circle_vtx)) * 2 * NK_PI;
../lib/public/nuklear.h:9234:        list->circle_vtx[i].x = (float)NK_COS(a);
../lib/public/nuklear.h:9235:        list->circle_vtx[i].y = (float)NK_SIN(a);
../lib/public/nuklear.h:9251:    canvas->buffer = cmds;
../lib/public/nuklear.h:9252:    canvas->config = *config;
../lib/public/nuklear.h:9253:    canvas->elements = elements;
../lib/public/nuklear.h:9254:    canvas->vertices = vertices;
../lib/public/nuklear.h:9255:    canvas->line_AA = line_aa;
../lib/public/nuklear.h:9256:    canvas->shape_AA = shape_aa;
../lib/public/nuklear.h:9257:    canvas->clip_rect = nk_null_rect;
../lib/public/nuklear.h:9259:    canvas->cmd_offset = 0;
../lib/public/nuklear.h:9260:    canvas->element_count = 0;
../lib/public/nuklear.h:9261:    canvas->vertex_count = 0;
../lib/public/nuklear.h:9262:    canvas->cmd_offset = 0;
../lib/public/nuklear.h:9263:    canvas->cmd_count = 0;
../lib/public/nuklear.h:9264:    canvas->path_count = 0;
../lib/public/nuklear.h:9274:    if (!buffer || !buffer->size || !canvas->cmd_count)
../lib/public/nuklear.h:9277:    memory = (nk_byte*)buffer->memory.ptr;
../lib/public/nuklear.h:9278:    offset = buffer->memory.size - canvas->cmd_offset;
../lib/public/nuklear.h:9295:    memory = (nk_byte*)buffer->memory.ptr;
../lib/public/nuklear.h:9296:    size = buffer->memory.size;
../lib/public/nuklear.h:9297:    offset = size - canvas->cmd_offset;
../lib/public/nuklear.h:9299:    end -= (canvas->cmd_count-1);
../lib/public/nuklear.h:9314:    return (cmd-1);
../lib/public/nuklear.h:9323:        nk_buffer_alloc(list->buffer, NK_BUFFER_FRONT,
../lib/public/nuklear.h:9327:    if (!list->path_offset) {
../lib/public/nuklear.h:9328:        void *memory = nk_buffer_memory(list->buffer);
../lib/public/nuklear.h:9329:        list->path_offset = (unsigned int)((nk_byte*)points - (nk_byte*)memory);
../lib/public/nuklear.h:9331:    list->path_count += (unsigned int)count;
../lib/public/nuklear.h:9339:    NK_ASSERT(list->path_count);
../lib/public/nuklear.h:9340:    memory = nk_buffer_memory(list->buffer);
../lib/public/nuklear.h:9341:    point = nk_ptr_add(struct nk_vec2, memory, list->path_offset);
../lib/public/nuklear.h:9342:    point += (list->path_count-1);
../lib/public/nuklear.h:9355:        nk_buffer_alloc(list->buffer, NK_BUFFER_BACK, cmd_size, cmd_align);
../lib/public/nuklear.h:9358:    if (!list->cmd_count) {
../lib/public/nuklear.h:9359:        nk_byte *memory = (nk_byte*)nk_buffer_memory(list->buffer);
../lib/public/nuklear.h:9360:        nk_size total = nk_buffer_total(list->buffer);
../lib/public/nuklear.h:9362:        list->cmd_offset = (nk_size)(memory - (nk_byte*)cmd);
../lib/public/nuklear.h:9365:    cmd->elem_count = 0;
../lib/public/nuklear.h:9366:    cmd->clip_rect = clip;
../lib/public/nuklear.h:9367:    cmd->texture = texture;
../lib/public/nuklear.h:9369:    cmd->userdata = list->userdata;
../lib/public/nuklear.h:9372:    list->cmd_count++;
../lib/public/nuklear.h:9373:    list->clip_rect = clip;
../lib/public/nuklear.h:9382:    NK_ASSERT(list->cmd_count);
../lib/public/nuklear.h:9384:    memory = nk_buffer_memory(list->buffer);
../lib/public/nuklear.h:9385:    size = nk_buffer_total(list->buffer);
../lib/public/nuklear.h:9386:    cmd = nk_ptr_add(struct nk_draw_command, memory, size - list->cmd_offset);
../lib/public/nuklear.h:9387:    return (cmd - (list->cmd_count-1));
../lib/public/nuklear.h:9394:    if (!list->cmd_count) {
../lib/public/nuklear.h:9395:        nk_draw_list_push_command(list, rect, list->config.null.texture);
../lib/public/nuklear.h:9398:        if (prev->elem_count == 0)
../lib/public/nuklear.h:9399:            prev->clip_rect = rect;
../lib/public/nuklear.h:9400:        nk_draw_list_push_command(list, rect, prev->texture);
../lib/public/nuklear.h:9408:    if (!list->cmd_count) {
../lib/public/nuklear.h:9412:        if (prev->elem_count == 0) {
../lib/public/nuklear.h:9413:            prev->texture = texture;
../lib/public/nuklear.h:9415:            prev->userdata = list->userdata;
../lib/public/nuklear.h:9417:    } else if (prev->texture.id != texture.id
../lib/public/nuklear.h:9419:            || prev->userdata.id != list->userdata.id
../lib/public/nuklear.h:9421:        ) nk_draw_list_push_command(list, prev->clip_rect, texture);
../lib/public/nuklear.h:9428:    list->userdata = userdata;
../lib/public/nuklear.h:9437:    vtx = nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT,
../lib/public/nuklear.h:9438:        list->config.vertex_size*count, list->config.vertex_alignment);
../lib/public/nuklear.h:9440:    list->vertex_count += (unsigned int)count;
../lib/public/nuklear.h:9451:    if(sizeof(nk_draw_index)==2) NK_ASSERT((list->vertex_count < NK_USHORT_MAX &&
../lib/public/nuklear.h:9452:        "To many verticies for 16-bit vertex indicies. Please read comment above on how to solve this problem"));
../lib/public/nuklear.h:9466:        nk_buffer_alloc(list->elements, NK_BUFFER_FRONT, elem_size*count, elem_align);
../lib/public/nuklear.h:9469:    list->element_count += (unsigned int)count;
../lib/public/nuklear.h:9470:    cmd->elem_count += (unsigned int)count;
../lib/public/nuklear.h:9477:    return (element->attribute == NK_VERTEX_ATTRIBUTE_COUNT ||
../lib/public/nuklear.h:9478:            element->format == NK_FORMAT_COUNT);
../lib/public/nuklear.h:9613:    void *result = (void*)((char*)dst + config->vertex_size);
../lib/public/nuklear.h:9614:    const struct nk_draw_vertex_layout_element *elem_iter = config->vertex_layout;
../lib/public/nuklear.h:9616:        void *address = (void*)((char*)dst + elem_iter->offset);
../lib/public/nuklear.h:9617:        switch (elem_iter->attribute) {
../lib/public/nuklear.h:9620:        case NK_VERTEX_POSITION: nk_draw_vertex_element(address, &pos.x, 2, elem_iter->format); break;
../lib/public/nuklear.h:9621:        case NK_VERTEX_TEXCOORD: nk_draw_vertex_element(address, &uv.x, 2, elem_iter->format); break;
../lib/public/nuklear.h:9622:        case NK_VERTEX_COLOR: nk_draw_vertex_color(address, &color.r, elem_iter->format); break;
../lib/public/nuklear.h:9640:    color.a = (nk_byte)((float)color.a * list->config.global_alpha);
../lib/public/nuklear.h:9642:    if (!closed) count = points_count-1;
../lib/public/nuklear.h:9646:    nk_draw_list_push_userdata(list, list->userdata);
../lib/public/nuklear.h:9649:    color.a = (nk_byte)((float)color.a * list->config.global_alpha);
../lib/public/nuklear.h:9655:        /* ANTI-ALIASED STROKE */
../lib/public/nuklear.h:9663:        nk_size index = list->vertex_count;
../lib/public/nuklear.h:9676:        vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);
../lib/public/nuklear.h:9677:        nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);
../lib/public/nuklear.h:9679:        normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);
../lib/public/nuklear.h:9684:        vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);
../lib/public/nuklear.h:9700:            normals[i1].y = -diff.x;
../lib/public/nuklear.h:9704:            normals[points_count-1] = normals[points_count-2];
../lib/public/nuklear.h:9712:                d = nk_vec2_muls(normals[points_count-1], AA_SIZE);
../lib/public/nuklear.h:9713:                temp[(points_count-1) * 2 + 0] = nk_vec2_add(points[points_count-1], d);
../lib/public/nuklear.h:9714:                temp[(points_count-1) * 2 + 1] = nk_vec2_sub(points[points_count-1], d);
../lib/public/nuklear.h:9750:                const struct nk_vec2 uv = list->config.null.uv;
../lib/public/nuklear.h:9751:                vtx = nk_draw_vertex(vtx, &list->config, points[i], uv, col);
../lib/public/nuklear.h:9752:                vtx = nk_draw_vertex(vtx, &list->config, temp[i*2+0], uv, col_trans);
../lib/public/nuklear.h:9753:                vtx = nk_draw_vertex(vtx, &list->config, temp[i*2+1], uv, col_trans);
../lib/public/nuklear.h:9757:            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
../lib/public/nuklear.h:9767:                d1 = nk_vec2_muls(normals[points_count-1], half_inner_thickness + AA_SIZE);
../lib/public/nuklear.h:9768:                d2 = nk_vec2_muls(normals[points_count-1], half_inner_thickness);
../lib/public/nuklear.h:9770:                temp[(points_count-1)*4+0] = nk_vec2_add(points[points_count-1], d1);
../lib/public/nuklear.h:9771:                temp[(points_count-1)*4+1] = nk_vec2_add(points[points_count-1], d2);
../lib/public/nuklear.h:9772:                temp[(points_count-1)*4+2] = nk_vec2_sub(points[points_count-1], d2);
../lib/public/nuklear.h:9773:                temp[(points_count-1)*4+3] = nk_vec2_sub(points[points_count-1], d1);
../lib/public/nuklear.h:9815:                const struct nk_vec2 uv = list->config.null.uv;
../lib/public/nuklear.h:9816:                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+0], uv, col_trans);
../lib/public/nuklear.h:9817:                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+1], uv, col);
../lib/public/nuklear.h:9818:                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+2], uv, col);
../lib/public/nuklear.h:9819:                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+3], uv, col_trans);
../lib/public/nuklear.h:9823:        nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);
../lib/public/nuklear.h:9825:        /* NON ANTI-ALIASED STROKE */
../lib/public/nuklear.h:9827:        nk_size idx = list->vertex_count;
../lib/public/nuklear.h:9836:            const struct nk_vec2 uv = list->config.null.uv;
../lib/public/nuklear.h:9854:            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x + dy, p1.y - dx), uv, col);
../lib/public/nuklear.h:9855:            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x + dy, p2.y - dx), uv, col);
../lib/public/nuklear.h:9856:            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x - dy, p2.y + dx), uv, col);
../lib/public/nuklear.h:9857:            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x - dy, p1.y + dx), uv, col);
../lib/public/nuklear.h:9882:    nk_draw_list_push_userdata(list, list->userdata);
../lib/public/nuklear.h:9885:    color.a = (nk_byte)((float)color.a * list->config.global_alpha);
../lib/public/nuklear.h:9897:        nk_size index = list->vertex_count;
../lib/public/nuklear.h:9899:        const nk_size idx_count = (points_count-2)*3 + points_count*6;
../lib/public/nuklear.h:9912:        vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);
../lib/public/nuklear.h:9913:        nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);
../lib/public/nuklear.h:9915:        normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);
../lib/public/nuklear.h:9917:        vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);
../lib/public/nuklear.h:9922:            ids[1] = (nk_draw_index)(vtx_inner_idx + ((i-1) << 1));
../lib/public/nuklear.h:9928:        for (i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++) {
../lib/public/nuklear.h:9941:            normals[i0].y = -diff.x;
../lib/public/nuklear.h:9945:        for (i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++) {
../lib/public/nuklear.h:9946:            const struct nk_vec2 uv = list->config.null.uv;
../lib/public/nuklear.h:9959:            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_sub(points[i1], dm), uv, col);
../lib/public/nuklear.h:9960:            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_add(points[i1], dm), uv, col_trans);
../lib/public/nuklear.h:9972:        nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);
../lib/public/nuklear.h:9975:        nk_size index = list->vertex_count;
../lib/public/nuklear.h:9976:        const nk_size idx_count = (points_count-2)*3;
../lib/public/nuklear.h:9983:            vtx = nk_draw_vertex(vtx, &list->config, points[i], list->config.null.uv, col);
../lib/public/nuklear.h:9986:            ids[1] = (nk_draw_index)(index+ i - 1);
../lib/public/nuklear.h:9997:    nk_buffer_reset(list->buffer, NK_BUFFER_FRONT);
../lib/public/nuklear.h:9998:    list->path_count = 0;
../lib/public/nuklear.h:9999:    list->path_offset = 0;
../lib/public/nuklear.h:10008:    if (!list->cmd_count)
../lib/public/nuklear.h:10012:    if (cmd && cmd->texture.ptr != list->config.null.texture.ptr)
../lib/public/nuklear.h:10013:        nk_draw_list_push_image(list, list->config.null.texture);
../lib/public/nuklear.h:10028:            const struct nk_vec2 c = list->circle_vtx[(nk_size)a % NK_LEN(list->circle_vtx)];
../lib/public/nuklear.h:10046:            cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)
../lib/public/nuklear.h:10057:            x' = r * cos(a + b) = x * cos(b) - y * sin(b)
../lib/public/nuklear.h:10062:    {const float d_angle = (a_max - a_min) / (float)segments;
../lib/public/nuklear.h:10074:        new_cx = cx * cos_d - cy * sin_d;
../lib/public/nuklear.h:10088:    r = NK_MIN(r, ((b.x-a.x) < 0) ? -(b.x-a.x): (b.x-a.x));
../lib/public/nuklear.h:10089:    r = NK_MIN(r, ((b.y-a.y) < 0) ? -(b.y-a.y): (b.y-a.y));
../lib/public/nuklear.h:10098:        nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, a.y + r), r, 9, 12);
../lib/public/nuklear.h:10099:        nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, b.y - r), r, 0, 3);
../lib/public/nuklear.h:10100:        nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, b.y - r), r, 3, 6);
../lib/public/nuklear.h:10112:    NK_ASSERT(list->path_count);
../lib/public/nuklear.h:10113:    if (!list || !list->path_count) return;
../lib/public/nuklear.h:10120:        float u = 1.0f - t;
../lib/public/nuklear.h:10136:    points = (struct nk_vec2*)nk_buffer_memory(list->buffer);
../lib/public/nuklear.h:10137:    nk_draw_list_fill_poly_convex(list, points, list->path_count, color, list->config.shape_AA);
../lib/public/nuklear.h:10147:    points = (struct nk_vec2*)nk_buffer_memory(list->buffer);
../lib/public/nuklear.h:10148:    nk_draw_list_stroke_poly_line(list, points, list->path_count, color,
../lib/public/nuklear.h:10149:        closed, thickness, list->config.line_AA);
../lib/public/nuklear.h:10158:    if (list->line_AA == NK_ANTI_ALIASING_ON) {
../lib/public/nuklear.h:10174:    if (list->line_AA == NK_ANTI_ALIASING_ON) {
../lib/public/nuklear.h:10178:        nk_draw_list_path_rect_to(list, nk_vec2(rect.x-0.5f, rect.y-0.5f),
../lib/public/nuklear.h:10188:    if (list->line_AA == NK_ANTI_ALIASING_ON) {
../lib/public/nuklear.h:10192:        nk_draw_list_path_rect_to(list, nk_vec2(rect.x-0.5f, rect.y-0.5f),
../lib/public/nuklear.h:10215:    nk_draw_list_push_image(list, list->config.null.texture);
../lib/public/nuklear.h:10216:    index = (nk_draw_index)list->vertex_count;
../lib/public/nuklear.h:10225:    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y), list->config.null.uv, col_left);
../lib/public/nuklear.h:10226:    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y), list->config.null.uv, col_top);
../lib/public/nuklear.h:10227:    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y + rect.h), list->config.null.uv, col_right);
../lib/public/nuklear.h:10228:    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y + rect.h), list->config.null.uv, col_bottom);
../lib/public/nuklear.h:10259:    a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;
../lib/public/nuklear.h:10270:    a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;
../lib/public/nuklear.h:10308:    index = (nk_draw_index)list->vertex_count;
../lib/public/nuklear.h:10317:    vtx = nk_draw_vertex(vtx, &list->config, a, uva, col);
../lib/public/nuklear.h:10318:    vtx = nk_draw_vertex(vtx, &list->config, b, uvb, col);
../lib/public/nuklear.h:10319:    vtx = nk_draw_vertex(vtx, &list->config, c, uvc, col);
../lib/public/nuklear.h:10320:    vtx = nk_draw_vertex(vtx, &list->config, d, uvd, col);
../lib/public/nuklear.h:10359:        list->clip_rect.x, list->clip_rect.y, list->clip_rect.w, list->clip_rect.h)) return;
../lib/public/nuklear.h:10361:    nk_draw_list_push_image(list, font->texture);
../lib/public/nuklear.h:10367:    fg.a = (nk_byte)((float)fg.a * list->config.global_alpha);
../lib/public/nuklear.h:10374:        next_glyph_len = nk_utf_decode(text + text_len + glyph_len, &next, (int)len - text_len);
../lib/public/nuklear.h:10375:        font->query(font->userdata, font_height, &g, unicode,
../lib/public/nuklear.h:10397:    struct nk_draw_command *dcmd = nk_draw_list_push_command(list, list->clip_rect, (nk_handle){0});
../lib/public/nuklear.h:10400:    dcmd->userdata.ptr = malloc(sizeof(struct nk_command_userdata));
../lib/public/nuklear.h:10401:    if(!dcmd->userdata.ptr)
../lib/public/nuklear.h:10403:    dcmd->elem_count = 1; /* Needed so that our userdata pointer doesn't get overwritten later */
../lib/public/nuklear.h:10404:    *(struct nk_command_userdata*)(dcmd->userdata.ptr) = (struct nk_command_userdata) {
../lib/public/nuklear.h:10418:    if (!list->cmd_count) {
../lib/public/nuklear.h:10422:        if (dcmd->elem_count == 0) {
../lib/public/nuklear.h:10423:            dcmd->texture = (nk_handle){0};
../lib/public/nuklear.h:10425:            dcmd->userdata = list->userdata;
../lib/public/nuklear.h:10427:    } else if (dcmd->texture.id != 0
../lib/public/nuklear.h:10429:            || dcmd->userdata.id != list->userdata.id
../lib/public/nuklear.h:10431:        ) dcmd = nk_draw_list_push_command(list, dcmd->clip_rect, (nk_handle){0});
../lib/public/nuklear.h:10435:    dcmd->userdata.ptr = malloc(sizeof(struct nk_command_userdata));
../lib/public/nuklear.h:10436:    if(!dcmd->userdata.ptr)
../lib/public/nuklear.h:10438:    *(struct nk_command_userdata*)(dcmd->userdata.ptr) = (struct nk_command_userdata) {
../lib/public/nuklear.h:10441:    strcpy(((struct nk_command_userdata*)(dcmd->userdata.ptr))->texpath, texpath);
../lib/public/nuklear.h:10460:    NK_ASSERT(config->vertex_layout);
../lib/public/nuklear.h:10461:    NK_ASSERT(config->vertex_size);
../lib/public/nuklear.h:10462:    if (!ctx || !cmds || !vertices || !elements || !config || !config->vertex_layout)
../lib/public/nuklear.h:10465:    nk_draw_list_setup(&ctx->draw_list, config, cmds, vertices, elements,
../lib/public/nuklear.h:10466:        config->line_AA, config->shape_AA);
../lib/public/nuklear.h:10470:        ctx->draw_list.userdata = cmd->userdata;
../lib/public/nuklear.h:10472:        switch (cmd->type) {
../lib/public/nuklear.h:10476:            nk_draw_list_add_clip(&ctx->draw_list, nk_rect(s->x, s->y, s->w, s->h));
../lib/public/nuklear.h:10480:            nk_draw_list_stroke_line(&ctx->draw_list, nk_vec2(l->begin.x, l->begin.y),
../lib/public/nuklear.h:10481:                nk_vec2(l->end.x, l->end.y), l->color, l->line_thickness);
../lib/public/nuklear.h:10485:            nk_draw_list_stroke_curve(&ctx->draw_list, nk_vec2(q->begin.x, q->begin.y),
../lib/public/nuklear.h:10486:                nk_vec2(q->ctrl[0].x, q->ctrl[0].y), nk_vec2(q->ctrl[1].x,
../lib/public/nuklear.h:10487:                q->ctrl[1].y), nk_vec2(q->end.x, q->end.y), q->color,
../lib/public/nuklear.h:10488:                config->curve_segment_count, q->line_thickness);
../lib/public/nuklear.h:10492:            nk_draw_list_stroke_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
../lib/public/nuklear.h:10493:                r->color, (float)r->rounding, r->line_thickness);
../lib/public/nuklear.h:10497:            nk_draw_list_fill_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
../lib/public/nuklear.h:10498:                r->color, (float)r->rounding);
../lib/public/nuklear.h:10502:            nk_draw_list_fill_rect_multi_color(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
../lib/public/nuklear.h:10503:                r->left, r->top, r->right, r->bottom);
../lib/public/nuklear.h:10507:            nk_draw_list_stroke_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w/2,
../lib/public/nuklear.h:10508:                (float)c->y + (float)c->h/2), (float)c->w/2, c->color,
../lib/public/nuklear.h:10509:                config->circle_segment_count, c->line_thickness);
../lib/public/nuklear.h:10513:            nk_draw_list_fill_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w/2,
../lib/public/nuklear.h:10514:                (float)c->y + (float)c->h/2), (float)c->w/2, c->color,
../lib/public/nuklear.h:10515:                config->circle_segment_count);
../lib/public/nuklear.h:10519:            nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));
../lib/public/nuklear.h:10520:            nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,
../lib/public/nuklear.h:10521:                c->a[0], c->a[1], config->arc_segment_count);
../lib/public/nuklear.h:10522:            nk_draw_list_path_stroke(&ctx->draw_list, c->color, NK_STROKE_CLOSED, c->line_thickness);
../lib/public/nuklear.h:10526:            nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));
../lib/public/nuklear.h:10527:            nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,
../lib/public/nuklear.h:10528:                c->a[0], c->a[1], config->arc_segment_count);
../lib/public/nuklear.h:10529:            nk_draw_list_path_fill(&ctx->draw_list, c->color);
../lib/public/nuklear.h:10533:            nk_draw_list_stroke_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),
../lib/public/nuklear.h:10534:                nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color,
../lib/public/nuklear.h:10535:                t->line_thickness);
../lib/public/nuklear.h:10539:            nk_draw_list_fill_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),
../lib/public/nuklear.h:10540:                nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color);
../lib/public/nuklear.h:10545:            for (i = 0; i < p->point_count; ++i) {
../lib/public/nuklear.h:10546:                struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
../lib/public/nuklear.h:10547:                nk_draw_list_path_line_to(&ctx->draw_list, pnt);
../lib/public/nuklear.h:10549:            nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_CLOSED, p->line_thickness);
../lib/public/nuklear.h:10554:            for (i = 0; i < p->point_count; ++i) {
../lib/public/nuklear.h:10555:                struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
../lib/public/nuklear.h:10556:                nk_draw_list_path_line_to(&ctx->draw_list, pnt);
../lib/public/nuklear.h:10558:            nk_draw_list_path_fill(&ctx->draw_list, p->color);
../lib/public/nuklear.h:10563:            for (i = 0; i < p->point_count; ++i) {
../lib/public/nuklear.h:10564:                struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
../lib/public/nuklear.h:10565:                nk_draw_list_path_line_to(&ctx->draw_list, pnt);
../lib/public/nuklear.h:10567:            nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_OPEN, p->line_thickness);
../lib/public/nuklear.h:10571:            nk_draw_list_add_text(&ctx->draw_list, t->font, nk_rect(t->x, t->y, t->w, t->h),
../lib/public/nuklear.h:10572:                t->string, t->length, t->height, t->foreground);
../lib/public/nuklear.h:10576:            nk_draw_list_add_image(&ctx->draw_list, i->img, nk_rect(i->x, i->y, i->w, i->h), i->col);
../lib/public/nuklear.h:10580:            c->callback(&ctx->draw_list, c->x, c->y, c->w, c->h, c->callback_data);
../lib/public/nuklear.h:10584:            nk_draw_list_add_set_vres(&ctx->draw_list, (struct nk_vec2i){c->x, c->y});
../lib/public/nuklear.h:10588:            nk_draw_list_add_image_texpath(&ctx->draw_list, i->texpath, nk_rect(i->x, i->y, i->w, i->h), i->col);
../lib/public/nuklear.h:10593:    res |= (cmds->needed > cmds->allocated + (cmds->memory.size - cmds->size)) ? NK_CONVERT_COMMAND_BUFFER_FULL: 0;
../lib/public/nuklear.h:10594:    res |= (vertices->needed > vertices->allocated) ? NK_CONVERT_VERTEX_BUFFER_FULL: 0;
../lib/public/nuklear.h:10595:    res |= (elements->needed > elements->allocated) ? NK_CONVERT_ELEMENT_BUFFER_FULL: 0;
../lib/public/nuklear.h:10602:    return nk__draw_list_begin(&ctx->draw_list, buffer);
../lib/public/nuklear.h:10607:    return nk__draw_list_end(&ctx->draw_list, buffer);
../lib/public/nuklear.h:10613:    return nk__draw_list_next(cmd, buffer, &ctx->draw_list);
../lib/public/nuklear.h:10622:/* -------------------------------------------------------------
../lib/public/nuklear.h:10626: * --------------------------------------------------------------*/
../lib/public/nuklear.h:10627:/* stb_rect_pack.h - v0.05 - public domain - rectangle packing */
../lib/public/nuklear.h:10640:    /* non-zero if valid packing */
../lib/public/nuklear.h:10658:    /* we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2' */
../lib/public/nuklear.h:10681:        context->align = 1;
../lib/public/nuklear.h:10689:        context->align = (context->width + context->num_nodes-1) / context->num_nodes;
../lib/public/nuklear.h:10701:    for (i=0; i < num_nodes-1; ++i)
../lib/public/nuklear.h:10704:    context->init_mode = NK_RP__INIT_skyline;
../lib/public/nuklear.h:10705:    context->heuristic = NK_RP_HEURISTIC_Skyline_default;
../lib/public/nuklear.h:10706:    context->free_head = &nodes[0];
../lib/public/nuklear.h:10707:    context->active_head = &context->extra[0];
../lib/public/nuklear.h:10708:    context->width = width;
../lib/public/nuklear.h:10709:    context->height = height;
../lib/public/nuklear.h:10710:    context->num_nodes = num_nodes;
../lib/public/nuklear.h:10714:    context->extra[0].x = 0;
../lib/public/nuklear.h:10715:    context->extra[0].y = 0;
../lib/public/nuklear.h:10716:    context->extra[0].next = &context->extra[1];
../lib/public/nuklear.h:10717:    context->extra[1].x = (nk_rp_coord) width;
../lib/public/nuklear.h:10718:    context->extra[1].y = 65535;
../lib/public/nuklear.h:10719:    context->extra[1].next = 0;
../lib/public/nuklear.h:10729:    NK_ASSERT(first->x <= x0);
../lib/public/nuklear.h:10732:    NK_ASSERT(node->next->x > x0);
../lib/public/nuklear.h:10734:    NK_ASSERT(node->x <= x0);
../lib/public/nuklear.h:10739:    while (node->x < x1)
../lib/public/nuklear.h:10741:        if (node->y > min_y) {
../lib/public/nuklear.h:10745:            waste_area += visited_width * (node->y - min_y);
../lib/public/nuklear.h:10746:            min_y = node->y;
../lib/public/nuklear.h:10748:            if (node->x < x0)
../lib/public/nuklear.h:10749:            visited_width += node->next->x - x0;
../lib/public/nuklear.h:10751:            visited_width += node->next->x - node->x;
../lib/public/nuklear.h:10754:            int under_width = node->next->x - node->x;
../lib/public/nuklear.h:10756:            under_width = width - visited_width;
../lib/public/nuklear.h:10757:            waste_area += under_width * (min_y - node->y);
../lib/public/nuklear.h:10760:        node = node->next;
../lib/public/nuklear.h:10772:    /* align to multiple of c->align */
../lib/public/nuklear.h:10773:    width = (width + c->align - 1);
../lib/public/nuklear.h:10774:    width -= width % c->align;
../lib/public/nuklear.h:10775:    NK_ASSERT(width % c->align == 0);
../lib/public/nuklear.h:10777:    node = c->active_head;
../lib/public/nuklear.h:10778:    prev = &c->active_head;
../lib/public/nuklear.h:10779:    while (node->x + width <= c->width) {
../lib/public/nuklear.h:10781:        y = nk_rp__skyline_find_min_y(c, node, node->x, width, &waste);
../lib/public/nuklear.h:10783:        if (c->heuristic == NK_RP_HEURISTIC_Skyline_BL_sortHeight) {
../lib/public/nuklear.h:10790:            /* best-fit */
../lib/public/nuklear.h:10791:            if (y + height <= c->height) {
../lib/public/nuklear.h:10800:        prev = &node->next;
../lib/public/nuklear.h:10801:        node = node->next;
../lib/public/nuklear.h:10803:    best_x = (best == 0) ? 0 : (*best)->x;
../lib/public/nuklear.h:10805:    /* if doing best-fit (BF), we also have to try aligning right edge to each node position */
../lib/public/nuklear.h:10818:    /* then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned */
../lib/public/nuklear.h:10821:    if (c->heuristic == NK_RP_HEURISTIC_Skyline_BF_sortHeight)
../lib/public/nuklear.h:10823:        tail = c->active_head;
../lib/public/nuklear.h:10824:        node = c->active_head;
../lib/public/nuklear.h:10825:        prev = &c->active_head;
../lib/public/nuklear.h:10827:        while (tail->x < width)
../lib/public/nuklear.h:10828:            tail = tail->next;
../lib/public/nuklear.h:10831:            int xpos = tail->x - width;
../lib/public/nuklear.h:10835:            while (node->next->x <= xpos) {
../lib/public/nuklear.h:10836:                prev = &node->next;
../lib/public/nuklear.h:10837:                node = node->next;
../lib/public/nuklear.h:10839:            NK_ASSERT(node->next->x > xpos && node->x <= xpos);
../lib/public/nuklear.h:10841:            if (y + height < c->height) {
../lib/public/nuklear.h:10852:            tail = tail->next;
../lib/public/nuklear.h:10871:    if (res.prev_link == 0 || res.y + height > context->height || context->free_head == 0) {
../lib/public/nuklear.h:10877:    node = context->free_head;
../lib/public/nuklear.h:10878:    node->x = (nk_rp_coord) res.x;
../lib/public/nuklear.h:10879:    node->y = (nk_rp_coord) (res.y + height);
../lib/public/nuklear.h:10881:    context->free_head = node->next;
../lib/public/nuklear.h:10887:    if (cur->x < res.x) {
../lib/public/nuklear.h:10889:        struct nk_rp_node *next = cur->next;
../lib/public/nuklear.h:10890:        cur->next = node;
../lib/public/nuklear.h:10898:    while (cur->next && cur->next->x <= res.x + width) {
../lib/public/nuklear.h:10899:        struct nk_rp_node *next = cur->next;
../lib/public/nuklear.h:10901:        cur->next = context->free_head;
../lib/public/nuklear.h:10902:        context->free_head = cur;
../lib/public/nuklear.h:10906:    node->next = cur;
../lib/public/nuklear.h:10908:    if (cur->x < res.x + width)
../lib/public/nuklear.h:10909:        cur->x = (nk_rp_coord) (res.x + width);
../lib/public/nuklear.h:10917:    if (p->h > q->h)
../lib/public/nuklear.h:10918:        return -1;
../lib/public/nuklear.h:10919:    if (p->h < q->h)
../lib/public/nuklear.h:10921:    return (p->w > q->w) ? -1 : (p->w < q->w);
../lib/public/nuklear.h:10928:    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
../lib/public/nuklear.h:10941:            pivot = array[left+seed%(len-left)];
../lib/public/nuklear.h:10944:            for (right = left-1;;) {
../lib/public/nuklear.h:10946:                while (cmp(&pivot, &array[--len]) < 0);
../lib/public/nuklear.h:10955:        len = stack[--pos];
../lib/public/nuklear.h:10996:/* stb_truetype.h - v1.07 - public domain */
../lib/public/nuklear.h:10998:#define NK_TT__OVER_MASK  (NK_TT_MAX_OVERSAMPLE-1)
../lib/public/nuklear.h:11007:    float x0,y0,s0,t0; /* top-left */
../lib/public/nuklear.h:11008:    float x1,y1,s1,t1; /* bottom-right */
../lib/public/nuklear.h:11021:    /* if non-zero, then the chars are continuous, and this is the first codepoint */
../lib/public/nuklear.h:11023:    /* if non-zero, then this is an array of unicode codepoints */
../lib/public/nuklear.h:11188:    info->data = data;
../lib/public/nuklear.h:11189:    info->fontstart = fontstart;
../lib/public/nuklear.h:11192:    info->loca = (int)nk_tt__find_table(data, (nk_uint)fontstart, "loca"); /* required */
../lib/public/nuklear.h:11193:    info->head = (int)nk_tt__find_table(data, (nk_uint)fontstart, "head"); /* required */
../lib/public/nuklear.h:11194:    info->glyf = (int)nk_tt__find_table(data, (nk_uint)fontstart, "glyf"); /* required */
../lib/public/nuklear.h:11195:    info->hhea = (int)nk_tt__find_table(data, (nk_uint)fontstart, "hhea"); /* required */
../lib/public/nuklear.h:11196:    info->hmtx = (int)nk_tt__find_table(data, (nk_uint)fontstart, "hmtx"); /* required */
../lib/public/nuklear.h:11197:    info->kern = (int)nk_tt__find_table(data, (nk_uint)fontstart, "kern"); /* not required */
../lib/public/nuklear.h:11198:    if (!cmap || !info->loca || !info->head || !info->glyf || !info->hhea || !info->hmtx)
../lib/public/nuklear.h:11202:    if (t) info->numGlyphs = nk_ttUSHORT(data+t+4);
../lib/public/nuklear.h:11203:    else info->numGlyphs = 0xffff;
../lib/public/nuklear.h:11209:    info->index_map = 0;
../lib/public/nuklear.h:11220:                info->index_map = (int)(cmap + nk_ttULONG(data+encoding_record+4));
../lib/public/nuklear.h:11227:            info->index_map = (int)(cmap + nk_ttULONG(data+encoding_record+4));
../lib/public/nuklear.h:11232:    if (info->index_map == 0)
../lib/public/nuklear.h:11234:    info->indexToLocFormat = nk_ttUSHORT(data+info->head + 50);
../lib/public/nuklear.h:11240:    const nk_byte *data = info->data;
../lib/public/nuklear.h:11241:    nk_uint index_map = (nk_uint)info->index_map;
../lib/public/nuklear.h:11246:        if (unicode_codepoint < bytes-6)
../lib/public/nuklear.h:11253:            return nk_ttUSHORT(data + index_map + 10 + (unicode_codepoint - (int)first)*2);
../lib/public/nuklear.h:11256:        NK_ASSERT(0); /* @TODO: high-byte mapping for japanese/chinese/korean */
../lib/public/nuklear.h:11277:        search -= 2;
../lib/public/nuklear.h:11284:            --entrySelector;
../lib/public/nuklear.h:11290:         nk_ushort item = (nk_ushort) ((search - endCount) >> 1);
../lib/public/nuklear.h:11301:         return nk_ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
../lib/public/nuklear.h:11309:            nk_int mid = low + ((high-low) >> 1); /* rounds down, so low <= mid < high */
../lib/public/nuklear.h:11319:                    return (int)start_glyph + (int)unicode_codepoint - (int)start_char;
../lib/public/nuklear.h:11333:    v->type = type;
../lib/public/nuklear.h:11334:    v->x = (nk_short) x;
../lib/public/nuklear.h:11335:    v->y = (nk_short) y;
../lib/public/nuklear.h:11336:    v->cx = (nk_short) cx;
../lib/public/nuklear.h:11337:    v->cy = (nk_short) cy;
../lib/public/nuklear.h:11343:    if (glyph_index >= info->numGlyphs) return -1; /* glyph index out of range */
../lib/public/nuklear.h:11344:    if (info->indexToLocFormat >= 2)    return -1; /* unknown index->glyph map format */
../lib/public/nuklear.h:11346:    if (info->indexToLocFormat == 0) {
../lib/public/nuklear.h:11347:        g1 = info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
../lib/public/nuklear.h:11348:        g2 = info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
../lib/public/nuklear.h:11350:        g1 = info->glyf + (int)nk_ttULONG (info->data + info->loca + glyph_index * 4);
../lib/public/nuklear.h:11351:        g2 = info->glyf + (int)nk_ttULONG (info->data + info->loca + glyph_index * 4 + 4);
../lib/public/nuklear.h:11353:    return g1==g2 ? -1 : g1; /* if length is 0, return -1 */
../lib/public/nuklear.h:11362:    if (x0) *x0 = nk_ttSHORT(info->data + g + 2);
../lib/public/nuklear.h:11363:    if (y0) *y0 = nk_ttSHORT(info->data + g + 4);
../lib/public/nuklear.h:11364:    if (x1) *x1 = nk_ttSHORT(info->data + g + 6);
../lib/public/nuklear.h:11365:    if (y1) *y1 = nk_ttSHORT(info->data + g + 8);
../lib/public/nuklear.h:11390:    const nk_byte *data = info->data;
../lib/public/nuklear.h:11407:        n = 1+nk_ttUSHORT(endPtsOfContours + numberOfContours*2-2);
../lib/public/nuklear.h:11409:        vertices = (struct nk_tt_vertex *)alloc->alloc(alloc->userdata, 0, (nk_size)m * sizeof(vertices[0]));
../lib/public/nuklear.h:11419:        off = m - n; /* starting offset for uninterpreted data, regardless of how m ends up being calculated */
../lib/public/nuklear.h:11427:            } else --flagcount;
../lib/public/nuklear.h:11437:                x += (flags & 16) ? dx : -dx; /* ??? */
../lib/public/nuklear.h:11453:                y += (flags & 32) ? dy : -dy; /* ??? */
../lib/public/nuklear.h:11479:                    /* if we start off with an off-curve point, then when we need to find a point on the curve */
../lib/public/nuklear.h:11484:                        /* next point is also a curve point, so interpolate an on-point curve */
../lib/public/nuklear.h:11504:                    if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */
../lib/public/nuklear.h:11518:    } else if (numberOfContours == -1) {
../lib/public/nuklear.h:11573:                    x=v->x; y=v->y;
../lib/public/nuklear.h:11574:                    v->x = (short)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
../lib/public/nuklear.h:11575:                    v->y = (short)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
../lib/public/nuklear.h:11576:                    x=v->cx; y=v->cy;
../lib/public/nuklear.h:11577:                    v->cx = (short)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
../lib/public/nuklear.h:11578:                    v->cy = (short)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
../lib/public/nuklear.h:11581:                tmp = (struct nk_tt_vertex*)alloc->alloc(alloc->userdata, 0,
../lib/public/nuklear.h:11584:                    if (vertices) alloc->free(alloc->userdata, vertices);
../lib/public/nuklear.h:11585:                    if (comp_verts) alloc->free(alloc->userdata, comp_verts);
../lib/public/nuklear.h:11590:                if (vertices) alloc->free(alloc->userdata,vertices);
../lib/public/nuklear.h:11592:                alloc->free(alloc->userdata,comp_verts);
../lib/public/nuklear.h:11611:    nk_ushort numOfLongHorMetrics = nk_ttUSHORT(info->data+info->hhea + 34);
../lib/public/nuklear.h:11614:            *advanceWidth    = nk_ttSHORT(info->data + info->hmtx + 4*glyph_index);
../lib/public/nuklear.h:11616:            *leftSideBearing = nk_ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
../lib/public/nuklear.h:11619:            *advanceWidth    = nk_ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
../lib/public/nuklear.h:11621:            *leftSideBearing = nk_ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
../lib/public/nuklear.h:11628:   if (ascent ) *ascent  = nk_ttSHORT(info->data+info->hhea + 4);
../lib/public/nuklear.h:11629:   if (descent) *descent = nk_ttSHORT(info->data+info->hhea + 6);
../lib/public/nuklear.h:11630:   if (lineGap) *lineGap = nk_ttSHORT(info->data+info->hhea + 8);
../lib/public/nuklear.h:11635:   int fheight = nk_ttSHORT(info->data + info->hhea + 4) - nk_ttSHORT(info->data + info->hhea + 6);
../lib/public/nuklear.h:11641:   int unitsPerEm = nk_ttUSHORT(info->data + info->head + 18);
../lib/public/nuklear.h:11645:/*-------------------------------------------------------------
../lib/public/nuklear.h:11647: * --------------------------------------------------------------*/
../lib/public/nuklear.h:11663:        if (iy0) *iy0 = nk_ifloorf((float)-y1 * scale_y + shift_y);
../lib/public/nuklear.h:11665:        if (iy1) *iy1 = nk_iceilf ((float)-y0 * scale_y + shift_y);
../lib/public/nuklear.h:11675:/*-------------------------------------------------------------
../lib/public/nuklear.h:11677: * --------------------------------------------------------------*/
../lib/public/nuklear.h:11681:    if (hh->first_free) {
../lib/public/nuklear.h:11682:        void *p = hh->first_free;
../lib/public/nuklear.h:11683:        hh->first_free = * (void **) p;
../lib/public/nuklear.h:11686:        if (hh->num_remaining_in_head_chunk == 0) {
../lib/public/nuklear.h:11689:                hh->alloc.alloc(hh->alloc.userdata, 0,
../lib/public/nuklear.h:11692:            c->next = hh->head;
../lib/public/nuklear.h:11693:            hh->head = c;
../lib/public/nuklear.h:11694:            hh->num_remaining_in_head_chunk = count;
../lib/public/nuklear.h:11696:        --hh->num_remaining_in_head_chunk;
../lib/public/nuklear.h:11697:        return (char *) (hh->head) + size * (nk_size)hh->num_remaining_in_head_chunk;
../lib/public/nuklear.h:11703:    *(void **) p = hh->first_free;
../lib/public/nuklear.h:11704:    hh->first_free = p;
../lib/public/nuklear.h:11709:    struct nk_tt__hheap_chunk *c = hh->head;
../lib/public/nuklear.h:11711:        struct nk_tt__hheap_chunk *n = c->next;
../lib/public/nuklear.h:11712:        hh->alloc.free(hh->alloc.userdata, c);
../lib/public/nuklear.h:11722:    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
../lib/public/nuklear.h:11723:    /*STBTT_assert(e->y0 <= start_point); */
../lib/public/nuklear.h:11725:    z->fdx = dxdy;
../lib/public/nuklear.h:11726:    z->fdy = (dxdy != 0) ? (1/dxdy): 0;
../lib/public/nuklear.h:11727:    z->fx = e->x0 + dxdy * (start_point - e->y0);
../lib/public/nuklear.h:11728:    z->fx -= (float)off_x;
../lib/public/nuklear.h:11729:    z->direction = e->invert ? 1.0f : -1.0f;
../lib/public/nuklear.h:11730:    z->sy = e->y0;
../lib/public/nuklear.h:11731:    z->ey = e->y1;
../lib/public/nuklear.h:11732:    z->next = 0;
../lib/public/nuklear.h:11741:    NK_ASSERT(e->sy <= e->ey);
../lib/public/nuklear.h:11742:    if (y0 > e->ey) return;
../lib/public/nuklear.h:11743:    if (y1 < e->sy) return;
../lib/public/nuklear.h:11744:    if (y0 < e->sy) {
../lib/public/nuklear.h:11745:        x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
../lib/public/nuklear.h:11746:        y0 = e->sy;
../lib/public/nuklear.h:11748:    if (y1 > e->ey) {
../lib/public/nuklear.h:11749:        x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
../lib/public/nuklear.h:11750:        y1 = e->ey;
../lib/public/nuklear.h:11760:        scanline[x] += e->direction * (y1-y0);
../lib/public/nuklear.h:11764:        /* coverage = 1 - average x position */
../lib/public/nuklear.h:11765:        scanline[x] += (float)e->direction * (float)(y1-y0) * (1.0f-((x0-(float)x)+(x1-(float)x))/2.0f);
../lib/public/nuklear.h:11777:        NK_ASSERT(e->ey >= y_top);
../lib/public/nuklear.h:11778:        if (e->fdx == 0) {
../lib/public/nuklear.h:11779:            float x0 = e->fx;
../lib/public/nuklear.h:11783:                    nk_tt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
../lib/public/nuklear.h:11785:                    nk_tt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
../lib/public/nuklear.h:11789:            float x0 = e->fx;
../lib/public/nuklear.h:11790:            float dx = e->fdx;
../lib/public/nuklear.h:11794:            float dy = e->fdy;
../lib/public/nuklear.h:11795:            NK_ASSERT(e->sy <= y_bottom && e->ey >= y_top);
../lib/public/nuklear.h:11800:            if (e->sy > y_top) {
../lib/public/nuklear.h:11801:                x_top = x0 + dx * (e->sy - y_top);
../lib/public/nuklear.h:11802:                y0 = e->sy;
../lib/public/nuklear.h:11808:            if (e->ey < y_bottom) {
../lib/public/nuklear.h:11809:                x_bottom = x0 + dx * (e->ey - y_top);
../lib/public/nuklear.h:11810:                y1 = e->ey;
../lib/public/nuklear.h:11823:                    height = y1 - y0;
../lib/public/nuklear.h:11825:                    scanline[x] += e->direction * (1.0f-(((float)x_top - (float)x) + ((float)x_bottom-(float)x))/2.0f)  * (float)height;
../lib/public/nuklear.h:11826:                    scanline_fill[x] += e->direction * (float)height; /* everything right of this pixel is filled */
../lib/public/nuklear.h:11835:                        y0 = y_bottom - (y0 - y_top);
../lib/public/nuklear.h:11836:                        y1 = y_bottom - (y1 - y_top);
../lib/public/nuklear.h:11839:                        dx = -dx;
../lib/public/nuklear.h:11840:                        dy = -dy;
../lib/public/nuklear.h:11847:                    y_crossing = ((float)x1+1 - (float)x0) * (float)dy + (float)y_top;
../lib/public/nuklear.h:11849:                    sign = e->direction;
../lib/public/nuklear.h:11851:                    area = sign * (y_crossing-y0);
../lib/public/nuklear.h:11853:                    scanline[x1] += area * (1.0f-((float)((float)x_top - (float)x1)+(float)(x1+1-x1))/2.0f);
../lib/public/nuklear.h:11860:                    y_crossing += (float)dy * (float)(x2 - (x1+1));
../lib/public/nuklear.h:11862:                    scanline[x2] += area + sign * (1.0f-((float)(x2-x2)+((float)x_bottom-(float)x2))/2.0f) * (y1-y_crossing);
../lib/public/nuklear.h:11863:                    scanline_fill[x2] += sign * (y1-y0);
../lib/public/nuklear.h:11879:                    /* regions. intersections with top & bottom do not necessitate case-wise logic. */
../lib/public/nuklear.h:11883:                    /* from top-to-bottom. however, this had a problem: if an x edge was epsilon */
../lib/public/nuklear.h:11896:                    yb = ((float)x - x0) / dx + y_top;
../lib/public/nuklear.h:11897:                    y2 = ((float)x+1 - x0) / dx + y_top;
../lib/public/nuklear.h:11899:                    if (x0 < x1 && x3 > x2) {         /* three segments descending down-right */
../lib/public/nuklear.h:11903:                    } else if (x3 < x1 && x0 > x2) {  /* three segments descending down-left */
../lib/public/nuklear.h:11907:                    } else if (x0 < x1 && x3 > x1) {  /* two segments across x, down-right */
../lib/public/nuklear.h:11910:                    } else if (x3 < x1 && x0 > x1) {  /* two segments across x, down-left */
../lib/public/nuklear.h:11913:                    } else if (x0 < x2 && x3 > x2) {  /* two segments across x+1, down-right */
../lib/public/nuklear.h:11916:                    } else if (x3 < x2 && x0 > x2) {  /* two segments across x+1, down-left */
../lib/public/nuklear.h:11925:        e = e->next;
../lib/public/nuklear.h:11942:    if (result->w > 64)
../lib/public/nuklear.h:11943:        scanline = (float *) alloc->alloc(alloc->userdata,0, (nk_size)(result->w*2+1) * sizeof(float));
../lib/public/nuklear.h:11946:    scanline2 = scanline + result->w;
../lib/public/nuklear.h:11948:    e[n].y0 = (float) (off_y + result->h) + 1;
../lib/public/nuklear.h:11950:    while (j < result->h)
../lib/public/nuklear.h:11957:        NK_MEMSET(scanline , 0, (nk_size)result->w*sizeof(scanline[0]));
../lib/public/nuklear.h:11958:        NK_MEMSET(scanline2, 0, (nk_size)(result->w+1)*sizeof(scanline[0]));
../lib/public/nuklear.h:11964:            if (z->ey <= scan_y_top) {
../lib/public/nuklear.h:11965:                *step = z->next; /* delete from list */
../lib/public/nuklear.h:11966:                NK_ASSERT(z->direction);
../lib/public/nuklear.h:11967:                z->direction = 0;
../lib/public/nuklear.h:11970:                step = &((*step)->next); /* advance through list */
../lib/public/nuklear.h:11975:        while (e->y0 <= scan_y_bottom) {
../lib/public/nuklear.h:11976:            if (e->y0 != e->y1) {
../lib/public/nuklear.h:11979:                    NK_ASSERT(z->ey >= scan_y_top);
../lib/public/nuklear.h:11981:                    z->next = active;
../lib/public/nuklear.h:11990:            nk_tt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
../lib/public/nuklear.h:11994:            for (i=0; i < result->w; ++i) {
../lib/public/nuklear.h:12002:                result->pixels[j*result->stride + i] = (unsigned char) m;
../lib/public/nuklear.h:12009:            z->fx += z->fdx; /* advance to position for current scanline */
../lib/public/nuklear.h:12010:            step = &((*step)->next); /* advance through list */
../lib/public/nuklear.h:12017:        alloc->free(alloc->userdata, scanline);
../lib/public/nuklear.h:12023:    #define NK_TT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
../lib/public/nuklear.h:12028:            struct nk_tt__edge *b = &p[j-1];
../lib/public/nuklear.h:12031:            p[j] = p[j-1];
../lib/public/nuklear.h:12032:            --j;
../lib/public/nuklear.h:12049:        c12 = NK_TT__COMPARE(&p[m],&p[n-1]);
../lib/public/nuklear.h:12055:            c = NK_TT__COMPARE(&p[0],&p[n-1]);
../lib/public/nuklear.h:12058:            z = (c == c12) ? 0 : n-1;
../lib/public/nuklear.h:12064:        /* now p[m] is the median-of-three */
../lib/public/nuklear.h:12072:        j=n-1;
../lib/public/nuklear.h:12079:            for (;;--j) {
../lib/public/nuklear.h:12090:            --j;
../lib/public/nuklear.h:12095:        if (j < (n-i)) {
../lib/public/nuklear.h:12098:            n = n-i;
../lib/public/nuklear.h:12100:            nk_tt__sort_edges_quicksort(p+i, n-i);
../lib/public/nuklear.h:12117:    float y_scale_inv = invert ? -scale_y : scale_y;
../lib/public/nuklear.h:12129:       alloc->alloc(alloc->userdata, 0,(sizeof(*e) * (nk_size)(n+1)));
../lib/public/nuklear.h:12138:        j = wcount[i]-1;
../lib/public/nuklear.h:12164:    alloc->free(alloc->userdata, e);
../lib/public/nuklear.h:12179:     * @TODO warped to compensate for non-linear stretching */
../lib/public/nuklear.h:12184:    float dx = (x0+x2)/2 - mx;
../lib/public/nuklear.h:12185:    float dy = (y0+y2)/2 - my;
../lib/public/nuklear.h:12189:    /* half-pixel error allowed... need to be smaller if AA */
../lib/public/nuklear.h:12223:        alloc->alloc(alloc->userdata,0, (sizeof(**contour_lengths) * (nk_size)n));
../lib/public/nuklear.h:12235:                alloc->alloc(alloc->userdata,0, (nk_size)num_points * sizeof(points[0]));
../lib/public/nuklear.h:12239:        n= -1;
../lib/public/nuklear.h:12247:                (*contour_lengths)[n] = num_points - start;
../lib/public/nuklear.h:12268:      (*contour_lengths)[n] = num_points - start;
../lib/public/nuklear.h:12273:   alloc->free(alloc->userdata, points);
../lib/public/nuklear.h:12274:   alloc->free(alloc->userdata, *contour_lengths);
../lib/public/nuklear.h:12294:        alloc->free(alloc->userdata, winding_lengths);
../lib/public/nuklear.h:12295:        alloc->free(alloc->userdata, windings);
../lib/public/nuklear.h:12318:    alloc->free(alloc->userdata, vertices);
../lib/public/nuklear.h:12321:/*-------------------------------------------------------------
../lib/public/nuklear.h:12323: * --------------------------------------------------------------*/
../lib/public/nuklear.h:12328:    int num_nodes = pw - padding;
../lib/public/nuklear.h:12330:        alloc->alloc(alloc->userdata,0, sizeof(*context));
../lib/public/nuklear.h:12332:        alloc->alloc(alloc->userdata,0, (sizeof(*nodes  ) * (nk_size)num_nodes));
../lib/public/nuklear.h:12335:        if (context != 0) alloc->free(alloc->userdata, context);
../lib/public/nuklear.h:12336:        if (nodes   != 0) alloc->free(alloc->userdata, nodes);
../lib/public/nuklear.h:12340:    spc->width = pw;
../lib/public/nuklear.h:12341:    spc->height = ph;
../lib/public/nuklear.h:12342:    spc->pixels = pixels;
../lib/public/nuklear.h:12343:    spc->pack_info = context;
../lib/public/nuklear.h:12344:    spc->nodes = nodes;
../lib/public/nuklear.h:12345:    spc->padding = padding;
../lib/public/nuklear.h:12346:    spc->stride_in_bytes = (stride_in_bytes != 0) ? stride_in_bytes : pw;
../lib/public/nuklear.h:12347:    spc->h_oversample = 1;
../lib/public/nuklear.h:12348:    spc->v_oversample = 1;
../lib/public/nuklear.h:12350:    nk_rp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
../lib/public/nuklear.h:12358:    alloc->free(alloc->userdata, spc->nodes);
../lib/public/nuklear.h:12359:    alloc->free(alloc->userdata, spc->pack_info);
../lib/public/nuklear.h:12368:      spc->h_oversample = h_oversample;
../lib/public/nuklear.h:12370:      spc->v_oversample = v_oversample;
../lib/public/nuklear.h:12377:    int safe_w = w - kernel_width;
../lib/public/nuklear.h:12392:                total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12399:                total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12406:                total += (unsigned int)pixels[i] - buffer[i & NK_TT__OVER_MASK];
../lib/public/nuklear.h:12413:                total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12420:                total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12429:            total -= (unsigned int)(buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12440:    int safe_h = h - kernel_width;
../lib/public/nuklear.h:12455:                total += (unsigned int)(pixels[i*stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12462:                total += (unsigned int)(pixels[i*stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12469:                total += (unsigned int)(pixels[i*stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12476:                total += (unsigned int)(pixels[i*stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12483:                total += (unsigned int)(pixels[i*stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12492:            total -= (unsigned int)(buffer[i & NK_TT__OVER_MASK]);
../lib/public/nuklear.h:12505:    /* which shifts phase by (oversample - 1)/2 pixels in */
../lib/public/nuklear.h:12508:    return (float)-(oversample - 1) / (2.0f * (float)oversample);
../lib/public/nuklear.h:12522:            nk_tt_ScaleForMappingEmToPixels(info, -fh);
../lib/public/nuklear.h:12523:        ranges[i].h_oversample = (unsigned char) spc->h_oversample;
../lib/public/nuklear.h:12524:        ranges[i].v_oversample = (unsigned char) spc->v_oversample;
../lib/public/nuklear.h:12532:            nk_tt_GetGlyphBitmapBoxSubpixel(info,glyph, scale * (float)spc->h_oversample,
../lib/public/nuklear.h:12533:                scale * (float)spc->v_oversample, 0,0, &x0,&y0,&x1,&y1);
../lib/public/nuklear.h:12534:            rects[k].w = (nk_rp_coord) (x1-x0 + spc->padding + (int)spc->h_oversample-1);
../lib/public/nuklear.h:12535:            rects[k].h = (nk_rp_coord) (y1-y0 + spc->padding + (int)spc->v_oversample-1);
../lib/public/nuklear.h:12548:    int old_h_over = (int)spc->h_oversample;
../lib/public/nuklear.h:12549:    int old_v_over = (int)spc->v_oversample;
../lib/public/nuklear.h:12558:            nk_tt_ScaleForMappingEmToPixels(info, -fh);
../lib/public/nuklear.h:12560:        spc->h_oversample = ranges[i].h_oversample;
../lib/public/nuklear.h:12561:        spc->v_oversample = ranges[i].v_oversample;
../lib/public/nuklear.h:12563:        recip_h = 1.0f / (float)spc->h_oversample;
../lib/public/nuklear.h:12564:        recip_v = 1.0f / (float)spc->v_oversample;
../lib/public/nuklear.h:12566:        sub_x = nk_tt__oversample_shift((int)spc->h_oversample);
../lib/public/nuklear.h:12567:        sub_y = nk_tt__oversample_shift((int)spc->v_oversample);
../lib/public/nuklear.h:12572:            if (r->was_packed)
../lib/public/nuklear.h:12580:                nk_rp_coord pad = (nk_rp_coord) spc->padding;
../lib/public/nuklear.h:12583:                r->x = (nk_rp_coord)((int)r->x + (int)pad);
../lib/public/nuklear.h:12584:                r->y = (nk_rp_coord)((int)r->y + (int)pad);
../lib/public/nuklear.h:12585:                r->w = (nk_rp_coord)((int)r->w - (int)pad);
../lib/public/nuklear.h:12586:                r->h = (nk_rp_coord)((int)r->h - (int)pad);
../lib/public/nuklear.h:12589:                nk_tt_GetGlyphBitmapBox(info, glyph, scale * (float)spc->h_oversample,
../lib/public/nuklear.h:12590:                        (scale * (float)spc->v_oversample), &x0,&y0,&x1,&y1);
../lib/public/nuklear.h:12591:                nk_tt_MakeGlyphBitmapSubpixel(info, spc->pixels + r->x + r->y*spc->stride_in_bytes,
../lib/public/nuklear.h:12592:                    (int)(r->w - spc->h_oversample+1), (int)(r->h - spc->v_oversample+1),
../lib/public/nuklear.h:12593:                    spc->stride_in_bytes, scale * (float)spc->h_oversample,
../lib/public/nuklear.h:12594:                    scale * (float)spc->v_oversample, 0,0, glyph, alloc);
../lib/public/nuklear.h:12596:                if (spc->h_oversample > 1)
../lib/public/nuklear.h:12597:                   nk_tt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
../lib/public/nuklear.h:12598:                        r->w, r->h, spc->stride_in_bytes, (int)spc->h_oversample);
../lib/public/nuklear.h:12600:                if (spc->v_oversample > 1)
../lib/public/nuklear.h:12601:                   nk_tt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
../lib/public/nuklear.h:12602:                        r->w, r->h, spc->stride_in_bytes, (int)spc->v_oversample);
../lib/public/nuklear.h:12604:                bc->x0       = (nk_ushort)  r->x;
../lib/public/nuklear.h:12605:                bc->y0       = (nk_ushort)  r->y;
../lib/public/nuklear.h:12606:                bc->x1       = (nk_ushort) (r->x + r->w);
../lib/public/nuklear.h:12607:                bc->y1       = (nk_ushort) (r->y + r->h);
../lib/public/nuklear.h:12608:                bc->xadvance = scale * (float)advance;
../lib/public/nuklear.h:12609:                bc->xoff     = (float)  x0 * recip_h + sub_x;
../lib/public/nuklear.h:12610:                bc->yoff     = (float)  y0 * recip_v + sub_y;
../lib/public/nuklear.h:12611:                bc->xoff2    = ((float)x0 + r->w) * recip_h + sub_x;
../lib/public/nuklear.h:12612:                bc->yoff2    = ((float)y0 + r->h) * recip_v + sub_y;
../lib/public/nuklear.h:12620:    spc->h_oversample = (unsigned int)old_h_over;
../lib/public/nuklear.h:12621:    spc->v_oversample = (unsigned int)old_v_over;
../lib/public/nuklear.h:12632:        int tx = nk_ifloorf((*xpos + b->xoff) + 0.5f);
../lib/public/nuklear.h:12633:        int ty = nk_ifloorf((*ypos + b->yoff) + 0.5f);
../lib/public/nuklear.h:12638:        q->x0 = x;
../lib/public/nuklear.h:12639:        q->y0 = y;
../lib/public/nuklear.h:12640:        q->x1 = x + b->xoff2 - b->xoff;
../lib/public/nuklear.h:12641:        q->y1 = y + b->yoff2 - b->yoff;
../lib/public/nuklear.h:12643:        q->x0 = *xpos + b->xoff;
../lib/public/nuklear.h:12644:        q->y0 = *ypos + b->yoff;
../lib/public/nuklear.h:12645:        q->x1 = *xpos + b->xoff2;
../lib/public/nuklear.h:12646:        q->y1 = *ypos + b->yoff2;
../lib/public/nuklear.h:12648:    q->s0 = b->x0 * ipw;
../lib/public/nuklear.h:12649:    q->t0 = b->y0 * iph;
../lib/public/nuklear.h:12650:    q->s1 = b->x1 * ipw;
../lib/public/nuklear.h:12651:    q->t1 = b->y1 * iph;
../lib/public/nuklear.h:12652:    *xpos += b->xadvance;
../lib/public/nuklear.h:12655:/* -------------------------------------------------------------
../lib/public/nuklear.h:12659: * --------------------------------------------------------------*/
../lib/public/nuklear.h:12689:    return (iter == range) ? 0 : (int)((iter - range)/2);
../lib/public/nuklear.h:12701:        diff = (int)((t - f) + 1);
../lib/public/nuklear.h:12764:    for (iter = config_list; iter; iter = iter->next) {
../lib/public/nuklear.h:12766:        do {if (!i->range) iter->range = nk_font_default_glyph_ranges();
../lib/public/nuklear.h:12767:            range_count = nk_range_count(i->range);
../lib/public/nuklear.h:12769:            *glyph_count += nk_range_glyph_count(i->range, range_count);
../lib/public/nuklear.h:12770:        } while ((i = i->n) != iter);
../lib/public/nuklear.h:12787:    baker->build = (struct nk_font_bake_data*)NK_ALIGN_PTR((baker + 1), nk_build_align);
../lib/public/nuklear.h:12788:    baker->packed_chars = (struct nk_tt_packedchar*)NK_ALIGN_PTR((baker->build + count), nk_char_align);
../lib/public/nuklear.h:12789:    baker->rects = (struct nk_rp_rect*)NK_ALIGN_PTR((baker->packed_chars + glyph_count), nk_rect_align);
../lib/public/nuklear.h:12790:    baker->ranges = (struct nk_tt_pack_range*)NK_ALIGN_PTR((baker->rects + glyph_count), nk_range_align);
../lib/public/nuklear.h:12791:    baker->alloc = *alloc;
../lib/public/nuklear.h:12815:    for (config_iter = config_list; config_iter; config_iter = config_iter->next) {
../lib/public/nuklear.h:12817:        do {range_count = nk_range_count(it->range);
../lib/public/nuklear.h:12819:            total_glyph_count += nk_range_glyph_count(it->range, range_count);
../lib/public/nuklear.h:12820:        } while ((it = it->n) != config_iter);
../lib/public/nuklear.h:12823:    for (config_iter = config_list; config_iter; config_iter = config_iter->next) {
../lib/public/nuklear.h:12825:        do {if (!nk_tt_InitFont(&baker->build[i++].info, (const unsigned char*)it->ttf_blob, 0))
../lib/public/nuklear.h:12827:        } while ((it = it->n) != config_iter);
../lib/public/nuklear.h:12831:    nk_tt_PackBegin(&baker->spc, 0, (int)*width, (int)max_height, 0, 1, alloc);
../lib/public/nuklear.h:12842:            custom_space.w = (nk_rp_coord)(custom->w);
../lib/public/nuklear.h:12843:            custom_space.h = (nk_rp_coord)(custom->h);
../lib/public/nuklear.h:12845:            nk_tt_PackSetOversampling(&baker->spc, 1, 1);
../lib/public/nuklear.h:12846:            nk_rp_pack_rects((struct nk_rp_context*)baker->spc.pack_info, &custom_space, 1);
../lib/public/nuklear.h:12849:            custom->x = (short)custom_space.x;
../lib/public/nuklear.h:12850:            custom->y = (short)custom_space.y;
../lib/public/nuklear.h:12851:            custom->w = (short)custom_space.w;
../lib/public/nuklear.h:12852:            custom->h = (short)custom_space.h;
../lib/public/nuklear.h:12857:            config_iter = config_iter->next) {
../lib/public/nuklear.h:12863:                struct nk_font_bake_data *tmp = &baker->build[input_i++];
../lib/public/nuklear.h:12867:                for (in_range = cfg->range; in_range[0] && in_range[1]; in_range += 2) {
../lib/public/nuklear.h:12868:                    glyph_count += (int)(in_range[1] - in_range[0]) + 1;
../lib/public/nuklear.h:12873:                tmp->ranges = baker->ranges + range_n;
../lib/public/nuklear.h:12874:                tmp->range_count = (nk_rune)range_count;
../lib/public/nuklear.h:12877:                    in_range = &cfg->range[i * 2];
../lib/public/nuklear.h:12878:                    tmp->ranges[i].font_size = cfg->size;
../lib/public/nuklear.h:12879:                    tmp->ranges[i].first_unicode_codepoint_in_range = (int)in_range[0];
../lib/public/nuklear.h:12880:                    tmp->ranges[i].num_chars = (int)(in_range[1]- in_range[0]) + 1;
../lib/public/nuklear.h:12881:                    tmp->ranges[i].chardata_for_range = baker->packed_chars + char_n;
../lib/public/nuklear.h:12882:                    char_n += tmp->ranges[i].num_chars;
../lib/public/nuklear.h:12886:                tmp->rects = baker->rects + rect_n;
../lib/public/nuklear.h:12888:                nk_tt_PackSetOversampling(&baker->spc, cfg->oversample_h, cfg->oversample_v);
../lib/public/nuklear.h:12889:                n = nk_tt_PackFontRangesGatherRects(&baker->spc, &tmp->info,
../lib/public/nuklear.h:12890:                    tmp->ranges, (int)tmp->range_count, tmp->rects);
../lib/public/nuklear.h:12891:                nk_rp_pack_rects((struct nk_rp_context*)baker->spc.pack_info, tmp->rects, (int)n);
../lib/public/nuklear.h:12895:                    if (tmp->rects[i].was_packed)
../lib/public/nuklear.h:12896:                        *height = NK_MAX(*height, tmp->rects[i].y + tmp->rects[i].h);
../lib/public/nuklear.h:12898:            } while ((it = it->n) != config_iter);
../lib/public/nuklear.h:12931:    baker->spc.pixels = (unsigned char*)image_memory;
../lib/public/nuklear.h:12932:    baker->spc.height = (int)height;
../lib/public/nuklear.h:12934:        config_iter = config_iter->next) {
../lib/public/nuklear.h:12937:            struct nk_font_bake_data *tmp = &baker->build[input_i++];
../lib/public/nuklear.h:12938:            nk_tt_PackSetOversampling(&baker->spc, cfg->oversample_h, cfg->oversample_v);
../lib/public/nuklear.h:12939:            nk_tt_PackFontRangesRenderIntoRects(&baker->spc, &tmp->info, tmp->ranges,
../lib/public/nuklear.h:12940:                (int)tmp->range_count, tmp->rects, &baker->alloc);
../lib/public/nuklear.h:12941:        } while ((it = it->n) != config_iter);
../lib/public/nuklear.h:12942:    } nk_tt_PackEnd(&baker->spc, &baker->alloc);
../lib/public/nuklear.h:12946:        config_iter = config_iter->next) {
../lib/public/nuklear.h:12952:            struct nk_font_bake_data *tmp = &baker->build[input_i++];
../lib/public/nuklear.h:12953:            struct nk_baked_font *dst_font = cfg->font;
../lib/public/nuklear.h:12955:            float font_scale = nk_tt_ScaleForPixelHeight(&tmp->info, cfg->size);
../lib/public/nuklear.h:12957:            nk_tt_GetFontVMetrics(&tmp->info, &unscaled_ascent, &unscaled_descent,
../lib/public/nuklear.h:12961:            if (!cfg->merge_mode) {
../lib/public/nuklear.h:12962:                dst_font->ranges = cfg->range;
../lib/public/nuklear.h:12963:                dst_font->height = cfg->size;
../lib/public/nuklear.h:12964:                dst_font->ascent = ((float)unscaled_ascent * font_scale);
../lib/public/nuklear.h:12965:                dst_font->descent = ((float)unscaled_descent * font_scale);
../lib/public/nuklear.h:12966:                dst_font->glyph_offset = glyph_n;
../lib/public/nuklear.h:12970:            for (i = 0; i < tmp->range_count; ++i) {
../lib/public/nuklear.h:12971:                struct nk_tt_pack_range *range = &tmp->ranges[i];
../lib/public/nuklear.h:12972:                for (char_idx = 0; char_idx < range->num_chars; char_idx++)
../lib/public/nuklear.h:12980:                    const struct nk_tt_packedchar *pc = &range->chardata_for_range[char_idx];
../lib/public/nuklear.h:12981:                    if (!pc->x0 && !pc->x1 && !pc->y0 && !pc->y1) continue;
../lib/public/nuklear.h:12982:                    codepoint = (nk_rune)(range->first_unicode_codepoint_in_range + char_idx);
../lib/public/nuklear.h:12983:                    nk_tt_GetPackedQuad(range->chardata_for_range, (int)width,
../lib/public/nuklear.h:12987:                    glyph = &glyphs[dst_font->glyph_offset + dst_font->glyph_count + (unsigned int)glyph_count];
../lib/public/nuklear.h:12988:                    glyph->codepoint = codepoint;
../lib/public/nuklear.h:12989:                    glyph->x0 = q.x0; glyph->y0 = q.y0;
../lib/public/nuklear.h:12990:                    glyph->x1 = q.x1; glyph->y1 = q.y1;
../lib/public/nuklear.h:12991:                    glyph->y0 += (dst_font->ascent + 0.5f);
../lib/public/nuklear.h:12992:                    glyph->y1 += (dst_font->ascent + 0.5f);
../lib/public/nuklear.h:12993:                    glyph->w = glyph->x1 - glyph->x0 + 0.5f;
../lib/public/nuklear.h:12994:                    glyph->h = glyph->y1 - glyph->y0;
../lib/public/nuklear.h:12996:                    if (cfg->coord_type == NK_COORD_PIXEL) {
../lib/public/nuklear.h:12997:                        glyph->u0 = q.s0 * (float)width;
../lib/public/nuklear.h:12998:                        glyph->v0 = q.t0 * (float)height;
../lib/public/nuklear.h:12999:                        glyph->u1 = q.s1 * (float)width;
../lib/public/nuklear.h:13000:                        glyph->v1 = q.t1 * (float)height;
../lib/public/nuklear.h:13002:                        glyph->u0 = q.s0;
../lib/public/nuklear.h:13003:                        glyph->v0 = q.t0;
../lib/public/nuklear.h:13004:                        glyph->u1 = q.s1;
../lib/public/nuklear.h:13005:                        glyph->v1 = q.t1;
../lib/public/nuklear.h:13007:                    glyph->xadvance = (pc->xadvance + cfg->spacing.x);
../lib/public/nuklear.h:13008:                    if (cfg->pixel_snap)
../lib/public/nuklear.h:13009:                        glyph->xadvance = (float)(int)(glyph->xadvance + 0.5f);
../lib/public/nuklear.h:13013:            dst_font->glyph_count += glyph_count;
../lib/public/nuklear.h:13015:        } while ((it = it->n) != config_iter);
../lib/public/nuklear.h:13062:    for (n = (int)(img_width * img_height); n > 0; n--)
../lib/public/nuklear.h:13066:/* -------------------------------------------------------------
../lib/public/nuklear.h:13070: * --------------------------------------------------------------*/
../lib/public/nuklear.h:13082:    NK_ASSERT(font->glyphs);
../lib/public/nuklear.h:13086:    scale = height/font->info.height;
../lib/public/nuklear.h:13095:        text_width += g->xadvance * scale;
../lib/public/nuklear.h:13098:        glyph_len = nk_utf_decode(text + text_len, &unicode, (int)len - text_len);
../lib/public/nuklear.h:13117:    NK_ASSERT(font->glyphs);
../lib/public/nuklear.h:13121:    scale = height/font->info.height;
../lib/public/nuklear.h:13123:    glyph->width = (g->x1 - g->x0) * scale;
../lib/public/nuklear.h:13124:    glyph->height = (g->y1 - g->y0) * scale;
../lib/public/nuklear.h:13125:    glyph->offset = nk_vec2(g->x0 * scale, g->y0 * scale);
../lib/public/nuklear.h:13126:    glyph->xadvance = (g->xadvance * scale);
../lib/public/nuklear.h:13127:    glyph->uv[0] = nk_vec2(g->u0, g->v0);
../lib/public/nuklear.h:13128:    glyph->uv[1] = nk_vec2(g->u1, g->v1);
../lib/public/nuklear.h:13141:    NK_ASSERT(font->glyphs);
../lib/public/nuklear.h:13142:    NK_ASSERT(font->info.ranges);
../lib/public/nuklear.h:13143:    if (!font || !font->glyphs) return 0;
../lib/public/nuklear.h:13145:    glyph = font->fallback;
../lib/public/nuklear.h:13146:    iter = font->config;
../lib/public/nuklear.h:13147:    do {count = nk_range_count(iter->range);
../lib/public/nuklear.h:13149:            nk_rune f = iter->range[(i*2)+0];
../lib/public/nuklear.h:13150:            nk_rune t = iter->range[(i*2)+1];
../lib/public/nuklear.h:13151:            int diff = (int)((t - f) + 1);
../lib/public/nuklear.h:13153:                return &font->glyphs[((nk_rune)total_glyphs + (unicode - f))];
../lib/public/nuklear.h:13156:    } while ((iter = iter->n) != font->config);
../lib/public/nuklear.h:13172:    font->fallback = 0;
../lib/public/nuklear.h:13173:    font->info = baked;
../lib/public/nuklear.h:13174:    font->scale = (float)pixel_height / (float)font->info.height;
../lib/public/nuklear.h:13175:    font->glyphs = &glyphs[baked_font->glyph_offset];
../lib/public/nuklear.h:13176:    font->texture = atlas;
../lib/public/nuklear.h:13177:    font->fallback_codepoint = fallback_codepoint;
../lib/public/nuklear.h:13178:    font->fallback = nk_font_find_glyph(font, fallback_codepoint);
../lib/public/nuklear.h:13180:    font->handle.height = font->info.height * font->scale;
../lib/public/nuklear.h:13181:    font->handle.width = nk_font_text_width;
../lib/public/nuklear.h:13182:    font->handle.userdata.ptr = font;
../lib/public/nuklear.h:13184:    font->handle.query = nk_font_query_font_glyph;
../lib/public/nuklear.h:13185:    font->handle.texture = font->texture;
../lib/public/nuklear.h:13189:/* ---------------------------------------------------------------------------
../lib/public/nuklear.h:13197: *-----------------------------------------------------------------------------*/
../lib/public/nuklear.h:13200:#pragma clang diagnostic ignored "-Woverlength-strings"
../lib/public/nuklear.h:13203:#pragma GCC diagnostic ignored "-Woverlength-strings"
../lib/public/nuklear.h:13209:    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
../lib/public/nuklear.h:13210:    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
../lib/public/nuklear.h:13211:    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
../lib/public/nuklear.h:13212:    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
../lib/public/nuklear.h:13213:    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
../lib/public/nuklear.h:13214:    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
../lib/public/nuklear.h:13215:    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
../lib/public/nuklear.h:13217:    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
../lib/public/nuklear.h:13219:    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
../lib/public/nuklear.h:13220:    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
../lib/public/nuklear.h:13221:    "_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
../lib/public/nuklear.h:13222:    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
../lib/public/nuklear.h:13223:    "/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
../lib/public/nuklear.h:13224:    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
../lib/public/nuklear.h:13225:    "OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
../lib/public/nuklear.h:13226:    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
../lib/public/nuklear.h:13227:    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
../lib/public/nuklear.h:13228:    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
../lib/public/nuklear.h:13229:    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
../lib/public/nuklear.h:13230:    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
../lib/public/nuklear.h:13231:    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
../lib/public/nuklear.h:13232:    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
../lib/public/nuklear.h:13233:    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
../lib/public/nuklear.h:13234:    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
../lib/public/nuklear.h:13235:    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
../lib/public/nuklear.h:13236:    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
../lib/public/nuklear.h:13237:    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
../lib/public/nuklear.h:13238:    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
../lib/public/nuklear.h:13239:    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
../lib/public/nuklear.h:13240:    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
../lib/public/nuklear.h:13241:    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
../lib/public/nuklear.h:13242:    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
../lib/public/nuklear.h:13243:    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
../lib/public/nuklear.h:13244:    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
../lib/public/nuklear.h:13245:    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
../lib/public/nuklear.h:13246:    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
../lib/public/nuklear.h:13247:    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
../lib/public/nuklear.h:13248:    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
../lib/public/nuklear.h:13249:    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
../lib/public/nuklear.h:13250:    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
../lib/public/nuklear.h:13251:    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
../lib/public/nuklear.h:13252:    "d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
../lib/public/nuklear.h:13253:    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
../lib/public/nuklear.h:13254:    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
../lib/public/nuklear.h:13256:    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
../lib/public/nuklear.h:13257:    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
../lib/public/nuklear.h:13258:    ":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
../lib/public/nuklear.h:13259:    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
../lib/public/nuklear.h:13261:    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
../lib/public/nuklear.h:13262:    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
../lib/public/nuklear.h:13263:    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
../lib/public/nuklear.h:13264:    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
../lib/public/nuklear.h:13265:    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
../lib/public/nuklear.h:13266:    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
../lib/public/nuklear.h:13267:    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
../lib/public/nuklear.h:13268:    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
../lib/public/nuklear.h:13269:    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
../lib/public/nuklear.h:13270:    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
../lib/public/nuklear.h:13271:    "S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
../lib/public/nuklear.h:13272:    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
../lib/public/nuklear.h:13273:    "+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
../lib/public/nuklear.h:13274:    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
../lib/public/nuklear.h:13275:    "?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
../lib/public/nuklear.h:13276:    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
../lib/public/nuklear.h:13277:    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
../lib/public/nuklear.h:13278:    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
../lib/public/nuklear.h:13279:    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
../lib/public/nuklear.h:13280:    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
../lib/public/nuklear.h:13281:    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
../lib/public/nuklear.h:13282:    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
../lib/public/nuklear.h:13283:    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
../lib/public/nuklear.h:13284:    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
../lib/public/nuklear.h:13285:    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
../lib/public/nuklear.h:13286:    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
../lib/public/nuklear.h:13287:    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
../lib/public/nuklear.h:13288:    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
../lib/public/nuklear.h:13289:    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
../lib/public/nuklear.h:13290:    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
../lib/public/nuklear.h:13291:    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
../lib/public/nuklear.h:13293:    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
../lib/public/nuklear.h:13294:    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";
../lib/public/nuklear.h:13302:    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX"
../lib/public/nuklear.h:13303:    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X"
../lib/public/nuklear.h:13304:    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X"
../lib/public/nuklear.h:13305:    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X"
../lib/public/nuklear.h:13306:    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X"
../lib/public/nuklear.h:13307:    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X"
../lib/public/nuklear.h:13308:    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX"
../lib/public/nuklear.h:13309:    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      "
../lib/public/nuklear.h:13310:    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       "
../lib/public/nuklear.h:13311:    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        "
../lib/public/nuklear.h:13312:    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         "
../lib/public/nuklear.h:13313:    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          "
../lib/public/nuklear.h:13314:    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           "
../lib/public/nuklear.h:13315:    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            "
../lib/public/nuklear.h:13316:    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           "
../lib/public/nuklear.h:13317:    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          "
../lib/public/nuklear.h:13318:    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          "
../lib/public/nuklear.h:13319:    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------"
../lib/public/nuklear.h:13320:    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           "
../lib/public/nuklear.h:13321:    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           "
../lib/public/nuklear.h:13322:    "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           "
../lib/public/nuklear.h:13323:    "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           "
../lib/public/nuklear.h:13324:    "------------        -    X    -           X           -X.....................X-           "
../lib/public/nuklear.h:13325:    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -           "
../lib/public/nuklear.h:13326:    "                                                      -  X..X           X..X  -           "
../lib/public/nuklear.h:13327:    "                                                      -   X.X           X.X   -           "
../lib/public/nuklear.h:13328:    "                                                      -    XX           XX    -           "
../lib/public/nuklear.h:13355:    while (length--) *nk__dout++ = *data++;
../lib/public/nuklear.h:13374:        if (*i >= 0x80)       nk__match(nk__dout-i[1]-1, (unsigned int)i[0] - 0x80 + 1), i += 2;
../lib/public/nuklear.h:13375:        else if (*i >= 0x40)  nk__match(nk__dout-(nk__in2(0) - 0x4000 + 1), (unsigned int)i[2]+1), i += 3;
../lib/public/nuklear.h:13376:        else /* *i >= 0x20 */ nk__lit(i+1, (unsigned int)i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
../lib/public/nuklear.h:13378:        if (*i >= 0x18)       nk__match(nk__dout-(unsigned int)(nk__in3(0) - 0x180000 + 1), (unsigned int)i[3]+1), i += 4;
../lib/public/nuklear.h:13379:        else if (*i >= 0x10)  nk__match(nk__dout-(unsigned int)(nk__in3(0) - 0x100000 + 1), (unsigned int)nk__in2(3)+1), i += 5;
../lib/public/nuklear.h:13380:        else if (*i >= 0x08)  nk__lit(i+2, (unsigned int)nk__in2(0) - 0x0800 + 1), i += 2 + (nk__in2(0) - 0x0800 + 1);
../lib/public/nuklear.h:13382:        else if (*i == 0x06)  nk__match(nk__dout-(unsigned int)(nk__in3(1)+1), i[4]+1u), i += 5;
../lib/public/nuklear.h:13383:        else if (*i == 0x04)  nk__match(nk__dout-(unsigned int)(nk__in3(1)+1), (unsigned int)nk__in2(4)+1u), i += 6;
../lib/public/nuklear.h:13412:        buflen -= (unsigned int)blocklen;
../lib/public/nuklear.h:13454:    return (unsigned int)((c >= '\\') ? c-36 : c-35);
../lib/public/nuklear.h:13468:        /* we can't assume little-endianess. */
../lib/public/nuklear.h:13479:/* -------------------------------------------------------------
../lib/public/nuklear.h:13483: * --------------------------------------------------------------*/
../lib/public/nuklear.h:13512:    atlas->temporary.userdata.ptr = 0;
../lib/public/nuklear.h:13513:    atlas->temporary.alloc = nk_malloc;
../lib/public/nuklear.h:13514:    atlas->temporary.free = nk_mfree;
../lib/public/nuklear.h:13515:    atlas->permanent.userdata.ptr = 0;
../lib/public/nuklear.h:13516:    atlas->permanent.alloc = nk_malloc;
../lib/public/nuklear.h:13517:    atlas->permanent.free = nk_mfree;
../lib/public/nuklear.h:13527:    atlas->permanent = *alloc;
../lib/public/nuklear.h:13528:    atlas->temporary = *alloc;
../lib/public/nuklear.h:13539:    atlas->permanent = *permanent;
../lib/public/nuklear.h:13540:    atlas->temporary = *temporary;
../lib/public/nuklear.h:13546:    NK_ASSERT(atlas->temporary.alloc && atlas->temporary.free);
../lib/public/nuklear.h:13547:    NK_ASSERT(atlas->permanent.alloc && atlas->permanent.free);
../lib/public/nuklear.h:13548:    if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free ||
../lib/public/nuklear.h:13549:        !atlas->temporary.alloc || !atlas->temporary.free) return;
../lib/public/nuklear.h:13550:    if (atlas->glyphs) {
../lib/public/nuklear.h:13551:        atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
../lib/public/nuklear.h:13552:        atlas->glyphs = 0;
../lib/public/nuklear.h:13554:    if (atlas->pixel) {
../lib/public/nuklear.h:13555:        atlas->permanent.free(atlas->permanent.userdata, atlas->pixel);
../lib/public/nuklear.h:13556:        atlas->pixel = 0;
../lib/public/nuklear.h:13566:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13567:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13568:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13569:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13572:    NK_ASSERT(config->ttf_blob);
../lib/public/nuklear.h:13573:    NK_ASSERT(config->ttf_size);
../lib/public/nuklear.h:13574:    NK_ASSERT(config->size > 0.0f);
../lib/public/nuklear.h:13576:    if (!atlas || !config || !config->ttf_blob || !config->ttf_size || config->size <= 0.0f||
../lib/public/nuklear.h:13577:        !atlas->permanent.alloc || !atlas->permanent.free ||
../lib/public/nuklear.h:13578:        !atlas->temporary.alloc || !atlas->temporary.free)
../lib/public/nuklear.h:13583:        atlas->permanent.alloc(atlas->permanent.userdata,0, sizeof(struct nk_font_config));
../lib/public/nuklear.h:13585:    cfg->n = cfg;
../lib/public/nuklear.h:13586:    cfg->p = cfg;
../lib/public/nuklear.h:13588:    if (!config->merge_mode) {
../lib/public/nuklear.h:13590:        if (!atlas->config) {
../lib/public/nuklear.h:13591:            atlas->config = cfg;
../lib/public/nuklear.h:13592:            cfg->next = 0;
../lib/public/nuklear.h:13594:            struct nk_font_config *i = atlas->config;
../lib/public/nuklear.h:13595:            while (i->next) i = i->next;
../lib/public/nuklear.h:13596:            i->next = cfg;
../lib/public/nuklear.h:13597:            cfg->next = 0;
../lib/public/nuklear.h:13601:            atlas->permanent.alloc(atlas->permanent.userdata,0, sizeof(struct nk_font));
../lib/public/nuklear.h:13605:        font->config = cfg;
../lib/public/nuklear.h:13608:        if (!atlas->fonts) {
../lib/public/nuklear.h:13609:            atlas->fonts = font;
../lib/public/nuklear.h:13610:            font->next = 0;
../lib/public/nuklear.h:13612:            struct nk_font *i = atlas->fonts;
../lib/public/nuklear.h:13613:            while (i->next) i = i->next;
../lib/public/nuklear.h:13614:            i->next = font;
../lib/public/nuklear.h:13615:            font->next = 0;
../lib/public/nuklear.h:13617:        cfg->font = &font->info;
../lib/public/nuklear.h:13622:        NK_ASSERT(atlas->font_num);
../lib/public/nuklear.h:13623:        f = atlas->fonts;
../lib/public/nuklear.h:13624:        c = f->config;
../lib/public/nuklear.h:13625:        cfg->font = &f->info;
../lib/public/nuklear.h:13627:        cfg->n = c;
../lib/public/nuklear.h:13628:        cfg->p = c->p;
../lib/public/nuklear.h:13629:        c->p->n = cfg;
../lib/public/nuklear.h:13630:        c->p = cfg;
../lib/public/nuklear.h:13633:    if (!config->ttf_data_owned_by_atlas) {
../lib/public/nuklear.h:13634:        cfg->ttf_blob = atlas->permanent.alloc(atlas->permanent.userdata,0, cfg->ttf_size);
../lib/public/nuklear.h:13635:        NK_ASSERT(cfg->ttf_blob);
../lib/public/nuklear.h:13636:        if (!cfg->ttf_blob) {
../lib/public/nuklear.h:13637:            atlas->font_num++;
../lib/public/nuklear.h:13640:        NK_MEMCPY(cfg->ttf_blob, config->ttf_blob, cfg->ttf_size);
../lib/public/nuklear.h:13641:        cfg->ttf_data_owned_by_atlas = 1;
../lib/public/nuklear.h:13643:    atlas->font_num++;
../lib/public/nuklear.h:13655:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13656:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13657:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13658:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13659:    if (!atlas || !atlas->temporary.alloc || !atlas->temporary.free || !memory || !size ||
../lib/public/nuklear.h:13660:        !atlas->permanent.alloc || !atlas->permanent.free)
../lib/public/nuklear.h:13680:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13681:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13682:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13683:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13686:    memory = nk_file_load(file_path, &size, &atlas->permanent);
../lib/public/nuklear.h:13707:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13708:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13709:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13710:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13714:    if (!atlas || !compressed_data || !atlas->temporary.alloc || !atlas->temporary.free ||
../lib/public/nuklear.h:13715:        !atlas->permanent.alloc || !atlas->permanent.free)
../lib/public/nuklear.h:13719:    decompressed_data = atlas->permanent.alloc(atlas->permanent.userdata,0,decompressed_size);
../lib/public/nuklear.h:13741:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13742:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13743:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13744:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13747:    if (!atlas || !data_base85 || !atlas->temporary.alloc || !atlas->temporary.free ||
../lib/public/nuklear.h:13748:        !atlas->permanent.alloc || !atlas->permanent.free)
../lib/public/nuklear.h:13752:    compressed_data = atlas->temporary.alloc(atlas->temporary.userdata,0, (nk_size)compressed_size);
../lib/public/nuklear.h:13758:    atlas->temporary.free(atlas->temporary.userdata, compressed_data);
../lib/public/nuklear.h:13768:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13769:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13770:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13771:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13787:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13788:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13789:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13790:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13795:        !atlas->temporary.alloc || !atlas->temporary.free ||
../lib/public/nuklear.h:13796:        !atlas->permanent.alloc || !atlas->permanent.free)
../lib/public/nuklear.h:13801:    if (!atlas->font_num)
../lib/public/nuklear.h:13802:        atlas->default_font = nk_font_atlas_add_default(atlas, 13.0f, 0);
../lib/public/nuklear.h:13804:    NK_ASSERT(atlas->font_num);
../lib/public/nuklear.h:13805:    if (!atlas->font_num) return 0;
../lib/public/nuklear.h:13808:    nk_font_baker_memory(&tmp_size, &atlas->glyph_count, atlas->config, atlas->font_num);
../lib/public/nuklear.h:13809:    tmp = atlas->temporary.alloc(atlas->temporary.userdata,0, tmp_size);
../lib/public/nuklear.h:13814:    baker = nk_font_baker(tmp, atlas->glyph_count, atlas->font_num, &atlas->temporary);
../lib/public/nuklear.h:13815:    atlas->glyphs = (struct nk_font_glyph*)atlas->permanent.alloc(
../lib/public/nuklear.h:13816:        atlas->permanent.userdata,0, sizeof(struct nk_font_glyph)*(nk_size)atlas->glyph_count);
../lib/public/nuklear.h:13817:    NK_ASSERT(atlas->glyphs);
../lib/public/nuklear.h:13818:    if (!atlas->glyphs)
../lib/public/nuklear.h:13822:    atlas->custom.w = (NK_CURSOR_DATA_W*2)+1;
../lib/public/nuklear.h:13823:    atlas->custom.h = NK_CURSOR_DATA_H + 1;
../lib/public/nuklear.h:13824:    if (!nk_font_bake_pack(baker, &img_size, width, height, &atlas->custom,
../lib/public/nuklear.h:13825:        atlas->config, atlas->font_num, &atlas->temporary))
../lib/public/nuklear.h:13829:    atlas->pixel = atlas->temporary.alloc(atlas->temporary.userdata,0, img_size);
../lib/public/nuklear.h:13830:    NK_ASSERT(atlas->pixel);
../lib/public/nuklear.h:13831:    if (!atlas->pixel)
../lib/public/nuklear.h:13835:    nk_font_bake(baker, atlas->pixel, *width, *height,
../lib/public/nuklear.h:13836:        atlas->glyphs, atlas->glyph_count, atlas->config, atlas->font_num);
../lib/public/nuklear.h:13837:    nk_font_bake_custom_data(atlas->pixel, *width, *height, atlas->custom,
../lib/public/nuklear.h:13842:        void *img_rgba = atlas->temporary.alloc(atlas->temporary.userdata,0,
../lib/public/nuklear.h:13846:        nk_font_bake_convert(img_rgba, *width, *height, atlas->pixel);
../lib/public/nuklear.h:13847:        atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
../lib/public/nuklear.h:13848:        atlas->pixel = img_rgba;
../lib/public/nuklear.h:13850:    atlas->tex_width = *width;
../lib/public/nuklear.h:13851:    atlas->tex_height = *height;
../lib/public/nuklear.h:13854:    for (font_iter = atlas->fonts; font_iter; font_iter = font_iter->next) {
../lib/public/nuklear.h:13856:        struct nk_font_config *config = font->config;
../lib/public/nuklear.h:13857:        nk_font_init(font, config->size, config->fallback_glyph, atlas->glyphs,
../lib/public/nuklear.h:13858:            config->font, nk_handle_ptr(0));
../lib/public/nuklear.h:13873:        struct nk_cursor *cursor = &atlas->cursors[i];
../lib/public/nuklear.h:13874:        cursor->img.w = (unsigned short)*width;
../lib/public/nuklear.h:13875:        cursor->img.h = (unsigned short)*height;
../lib/public/nuklear.h:13876:        cursor->img.region[0] = (unsigned short)(atlas->custom.x + nk_cursor_data[i][0].x);
../lib/public/nuklear.h:13877:        cursor->img.region[1] = (unsigned short)(atlas->custom.y + nk_cursor_data[i][0].y);
../lib/public/nuklear.h:13878:        cursor->img.region[2] = (unsigned short)nk_cursor_data[i][1].x;
../lib/public/nuklear.h:13879:        cursor->img.region[3] = (unsigned short)nk_cursor_data[i][1].y;
../lib/public/nuklear.h:13880:        cursor->size = nk_cursor_data[i][1];
../lib/public/nuklear.h:13881:        cursor->offset = nk_cursor_data[i][2];
../lib/public/nuklear.h:13884:    atlas->temporary.free(atlas->temporary.userdata, tmp);
../lib/public/nuklear.h:13885:    return atlas->pixel;
../lib/public/nuklear.h:13889:    if (tmp) atlas->temporary.free(atlas->temporary.userdata, tmp);
../lib/public/nuklear.h:13890:    if (atlas->glyphs) {
../lib/public/nuklear.h:13891:        atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
../lib/public/nuklear.h:13892:        atlas->glyphs = 0;
../lib/public/nuklear.h:13894:    if (atlas->pixel) {
../lib/public/nuklear.h:13895:        atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
../lib/public/nuklear.h:13896:        atlas->pixel = 0;
../lib/public/nuklear.h:13909:        null->texture = texture;
../lib/public/nuklear.h:13910:        null->uv = nk_vec2(0.5f,0.5f);
../lib/public/nuklear.h:13913:        null->texture = texture;
../lib/public/nuklear.h:13914:        null->uv.x = (atlas->custom.x + 0.5f)/(float)atlas->tex_width;
../lib/public/nuklear.h:13915:        null->uv.y = (atlas->custom.y + 0.5f)/(float)atlas->tex_height;
../lib/public/nuklear.h:13917:    for (font_iter = atlas->fonts; font_iter; font_iter = font_iter->next) {
../lib/public/nuklear.h:13918:        font_iter->texture = texture;
../lib/public/nuklear.h:13920:        font_iter->handle.texture = texture;
../lib/public/nuklear.h:13924:        atlas->cursors[i].img.handle = texture;
../lib/public/nuklear.h:13926:    atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
../lib/public/nuklear.h:13927:    atlas->pixel = 0;
../lib/public/nuklear.h:13928:    atlas->tex_width = 0;
../lib/public/nuklear.h:13929:    atlas->tex_height = 0;
../lib/public/nuklear.h:13930:    atlas->custom.x = 0;
../lib/public/nuklear.h:13931:    atlas->custom.y = 0;
../lib/public/nuklear.h:13932:    atlas->custom.w = 0;
../lib/public/nuklear.h:13933:    atlas->custom.h = 0;
../lib/public/nuklear.h:13939:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13940:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13941:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13942:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13943:    if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free) return;
../lib/public/nuklear.h:13944:    if (atlas->config) {
../lib/public/nuklear.h:13946:        for (iter = atlas->config; iter; iter = iter->next) {
../lib/public/nuklear.h:13948:            for (i = iter->n; i != iter; i = i->n) {
../lib/public/nuklear.h:13949:                atlas->permanent.free(atlas->permanent.userdata, i->ttf_blob);
../lib/public/nuklear.h:13950:                i->ttf_blob = 0;
../lib/public/nuklear.h:13952:            atlas->permanent.free(atlas->permanent.userdata, iter->ttf_blob);
../lib/public/nuklear.h:13953:            iter->ttf_blob = 0;
../lib/public/nuklear.h:13961:    NK_ASSERT(atlas->temporary.alloc);
../lib/public/nuklear.h:13962:    NK_ASSERT(atlas->temporary.free);
../lib/public/nuklear.h:13963:    NK_ASSERT(atlas->permanent.alloc);
../lib/public/nuklear.h:13964:    NK_ASSERT(atlas->permanent.free);
../lib/public/nuklear.h:13965:    if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free) return;
../lib/public/nuklear.h:13967:    if (atlas->config) {
../lib/public/nuklear.h:13969:        for (iter = atlas->config; iter; iter = next) {
../lib/public/nuklear.h:13971:            for (i = iter->n; i != iter; i = n) {
../lib/public/nuklear.h:13972:                n = i->n;
../lib/public/nuklear.h:13973:                if (i->ttf_blob)
../lib/public/nuklear.h:13974:                    atlas->permanent.free(atlas->permanent.userdata, i->ttf_blob);
../lib/public/nuklear.h:13975:                atlas->permanent.free(atlas->permanent.userdata, i);
../lib/public/nuklear.h:13977:            next = iter->next;
../lib/public/nuklear.h:13978:            if (i->ttf_blob)
../lib/public/nuklear.h:13979:                atlas->permanent.free(atlas->permanent.userdata, iter->ttf_blob);
../lib/public/nuklear.h:13980:            atlas->permanent.free(atlas->permanent.userdata, iter);
../lib/public/nuklear.h:13982:        atlas->config = 0;
../lib/public/nuklear.h:13984:    if (atlas->fonts) {
../lib/public/nuklear.h:13986:        for (iter = atlas->fonts; iter; iter = next) {
../lib/public/nuklear.h:13987:            next = iter->next;
../lib/public/nuklear.h:13988:            atlas->permanent.free(atlas->permanent.userdata, iter);
../lib/public/nuklear.h:13990:        atlas->fonts = 0;
../lib/public/nuklear.h:13992:    if (atlas->glyphs)
../lib/public/nuklear.h:13993:        atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
../lib/public/nuklear.h:14014:    in = &ctx->input;
../lib/public/nuklear.h:14016:        in->window_mouse.buttons[i].clicked = 0;
../lib/public/nuklear.h:14018:    in->keyboard.text_len = 0;
../lib/public/nuklear.h:14019:    in->window_mouse.scroll_delta = nk_vec2(0,0);
../lib/public/nuklear.h:14020:    in->window_mouse.prev.x = in->window_mouse.pos.x;
../lib/public/nuklear.h:14021:    in->window_mouse.prev.y = in->window_mouse.pos.y;
../lib/public/nuklear.h:14022:    in->window_mouse.delta.x = 0;
../lib/public/nuklear.h:14023:    in->window_mouse.delta.y = 0;
../lib/public/nuklear.h:14025:        in->keyboard.keys[i].clicked = 0;
../lib/public/nuklear.h:14033:    in = &ctx->input;
../lib/public/nuklear.h:14034:    if (in->window_mouse.grab)
../lib/public/nuklear.h:14035:        in->window_mouse.grab = 0;
../lib/public/nuklear.h:14036:    if (in->window_mouse.ungrab) {
../lib/public/nuklear.h:14037:        in->window_mouse.grabbed = 0;
../lib/public/nuklear.h:14038:        in->window_mouse.ungrab = 0;
../lib/public/nuklear.h:14039:        in->window_mouse.grab = 0;
../lib/public/nuklear.h:14048:    in = &ctx->input;
../lib/public/nuklear.h:14049:    in->window_mouse.pos.x = (float)x;
../lib/public/nuklear.h:14050:    in->window_mouse.pos.y = (float)y;
../lib/public/nuklear.h:14051:    in->window_mouse.delta.x = in->window_mouse.pos.x - in->window_mouse.prev.x;
../lib/public/nuklear.h:14052:    in->window_mouse.delta.y = in->window_mouse.pos.y - in->window_mouse.prev.y;
../lib/public/nuklear.h:14060:    in = &ctx->input;
../lib/public/nuklear.h:14062:    if (in->keyboard.keys[key].down != down)
../lib/public/nuklear.h:14063:        in->keyboard.keys[key].clicked++;
../lib/public/nuklear.h:14065:    in->keyboard.keys[key].clicked++;
../lib/public/nuklear.h:14067:    in->keyboard.keys[key].down = down;
../lib/public/nuklear.h:14076:    in = &ctx->input;
../lib/public/nuklear.h:14077:    if (in->window_mouse.buttons[id].down == down) return;
../lib/public/nuklear.h:14079:    btn = &in->window_mouse.buttons[id];
../lib/public/nuklear.h:14080:    btn->clicked_pos.x = (float)x;
../lib/public/nuklear.h:14081:    btn->clicked_pos.y = (float)y;
../lib/public/nuklear.h:14082:    btn->down = down;
../lib/public/nuklear.h:14083:    btn->clicked++;
../lib/public/nuklear.h:14090:    ctx->input.window_mouse.scroll_delta.x += val.x;
../lib/public/nuklear.h:14091:    ctx->input.window_mouse.scroll_delta.y += val.y;
../lib/public/nuklear.h:14102:    in = &ctx->input;
../lib/public/nuklear.h:14105:    if (len && ((in->keyboard.text_len + len) < NK_INPUT_MAX)) {
../lib/public/nuklear.h:14106:        nk_utf_encode(unicode, &in->keyboard.text[in->keyboard.text_len],
../lib/public/nuklear.h:14107:            NK_INPUT_MAX - in->keyboard.text_len);
../lib/public/nuklear.h:14108:        in->keyboard.text_len += len;
../lib/public/nuklear.h:14134:    btn = &i->mouse.buttons[id];
../lib/public/nuklear.h:14135:    return (btn->clicked && btn->down == nk_false) ? nk_true : nk_false;
../lib/public/nuklear.h:14143:    btn = &i->mouse.buttons[id];
../lib/public/nuklear.h:14144:    if (!NK_INBOX(btn->clicked_pos.x,btn->clicked_pos.y,b.x,b.y,b.w,b.h))
../lib/public/nuklear.h:14154:    btn = &i->mouse.buttons[id];
../lib/public/nuklear.h:14155:    return nk_input_has_mouse_click_in_rect(i, id, b) && (btn->down == down);
../lib/public/nuklear.h:14163:    btn = &i->mouse.buttons[id];
../lib/public/nuklear.h:14165:            btn->clicked) ? nk_true : nk_false;
../lib/public/nuklear.h:14173:    btn = &i->mouse.buttons[id];
../lib/public/nuklear.h:14175:            btn->clicked) ? nk_true : nk_false;
../lib/public/nuklear.h:14189:    return NK_INBOX(i->mouse.pos.x, i->mouse.pos.y, rect.x, rect.y, rect.w, rect.h);
../lib/public/nuklear.h:14195:    return NK_INBOX(i->mouse.prev.x, i->mouse.prev.y, rect.x, rect.y, rect.w, rect.h);
../lib/public/nuklear.h:14208:    return i->mouse.buttons[id].down;
../lib/public/nuklear.h:14215:    b = &i->mouse.buttons[id];
../lib/public/nuklear.h:14216:    if (b->down && b->clicked)
../lib/public/nuklear.h:14224:    return (!i->mouse.buttons[id].down && i->mouse.buttons[id].clicked);
../lib/public/nuklear.h:14231:    k = &i->keyboard.keys[key];
../lib/public/nuklear.h:14232:    if ((k->down && k->clicked) || (!k->down && k->clicked >= 2))
../lib/public/nuklear.h:14241:    k = &i->keyboard.keys[key];
../lib/public/nuklear.h:14242:    if ((!k->down && k->clicked) || (k->down && k->clicked >= 2))
../lib/public/nuklear.h:14251:    k = &i->keyboard.keys[key];
../lib/public/nuklear.h:14252:    if (k->down) return nk_true;
../lib/public/nuklear.h:14335:    i.data.texpath[sizeof(i.data.texpath)-1] = '\0';
../lib/public/nuklear.h:14346:    if (b->use_clipping) {
../lib/public/nuklear.h:14347:        const struct nk_rect *c = &b->clip;
../lib/public/nuklear.h:14348:        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
../lib/public/nuklear.h:14355:    cmd->x = (short)r.x;
../lib/public/nuklear.h:14356:    cmd->y = (short)r.y;
../lib/public/nuklear.h:14357:    cmd->w = (unsigned short)NK_MAX(0, r.w);
../lib/public/nuklear.h:14358:    cmd->h = (unsigned short)NK_MAX(0, r.h);
../lib/public/nuklear.h:14359:    cmd->col = col;
../lib/public/nuklear.h:14361:    strncpy(cmd->texpath, texpath, sizeof(cmd->texpath));
../lib/public/nuklear.h:14362:    cmd->texpath[sizeof(cmd->texpath)-1] = '\0';
../lib/public/nuklear.h:14393:    style = &ctx->style;
../lib/public/nuklear.h:14397:    text = &style->text;
../lib/public/nuklear.h:14398:    text->color = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14399:    text->padding = nk_vec2(0,0);
../lib/public/nuklear.h:14402:    button = &style->button;
../lib/public/nuklear.h:14404:    button->normal          = nk_style_item_color(table[NK_COLOR_BUTTON]);
../lib/public/nuklear.h:14405:    button->hover           = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
../lib/public/nuklear.h:14406:    button->active          = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
../lib/public/nuklear.h:14407:    button->border_color    = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14408:    button->text_background = table[NK_COLOR_BUTTON];
../lib/public/nuklear.h:14409:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14410:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14411:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14412:    button->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14413:    button->image_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14414:    button->touch_padding   = nk_vec2(0.0f, 0.0f);
../lib/public/nuklear.h:14415:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14416:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14417:    button->border          = 1.0f;
../lib/public/nuklear.h:14418:    button->rounding        = 4.0f;
../lib/public/nuklear.h:14419:    button->draw_begin      = 0;
../lib/public/nuklear.h:14420:    button->draw_end        = 0;
../lib/public/nuklear.h:14423:    button = &style->contextual_button;
../lib/public/nuklear.h:14425:    button->normal          = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14426:    button->hover           = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
../lib/public/nuklear.h:14427:    button->active          = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
../lib/public/nuklear.h:14428:    button->border_color    = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14429:    button->text_background = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14430:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14431:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14432:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14433:    button->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14434:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14435:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14436:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14437:    button->border          = 0.0f;
../lib/public/nuklear.h:14438:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14439:    button->draw_begin      = 0;
../lib/public/nuklear.h:14440:    button->draw_end        = 0;
../lib/public/nuklear.h:14443:    button = &style->menu_button;
../lib/public/nuklear.h:14445:    button->normal          = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14446:    button->hover           = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14447:    button->active          = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14448:    button->border_color    = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14449:    button->text_background = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14450:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14451:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14452:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14453:    button->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14454:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14455:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14456:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14457:    button->border          = 0.0f;
../lib/public/nuklear.h:14458:    button->rounding        = 1.0f;
../lib/public/nuklear.h:14459:    button->draw_begin      = 0;
../lib/public/nuklear.h:14460:    button->draw_end        = 0;
../lib/public/nuklear.h:14463:    toggle = &style->checkbox;
../lib/public/nuklear.h:14465:    toggle->normal          = nk_style_item_color(table[NK_COLOR_TOGGLE]);
../lib/public/nuklear.h:14466:    toggle->hover           = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
../lib/public/nuklear.h:14467:    toggle->active          = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
../lib/public/nuklear.h:14468:    toggle->cursor_normal   = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
../lib/public/nuklear.h:14469:    toggle->cursor_hover    = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
../lib/public/nuklear.h:14470:    toggle->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14471:    toggle->text_background = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14472:    toggle->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14473:    toggle->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14474:    toggle->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14475:    toggle->padding         = nk_vec2(2.0f, 2.0f);
../lib/public/nuklear.h:14476:    toggle->touch_padding   = nk_vec2(0,0);
../lib/public/nuklear.h:14477:    toggle->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14478:    toggle->border          = 0.0f;
../lib/public/nuklear.h:14479:    toggle->spacing         = 4;
../lib/public/nuklear.h:14482:    toggle = &style->option;
../lib/public/nuklear.h:14484:    toggle->normal          = nk_style_item_color(table[NK_COLOR_TOGGLE]);
../lib/public/nuklear.h:14485:    toggle->hover           = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
../lib/public/nuklear.h:14486:    toggle->active          = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
../lib/public/nuklear.h:14487:    toggle->cursor_normal   = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
../lib/public/nuklear.h:14488:    toggle->cursor_hover    = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
../lib/public/nuklear.h:14489:    toggle->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14490:    toggle->text_background = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14491:    toggle->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14492:    toggle->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14493:    toggle->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14494:    toggle->padding         = nk_vec2(3.0f, 3.0f);
../lib/public/nuklear.h:14495:    toggle->touch_padding   = nk_vec2(0,0);
../lib/public/nuklear.h:14496:    toggle->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14497:    toggle->border          = 0.0f;
../lib/public/nuklear.h:14498:    toggle->spacing         = 4;
../lib/public/nuklear.h:14501:    select = &style->selectable;
../lib/public/nuklear.h:14503:    select->normal          = nk_style_item_color(table[NK_COLOR_SELECT]);
../lib/public/nuklear.h:14504:    select->hover           = nk_style_item_color(table[NK_COLOR_SELECT]);
../lib/public/nuklear.h:14505:    select->pressed         = nk_style_item_color(table[NK_COLOR_SELECT]);
../lib/public/nuklear.h:14506:    select->normal_active   = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
../lib/public/nuklear.h:14507:    select->hover_active    = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
../lib/public/nuklear.h:14508:    select->pressed_active  = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
../lib/public/nuklear.h:14509:    select->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14510:    select->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14511:    select->text_pressed    = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14512:    select->text_normal_active  = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14513:    select->text_hover_active   = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14514:    select->text_pressed_active = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14515:    select->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14516:    select->image_padding   = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14517:    select->touch_padding   = nk_vec2(0,0);
../lib/public/nuklear.h:14518:    select->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14519:    select->rounding        = 0.0f;
../lib/public/nuklear.h:14520:    select->draw_begin      = 0;
../lib/public/nuklear.h:14521:    select->draw_end        = 0;
../lib/public/nuklear.h:14524:    slider = &style->slider;
../lib/public/nuklear.h:14526:    slider->normal          = nk_style_item_hide();
../lib/public/nuklear.h:14527:    slider->hover           = nk_style_item_hide();
../lib/public/nuklear.h:14528:    slider->active          = nk_style_item_hide();
../lib/public/nuklear.h:14529:    slider->bar_normal      = table[NK_COLOR_SLIDER];
../lib/public/nuklear.h:14530:    slider->bar_hover       = table[NK_COLOR_SLIDER];
../lib/public/nuklear.h:14531:    slider->bar_active      = table[NK_COLOR_SLIDER];
../lib/public/nuklear.h:14532:    slider->bar_filled      = table[NK_COLOR_SLIDER_CURSOR];
../lib/public/nuklear.h:14533:    slider->cursor_normal   = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
../lib/public/nuklear.h:14534:    slider->cursor_hover    = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
../lib/public/nuklear.h:14535:    slider->cursor_active   = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
../lib/public/nuklear.h:14536:    slider->inc_symbol      = NK_SYMBOL_TRIANGLE_RIGHT;
../lib/public/nuklear.h:14537:    slider->dec_symbol      = NK_SYMBOL_TRIANGLE_LEFT;
../lib/public/nuklear.h:14538:    slider->cursor_size     = nk_vec2(16,16);
../lib/public/nuklear.h:14539:    slider->padding         = nk_vec2(2,2);
../lib/public/nuklear.h:14540:    slider->spacing         = nk_vec2(2,2);
../lib/public/nuklear.h:14541:    slider->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14542:    slider->show_buttons    = nk_false;
../lib/public/nuklear.h:14543:    slider->bar_height      = 8;
../lib/public/nuklear.h:14544:    slider->rounding        = 0;
../lib/public/nuklear.h:14545:    slider->draw_begin      = 0;
../lib/public/nuklear.h:14546:    slider->draw_end        = 0;
../lib/public/nuklear.h:14549:    button = &style->slider.inc_button;
../lib/public/nuklear.h:14550:    button->normal          = nk_style_item_color(nk_rgb(40,40,40));
../lib/public/nuklear.h:14551:    button->hover           = nk_style_item_color(nk_rgb(42,42,42));
../lib/public/nuklear.h:14552:    button->active          = nk_style_item_color(nk_rgb(44,44,44));
../lib/public/nuklear.h:14553:    button->border_color    = nk_rgb(65,65,65);
../lib/public/nuklear.h:14554:    button->text_background = nk_rgb(40,40,40);
../lib/public/nuklear.h:14555:    button->text_normal     = nk_rgb(175,175,175);
../lib/public/nuklear.h:14556:    button->text_hover      = nk_rgb(175,175,175);
../lib/public/nuklear.h:14557:    button->text_active     = nk_rgb(175,175,175);
../lib/public/nuklear.h:14558:    button->padding         = nk_vec2(8.0f,8.0f);
../lib/public/nuklear.h:14559:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14560:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14561:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14562:    button->border          = 1.0f;
../lib/public/nuklear.h:14563:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14564:    button->draw_begin      = 0;
../lib/public/nuklear.h:14565:    button->draw_end        = 0;
../lib/public/nuklear.h:14566:    style->slider.dec_button = style->slider.inc_button;
../lib/public/nuklear.h:14569:    prog = &style->progress;
../lib/public/nuklear.h:14571:    prog->normal            = nk_style_item_color(table[NK_COLOR_SLIDER]);
../lib/public/nuklear.h:14572:    prog->hover             = nk_style_item_color(table[NK_COLOR_SLIDER]);
../lib/public/nuklear.h:14573:    prog->active            = nk_style_item_color(table[NK_COLOR_SLIDER]);
../lib/public/nuklear.h:14574:    prog->cursor_normal     = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
../lib/public/nuklear.h:14575:    prog->cursor_hover      = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
../lib/public/nuklear.h:14576:    prog->cursor_active     = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
../lib/public/nuklear.h:14577:    prog->border_color      = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14578:    prog->cursor_border_color = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14579:    prog->userdata          = nk_handle_ptr(0);
../lib/public/nuklear.h:14580:    prog->padding           = nk_vec2(4,4);
../lib/public/nuklear.h:14581:    prog->rounding          = 0;
../lib/public/nuklear.h:14582:    prog->border            = 0;
../lib/public/nuklear.h:14583:    prog->cursor_rounding   = 0;
../lib/public/nuklear.h:14584:    prog->cursor_border     = 0;
../lib/public/nuklear.h:14585:    prog->draw_begin        = 0;
../lib/public/nuklear.h:14586:    prog->draw_end          = 0;
../lib/public/nuklear.h:14589:    scroll = &style->scrollh;
../lib/public/nuklear.h:14591:    scroll->normal          = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
../lib/public/nuklear.h:14592:    scroll->hover           = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
../lib/public/nuklear.h:14593:    scroll->active          = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
../lib/public/nuklear.h:14594:    scroll->cursor_normal   = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR]);
../lib/public/nuklear.h:14595:    scroll->cursor_hover    = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_HOVER]);
../lib/public/nuklear.h:14596:    scroll->cursor_active   = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE]);
../lib/public/nuklear.h:14597:    scroll->dec_symbol      = NK_SYMBOL_CIRCLE_SOLID;
../lib/public/nuklear.h:14598:    scroll->inc_symbol      = NK_SYMBOL_CIRCLE_SOLID;
../lib/public/nuklear.h:14599:    scroll->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14600:    scroll->border_color    = table[NK_COLOR_SCROLLBAR];
../lib/public/nuklear.h:14601:    scroll->cursor_border_color = table[NK_COLOR_SCROLLBAR];
../lib/public/nuklear.h:14602:    scroll->padding         = nk_vec2(0,0);
../lib/public/nuklear.h:14603:    scroll->show_buttons    = nk_false;
../lib/public/nuklear.h:14604:    scroll->border          = 0;
../lib/public/nuklear.h:14605:    scroll->rounding        = 0;
../lib/public/nuklear.h:14606:    scroll->border_cursor   = 0;
../lib/public/nuklear.h:14607:    scroll->rounding_cursor = 0;
../lib/public/nuklear.h:14608:    scroll->draw_begin      = 0;
../lib/public/nuklear.h:14609:    scroll->draw_end        = 0;
../lib/public/nuklear.h:14610:    style->scrollv = style->scrollh;
../lib/public/nuklear.h:14613:    button = &style->scrollh.inc_button;
../lib/public/nuklear.h:14614:    button->normal          = nk_style_item_color(nk_rgb(40,40,40));
../lib/public/nuklear.h:14615:    button->hover           = nk_style_item_color(nk_rgb(42,42,42));
../lib/public/nuklear.h:14616:    button->active          = nk_style_item_color(nk_rgb(44,44,44));
../lib/public/nuklear.h:14617:    button->border_color    = nk_rgb(65,65,65);
../lib/public/nuklear.h:14618:    button->text_background = nk_rgb(40,40,40);
../lib/public/nuklear.h:14619:    button->text_normal     = nk_rgb(175,175,175);
../lib/public/nuklear.h:14620:    button->text_hover      = nk_rgb(175,175,175);
../lib/public/nuklear.h:14621:    button->text_active     = nk_rgb(175,175,175);
../lib/public/nuklear.h:14622:    button->padding         = nk_vec2(4.0f,4.0f);
../lib/public/nuklear.h:14623:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14624:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14625:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14626:    button->border          = 1.0f;
../lib/public/nuklear.h:14627:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14628:    button->draw_begin      = 0;
../lib/public/nuklear.h:14629:    button->draw_end        = 0;
../lib/public/nuklear.h:14630:    style->scrollh.dec_button = style->scrollh.inc_button;
../lib/public/nuklear.h:14631:    style->scrollv.inc_button = style->scrollh.inc_button;
../lib/public/nuklear.h:14632:    style->scrollv.dec_button = style->scrollh.inc_button;
../lib/public/nuklear.h:14635:    edit = &style->edit;
../lib/public/nuklear.h:14637:    edit->normal            = nk_style_item_color(table[NK_COLOR_EDIT]);
../lib/public/nuklear.h:14638:    edit->hover             = nk_style_item_color(table[NK_COLOR_EDIT]);
../lib/public/nuklear.h:14639:    edit->active            = nk_style_item_color(table[NK_COLOR_EDIT]);
../lib/public/nuklear.h:14640:    edit->cursor_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14641:    edit->cursor_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14642:    edit->cursor_text_normal= table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14643:    edit->cursor_text_hover = table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14644:    edit->border_color      = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14645:    edit->text_normal       = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14646:    edit->text_hover        = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14647:    edit->text_active       = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14648:    edit->selected_normal   = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14649:    edit->selected_hover    = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14650:    edit->selected_text_normal  = table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14651:    edit->selected_text_hover   = table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14652:    edit->scrollbar_size    = nk_vec2(10,10);
../lib/public/nuklear.h:14653:    edit->scrollbar         = style->scrollv;
../lib/public/nuklear.h:14654:    edit->padding           = nk_vec2(4,4);
../lib/public/nuklear.h:14655:    edit->row_padding       = 2;
../lib/public/nuklear.h:14656:    edit->cursor_size       = 4;
../lib/public/nuklear.h:14657:    edit->border            = 1;
../lib/public/nuklear.h:14658:    edit->rounding          = 0;
../lib/public/nuklear.h:14661:    property = &style->property;
../lib/public/nuklear.h:14663:    property->normal        = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14664:    property->hover         = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14665:    property->active        = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14666:    property->border_color  = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14667:    property->label_normal  = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14668:    property->label_hover   = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14669:    property->label_active  = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14670:    property->sym_left      = NK_SYMBOL_TRIANGLE_LEFT;
../lib/public/nuklear.h:14671:    property->sym_right     = NK_SYMBOL_TRIANGLE_RIGHT;
../lib/public/nuklear.h:14672:    property->userdata      = nk_handle_ptr(0);
../lib/public/nuklear.h:14673:    property->padding       = nk_vec2(4,4);
../lib/public/nuklear.h:14674:    property->border        = 1;
../lib/public/nuklear.h:14675:    property->rounding      = 10;
../lib/public/nuklear.h:14676:    property->draw_begin    = 0;
../lib/public/nuklear.h:14677:    property->draw_end      = 0;
../lib/public/nuklear.h:14680:    button = &style->property.dec_button;
../lib/public/nuklear.h:14682:    button->normal          = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14683:    button->hover           = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14684:    button->active          = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14685:    button->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14686:    button->text_background = table[NK_COLOR_PROPERTY];
../lib/public/nuklear.h:14687:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14688:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14689:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14690:    button->padding         = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14691:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14692:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14693:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14694:    button->border          = 0.0f;
../lib/public/nuklear.h:14695:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14696:    button->draw_begin      = 0;
../lib/public/nuklear.h:14697:    button->draw_end        = 0;
../lib/public/nuklear.h:14698:    style->property.inc_button = style->property.dec_button;
../lib/public/nuklear.h:14701:    edit = &style->property.edit;
../lib/public/nuklear.h:14703:    edit->normal            = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14704:    edit->hover             = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14705:    edit->active            = nk_style_item_color(table[NK_COLOR_PROPERTY]);
../lib/public/nuklear.h:14706:    edit->border_color      = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14707:    edit->cursor_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14708:    edit->cursor_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14709:    edit->cursor_text_normal= table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14710:    edit->cursor_text_hover = table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14711:    edit->text_normal       = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14712:    edit->text_hover        = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14713:    edit->text_active       = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14714:    edit->selected_normal   = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14715:    edit->selected_hover    = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14716:    edit->selected_text_normal  = table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14717:    edit->selected_text_hover   = table[NK_COLOR_EDIT];
../lib/public/nuklear.h:14718:    edit->padding           = nk_vec2(0,0);
../lib/public/nuklear.h:14719:    edit->cursor_size       = 8;
../lib/public/nuklear.h:14720:    edit->border            = 0;
../lib/public/nuklear.h:14721:    edit->rounding          = 0;
../lib/public/nuklear.h:14724:    chart = &style->chart;
../lib/public/nuklear.h:14726:    chart->background       = nk_style_item_color(table[NK_COLOR_CHART]);
../lib/public/nuklear.h:14727:    chart->border_color     = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14728:    chart->selected_color   = table[NK_COLOR_CHART_COLOR_HIGHLIGHT];
../lib/public/nuklear.h:14729:    chart->color            = table[NK_COLOR_CHART_COLOR];
../lib/public/nuklear.h:14730:    chart->padding          = nk_vec2(4,4);
../lib/public/nuklear.h:14731:    chart->border           = 0;
../lib/public/nuklear.h:14732:    chart->rounding         = 0;
../lib/public/nuklear.h:14735:    combo = &style->combo;
../lib/public/nuklear.h:14736:    combo->normal           = nk_style_item_color(table[NK_COLOR_COMBO]);
../lib/public/nuklear.h:14737:    combo->hover            = nk_style_item_color(table[NK_COLOR_COMBO]);
../lib/public/nuklear.h:14738:    combo->active           = nk_style_item_color(table[NK_COLOR_COMBO]);
../lib/public/nuklear.h:14739:    combo->border_color     = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14740:    combo->label_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14741:    combo->label_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14742:    combo->label_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14743:    combo->sym_normal       = NK_SYMBOL_TRIANGLE_DOWN;
../lib/public/nuklear.h:14744:    combo->sym_hover        = NK_SYMBOL_TRIANGLE_DOWN;
../lib/public/nuklear.h:14745:    combo->sym_active       = NK_SYMBOL_TRIANGLE_DOWN;
../lib/public/nuklear.h:14746:    combo->content_padding  = nk_vec2(4,4);
../lib/public/nuklear.h:14747:    combo->button_padding   = nk_vec2(0,4);
../lib/public/nuklear.h:14748:    combo->spacing          = nk_vec2(4,0);
../lib/public/nuklear.h:14749:    combo->border           = 1;
../lib/public/nuklear.h:14750:    combo->rounding         = 0;
../lib/public/nuklear.h:14753:    button = &style->combo.button;
../lib/public/nuklear.h:14755:    button->normal          = nk_style_item_color(table[NK_COLOR_COMBO]);
../lib/public/nuklear.h:14756:    button->hover           = nk_style_item_color(table[NK_COLOR_COMBO]);
../lib/public/nuklear.h:14757:    button->active          = nk_style_item_color(table[NK_COLOR_COMBO]);
../lib/public/nuklear.h:14758:    button->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14759:    button->text_background = table[NK_COLOR_COMBO];
../lib/public/nuklear.h:14760:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14761:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14762:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14763:    button->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14764:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14765:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14766:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14767:    button->border          = 0.0f;
../lib/public/nuklear.h:14768:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14769:    button->draw_begin      = 0;
../lib/public/nuklear.h:14770:    button->draw_end        = 0;
../lib/public/nuklear.h:14773:    tab = &style->tab;
../lib/public/nuklear.h:14774:    tab->background         = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
../lib/public/nuklear.h:14775:    tab->border_color       = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14776:    tab->text               = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14777:    tab->sym_minimize       = NK_SYMBOL_TRIANGLE_RIGHT;
../lib/public/nuklear.h:14778:    tab->sym_maximize       = NK_SYMBOL_TRIANGLE_DOWN;
../lib/public/nuklear.h:14779:    tab->padding            = nk_vec2(4,4);
../lib/public/nuklear.h:14780:    tab->spacing            = nk_vec2(4,4);
../lib/public/nuklear.h:14781:    tab->indent             = 10.0f;
../lib/public/nuklear.h:14782:    tab->border             = 1;
../lib/public/nuklear.h:14783:    tab->rounding           = 0;
../lib/public/nuklear.h:14786:    button = &style->tab.tab_minimize_button;
../lib/public/nuklear.h:14788:    button->normal          = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
../lib/public/nuklear.h:14789:    button->hover           = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
../lib/public/nuklear.h:14790:    button->active          = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
../lib/public/nuklear.h:14791:    button->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14792:    button->text_background = table[NK_COLOR_TAB_HEADER];
../lib/public/nuklear.h:14793:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14794:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14795:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14796:    button->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14797:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14798:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14799:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14800:    button->border          = 0.0f;
../lib/public/nuklear.h:14801:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14802:    button->draw_begin      = 0;
../lib/public/nuklear.h:14803:    button->draw_end        = 0;
../lib/public/nuklear.h:14804:    style->tab.tab_maximize_button =*button;
../lib/public/nuklear.h:14807:    button = &style->tab.node_minimize_button;
../lib/public/nuklear.h:14809:    button->normal          = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14810:    button->hover           = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14811:    button->active          = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14812:    button->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14813:    button->text_background = table[NK_COLOR_TAB_HEADER];
../lib/public/nuklear.h:14814:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14815:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14816:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14817:    button->padding         = nk_vec2(2.0f,2.0f);
../lib/public/nuklear.h:14818:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14819:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14820:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14821:    button->border          = 0.0f;
../lib/public/nuklear.h:14822:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14823:    button->draw_begin      = 0;
../lib/public/nuklear.h:14824:    button->draw_end        = 0;
../lib/public/nuklear.h:14825:    style->tab.node_maximize_button =*button;
../lib/public/nuklear.h:14828:    win = &style->window;
../lib/public/nuklear.h:14829:    win->header.align = NK_HEADER_RIGHT;
../lib/public/nuklear.h:14830:    win->header.close_symbol = NK_SYMBOL_X;
../lib/public/nuklear.h:14831:    win->header.minimize_symbol = NK_SYMBOL_MINUS;
../lib/public/nuklear.h:14832:    win->header.maximize_symbol = NK_SYMBOL_PLUS;
../lib/public/nuklear.h:14833:    win->header.normal = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14834:    win->header.hover = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14835:    win->header.active = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14836:    win->header.label_normal = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14837:    win->header.label_hover = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14838:    win->header.label_active = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14839:    win->header.label_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14840:    win->header.padding = nk_vec2(4,4);
../lib/public/nuklear.h:14841:    win->header.spacing = nk_vec2(0,0);
../lib/public/nuklear.h:14844:    button = &style->window.header.close_button;
../lib/public/nuklear.h:14846:    button->normal          = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14847:    button->hover           = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14848:    button->active          = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14849:    button->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14850:    button->text_background = table[NK_COLOR_HEADER];
../lib/public/nuklear.h:14851:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14852:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14853:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14854:    button->padding         = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14855:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14856:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14857:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14858:    button->border          = 0.0f;
../lib/public/nuklear.h:14859:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14860:    button->draw_begin      = 0;
../lib/public/nuklear.h:14861:    button->draw_end        = 0;
../lib/public/nuklear.h:14864:    button = &style->window.header.minimize_button;
../lib/public/nuklear.h:14866:    button->normal          = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14867:    button->hover           = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14868:    button->active          = nk_style_item_color(table[NK_COLOR_HEADER]);
../lib/public/nuklear.h:14869:    button->border_color    = nk_rgba(0,0,0,0);
../lib/public/nuklear.h:14870:    button->text_background = table[NK_COLOR_HEADER];
../lib/public/nuklear.h:14871:    button->text_normal     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14872:    button->text_hover      = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14873:    button->text_active     = table[NK_COLOR_TEXT];
../lib/public/nuklear.h:14874:    button->padding         = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14875:    button->touch_padding   = nk_vec2(0.0f,0.0f);
../lib/public/nuklear.h:14876:    button->userdata        = nk_handle_ptr(0);
../lib/public/nuklear.h:14877:    button->text_alignment  = NK_TEXT_CENTERED;
../lib/public/nuklear.h:14878:    button->border          = 0.0f;
../lib/public/nuklear.h:14879:    button->rounding        = 0.0f;
../lib/public/nuklear.h:14880:    button->draw_begin      = 0;
../lib/public/nuklear.h:14881:    button->draw_end        = 0;
../lib/public/nuklear.h:14884:    win->background = table[NK_COLOR_WINDOW];
../lib/public/nuklear.h:14885:    win->fixed_background = nk_style_item_color(table[NK_COLOR_WINDOW]);
../lib/public/nuklear.h:14886:    win->border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14887:    win->popup_border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14888:    win->combo_border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14889:    win->contextual_border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14890:    win->menu_border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14891:    win->group_border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14892:    win->tooltip_border_color = table[NK_COLOR_BORDER];
../lib/public/nuklear.h:14893:    win->scaler = nk_style_item_color(table[NK_COLOR_TEXT]);
../lib/public/nuklear.h:14895:    win->rounding = 0.0f;
../lib/public/nuklear.h:14896:    win->spacing = nk_vec2(4,4);
../lib/public/nuklear.h:14897:    win->scrollbar_size = nk_vec2(10,10);
../lib/public/nuklear.h:14898:    win->min_size = nk_vec2(64,64);
../lib/public/nuklear.h:14900:    win->combo_border = 1.0f;
../lib/public/nuklear.h:14901:    win->contextual_border = 1.0f;
../lib/public/nuklear.h:14902:    win->menu_border = 1.0f;
../lib/public/nuklear.h:14903:    win->group_border = 1.0f;
../lib/public/nuklear.h:14904:    win->tooltip_border = 1.0f;
../lib/public/nuklear.h:14905:    win->popup_border = 1.0f;
../lib/public/nuklear.h:14906:    win->border = 2.0f;
../lib/public/nuklear.h:14907:    win->min_row_height_padding = 8;
../lib/public/nuklear.h:14909:    win->padding = nk_vec2(4,4);
../lib/public/nuklear.h:14910:    win->group_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14911:    win->popup_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14912:    win->combo_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14913:    win->contextual_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14914:    win->menu_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14915:    win->tooltip_padding = nk_vec2(4,4);
../lib/public/nuklear.h:14924:    style = &ctx->style;
../lib/public/nuklear.h:14925:    style->font = font;
../lib/public/nuklear.h:14926:    ctx->stacks.fonts.head = 0;
../lib/public/nuklear.h:14927:    if (ctx->current)
../lib/public/nuklear.h:14939:    font_stack = &ctx->stacks.fonts;
../lib/public/nuklear.h:14940:    NK_ASSERT(font_stack->head < (int)NK_LEN(font_stack->elements));
../lib/public/nuklear.h:14941:    if (font_stack->head >= (int)NK_LEN(font_stack->elements))
../lib/public/nuklear.h:14944:    element = &font_stack->elements[font_stack->head++];
../lib/public/nuklear.h:14945:    element->address = &ctx->style.font;
../lib/public/nuklear.h:14946:    element->old_value = ctx->style.font;
../lib/public/nuklear.h:14947:    ctx->style.font = font;
../lib/public/nuklear.h:14959:    font_stack = &ctx->stacks.fonts;
../lib/public/nuklear.h:14960:    NK_ASSERT(font_stack->head > 0);
../lib/public/nuklear.h:14961:    if (font_stack->head < 1)
../lib/public/nuklear.h:14964:    element = &font_stack->elements[--font_stack->head];
../lib/public/nuklear.h:14965:    *element->address = element->old_value;
../lib/public/nuklear.h:14975:    type_stack = &ctx->stacks.stack;\
../lib/public/nuklear.h:14976:    NK_ASSERT(type_stack->head < (int)NK_LEN(type_stack->elements));\
../lib/public/nuklear.h:14977:    if (type_stack->head >= (int)NK_LEN(type_stack->elements))\
../lib/public/nuklear.h:14979:    element = &type_stack->elements[type_stack->head++];\
../lib/public/nuklear.h:14980:    element->address = address;\
../lib/public/nuklear.h:14981:    element->old_value = *address;\
../lib/public/nuklear.h:14992:    type_stack = &ctx->stacks.stack;\
../lib/public/nuklear.h:14993:    NK_ASSERT(type_stack->head > 0);\
../lib/public/nuklear.h:14994:    if (type_stack->head < 1)\
../lib/public/nuklear.h:14996:    element = &type_stack->elements[--type_stack->head];\
../lib/public/nuklear.h:14997:    *element->address = element->old_value;\
../lib/public/nuklear.h:15018:    style = &ctx->style;
../lib/public/nuklear.h:15019:    if (style->cursors[c]) {
../lib/public/nuklear.h:15020:        style->cursor_active = style->cursors[c];
../lib/public/nuklear.h:15028:    ctx->style.cursor_visible = nk_true;
../lib/public/nuklear.h:15033:    ctx->style.cursor_visible = nk_false;
../lib/public/nuklear.h:15042:    style = &ctx->style;
../lib/public/nuklear.h:15043:    style->cursors[cursor] = c;
../lib/public/nuklear.h:15052:    style = &ctx->style;
../lib/public/nuklear.h:15054:        style->cursors[i] = &cursors[i];
../lib/public/nuklear.h:15055:    style->cursor_visible = nk_true;
../lib/public/nuklear.h:15074:    ctx->seq = 1;
../lib/public/nuklear.h:15075:    if (font) ctx->style.font = font;
../lib/public/nuklear.h:15077:    nk_draw_list_init(&ctx->draw_list);
../lib/public/nuklear.h:15098:    nk_buffer_init_fixed(&ctx->memory, memory, size);
../lib/public/nuklear.h:15099:    ctx->use_pool = nk_false;
../lib/public/nuklear.h:15111:    ctx->memory = *cmds;
../lib/public/nuklear.h:15112:    if (pool->type == NK_BUFFER_FIXED) {
../lib/public/nuklear.h:15114:        nk_pool_init_fixed(&ctx->pool, pool->memory.ptr, pool->memory.size);
../lib/public/nuklear.h:15117:        struct nk_allocator *alloc = &pool->pool;
../lib/public/nuklear.h:15118:        nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
../lib/public/nuklear.h:15120:    ctx->use_pool = nk_true;
../lib/public/nuklear.h:15130:    nk_buffer_init(&ctx->memory, alloc, NK_DEFAULT_COMMAND_BUFFER_SIZE);
../lib/public/nuklear.h:15131:    nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
../lib/public/nuklear.h:15132:    ctx->use_pool = nk_true;
../lib/public/nuklear.h:15140:    ctx->userdata = handle;
../lib/public/nuklear.h:15141:    if (ctx->current)
../lib/public/nuklear.h:15142:        ctx->current->buffer.userdata = handle;
../lib/public/nuklear.h:15150:    nk_buffer_free(&ctx->memory);
../lib/public/nuklear.h:15151:    if (ctx->use_pool)
../lib/public/nuklear.h:15152:        nk_pool_free(&ctx->pool);
../lib/public/nuklear.h:15154:    nk_zero(&ctx->input, sizeof(ctx->input));
../lib/public/nuklear.h:15155:    nk_zero(&ctx->style, sizeof(ctx->style));
../lib/public/nuklear.h:15156:    nk_zero(&ctx->memory, sizeof(ctx->memory));
../lib/public/nuklear.h:15158:    ctx->seq = 0;
../lib/public/nuklear.h:15159:    ctx->build = 0;
../lib/public/nuklear.h:15160:    ctx->begin = 0;
../lib/public/nuklear.h:15161:    ctx->end = 0;
../lib/public/nuklear.h:15162:    ctx->active = 0;
../lib/public/nuklear.h:15163:    ctx->current = 0;
../lib/public/nuklear.h:15164:    ctx->freelist = 0;
../lib/public/nuklear.h:15165:    ctx->count = 0;
../lib/public/nuklear.h:15175:    if (ctx->use_pool)
../lib/public/nuklear.h:15176:        nk_buffer_clear(&ctx->memory);
../lib/public/nuklear.h:15177:    else nk_buffer_reset(&ctx->memory, NK_BUFFER_FRONT);
../lib/public/nuklear.h:15179:    ctx->build = 0;
../lib/public/nuklear.h:15180:    ctx->memory.calls = 0;
../lib/public/nuklear.h:15181:    ctx->last_widget_state = 0;
../lib/public/nuklear.h:15182:    ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
../lib/public/nuklear.h:15183:    NK_MEMSET(&ctx->overlay, 0, sizeof(ctx->overlay));
../lib/public/nuklear.h:15186:    iter = ctx->begin;
../lib/public/nuklear.h:15189:        if ((iter->flags & NK_WINDOW_MINIMIZED) &&
../lib/public/nuklear.h:15190:            !(iter->flags & NK_WINDOW_CLOSED) &&
../lib/public/nuklear.h:15191:            iter->seq == ctx->seq) {
../lib/public/nuklear.h:15192:            iter = iter->next;
../lib/public/nuklear.h:15196:        if (((iter->flags & NK_WINDOW_HIDDEN) ||
../lib/public/nuklear.h:15197:            (iter->flags & NK_WINDOW_CLOSED)) &&
../lib/public/nuklear.h:15198:            iter == ctx->active) {
../lib/public/nuklear.h:15199:            ctx->active = iter->prev;
../lib/public/nuklear.h:15200:            ctx->end = iter->prev;
../lib/public/nuklear.h:15201:            if (!ctx->end)
../lib/public/nuklear.h:15202:                ctx->begin = 0;
../lib/public/nuklear.h:15203:            if (ctx->active)
../lib/public/nuklear.h:15204:                ctx->active->flags &= ~(unsigned)NK_WINDOW_ROM;
../lib/public/nuklear.h:15207:        if (iter->popup.win && iter->popup.win->seq != ctx->seq) {
../lib/public/nuklear.h:15208:            nk_free_window(ctx, iter->popup.win);
../lib/public/nuklear.h:15209:            iter->popup.win = 0;
../lib/public/nuklear.h:15212:        {struct nk_table *n, *it = iter->tables;
../lib/public/nuklear.h:15214:            n = it->next;
../lib/public/nuklear.h:15215:            if (it->seq != ctx->seq) {
../lib/public/nuklear.h:15219:                if (it == iter->tables)
../lib/public/nuklear.h:15220:                    iter->tables = n;
../lib/public/nuklear.h:15224:        if (iter->seq != ctx->seq || iter->flags & NK_WINDOW_CLOSED) {
../lib/public/nuklear.h:15225:            next = iter->next;
../lib/public/nuklear.h:15229:        } else iter = iter->next;
../lib/public/nuklear.h:15231:    ctx->seq++;
../lib/public/nuklear.h:15239:    buffer->begin = ctx->memory.allocated;
../lib/public/nuklear.h:15240:    buffer->end = buffer->begin;
../lib/public/nuklear.h:15241:    buffer->last = buffer->begin;
../lib/public/nuklear.h:15242:    buffer->clip = nk_null_rect;
../lib/public/nuklear.h:15249:    nk_start_buffer(ctx, &win->buffer);
../lib/public/nuklear.h:15260:    buf = &win->popup.buf;
../lib/public/nuklear.h:15261:    buf->begin = win->buffer.end;
../lib/public/nuklear.h:15262:    buf->end = win->buffer.end;
../lib/public/nuklear.h:15263:    buf->parent = win->buffer.last;
../lib/public/nuklear.h:15264:    buf->last = buf->begin;
../lib/public/nuklear.h:15265:    buf->active = nk_true;
../lib/public/nuklear.h:15275:    buf = &win->popup.buf;
../lib/public/nuklear.h:15276:    buf->last = win->buffer.last;
../lib/public/nuklear.h:15277:    buf->end = win->buffer.end;
../lib/public/nuklear.h:15285:    buffer->end = ctx->memory.allocated;
../lib/public/nuklear.h:15297:    nk_finish_buffer(ctx, &win->buffer);
../lib/public/nuklear.h:15298:    if (!win->popup.buf.active) return;
../lib/public/nuklear.h:15300:    buf = &win->popup.buf;
../lib/public/nuklear.h:15301:    memory = ctx->memory.memory.ptr;
../lib/public/nuklear.h:15302:    parent_last = nk_ptr_add(struct nk_command, memory, buf->parent);
../lib/public/nuklear.h:15303:    parent_last->next = buf->end;
../lib/public/nuklear.h:15313:    if (!ctx->style.cursor_active)
../lib/public/nuklear.h:15314:        ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
../lib/public/nuklear.h:15315:    if (ctx->style.cursor_active && !ctx->input.mouse.grabbed && ctx->style.cursor_visible) {
../lib/public/nuklear.h:15317:        const struct nk_cursor *cursor = ctx->style.cursor_active;
../lib/public/nuklear.h:15318:        nk_command_buffer_init(&ctx->overlay, &ctx->memory, NK_CLIPPING_OFF);
../lib/public/nuklear.h:15319:        nk_start_buffer(ctx, &ctx->overlay);
../lib/public/nuklear.h:15321:        mouse_bounds.x = ctx->input.mouse.pos.x - cursor->offset.x;
../lib/public/nuklear.h:15322:        mouse_bounds.y = ctx->input.mouse.pos.y - cursor->offset.y;
../lib/public/nuklear.h:15323:        mouse_bounds.w = cursor->size.x;
../lib/public/nuklear.h:15324:        mouse_bounds.h = cursor->size.y;
../lib/public/nuklear.h:15326:        nk_draw_image(&ctx->overlay, mouse_bounds, &cursor->img, nk_white);
../lib/public/nuklear.h:15327:        nk_finish_buffer(ctx, &ctx->overlay);
../lib/public/nuklear.h:15330:    it = ctx->begin;
../lib/public/nuklear.h:15331:    buffer = (nk_byte*)ctx->memory.memory.ptr;
../lib/public/nuklear.h:15333:        struct nk_window *next = it->next;
../lib/public/nuklear.h:15334:        if (it->buffer.last == it->buffer.begin || (it->flags & NK_WINDOW_HIDDEN)||
../lib/public/nuklear.h:15335:            it->seq != ctx->seq)
../lib/public/nuklear.h:15338:        cmd = nk_ptr_add(struct nk_command, buffer, it->buffer.last);
../lib/public/nuklear.h:15339:        while (next && ((next->buffer.last == next->buffer.begin) ||
../lib/public/nuklear.h:15340:            (next->flags & NK_WINDOW_HIDDEN) || next->seq != ctx->seq))
../lib/public/nuklear.h:15341:            next = next->next; /* skip empty command buffers */
../lib/public/nuklear.h:15343:        if (next) cmd->next = next->buffer.begin;
../lib/public/nuklear.h:15347:    it = ctx->begin;
../lib/public/nuklear.h:15349:        struct nk_window *next = it->next;
../lib/public/nuklear.h:15351:        if (!it->popup.buf.active)
../lib/public/nuklear.h:15354:        buf = &it->popup.buf;
../lib/public/nuklear.h:15355:        cmd->next = buf->begin;
../lib/public/nuklear.h:15356:        cmd = nk_ptr_add(struct nk_command, buffer, buf->last);
../lib/public/nuklear.h:15357:        buf->active = nk_false;
../lib/public/nuklear.h:15362:        if (ctx->overlay.end != ctx->overlay.begin)
../lib/public/nuklear.h:15363:            cmd->next = ctx->overlay.begin;
../lib/public/nuklear.h:15364:        else cmd->next = ctx->memory.allocated;
../lib/public/nuklear.h:15374:    if (!ctx->count) return 0;
../lib/public/nuklear.h:15376:    buffer = (nk_byte*)ctx->memory.memory.ptr;
../lib/public/nuklear.h:15377:    if (!ctx->build) {
../lib/public/nuklear.h:15379:        ctx->build = nk_true;
../lib/public/nuklear.h:15381:    iter = ctx->begin;
../lib/public/nuklear.h:15382:    while (iter && ((iter->buffer.begin == iter->buffer.end) ||
../lib/public/nuklear.h:15383:        (iter->flags & NK_WINDOW_HIDDEN) || iter->seq != ctx->seq))
../lib/public/nuklear.h:15384:        iter = iter->next;
../lib/public/nuklear.h:15386:    return nk_ptr_add_const(struct nk_command, buffer, iter->buffer.begin);
../lib/public/nuklear.h:15395:    if (!ctx || !cmd || !ctx->count) return 0;
../lib/public/nuklear.h:15396:    if (cmd->next >= ctx->memory.allocated) return 0;
../lib/public/nuklear.h:15397:    buffer = (nk_byte*)ctx->memory.memory.ptr;
../lib/public/nuklear.h:15398:    next = nk_ptr_add_const(struct nk_command, buffer, cmd->next);
../lib/public/nuklear.h:15417:    pool->alloc = *alloc;
../lib/public/nuklear.h:15418:    pool->capacity = capacity;
../lib/public/nuklear.h:15419:    pool->type = NK_BUFFER_DYNAMIC;
../lib/public/nuklear.h:15420:    pool->pages = 0;
../lib/public/nuklear.h:15425:    struct nk_page *iter = pool->pages;
../lib/public/nuklear.h:15427:    if (pool->type == NK_BUFFER_FIXED) return;
../lib/public/nuklear.h:15429:        struct nk_page *next = iter->next;
../lib/public/nuklear.h:15430:        pool->alloc.free(pool->alloc.userdata, iter);
../lib/public/nuklear.h:15440:    pool->capacity = (unsigned)(size - sizeof(struct nk_page)) / sizeof(struct nk_page_element);
../lib/public/nuklear.h:15441:    pool->pages = (struct nk_page*)memory;
../lib/public/nuklear.h:15442:    pool->type = NK_BUFFER_FIXED;
../lib/public/nuklear.h:15443:    pool->size = size;
../lib/public/nuklear.h:15448:    if (!pool->pages || pool->pages->size >= pool->capacity) {
../lib/public/nuklear.h:15451:        if (pool->type == NK_BUFFER_FIXED) {
../lib/public/nuklear.h:15452:            NK_ASSERT(pool->pages);
../lib/public/nuklear.h:15453:            if (!pool->pages) return 0;
../lib/public/nuklear.h:15454:            NK_ASSERT(pool->pages->size < pool->capacity);
../lib/public/nuklear.h:15459:            page = (struct nk_page*)pool->alloc.alloc(pool->alloc.userdata,0, size);
../lib/public/nuklear.h:15460:            page->next = pool->pages;
../lib/public/nuklear.h:15461:            pool->pages = page;
../lib/public/nuklear.h:15462:            page->size = 0;
../lib/public/nuklear.h:15464:    } return &pool->pages->win[pool->pages->size++];
../lib/public/nuklear.h:15480:    if (ctx->freelist) {
../lib/public/nuklear.h:15482:        elem = ctx->freelist;
../lib/public/nuklear.h:15483:        ctx->freelist = elem->next;
../lib/public/nuklear.h:15484:    } else if (ctx->use_pool) {
../lib/public/nuklear.h:15486:        elem = nk_pool_alloc(&ctx->pool);
../lib/public/nuklear.h:15493:        elem = (struct nk_page_element*)nk_buffer_alloc(&ctx->memory, NK_BUFFER_BACK, size, align);
../lib/public/nuklear.h:15498:    elem->next = 0;
../lib/public/nuklear.h:15499:    elem->prev = 0;
../lib/public/nuklear.h:15507:    if (!ctx->freelist) {
../lib/public/nuklear.h:15508:        ctx->freelist = elem;
../lib/public/nuklear.h:15510:        elem->next = ctx->freelist;
../lib/public/nuklear.h:15511:        ctx->freelist = elem;
../lib/public/nuklear.h:15518:    if (ctx->use_pool) {
../lib/public/nuklear.h:15524:    void *buffer_end = (nk_byte*)ctx->memory.memory.ptr + ctx->memory.size;
../lib/public/nuklear.h:15526:        ctx->memory.size -= sizeof(struct nk_page_element);
../lib/public/nuklear.h:15546:    return &elem->data.tbl;
../lib/public/nuklear.h:15558:    if (!win->tables) {
../lib/public/nuklear.h:15559:        win->tables = tbl;
../lib/public/nuklear.h:15560:        tbl->next = 0;
../lib/public/nuklear.h:15561:        tbl->prev = 0;
../lib/public/nuklear.h:15562:        tbl->size = 0;
../lib/public/nuklear.h:15563:        win->table_count = 1;
../lib/public/nuklear.h:15566:    win->tables->prev = tbl;
../lib/public/nuklear.h:15567:    tbl->next = win->tables;
../lib/public/nuklear.h:15568:    tbl->prev = 0;
../lib/public/nuklear.h:15569:    tbl->size = 0;
../lib/public/nuklear.h:15570:    win->tables = tbl;
../lib/public/nuklear.h:15571:    win->table_count++;
../lib/public/nuklear.h:15576:    if (win->tables == tbl)
../lib/public/nuklear.h:15577:        win->tables = tbl->next;
../lib/public/nuklear.h:15578:    if (tbl->next)
../lib/public/nuklear.h:15579:        tbl->next->prev = tbl->prev;
../lib/public/nuklear.h:15580:    if (tbl->prev)
../lib/public/nuklear.h:15581:        tbl->prev->next = tbl->next;
../lib/public/nuklear.h:15582:    tbl->next = 0;
../lib/public/nuklear.h:15583:    tbl->prev = 0;
../lib/public/nuklear.h:15592:    if (!win->tables || win->tables->size >= NK_VALUE_PAGE_CAPACITY) {
../lib/public/nuklear.h:15598:    win->tables->seq = win->seq;
../lib/public/nuklear.h:15599:    win->tables->keys[win->tables->size] = name;
../lib/public/nuklear.h:15600:    win->tables->values[win->tables->size] = value;
../lib/public/nuklear.h:15601:    return &win->tables->values[win->tables->size++];
../lib/public/nuklear.h:15606:    struct nk_table *iter = win->tables;
../lib/public/nuklear.h:15609:        unsigned int size = iter->size;
../lib/public/nuklear.h:15611:            if (iter->keys[i] == name) {
../lib/public/nuklear.h:15612:                iter->seq = win->seq;
../lib/public/nuklear.h:15613:                return &iter->values[i];
../lib/public/nuklear.h:15616:        iter = iter->next;
../lib/public/nuklear.h:15637:    return &elem->data.pan;
../lib/public/nuklear.h:15660:    case NK_PANEL_WINDOW: return style->window.padding;
../lib/public/nuklear.h:15661:    case NK_PANEL_GROUP: return style->window.group_padding;
../lib/public/nuklear.h:15662:    case NK_PANEL_POPUP: return style->window.popup_padding;
../lib/public/nuklear.h:15663:    case NK_PANEL_CONTEXTUAL: return style->window.contextual_padding;
../lib/public/nuklear.h:15664:    case NK_PANEL_COMBO: return style->window.combo_padding;
../lib/public/nuklear.h:15665:    case NK_PANEL_MENU: return style->window.menu_padding;
../lib/public/nuklear.h:15666:    case NK_PANEL_TOOLTIP: return style->window.menu_padding;}
../lib/public/nuklear.h:15675:        case NK_PANEL_WINDOW: return style->window.border;
../lib/public/nuklear.h:15676:        case NK_PANEL_GROUP: return style->window.group_border;
../lib/public/nuklear.h:15677:        case NK_PANEL_POPUP: return style->window.popup_border;
../lib/public/nuklear.h:15678:        case NK_PANEL_CONTEXTUAL: return style->window.contextual_border;
../lib/public/nuklear.h:15679:        case NK_PANEL_COMBO: return style->window.combo_border;
../lib/public/nuklear.h:15680:        case NK_PANEL_MENU: return style->window.menu_border;
../lib/public/nuklear.h:15681:        case NK_PANEL_TOOLTIP: return style->window.menu_border;
../lib/public/nuklear.h:15689:    case NK_PANEL_WINDOW: return style->window.border_color;
../lib/public/nuklear.h:15690:    case NK_PANEL_GROUP: return style->window.group_border_color;
../lib/public/nuklear.h:15691:    case NK_PANEL_POPUP: return style->window.popup_border_color;
../lib/public/nuklear.h:15692:    case NK_PANEL_CONTEXTUAL: return style->window.contextual_border_color;
../lib/public/nuklear.h:15693:    case NK_PANEL_COMBO: return style->window.combo_border_color;
../lib/public/nuklear.h:15694:    case NK_PANEL_MENU: return style->window.menu_border_color;
../lib/public/nuklear.h:15695:    case NK_PANEL_TOOLTIP: return style->window.menu_border_color;}
../lib/public/nuklear.h:15721:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:15722:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:15723:    if (!ctx || !ctx->current || !ctx->current->layout) return 0;
../lib/public/nuklear.h:15724:    nk_zero(ctx->current->layout, sizeof(*ctx->current->layout));
../lib/public/nuklear.h:15725:    if ((ctx->current->flags & NK_WINDOW_HIDDEN) || (ctx->current->flags & NK_WINDOW_CLOSED)) {
../lib/public/nuklear.h:15726:        nk_zero(ctx->current->layout, sizeof(struct nk_panel));
../lib/public/nuklear.h:15727:        ctx->current->layout->type = panel_type;
../lib/public/nuklear.h:15731:    style = &ctx->style;
../lib/public/nuklear.h:15732:    font = style->font;
../lib/public/nuklear.h:15733:    win = ctx->current;
../lib/public/nuklear.h:15734:    layout = win->layout;
../lib/public/nuklear.h:15735:    out = &win->buffer;
../lib/public/nuklear.h:15736:    in = (win->flags & NK_WINDOW_NO_INPUT) ? 0: &ctx->input;
../lib/public/nuklear.h:15738:    win->buffer.userdata = ctx->userdata;
../lib/public/nuklear.h:15741:    scrollbar_size = style->window.scrollbar_size;
../lib/public/nuklear.h:15744:    win->minimized = 0;
../lib/public/nuklear.h:15745:    win->maximized = 0;
../lib/public/nuklear.h:15748:    if ((win->flags & NK_WINDOW_MOVABLE) && !(win->flags & NK_WINDOW_ROM)) {
../lib/public/nuklear.h:15755:        header.x = win->bounds.x;
../lib/public/nuklear.h:15756:        header.y = win->bounds.y;
../lib/public/nuklear.h:15757:        header.w = win->bounds.w;
../lib/public/nuklear.h:15758:        if (nk_panel_has_header(win->flags, title)) {
../lib/public/nuklear.h:15759:            header.h = font->height + 2.0f * style->window.header.padding.y;
../lib/public/nuklear.h:15760:            header.h += 2.0f * style->window.header.label_padding.y;
../lib/public/nuklear.h:15764:        left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
../lib/public/nuklear.h:15765:        left_mouse_clicked = (int)in->mouse.buttons[NK_BUTTON_LEFT].clicked;
../lib/public/nuklear.h:15769:            win->bounds.x = win->bounds.x + in->mouse.delta.x;
../lib/public/nuklear.h:15770:            win->bounds.y = win->bounds.y + in->mouse.delta.y;
../lib/public/nuklear.h:15771:            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x += in->mouse.delta.x;
../lib/public/nuklear.h:15772:            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y += in->mouse.delta.y;
../lib/public/nuklear.h:15773:            ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_MOVE];
../lib/public/nuklear.h:15778:    layout->type = panel_type;
../lib/public/nuklear.h:15779:    layout->flags = win->flags;
../lib/public/nuklear.h:15780:    layout->bounds = win->bounds;
../lib/public/nuklear.h:15781:    layout->bounds.x += panel_padding.x;
../lib/public/nuklear.h:15782:    layout->bounds.w -= 2*panel_padding.x;
../lib/public/nuklear.h:15783:    if (win->flags & NK_WINDOW_BORDER) {
../lib/public/nuklear.h:15784:        layout->border = nk_panel_get_border(style, win->flags, panel_type);
../lib/public/nuklear.h:15785:        layout->bounds = nk_shrink_rect(layout->bounds, layout->border);
../lib/public/nuklear.h:15786:    } else layout->border = 0;
../lib/public/nuklear.h:15787:    layout->at_y = layout->bounds.y;
../lib/public/nuklear.h:15788:    layout->at_x = layout->bounds.x;
../lib/public/nuklear.h:15789:    layout->max_x = 0;
../lib/public/nuklear.h:15790:    layout->header_height = 0;
../lib/public/nuklear.h:15791:    layout->footer_height = 0;
../lib/public/nuklear.h:15793:    layout->row.index = 0;
../lib/public/nuklear.h:15794:    layout->row.columns = 0;
../lib/public/nuklear.h:15795:    layout->row.ratio = 0;
../lib/public/nuklear.h:15796:    layout->row.item_width = 0;
../lib/public/nuklear.h:15797:    layout->row.tree_depth = 0;
../lib/public/nuklear.h:15798:    layout->row.height = panel_padding.y;
../lib/public/nuklear.h:15799:    layout->has_scrolling = nk_true;
../lib/public/nuklear.h:15800:    if (!(win->flags & NK_WINDOW_NO_SCROLLBAR))
../lib/public/nuklear.h:15801:        layout->bounds.w -= scrollbar_size.x;
../lib/public/nuklear.h:15803:        layout->footer_height = 0;
../lib/public/nuklear.h:15804:        if (!(win->flags & NK_WINDOW_NO_SCROLLBAR) || win->flags & NK_WINDOW_SCALABLE)
../lib/public/nuklear.h:15805:            layout->footer_height = scrollbar_size.y;
../lib/public/nuklear.h:15806:        layout->bounds.h -= layout->footer_height;
../lib/public/nuklear.h:15810:    if (nk_panel_has_header(win->flags, title))
../lib/public/nuklear.h:15817:        header.x = win->bounds.x;
../lib/public/nuklear.h:15818:        header.y = win->bounds.y;
../lib/public/nuklear.h:15819:        header.w = win->bounds.w;
../lib/public/nuklear.h:15820:        header.h = font->height + 2.0f * style->window.header.padding.y;
../lib/public/nuklear.h:15821:        header.h += (2.0f * style->window.header.label_padding.y);
../lib/public/nuklear.h:15824:        layout->header_height = header.h;
../lib/public/nuklear.h:15825:        layout->bounds.y += header.h;
../lib/public/nuklear.h:15826:        layout->bounds.h -= header.h;
../lib/public/nuklear.h:15827:        layout->at_y += header.h;
../lib/public/nuklear.h:15830:        if (ctx->active == win) {
../lib/public/nuklear.h:15831:            background = &style->window.header.active;
../lib/public/nuklear.h:15832:            text.text = style->window.header.label_active;
../lib/public/nuklear.h:15833:        } else if (nk_input_is_mouse_hovering_rect(&ctx->input, header)) {
../lib/public/nuklear.h:15834:            background = &style->window.header.hover;
../lib/public/nuklear.h:15835:            text.text = style->window.header.label_hover;
../lib/public/nuklear.h:15837:            background = &style->window.header.normal;
../lib/public/nuklear.h:15838:            text.text = style->window.header.label_normal;
../lib/public/nuklear.h:15843:        if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:15845:            nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
../lib/public/nuklear.h:15846:        }else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:15848:            nk_draw_texpath(&win->buffer, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:15850:            text.background = background->data.color;
../lib/public/nuklear.h:15851:            nk_fill_rect(out, header, 0, background->data.color);
../lib/public/nuklear.h:15856:        button.y = header.y + style->window.header.padding.y;
../lib/public/nuklear.h:15857:        button.h = header.h - 2 * style->window.header.padding.y;
../lib/public/nuklear.h:15859:        if (win->flags & NK_WINDOW_CLOSABLE) {
../lib/public/nuklear.h:15861:            if (style->window.header.align == NK_HEADER_RIGHT) {
../lib/public/nuklear.h:15862:                button.x = (header.w + header.x) - (button.w + style->window.header.padding.x);
../lib/public/nuklear.h:15863:                header.w -= button.w + style->window.header.spacing.x + style->window.header.padding.x;
../lib/public/nuklear.h:15865:                button.x = header.x + style->window.header.padding.x;
../lib/public/nuklear.h:15866:                header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
../lib/public/nuklear.h:15869:            if (nk_do_button_symbol(&ws, &win->buffer, button,
../lib/public/nuklear.h:15870:                style->window.header.close_symbol, NK_BUTTON_DEFAULT,
../lib/public/nuklear.h:15871:                &style->window.header.close_button, in, style->font) && !(win->flags & NK_WINDOW_ROM))
../lib/public/nuklear.h:15873:                layout->flags |= NK_WINDOW_HIDDEN;
../lib/public/nuklear.h:15874:                layout->flags &= (nk_flags)~NK_WINDOW_MINIMIZED;
../lib/public/nuklear.h:15879:        if (win->flags & NK_WINDOW_MINIMIZABLE) {
../lib/public/nuklear.h:15881:            if (style->window.header.align == NK_HEADER_RIGHT) {
../lib/public/nuklear.h:15882:                button.x = (header.w + header.x) - button.w;
../lib/public/nuklear.h:15883:                if (!(win->flags & NK_WINDOW_CLOSABLE)) {
../lib/public/nuklear.h:15884:                    button.x -= style->window.header.padding.x;
../lib/public/nuklear.h:15885:                    header.w -= style->window.header.padding.x;
../lib/public/nuklear.h:15887:                header.w -= button.w + style->window.header.spacing.x;
../lib/public/nuklear.h:15890:                header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
../lib/public/nuklear.h:15892:            int old_flags = layout->flags;
../lib/public/nuklear.h:15893:            if (nk_do_button_symbol(&ws, &win->buffer, button, (layout->flags & NK_WINDOW_MINIMIZED)?
../lib/public/nuklear.h:15894:                style->window.header.maximize_symbol: style->window.header.minimize_symbol,
../lib/public/nuklear.h:15895:                NK_BUTTON_DEFAULT, &style->window.header.minimize_button, in, style->font) && !(win->flags & NK_WINDOW_ROM)) {
../lib/public/nuklear.h:15896:                layout->flags = (layout->flags & NK_WINDOW_MINIMIZED) ?
../lib/public/nuklear.h:15897:                    layout->flags & (nk_flags)~NK_WINDOW_MINIMIZED:
../lib/public/nuklear.h:15898:                    layout->flags | NK_WINDOW_MINIMIZED;
../lib/public/nuklear.h:15899:                if((old_flags & NK_WINDOW_MINIMIZED) && !(layout->flags & NK_WINDOW_MINIMIZED))
../lib/public/nuklear.h:15900:                    win->maximized = 1;
../lib/public/nuklear.h:15901:                if(!(old_flags & NK_WINDOW_MINIMIZED) && (layout->flags & NK_WINDOW_MINIMIZED))
../lib/public/nuklear.h:15902:                    win->minimized = 1;
../lib/public/nuklear.h:15909:        float t = font->width(font->userdata, font->height, title, text_len);
../lib/public/nuklear.h:15912:        label.x = header.x + style->window.header.padding.x;
../lib/public/nuklear.h:15913:        label.x += style->window.header.label_padding.x;
../lib/public/nuklear.h:15914:        label.y = header.y + style->window.header.label_padding.y;
../lib/public/nuklear.h:15915:        label.h = font->height + 2 * style->window.header.label_padding.y;
../lib/public/nuklear.h:15916:        label.w = t + 2 * style->window.header.spacing.x;
../lib/public/nuklear.h:15917:        label.w = NK_CLAMP(0, label.w, header.x + header.w - label.x);
../lib/public/nuklear.h:15922:    if (!(layout->flags & NK_WINDOW_MINIMIZED) && !(layout->flags & NK_WINDOW_DYNAMIC)) {
../lib/public/nuklear.h:15924:        body.x = win->bounds.x;
../lib/public/nuklear.h:15925:        body.w = win->bounds.w;
../lib/public/nuklear.h:15926:        body.y = (win->bounds.y + layout->header_height);
../lib/public/nuklear.h:15927:        body.h = (win->bounds.h - layout->header_height);
../lib/public/nuklear.h:15928:        if (style->window.fixed_background.type == NK_STYLE_ITEM_IMAGE)
../lib/public/nuklear.h:15929:            nk_draw_image(out, body, &style->window.fixed_background.data.image, nk_white);
../lib/public/nuklear.h:15930:        else if(style->window.fixed_background.type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:15931:            nk_draw_texpath(out, body, style->window.fixed_background.data.texpath, nk_white);
../lib/public/nuklear.h:15932:        else nk_fill_rect(out, body, 0, style->window.fixed_background.data.color);
../lib/public/nuklear.h:15937:    layout->clip = layout->bounds;
../lib/public/nuklear.h:15938:    nk_unify(&clip, &win->buffer.clip, layout->clip.x, layout->clip.y,
../lib/public/nuklear.h:15939:        layout->clip.x + layout->clip.w, layout->clip.y + layout->clip.h);
../lib/public/nuklear.h:15941:    layout->clip = clip;}
../lib/public/nuklear.h:15942:    return !(layout->flags & NK_WINDOW_HIDDEN) && !(layout->flags & NK_WINDOW_MINIMIZED);
../lib/public/nuklear.h:15957:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:15958:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:15959:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:15962:    window = ctx->current;
../lib/public/nuklear.h:15963:    layout = window->layout;
../lib/public/nuklear.h:15964:    style = &ctx->style;
../lib/public/nuklear.h:15965:    out = &window->buffer;
../lib/public/nuklear.h:15966:    in = (layout->flags & NK_WINDOW_ROM || layout->flags & NK_WINDOW_NO_INPUT) ? 0 :&ctx->input;
../lib/public/nuklear.h:15967:    if (!nk_panel_is_sub(layout->type))
../lib/public/nuklear.h:15971:    scrollbar_size = style->window.scrollbar_size;
../lib/public/nuklear.h:15972:    panel_padding = nk_panel_get_padding(style, layout->type);
../lib/public/nuklear.h:15974:    /* update the current cursor Y-position to point over the last added widget */
../lib/public/nuklear.h:15975:    layout->at_y += layout->row.height;
../lib/public/nuklear.h:15978:    if (layout->flags & NK_WINDOW_DYNAMIC && !(layout->flags & NK_WINDOW_MINIMIZED))
../lib/public/nuklear.h:15982:        if (layout->at_y < (layout->bounds.y + layout->bounds.h))
../lib/public/nuklear.h:15983:            layout->bounds.h = layout->at_y - layout->bounds.y;
../lib/public/nuklear.h:15986:        empty_space.x = window->bounds.x;
../lib/public/nuklear.h:15987:        empty_space.y = layout->bounds.y;
../lib/public/nuklear.h:15989:        empty_space.w = window->bounds.w;
../lib/public/nuklear.h:15990:        nk_fill_rect(out, empty_space, 0, style->window.background);
../lib/public/nuklear.h:15993:        empty_space.x = window->bounds.x;
../lib/public/nuklear.h:15994:        empty_space.y = layout->bounds.y;
../lib/public/nuklear.h:15995:        empty_space.w = panel_padding.x + layout->border;
../lib/public/nuklear.h:15996:        empty_space.h = layout->bounds.h;
../lib/public/nuklear.h:15997:        nk_fill_rect(out, empty_space, 0, style->window.background);
../lib/public/nuklear.h:16000:        empty_space.x = layout->bounds.x + layout->bounds.w - layout->border;
../lib/public/nuklear.h:16001:        empty_space.y = layout->bounds.y;
../lib/public/nuklear.h:16002:        empty_space.w = panel_padding.x + layout->border;
../lib/public/nuklear.h:16003:        empty_space.h = layout->bounds.h;
../lib/public/nuklear.h:16004:        if (*layout->offset_y == 0 && !(layout->flags & NK_WINDOW_NO_SCROLLBAR))
../lib/public/nuklear.h:16006:        nk_fill_rect(out, empty_space, 0, style->window.background);
../lib/public/nuklear.h:16009:        if (layout->footer_height > 0) {
../lib/public/nuklear.h:16010:            empty_space.x = window->bounds.x;
../lib/public/nuklear.h:16011:            empty_space.y = layout->bounds.y + layout->bounds.h;
../lib/public/nuklear.h:16012:            empty_space.w = window->bounds.w;
../lib/public/nuklear.h:16013:            empty_space.h = layout->footer_height;
../lib/public/nuklear.h:16014:            nk_fill_rect(out, empty_space, 0, style->window.background);
../lib/public/nuklear.h:16019:    if (!(layout->flags & NK_WINDOW_NO_SCROLLBAR) &&
../lib/public/nuklear.h:16020:        !(layout->flags & NK_WINDOW_MINIMIZED) &&
../lib/public/nuklear.h:16021:        window->scrollbar_hiding_timer < NK_SCROLLBAR_HIDING_TIMEOUT)
../lib/public/nuklear.h:16031:        if (nk_panel_is_sub(layout->type))
../lib/public/nuklear.h:16033:            /* sub-window mouse wheel scrolling */
../lib/public/nuklear.h:16035:            struct nk_panel *root_panel = window->layout;
../lib/public/nuklear.h:16036:            while (root_panel->parent)
../lib/public/nuklear.h:16037:                root_panel = root_panel->parent;
../lib/public/nuklear.h:16038:            while (root_window->parent)
../lib/public/nuklear.h:16039:                root_window = root_window->parent;
../lib/public/nuklear.h:16043:            if ((root_window == ctx->active) && layout->has_scrolling) {
../lib/public/nuklear.h:16045:                if (nk_input_is_mouse_hovering_rect(in, layout->bounds) &&
../lib/public/nuklear.h:16046:                    NK_INTERSECT(layout->bounds.x, layout->bounds.y, layout->bounds.w, layout->bounds.h,
../lib/public/nuklear.h:16047:                        root_panel->clip.x, root_panel->clip.y, root_panel->clip.w, root_panel->clip.h))
../lib/public/nuklear.h:16050:                    root_panel = window->layout;
../lib/public/nuklear.h:16051:                    while (root_panel->parent) {
../lib/public/nuklear.h:16052:                        root_panel->has_scrolling = nk_false;
../lib/public/nuklear.h:16053:                        root_panel = root_panel->parent;
../lib/public/nuklear.h:16055:                    root_panel->has_scrolling = nk_false;
../lib/public/nuklear.h:16059:        } else if (!nk_panel_is_sub(layout->type)) {
../lib/public/nuklear.h:16061:            scroll_has_scrolling = (window == ctx->active) && layout->has_scrolling;
../lib/public/nuklear.h:16062:            if (in && (in->mouse.scroll_delta.y > 0 || in->mouse.scroll_delta.x > 0) && scroll_has_scrolling)
../lib/public/nuklear.h:16063:                window->scrolled = nk_true;
../lib/public/nuklear.h:16064:            else window->scrolled = nk_false;
../lib/public/nuklear.h:16070:            scroll.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
../lib/public/nuklear.h:16071:            scroll.y = layout->bounds.y;
../lib/public/nuklear.h:16073:            scroll.h = layout->bounds.h;
../lib/public/nuklear.h:16075:            scroll_offset = (float)*layout->offset_y;
../lib/public/nuklear.h:16078:            scroll_target = (float)(int)(layout->at_y - scroll.y);
../lib/public/nuklear.h:16081:                &ctx->style.scrollv, in, style->font);
../lib/public/nuklear.h:16082:            *layout->offset_y = (nk_uint)scroll_offset;
../lib/public/nuklear.h:16084:                in->mouse.scroll_delta.y = 0;
../lib/public/nuklear.h:16089:            scroll.x = layout->bounds.x;
../lib/public/nuklear.h:16090:            scroll.y = layout->bounds.y + layout->bounds.h;
../lib/public/nuklear.h:16091:            scroll.w = layout->bounds.w;
../lib/public/nuklear.h:16094:            scroll_offset = (float)*layout->offset_x;
../lib/public/nuklear.h:16095:            scroll_target = (float)(int)(layout->max_x - scroll.x);
../lib/public/nuklear.h:16096:            scroll_step = layout->max_x * 0.05f;
../lib/public/nuklear.h:16097:            scroll_inc = layout->max_x * 0.005f;
../lib/public/nuklear.h:16100:                &ctx->style.scrollh, in, style->font);
../lib/public/nuklear.h:16101:            *layout->offset_x = (nk_uint)scroll_offset;
../lib/public/nuklear.h:16106:    if (window->flags & NK_WINDOW_SCROLL_AUTO_HIDE) {
../lib/public/nuklear.h:16107:        int has_input = ctx->input.mouse.delta.x != 0 || ctx->input.mouse.delta.y != 0 || ctx->input.mouse.scroll_delta.y != 0;
../lib/public/nuklear.h:16109:        int any_item_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
../lib/public/nuklear.h:16111:            window->scrollbar_hiding_timer += ctx->delta_time_seconds;
../lib/public/nuklear.h:16112:        else window->scrollbar_hiding_timer = 0;
../lib/public/nuklear.h:16113:    } else window->scrollbar_hiding_timer = 0;
../lib/public/nuklear.h:16116:    if (layout->flags & NK_WINDOW_BORDER)
../lib/public/nuklear.h:16118:        struct nk_color border_color = nk_panel_get_border_color(style, layout->type);
../lib/public/nuklear.h:16119:        const float padding_y = (layout->flags & NK_WINDOW_MINIMIZED)
../lib/public/nuklear.h:16120:            ? (style->window.border + window->bounds.y + layout->header_height)
../lib/public/nuklear.h:16121:            : ((layout->flags & NK_WINDOW_DYNAMIC)
../lib/public/nuklear.h:16122:                ? (layout->bounds.y + layout->bounds.h + layout->footer_height)
../lib/public/nuklear.h:16123:                : (window->bounds.y + window->bounds.h));
../lib/public/nuklear.h:16124:        struct nk_rect b = window->bounds;
../lib/public/nuklear.h:16125:        b.h = padding_y - window->bounds.y;
../lib/public/nuklear.h:16126:        nk_stroke_rect(out, b, 0, layout->border, border_color);
../lib/public/nuklear.h:16130:    if ((layout->flags & NK_WINDOW_SCALABLE) && in && !(layout->flags & NK_WINDOW_MINIMIZED))
../lib/public/nuklear.h:16136:        scaler.y = layout->bounds.y + layout->bounds.h;
../lib/public/nuklear.h:16137:        if (layout->flags & NK_WINDOW_SCALE_LEFT)
../lib/public/nuklear.h:16138:            scaler.x = layout->bounds.x - panel_padding.x * 0.5f;
../lib/public/nuklear.h:16139:        else scaler.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
../lib/public/nuklear.h:16140:        if (layout->flags & NK_WINDOW_NO_SCROLLBAR)
../lib/public/nuklear.h:16141:            scaler.x -= scaler.w;
../lib/public/nuklear.h:16144:        {const struct nk_style_item *item = &style->window.scaler;
../lib/public/nuklear.h:16145:        if (item->type == NK_STYLE_ITEM_IMAGE)
../lib/public/nuklear.h:16146:            nk_draw_image(out, scaler, &item->data.image, nk_white);
../lib/public/nuklear.h:16147:        else if (item->type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:16148:            nk_draw_texpath(out, scaler, item->data.texpath, nk_white);
../lib/public/nuklear.h:16150:            if (layout->flags & NK_WINDOW_SCALE_LEFT) {
../lib/public/nuklear.h:16153:                    scaler.y + scaler.h, item->data.color);
../lib/public/nuklear.h:16156:                    scaler.y + scaler.h, scaler.x, scaler.y + scaler.h, item->data.color);
../lib/public/nuklear.h:16161:        if (!(window->flags & NK_WINDOW_ROM)) {
../lib/public/nuklear.h:16162:            struct nk_vec2 window_size = style->window.min_size;
../lib/public/nuklear.h:16163:            int left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
../lib/public/nuklear.h:16168:                float delta_x = in->mouse.delta.x;
../lib/public/nuklear.h:16169:                if (layout->flags & NK_WINDOW_SCALE_LEFT) {
../lib/public/nuklear.h:16170:                    delta_x = -delta_x;
../lib/public/nuklear.h:16171:                    window->bounds.x += in->mouse.delta.x;
../lib/public/nuklear.h:16173:                /* dragging in x-direction  */
../lib/public/nuklear.h:16174:                if (window->bounds.w + delta_x >= window_size.x) {
../lib/public/nuklear.h:16175:                    if ((delta_x < 0) || (delta_x > 0 && in->mouse.pos.x >= scaler.x)) {
../lib/public/nuklear.h:16176:                        window->bounds.w = window->bounds.w + delta_x;
../lib/public/nuklear.h:16177:                        scaler.x += in->mouse.delta.x;
../lib/public/nuklear.h:16180:                /* dragging in y-direction (only possible if static window) */
../lib/public/nuklear.h:16181:                if (!(layout->flags & NK_WINDOW_DYNAMIC)) {
../lib/public/nuklear.h:16182:                    if (window_size.y < window->bounds.h + in->mouse.delta.y) {
../lib/public/nuklear.h:16183:                        if ((in->mouse.delta.y < 0) || (in->mouse.delta.y > 0 && in->mouse.pos.y >= scaler.y)) {
../lib/public/nuklear.h:16184:                            window->bounds.h = window->bounds.h + in->mouse.delta.y;
../lib/public/nuklear.h:16185:                            scaler.y += in->mouse.delta.y;
../lib/public/nuklear.h:16189:                ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT];
../lib/public/nuklear.h:16190:                in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = scaler.x + scaler.w/2.0f;
../lib/public/nuklear.h:16191:                in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = scaler.y + scaler.h/2.0f;
../lib/public/nuklear.h:16195:    if (!nk_panel_is_sub(layout->type)) {
../lib/public/nuklear.h:16197:        if (layout->flags & NK_WINDOW_HIDDEN)
../lib/public/nuklear.h:16198:            nk_command_buffer_reset(&window->buffer);
../lib/public/nuklear.h:16204:    if (layout->flags & NK_WINDOW_REMOVE_ROM) {
../lib/public/nuklear.h:16205:        layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16206:        layout->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
../lib/public/nuklear.h:16208:    window->flags = layout->flags;
../lib/public/nuklear.h:16211:    if (window->property.active && window->property.old != window->property.seq &&
../lib/public/nuklear.h:16212:        window->property.active == window->property.prev) {
../lib/public/nuklear.h:16213:        nk_zero(&window->property, sizeof(window->property));
../lib/public/nuklear.h:16215:        window->property.old = window->property.seq;
../lib/public/nuklear.h:16216:        window->property.prev = window->property.active;
../lib/public/nuklear.h:16217:        window->property.seq = 0;
../lib/public/nuklear.h:16220:    if (window->edit.active && window->edit.old != window->edit.seq &&
../lib/public/nuklear.h:16221:       window->edit.active == window->edit.prev) {
../lib/public/nuklear.h:16222:        nk_zero(&window->edit, sizeof(window->edit));
../lib/public/nuklear.h:16224:        window->edit.old = window->edit.seq;
../lib/public/nuklear.h:16225:        window->edit.prev = window->edit.active;
../lib/public/nuklear.h:16226:        window->edit.seq = 0;
../lib/public/nuklear.h:16229:    if (window->popup.active_con && window->popup.con_old != window->popup.con_count) {
../lib/public/nuklear.h:16230:        window->popup.con_count = 0;
../lib/public/nuklear.h:16231:        window->popup.con_old = 0;
../lib/public/nuklear.h:16232:        window->popup.active_con = 0;
../lib/public/nuklear.h:16234:        window->popup.con_old = window->popup.con_count;
../lib/public/nuklear.h:16235:        window->popup.con_count = 0;
../lib/public/nuklear.h:16237:    window->popup.combo_count = 0;
../lib/public/nuklear.h:16239:    NK_ASSERT(!layout->row.tree_depth);
../lib/public/nuklear.h:16257:    elem->data.win.seq = ctx->seq;
../lib/public/nuklear.h:16258:    return &elem->data.win;
../lib/public/nuklear.h:16264:    struct nk_table *it = win->tables;
../lib/public/nuklear.h:16265:    if (win->popup.win) {
../lib/public/nuklear.h:16266:        nk_free_window(ctx, win->popup.win);
../lib/public/nuklear.h:16267:        win->popup.win = 0;
../lib/public/nuklear.h:16269:    win->next = 0;
../lib/public/nuklear.h:16270:    win->prev = 0;
../lib/public/nuklear.h:16274:        struct nk_table *n = it->next;
../lib/public/nuklear.h:16277:        if (it == win->tables)
../lib/public/nuklear.h:16278:            win->tables = n;
../lib/public/nuklear.h:16291:    iter = ctx->begin;
../lib/public/nuklear.h:16293:        NK_ASSERT(iter != iter->next);
../lib/public/nuklear.h:16294:        if (iter->name == hash) {
../lib/public/nuklear.h:16295:            int max_len = nk_strlen(iter->name_string);
../lib/public/nuklear.h:16296:            if (!nk_stricmpn(iter->name_string, name, max_len))
../lib/public/nuklear.h:16299:        iter = iter->next;
../lib/public/nuklear.h:16312:    iter = ctx->begin;
../lib/public/nuklear.h:16314:        NK_ASSERT(iter != iter->next);
../lib/public/nuklear.h:16317:        iter = iter->next;
../lib/public/nuklear.h:16320:    if (!ctx->begin) {
../lib/public/nuklear.h:16321:        win->next = 0;
../lib/public/nuklear.h:16322:        win->prev = 0;
../lib/public/nuklear.h:16323:        ctx->begin = win;
../lib/public/nuklear.h:16324:        ctx->end = win;
../lib/public/nuklear.h:16325:        ctx->count = 1;
../lib/public/nuklear.h:16330:        end = ctx->end;
../lib/public/nuklear.h:16331:        end->flags |= NK_WINDOW_ROM;
../lib/public/nuklear.h:16332:        end->next = win;
../lib/public/nuklear.h:16333:        win->prev = ctx->end;
../lib/public/nuklear.h:16334:        win->next = 0;
../lib/public/nuklear.h:16335:        ctx->end = win;
../lib/public/nuklear.h:16336:        ctx->active = ctx->end;
../lib/public/nuklear.h:16337:        ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16339:        /*ctx->end->flags |= NK_WINDOW_ROM;*/
../lib/public/nuklear.h:16340:        ctx->begin->prev = win;
../lib/public/nuklear.h:16341:        win->next = ctx->begin;
../lib/public/nuklear.h:16342:        win->prev = 0;
../lib/public/nuklear.h:16343:        ctx->begin = win;
../lib/public/nuklear.h:16344:        ctx->begin->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16346:    ctx->count++;
../lib/public/nuklear.h:16351:    if (win == ctx->begin || win == ctx->end) {
../lib/public/nuklear.h:16352:        if (win == ctx->begin) {
../lib/public/nuklear.h:16353:            ctx->begin = win->next;
../lib/public/nuklear.h:16354:            if (win->next)
../lib/public/nuklear.h:16355:                win->next->prev = 0;
../lib/public/nuklear.h:16357:        if (win == ctx->end) {
../lib/public/nuklear.h:16358:            ctx->end = win->prev;
../lib/public/nuklear.h:16359:            if (win->prev)
../lib/public/nuklear.h:16360:                win->prev->next = 0;
../lib/public/nuklear.h:16363:        if (win->next)
../lib/public/nuklear.h:16364:            win->next->prev = win->prev;
../lib/public/nuklear.h:16365:        if (win->prev)
../lib/public/nuklear.h:16366:            win->prev->next = win->next;
../lib/public/nuklear.h:16368:    if (win == ctx->active || !ctx->active) {
../lib/public/nuklear.h:16369:        ctx->active = ctx->end;
../lib/public/nuklear.h:16370:        if (ctx->end)
../lib/public/nuklear.h:16371:            ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16373:    win->next = 0;
../lib/public/nuklear.h:16374:    win->prev = 0;
../lib/public/nuklear.h:16375:    ctx->count--;
../lib/public/nuklear.h:16380:    struct nk_vec2i curr_res = ctx->screen.get_drawable_size();
../lib/public/nuklear.h:16383:        ctx->input.mouse.buttons[i].down = ctx->input.window_mouse.buttons[i].down;
../lib/public/nuklear.h:16384:        ctx->input.mouse.buttons[i].clicked = ctx->input.window_mouse.buttons[i].clicked;
../lib/public/nuklear.h:16385:        ctx->input.mouse.buttons[i].clicked_pos = (struct nk_vec2) {
../lib/public/nuklear.h:16386:            ctx->input.window_mouse.buttons[i].clicked_pos.x / (float)curr_res.x * vres.x,
../lib/public/nuklear.h:16387:            ctx->input.window_mouse.buttons[i].clicked_pos.y / (float)curr_res.y * vres.y
../lib/public/nuklear.h:16390:    ctx->input.mouse.pos = (struct nk_vec2) {
../lib/public/nuklear.h:16391:        ctx->input.window_mouse.pos.x / (float)curr_res.x * vres.x,
../lib/public/nuklear.h:16392:        ctx->input.window_mouse.pos.y / (float)curr_res.y * vres.y,
../lib/public/nuklear.h:16394:    ctx->input.mouse.prev = (struct nk_vec2) {
../lib/public/nuklear.h:16395:        ctx->input.window_mouse.prev.x / (float)curr_res.x * vres.x,
../lib/public/nuklear.h:16396:        ctx->input.window_mouse.prev.y / (float)curr_res.y * vres.y,
../lib/public/nuklear.h:16398:    ctx->input.mouse.delta = (struct nk_vec2) {
../lib/public/nuklear.h:16399:        ctx->input.window_mouse.delta.x / (float)curr_res.x * vres.x,
../lib/public/nuklear.h:16400:        ctx->input.window_mouse.delta.y / (float)curr_res.y * vres.y,
../lib/public/nuklear.h:16402:    ctx->input.mouse.scroll_delta = (struct nk_vec2) {
../lib/public/nuklear.h:16403:        ctx->input.window_mouse.scroll_delta.x / (float)curr_res.x * vres.x,
../lib/public/nuklear.h:16404:        ctx->input.window_mouse.scroll_delta.y / (float)curr_res.y * vres.y,
../lib/public/nuklear.h:16406:    ctx->input.mouse.grab = ctx->input.window_mouse.grab;
../lib/public/nuklear.h:16407:    ctx->input.mouse.grabbed = ctx->input.window_mouse.grabbed;
../lib/public/nuklear.h:16408:    ctx->input.mouse.ungrab = ctx->input.window_mouse.ungrab;
../lib/public/nuklear.h:16413:    struct nk_vec2i curr_res = ctx->screen.get_drawable_size();
../lib/public/nuklear.h:16416:        ctx->input.window_mouse.buttons[i].down = ctx->input.mouse.buttons[i].down;
../lib/public/nuklear.h:16417:        ctx->input.window_mouse.buttons[i].clicked = ctx->input.mouse.buttons[i].clicked;
../lib/public/nuklear.h:16418:        ctx->input.window_mouse.buttons[i].clicked_pos = (struct nk_vec2) {
../lib/public/nuklear.h:16419:            ctx->input.mouse.buttons[i].clicked_pos.x / (float)vres.x * curr_res.x,
../lib/public/nuklear.h:16420:            ctx->input.mouse.buttons[i].clicked_pos.y / (float)vres.y * curr_res.y
../lib/public/nuklear.h:16423:    ctx->input.window_mouse.pos = (struct nk_vec2) {
../lib/public/nuklear.h:16424:        ctx->input.mouse.pos.x / (float)vres.x * curr_res.x,
../lib/public/nuklear.h:16425:        ctx->input.mouse.pos.y / (float)vres.y * curr_res.y,
../lib/public/nuklear.h:16427:    ctx->input.window_mouse.prev = (struct nk_vec2) {
../lib/public/nuklear.h:16428:        ctx->input.mouse.prev.x / (float)vres.x * curr_res.x,
../lib/public/nuklear.h:16429:        ctx->input.mouse.prev.y / (float)vres.y * curr_res.y,
../lib/public/nuklear.h:16431:    ctx->input.window_mouse.delta = (struct nk_vec2) {
../lib/public/nuklear.h:16432:        ctx->input.mouse.delta.x / (float)vres.x * curr_res.x,
../lib/public/nuklear.h:16433:        ctx->input.mouse.delta.y / (float)vres.y * curr_res.y,
../lib/public/nuklear.h:16435:    ctx->input.window_mouse.scroll_delta = (struct nk_vec2) {
../lib/public/nuklear.h:16436:        ctx->input.mouse.scroll_delta.x / (float)vres.x * curr_res.x,
../lib/public/nuklear.h:16437:        ctx->input.mouse.scroll_delta.y / (float)vres.y * curr_res.y,
../lib/public/nuklear.h:16439:    ctx->input.window_mouse.grab = ctx->input.mouse.grab;
../lib/public/nuklear.h:16440:    ctx->input.window_mouse.grabbed = ctx->input.mouse.grabbed;
../lib/public/nuklear.h:16441:    ctx->input.window_mouse.ungrab = ctx->input.mouse.ungrab;
../lib/public/nuklear.h:16447:    struct nk_vec2i native_res = ctx->screen.get_screen_size();
../lib/public/nuklear.h:16471:    NK_ASSERT(ctx->style.font && ctx->style.font->width && "if this triggers you forgot to add a font");
../lib/public/nuklear.h:16472:    NK_ASSERT(!ctx->current && "if this triggers you missed a `nk_end` call");
../lib/public/nuklear.h:16473:    if (!ctx || ctx->current || !title || !name)
../lib/public/nuklear.h:16477:    style = &ctx->style;
../lib/public/nuklear.h:16491:        nk_command_buffer_init(&win->buffer, &ctx->memory, NK_CLIPPING_ON);
../lib/public/nuklear.h:16493:        win->flags = flags;
../lib/public/nuklear.h:16494:        win->bounds = bounds;
../lib/public/nuklear.h:16495:        win->name = name_hash;
../lib/public/nuklear.h:16496:        name_length = NK_MIN(name_length, NK_WINDOW_MAX_NAME-1);
../lib/public/nuklear.h:16497:        NK_MEMCPY(win->name_string, name, name_length);
../lib/public/nuklear.h:16498:        win->name_string[name_length] = 0;
../lib/public/nuklear.h:16499:        win->popup.win = 0;
../lib/public/nuklear.h:16500:        if (!ctx->active)
../lib/public/nuklear.h:16501:            ctx->active = win;
../lib/public/nuklear.h:16504:        win->flags &= ~(nk_flags)(NK_WINDOW_PRIVATE-1);
../lib/public/nuklear.h:16505:        win->flags |= flags;
../lib/public/nuklear.h:16506:        if (!(win->flags & (NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE)))
../lib/public/nuklear.h:16507:            win->bounds = bounds;
../lib/public/nuklear.h:16515:        NK_ASSERT(win->seq != ctx->seq);
../lib/public/nuklear.h:16516:        win->seq = ctx->seq;
../lib/public/nuklear.h:16517:        if (!ctx->active && !(win->flags & NK_WINDOW_HIDDEN)) {
../lib/public/nuklear.h:16518:            ctx->active = win;
../lib/public/nuklear.h:16519:            ctx->end = win;
../lib/public/nuklear.h:16522:    if (win->flags & NK_WINDOW_HIDDEN) {
../lib/public/nuklear.h:16523:        ctx->current = win;
../lib/public/nuklear.h:16524:        win->layout = 0;
../lib/public/nuklear.h:16528:    win->vres = vres;
../lib/public/nuklear.h:16533:        nk_command_buffer_push(&win->buffer, NK_COMMAND_SET_VRES, sizeof(*cmd));
../lib/public/nuklear.h:16535:        cmd->x = win->vres.x;
../lib/public/nuklear.h:16536:        cmd->y = win->vres.y;
../lib/public/nuklear.h:16540:    if (!(win->flags & NK_WINDOW_HIDDEN) && !(win->flags & NK_WINDOW_NO_INPUT))
../lib/public/nuklear.h:16544:        float h = ctx->style.font->height + 2.0f * style->window.header.padding.y +
../lib/public/nuklear.h:16545:            (2.0f * style->window.header.label_padding.y);
../lib/public/nuklear.h:16546:        struct nk_rect win_bounds = (!(win->flags & NK_WINDOW_MINIMIZED))?
../lib/public/nuklear.h:16547:            win->bounds: nk_rect(win->bounds.x, win->bounds.y, win->bounds.w, h);
../lib/public/nuklear.h:16550:        inpanel = nk_input_has_mouse_click_down_in_rect(&ctx->input, NK_BUTTON_LEFT, win_bounds, nk_true);
../lib/public/nuklear.h:16551:        inpanel = inpanel && ctx->input.mouse.buttons[NK_BUTTON_LEFT].clicked;
../lib/public/nuklear.h:16552:        ishovered = nk_input_is_mouse_hovering_rect(&ctx->input, win_bounds);
../lib/public/nuklear.h:16553:        if ((win != ctx->active) && ishovered && !ctx->input.mouse.buttons[NK_BUTTON_LEFT].down) {
../lib/public/nuklear.h:16554:            iter = win->next;
../lib/public/nuklear.h:16556:                struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED))?
../lib/public/nuklear.h:16557:                    iter->bounds: nk_rect(iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
../lib/public/nuklear.h:16560:                    (!(iter->flags & NK_WINDOW_HIDDEN)))
../lib/public/nuklear.h:16563:                if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
../lib/public/nuklear.h:16564:                    NK_INTERSECT(win->bounds.x, win_bounds.y, win_bounds.w, win_bounds.h,
../lib/public/nuklear.h:16565:                    iter->popup.win->bounds.x, iter->popup.win->bounds.y,
../lib/public/nuklear.h:16566:                    iter->popup.win->bounds.w, iter->popup.win->bounds.h))
../lib/public/nuklear.h:16568:                iter = iter->next;
../lib/public/nuklear.h:16573:        if (iter && inpanel && (win != ctx->end)) {
../lib/public/nuklear.h:16574:            iter = win->next;
../lib/public/nuklear.h:16577:                struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED))?
../lib/public/nuklear.h:16578:                iter->bounds: nk_rect(iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
../lib/public/nuklear.h:16579:                if (NK_INBOX(ctx->input.mouse.pos.x, ctx->input.mouse.pos.y,
../lib/public/nuklear.h:16581:                    !(iter->flags & NK_WINDOW_HIDDEN))
../lib/public/nuklear.h:16583:                if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
../lib/public/nuklear.h:16585:                    iter->popup.win->bounds.x, iter->popup.win->bounds.y,
../lib/public/nuklear.h:16586:                    iter->popup.win->bounds.w, iter->popup.win->bounds.h))
../lib/public/nuklear.h:16588:                iter = iter->next;
../lib/public/nuklear.h:16591:        if (iter && !(win->flags & NK_WINDOW_ROM) && (win->flags & NK_WINDOW_BACKGROUND)) {
../lib/public/nuklear.h:16592:            win->flags |= (nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16593:            iter->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16594:            ctx->active = iter;
../lib/public/nuklear.h:16595:            if (!(iter->flags & NK_WINDOW_BACKGROUND)) {
../lib/public/nuklear.h:16602:            if (!iter && ctx->end != win) {
../lib/public/nuklear.h:16603:                if (!(win->flags & NK_WINDOW_BACKGROUND)) {
../lib/public/nuklear.h:16609:                win->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:16610:                ctx->active = win;
../lib/public/nuklear.h:16612:            if (ctx->end != win && !(win->flags & NK_WINDOW_BACKGROUND))
../lib/public/nuklear.h:16613:                win->flags |= NK_WINDOW_ROM;
../lib/public/nuklear.h:16616:    win->layout = (struct nk_panel*)nk_create_panel(ctx);
../lib/public/nuklear.h:16617:    ctx->current = win;
../lib/public/nuklear.h:16619:    win->layout->offset_x = &win->scrollbar.x;
../lib/public/nuklear.h:16620:    win->layout->offset_y = &win->scrollbar.y;
../lib/public/nuklear.h:16628:    NK_ASSERT(ctx->current && "if this triggers you forgot to call `nk_begin`");
../lib/public/nuklear.h:16629:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:16632:    nk_window_mouse_end(ctx, ctx->current->vres);
../lib/public/nuklear.h:16633:    layout = ctx->current->layout;
../lib/public/nuklear.h:16634:    if (!layout || (layout->type == NK_PANEL_WINDOW && (ctx->current->flags & NK_WINDOW_HIDDEN))) {
../lib/public/nuklear.h:16635:        ctx->current = 0;
../lib/public/nuklear.h:16639:    nk_free_panel(ctx, ctx->current->layout);
../lib/public/nuklear.h:16640:    ctx->current = 0;
../lib/public/nuklear.h:16646:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16647:    if (!ctx || !ctx->current) return nk_rect(0,0,0,0);
../lib/public/nuklear.h:16648:    return ctx->current->bounds;
../lib/public/nuklear.h:16654:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16655:    if (!ctx || !ctx->current) return nk_vec2(0,0);
../lib/public/nuklear.h:16656:    return nk_vec2(ctx->current->bounds.x, ctx->current->bounds.y);
../lib/public/nuklear.h:16662:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16663:    if (!ctx || !ctx->current) return nk_vec2(0,0);
../lib/public/nuklear.h:16664:    return nk_vec2(ctx->current->bounds.w, ctx->current->bounds.h);
../lib/public/nuklear.h:16670:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16671:    if (!ctx || !ctx->current) return 0;
../lib/public/nuklear.h:16672:    return ctx->current->bounds.w;
../lib/public/nuklear.h:16678:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16679:    if (!ctx || !ctx->current) return 0;
../lib/public/nuklear.h:16680:    return ctx->current->bounds.h;
../lib/public/nuklear.h:16686:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16687:    if (!ctx || !ctx->current) return nk_rect(0,0,0,0);
../lib/public/nuklear.h:16688:    return ctx->current->layout->clip;
../lib/public/nuklear.h:16694:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16695:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:16696:    if (!ctx || !ctx->current) return nk_vec2(0,0);
../lib/public/nuklear.h:16697:    return nk_vec2(ctx->current->layout->clip.x, ctx->current->layout->clip.y);
../lib/public/nuklear.h:16703:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16704:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:16705:    if (!ctx || !ctx->current) return nk_vec2(0,0);
../lib/public/nuklear.h:16706:    return nk_vec2(ctx->current->layout->clip.x + ctx->current->layout->clip.w,
../lib/public/nuklear.h:16707:        ctx->current->layout->clip.y + ctx->current->layout->clip.h);
../lib/public/nuklear.h:16713:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16714:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:16715:    if (!ctx || !ctx->current) return nk_vec2(0,0);
../lib/public/nuklear.h:16716:    return nk_vec2(ctx->current->layout->clip.w, ctx->current->layout->clip.h);
../lib/public/nuklear.h:16722:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16723:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:16724:    if (!ctx || !ctx->current) return 0;
../lib/public/nuklear.h:16725:    return &ctx->current->buffer;
../lib/public/nuklear.h:16731:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16732:    if (!ctx || !ctx->current) return 0;
../lib/public/nuklear.h:16733:    return ctx->current->layout;
../lib/public/nuklear.h:16739:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16740:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:16741:    if (!ctx || !ctx->current) return 0;
../lib/public/nuklear.h:16742:    return ctx->current == ctx->active;
../lib/public/nuklear.h:16748:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16749:    if (!ctx || !ctx->current) return 0;
../lib/public/nuklear.h:16750:    if(ctx->current->flags & NK_WINDOW_HIDDEN)
../lib/public/nuklear.h:16752:    return nk_input_is_mouse_hovering_rect(&ctx->input, ctx->current->bounds);
../lib/public/nuklear.h:16760:    iter = ctx->begin;
../lib/public/nuklear.h:16763:        if(!(iter->flags & NK_WINDOW_HIDDEN)) {
../lib/public/nuklear.h:16765:            if (iter->popup.active && iter->popup.win && nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))
../lib/public/nuklear.h:16768:            if (iter->flags & NK_WINDOW_MINIMIZED) {
../lib/public/nuklear.h:16769:                struct nk_rect header = iter->bounds;
../lib/public/nuklear.h:16770:                header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;
../lib/public/nuklear.h:16771:                if (nk_input_is_mouse_hovering_rect(&ctx->input, header))
../lib/public/nuklear.h:16773:            } else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {
../lib/public/nuklear.h:16777:        iter = iter->next;
../lib/public/nuklear.h:16785:    int any_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
../lib/public/nuklear.h:16801:    return win->flags & NK_WINDOW_MINIMIZED;
../lib/public/nuklear.h:16816:    return (win->flags & NK_WINDOW_CLOSED);
../lib/public/nuklear.h:16831:    return (win->flags & NK_WINDOW_HIDDEN);
../lib/public/nuklear.h:16846:    return win == ctx->active;
../lib/public/nuklear.h:16865:    NK_ASSERT(ctx->current != win && "You cannot close a currently active window");
../lib/public/nuklear.h:16866:    if (ctx->current == win) return;
../lib/public/nuklear.h:16867:    win->flags |= NK_WINDOW_HIDDEN;
../lib/public/nuklear.h:16868:    win->flags |= NK_WINDOW_CLOSED;
../lib/public/nuklear.h:16879:    NK_ASSERT(ctx->current != win && "You cannot update a currently in procecss window");
../lib/public/nuklear.h:16880:    win->bounds = bounds;
../lib/public/nuklear.h:16888:    win->bounds.x = pos.x;
../lib/public/nuklear.h:16889:    win->bounds.y = pos.y;
../lib/public/nuklear.h:16897:    win->bounds.w = size.x;
../lib/public/nuklear.h:16898:    win->bounds.h = size.y;
../lib/public/nuklear.h:16915:        win->flags |= NK_WINDOW_MINIMIZED;
../lib/public/nuklear.h:16916:    else win->flags &= ~(nk_flags)NK_WINDOW_MINIMIZED;
../lib/public/nuklear.h:16940:        win->flags |= NK_WINDOW_HIDDEN;
../lib/public/nuklear.h:16941:    } else win->flags &= ~(nk_flags)NK_WINDOW_HIDDEN;
../lib/public/nuklear.h:16964:    if (win && ctx->end != win) {
../lib/public/nuklear.h:16968:    ctx->active = win;
../lib/public/nuklear.h:16994:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:16995:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:16996:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:16999:    win = ctx->current;
../lib/public/nuklear.h:17000:    panel = win->layout;
../lib/public/nuklear.h:17001:    NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP) && "popups are not allowed to have popups");
../lib/public/nuklear.h:17006:    popup = win->popup.win;
../lib/public/nuklear.h:17009:        popup->parent = win;
../lib/public/nuklear.h:17010:        win->popup.win = popup;
../lib/public/nuklear.h:17011:        win->popup.active = 0;
../lib/public/nuklear.h:17012:        win->popup.type = NK_PANEL_POPUP;
../lib/public/nuklear.h:17016:    if (win->popup.name != title_hash) {
../lib/public/nuklear.h:17017:        if (!win->popup.active) {
../lib/public/nuklear.h:17019:            win->popup.name = title_hash;
../lib/public/nuklear.h:17020:            win->popup.active = 1;
../lib/public/nuklear.h:17021:            win->popup.type = NK_PANEL_POPUP;
../lib/public/nuklear.h:17026:    ctx->current = popup;
../lib/public/nuklear.h:17027:    rect.x += win->layout->clip.x;
../lib/public/nuklear.h:17028:    rect.y += win->layout->clip.y;
../lib/public/nuklear.h:17031:    popup->parent = win;
../lib/public/nuklear.h:17032:    popup->bounds = rect;
../lib/public/nuklear.h:17033:    popup->seq = ctx->seq;
../lib/public/nuklear.h:17034:    popup->layout = (struct nk_panel*)nk_create_panel(ctx);
../lib/public/nuklear.h:17035:    popup->flags = flags;
../lib/public/nuklear.h:17036:    popup->flags |= NK_WINDOW_BORDER;
../lib/public/nuklear.h:17038:        popup->flags |= NK_WINDOW_DYNAMIC;
../lib/public/nuklear.h:17040:    popup->buffer = win->buffer;
../lib/public/nuklear.h:17042:    allocated = ctx->memory.allocated;
../lib/public/nuklear.h:17043:    nk_push_scissor(&popup->buffer, nk_null_rect);
../lib/public/nuklear.h:17048:        root = win->layout;
../lib/public/nuklear.h:17050:            root->flags |= NK_WINDOW_ROM;
../lib/public/nuklear.h:17051:            root->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
../lib/public/nuklear.h:17052:            root = root->parent;
../lib/public/nuklear.h:17054:        win->popup.active = 1;
../lib/public/nuklear.h:17055:        popup->layout->offset_x = &popup->scrollbar.x;
../lib/public/nuklear.h:17056:        popup->layout->offset_y = &popup->scrollbar.y;
../lib/public/nuklear.h:17057:        popup->layout->parent = win->layout;
../lib/public/nuklear.h:17062:        root = win->layout;
../lib/public/nuklear.h:17064:            root->flags |= NK_WINDOW_REMOVE_ROM;
../lib/public/nuklear.h:17065:            root = root->parent;
../lib/public/nuklear.h:17067:        win->popup.buf.active = 0;
../lib/public/nuklear.h:17068:        win->popup.active = 0;
../lib/public/nuklear.h:17069:        ctx->memory.allocated = allocated;
../lib/public/nuklear.h:17070:        ctx->current = win;
../lib/public/nuklear.h:17071:        nk_free_panel(ctx, popup->layout);
../lib/public/nuklear.h:17072:        popup->layout = 0;
../lib/public/nuklear.h:17087:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17088:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17089:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17093:    win = ctx->current;
../lib/public/nuklear.h:17094:    panel = win->layout;
../lib/public/nuklear.h:17095:    NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP));
../lib/public/nuklear.h:17097:    popup = win->popup.win;
../lib/public/nuklear.h:17101:        popup->parent = win;
../lib/public/nuklear.h:17102:        win->popup.win = popup;
../lib/public/nuklear.h:17103:        win->popup.type = panel_type;
../lib/public/nuklear.h:17104:        nk_command_buffer_init(&popup->buffer, &ctx->memory, NK_CLIPPING_ON);
../lib/public/nuklear.h:17108:        pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
../lib/public/nuklear.h:17109:        in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
../lib/public/nuklear.h:17110:        in_header = nk_input_is_mouse_hovering_rect(&ctx->input, header);
../lib/public/nuklear.h:17114:    win->popup.header = header;
../lib/public/nuklear.h:17118:        struct nk_panel *root = win->layout;
../lib/public/nuklear.h:17120:            root->flags |= NK_WINDOW_REMOVE_ROM;
../lib/public/nuklear.h:17121:            root = root->parent;
../lib/public/nuklear.h:17125:    popup->bounds = body;
../lib/public/nuklear.h:17126:    popup->parent = win;
../lib/public/nuklear.h:17127:    popup->layout = (struct nk_panel*)nk_create_panel(ctx);
../lib/public/nuklear.h:17128:    popup->flags = flags;
../lib/public/nuklear.h:17129:    popup->flags |= NK_WINDOW_BORDER;
../lib/public/nuklear.h:17130:    popup->flags |= NK_WINDOW_DYNAMIC;
../lib/public/nuklear.h:17131:    popup->seq = ctx->seq;
../lib/public/nuklear.h:17132:    win->popup.active = 1;
../lib/public/nuklear.h:17133:    NK_ASSERT(popup->layout);
../lib/public/nuklear.h:17136:    popup->buffer = win->buffer;
../lib/public/nuklear.h:17137:    nk_push_scissor(&popup->buffer, nk_null_rect);
../lib/public/nuklear.h:17138:    ctx->current = popup;
../lib/public/nuklear.h:17141:    win->buffer = popup->buffer;
../lib/public/nuklear.h:17142:    popup->layout->parent = win->layout;
../lib/public/nuklear.h:17143:    popup->layout->offset_x = &popup->scrollbar.x;
../lib/public/nuklear.h:17144:    popup->layout->offset_y = &popup->scrollbar.y;
../lib/public/nuklear.h:17148:    root = win->layout;
../lib/public/nuklear.h:17150:        root->flags |= NK_WINDOW_ROM;
../lib/public/nuklear.h:17151:        root = root->parent;
../lib/public/nuklear.h:17160:    if (!ctx || !ctx->current) return;
../lib/public/nuklear.h:17162:    popup = ctx->current;
../lib/public/nuklear.h:17163:    NK_ASSERT(popup->parent);
../lib/public/nuklear.h:17164:    NK_ASSERT(popup->layout->type & NK_PANEL_SET_POPUP);
../lib/public/nuklear.h:17165:    popup->flags |= NK_WINDOW_HIDDEN;
../lib/public/nuklear.h:17174:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17175:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17176:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17179:    popup = ctx->current;
../lib/public/nuklear.h:17180:    if (!popup->parent) return;
../lib/public/nuklear.h:17181:    win = popup->parent;
../lib/public/nuklear.h:17182:    if (popup->flags & NK_WINDOW_HIDDEN) {
../lib/public/nuklear.h:17184:        root = win->layout;
../lib/public/nuklear.h:17186:            root->flags |= NK_WINDOW_REMOVE_ROM;
../lib/public/nuklear.h:17187:            root = root->parent;
../lib/public/nuklear.h:17189:        win->popup.active = 0;
../lib/public/nuklear.h:17191:    nk_push_scissor(&popup->buffer, nk_null_rect);
../lib/public/nuklear.h:17194:    win->buffer = popup->buffer;
../lib/public/nuklear.h:17196:    ctx->current = win;
../lib/public/nuklear.h:17197:    nk_push_scissor(&win->buffer, win->layout->clip);
../lib/public/nuklear.h:17217:    NK_STORAGE const struct nk_rect null_rect = {-1,-1,0,0};
../lib/public/nuklear.h:17223:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17224:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17225:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17228:    win = ctx->current;
../lib/public/nuklear.h:17229:    ++win->popup.con_count;
../lib/public/nuklear.h:17230:    if (ctx->current != ctx->active)
../lib/public/nuklear.h:17234:    popup = win->popup.win;
../lib/public/nuklear.h:17235:    is_open = (popup && win->popup.type == NK_PANEL_CONTEXTUAL);
../lib/public/nuklear.h:17236:    is_clicked = nk_input_mouse_clicked(&ctx->input, NK_BUTTON_RIGHT, trigger_bounds);
../lib/public/nuklear.h:17237:    if (win->popup.active_con && win->popup.con_count != win->popup.active_con)
../lib/public/nuklear.h:17239:    if (!is_open && win->popup.active_con)
../lib/public/nuklear.h:17240:        win->popup.active_con = 0;
../lib/public/nuklear.h:17245:    win->popup.active_con = win->popup.con_count;
../lib/public/nuklear.h:17247:        body.x = ctx->input.mouse.pos.x;
../lib/public/nuklear.h:17248:        body.y = ctx->input.mouse.pos.y;
../lib/public/nuklear.h:17250:        body.x = popup->bounds.x;
../lib/public/nuklear.h:17251:        body.y = popup->bounds.y;
../lib/public/nuklear.h:17259:    if (ret) win->popup.type = NK_PANEL_CONTEXTUAL;
../lib/public/nuklear.h:17261:        win->popup.active_con = 0;
../lib/public/nuklear.h:17262:        win->popup.type = NK_PANEL_NONE;
../lib/public/nuklear.h:17263:        if (win->popup.win)
../lib/public/nuklear.h:17264:            win->popup.win->flags = 0;
../lib/public/nuklear.h:17280:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17281:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17282:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17285:    win = ctx->current;
../lib/public/nuklear.h:17286:    style = &ctx->style;
../lib/public/nuklear.h:17287:    state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
../lib/public/nuklear.h:17290:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17291:    if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:17292:        text, len, alignment, NK_BUTTON_DEFAULT, &style->contextual_button, in, style->font)) {
../lib/public/nuklear.h:17315:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17316:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17317:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17320:    win = ctx->current;
../lib/public/nuklear.h:17321:    style = &ctx->style;
../lib/public/nuklear.h:17322:    state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
../lib/public/nuklear.h:17325:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17326:    if (nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:17327:        img, text, len, align, NK_BUTTON_DEFAULT, &style->contextual_button, style->font, in)){
../lib/public/nuklear.h:17351:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17352:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17353:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17356:    win = ctx->current;
../lib/public/nuklear.h:17357:    style = &ctx->style;
../lib/public/nuklear.h:17358:    state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
../lib/public/nuklear.h:17361:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17362:    if (nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:17363:        symbol, text, len, align, NK_BUTTON_DEFAULT, &style->contextual_button, style->font, in)) {
../lib/public/nuklear.h:17379:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17380:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17381:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:17390:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17391:    if (!ctx || !ctx->current) return;
../lib/public/nuklear.h:17393:    popup = ctx->current;
../lib/public/nuklear.h:17394:    panel = popup->layout;
../lib/public/nuklear.h:17395:    NK_ASSERT(popup->parent);
../lib/public/nuklear.h:17396:    NK_ASSERT(panel->type & NK_PANEL_SET_POPUP);
../lib/public/nuklear.h:17397:    if (panel->flags & NK_WINDOW_DYNAMIC) {
../lib/public/nuklear.h:17401:        click outside the non-blocking popup must close it at that direct frame.
../lib/public/nuklear.h:17404:        if (panel->at_y < (panel->bounds.y + panel->bounds.h)) {
../lib/public/nuklear.h:17405:            struct nk_vec2 padding = nk_panel_get_padding(&ctx->style, panel->type);
../lib/public/nuklear.h:17406:            body = panel->bounds;
../lib/public/nuklear.h:17407:            body.y = (panel->at_y + panel->footer_height + panel->border + padding.y + panel->row.height);
../lib/public/nuklear.h:17408:            body.h = (panel->bounds.y + panel->bounds.h) - body.y;
../lib/public/nuklear.h:17410:        {int pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
../lib/public/nuklear.h:17411:        int in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
../lib/public/nuklear.h:17413:            popup->flags |= NK_WINDOW_HIDDEN;
../lib/public/nuklear.h:17416:    if (popup->flags & NK_WINDOW_HIDDEN)
../lib/public/nuklear.h:17417:        popup->seq = 0;
../lib/public/nuklear.h:17436:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17437:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17438:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17441:    layout = ctx->current->layout;
../lib/public/nuklear.h:17442:    NK_ASSERT(layout->at_y == layout->bounds.y);
../lib/public/nuklear.h:17458:    if (layout->flags & NK_WINDOW_HIDDEN || layout->flags & NK_WINDOW_MINIMIZED)
../lib/public/nuklear.h:17461:    layout->menu.x = layout->at_x;
../lib/public/nuklear.h:17462:    layout->menu.y = layout->at_y + layout->row.height;
../lib/public/nuklear.h:17463:    layout->menu.w = layout->bounds.w;
../lib/public/nuklear.h:17464:    layout->menu.offset.x = *layout->offset_x;
../lib/public/nuklear.h:17465:    layout->menu.offset.y = *layout->offset_y;
../lib/public/nuklear.h:17466:    *layout->offset_y = 0;
../lib/public/nuklear.h:17476:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17477:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17478:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17481:    win = ctx->current;
../lib/public/nuklear.h:17482:    out = &win->buffer;
../lib/public/nuklear.h:17483:    layout = win->layout;
../lib/public/nuklear.h:17484:    if (layout->flags & NK_WINDOW_HIDDEN || layout->flags & NK_WINDOW_MINIMIZED)
../lib/public/nuklear.h:17487:    layout->menu.h = layout->at_y - layout->menu.y;
../lib/public/nuklear.h:17488:    layout->bounds.y += layout->menu.h + ctx->style.window.spacing.y + layout->row.height;
../lib/public/nuklear.h:17489:    layout->bounds.h -= layout->menu.h + ctx->style.window.spacing.y + layout->row.height;
../lib/public/nuklear.h:17491:    *layout->offset_x = layout->menu.offset.x;
../lib/public/nuklear.h:17492:    *layout->offset_y = layout->menu.offset.y;
../lib/public/nuklear.h:17493:    layout->at_y = layout->bounds.y - layout->row.height;
../lib/public/nuklear.h:17495:    layout->clip.y = layout->bounds.y;
../lib/public/nuklear.h:17496:    layout->clip.h = layout->bounds.h;
../lib/public/nuklear.h:17497:    nk_push_scissor(out, layout->clip);
../lib/public/nuklear.h:17510:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17511:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17512:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17520:    popup = win->popup.win;
../lib/public/nuklear.h:17522:    is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_MENU);
../lib/public/nuklear.h:17528:    win->popup.type = NK_PANEL_MENU;
../lib/public/nuklear.h:17529:    win->popup.name = hash;
../lib/public/nuklear.h:17543:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17544:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17545:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17548:    win = ctx->current;
../lib/public/nuklear.h:17551:    in = (state == NK_WIDGET_ROM || win->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17552:    if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, header,
../lib/public/nuklear.h:17553:        title, len, align, NK_BUTTON_DEFAULT, &ctx->style.menu_button, in, ctx->style.font))
../lib/public/nuklear.h:17573:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17574:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17575:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17578:    win = ctx->current;
../lib/public/nuklear.h:17581:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17582:    if (nk_do_button_image(&ctx->last_widget_state, &win->buffer, header,
../lib/public/nuklear.h:17583:        img, NK_BUTTON_DEFAULT, &ctx->style.menu_button, in))
../lib/public/nuklear.h:17598:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17599:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17600:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17603:    win = ctx->current;
../lib/public/nuklear.h:17606:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17607:    if (nk_do_button_symbol(&ctx->last_widget_state,  &win->buffer, header,
../lib/public/nuklear.h:17608:        sym, NK_BUTTON_DEFAULT, &ctx->style.menu_button, in, ctx->style.font))
../lib/public/nuklear.h:17623:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17624:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17625:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17628:    win = ctx->current;
../lib/public/nuklear.h:17631:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17632:    if (nk_do_button_text_image(&ctx->last_widget_state, &win->buffer,
../lib/public/nuklear.h:17633:        header, img, title, len, align, NK_BUTTON_DEFAULT, &ctx->style.menu_button,
../lib/public/nuklear.h:17634:        ctx->style.font, in))
../lib/public/nuklear.h:17655:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17656:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17657:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17660:    win = ctx->current;
../lib/public/nuklear.h:17664:    in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:17665:    if (nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer,
../lib/public/nuklear.h:17666:        header, sym, title, len, align, NK_BUTTON_DEFAULT, &ctx->style.menu_button,
../lib/public/nuklear.h:17667:        ctx->style.font, in)) is_clicked = nk_true;
../lib/public/nuklear.h:17734:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17735:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17736:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17739:    win = ctx->current;
../lib/public/nuklear.h:17740:    layout = win->layout;
../lib/public/nuklear.h:17741:    layout->row.min_height = height;
../lib/public/nuklear.h:17750:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17751:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17752:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17755:    win = ctx->current;
../lib/public/nuklear.h:17756:    layout = win->layout;
../lib/public/nuklear.h:17757:    layout->row.min_height = ctx->style.font->height;
../lib/public/nuklear.h:17758:    layout->row.min_height += ctx->style.text.padding.y*2;
../lib/public/nuklear.h:17759:    layout->row.min_height += ctx->style.window.min_row_height_padding*2;
../lib/public/nuklear.h:17772:    spacing = style->window.spacing;
../lib/public/nuklear.h:17777:    panel_spacing = (float)NK_MAX(columns - 1, 0) * spacing.x;
../lib/public/nuklear.h:17778:    panel_space  = total_space - panel_padding - panel_spacing;
../lib/public/nuklear.h:17793:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17794:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17795:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17799:    layout = win->layout;
../lib/public/nuklear.h:17800:    style = &ctx->style;
../lib/public/nuklear.h:17801:    out = &win->buffer;
../lib/public/nuklear.h:17802:    color = style->window.background;
../lib/public/nuklear.h:17803:    item_spacing = style->window.spacing;
../lib/public/nuklear.h:17810:    NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
../lib/public/nuklear.h:17811:    NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
../lib/public/nuklear.h:17812:    NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));
../lib/public/nuklear.h:17815:    layout->row.index = 0;
../lib/public/nuklear.h:17816:    layout->at_y += layout->row.height;
../lib/public/nuklear.h:17817:    layout->row.columns = cols;
../lib/public/nuklear.h:17819:        layout->row.height = NK_MAX(height, layout->row.min_height) + item_spacing.y;
../lib/public/nuklear.h:17820:    else layout->row.height = height + item_spacing.y;
../lib/public/nuklear.h:17822:    layout->row.item_offset = 0;
../lib/public/nuklear.h:17823:    if (layout->flags & NK_WINDOW_DYNAMIC) {
../lib/public/nuklear.h:17826:        background.x = win->bounds.x;
../lib/public/nuklear.h:17827:        background.w = win->bounds.w;
../lib/public/nuklear.h:17828:        background.y = layout->at_y - 1.0f;
../lib/public/nuklear.h:17829:        background.h = layout->row.height + 1.0f;
../lib/public/nuklear.h:17840:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17841:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17842:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17845:    win = ctx->current;
../lib/public/nuklear.h:17848:        win->layout->row.type = NK_LAYOUT_DYNAMIC_FIXED;
../lib/public/nuklear.h:17849:    else win->layout->row.type = NK_LAYOUT_STATIC_FIXED;
../lib/public/nuklear.h:17851:    win->layout->row.ratio = 0;
../lib/public/nuklear.h:17852:    win->layout->row.filled = 0;
../lib/public/nuklear.h:17853:    win->layout->row.item_offset = 0;
../lib/public/nuklear.h:17854:    win->layout->row.item_width = (float)width;
../lib/public/nuklear.h:17862:    if (!ctx || !ctx->current || !ctx->current->layout) return 0;
../lib/public/nuklear.h:17863:    win = ctx->current;
../lib/public/nuklear.h:17864:    return NK_CLAMP(0.0f, pixel_width/win->bounds.x, 1.0f);
../lib/public/nuklear.h:17884:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17885:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17886:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17889:    win = ctx->current;
../lib/public/nuklear.h:17890:    layout = win->layout;
../lib/public/nuklear.h:17893:        layout->row.type = NK_LAYOUT_DYNAMIC_ROW;
../lib/public/nuklear.h:17894:    else layout->row.type = NK_LAYOUT_STATIC_ROW;
../lib/public/nuklear.h:17896:    layout->row.ratio = 0;
../lib/public/nuklear.h:17897:    layout->row.filled = 0;
../lib/public/nuklear.h:17898:    layout->row.item_width = 0;
../lib/public/nuklear.h:17899:    layout->row.item_offset = 0;
../lib/public/nuklear.h:17900:    layout->row.columns = cols;
../lib/public/nuklear.h:17909:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17910:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17911:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17914:    win = ctx->current;
../lib/public/nuklear.h:17915:    layout = win->layout;
../lib/public/nuklear.h:17916:    NK_ASSERT(layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW);
../lib/public/nuklear.h:17917:    if (layout->row.type != NK_LAYOUT_STATIC_ROW && layout->row.type != NK_LAYOUT_DYNAMIC_ROW)
../lib/public/nuklear.h:17920:    if (layout->row.type == NK_LAYOUT_DYNAMIC_ROW) {
../lib/public/nuklear.h:17922:        if ((ratio + layout->row.filled) > 1.0f) return;
../lib/public/nuklear.h:17924:            layout->row.item_width = NK_SATURATE(ratio);
../lib/public/nuklear.h:17925:        else layout->row.item_width = 1.0f - layout->row.filled;
../lib/public/nuklear.h:17926:    } else layout->row.item_width = ratio_or_width;
../lib/public/nuklear.h:17935:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17936:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17937:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17940:    win = ctx->current;
../lib/public/nuklear.h:17941:    layout = win->layout;
../lib/public/nuklear.h:17942:    NK_ASSERT(layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW);
../lib/public/nuklear.h:17943:    if (layout->row.type != NK_LAYOUT_STATIC_ROW && layout->row.type != NK_LAYOUT_DYNAMIC_ROW)
../lib/public/nuklear.h:17945:    layout->row.item_width = 0;
../lib/public/nuklear.h:17946:    layout->row.item_offset = 0;
../lib/public/nuklear.h:17958:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17959:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17960:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17963:    win = ctx->current;
../lib/public/nuklear.h:17964:    layout = win->layout;
../lib/public/nuklear.h:17969:        layout->row.ratio = ratio;
../lib/public/nuklear.h:17975:        r = NK_SATURATE(1.0f - r);
../lib/public/nuklear.h:17976:        layout->row.type = NK_LAYOUT_DYNAMIC;
../lib/public/nuklear.h:17977:        layout->row.item_width = (r > 0 && n_undef > 0) ? (r / (float)n_undef):0;
../lib/public/nuklear.h:17979:        layout->row.ratio = ratio;
../lib/public/nuklear.h:17980:        layout->row.type = NK_LAYOUT_STATIC;
../lib/public/nuklear.h:17981:        layout->row.item_width = 0;
../lib/public/nuklear.h:17982:        layout->row.item_offset = 0;
../lib/public/nuklear.h:17984:    layout->row.item_offset = 0;
../lib/public/nuklear.h:17985:    layout->row.filled = 0;
../lib/public/nuklear.h:17994:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:17995:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:17996:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:17999:    win = ctx->current;
../lib/public/nuklear.h:18000:    layout = win->layout;
../lib/public/nuklear.h:18002:    layout->row.type = NK_LAYOUT_TEMPLATE;
../lib/public/nuklear.h:18003:    layout->row.columns = 0;
../lib/public/nuklear.h:18004:    layout->row.ratio = 0;
../lib/public/nuklear.h:18005:    layout->row.item_width = 0;
../lib/public/nuklear.h:18006:    layout->row.item_height = 0;
../lib/public/nuklear.h:18007:    layout->row.item_offset = 0;
../lib/public/nuklear.h:18008:    layout->row.filled = 0;
../lib/public/nuklear.h:18009:    layout->row.item.x = 0;
../lib/public/nuklear.h:18010:    layout->row.item.y = 0;
../lib/public/nuklear.h:18011:    layout->row.item.w = 0;
../lib/public/nuklear.h:18012:    layout->row.item.h = 0;
../lib/public/nuklear.h:18021:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18022:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18023:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18026:    win = ctx->current;
../lib/public/nuklear.h:18027:    layout = win->layout;
../lib/public/nuklear.h:18028:    NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
../lib/public/nuklear.h:18029:    NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
../lib/public/nuklear.h:18030:    if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
../lib/public/nuklear.h:18031:    if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
../lib/public/nuklear.h:18032:    layout->row.templates[layout->row.columns++] = -1.0f;
../lib/public/nuklear.h:18041:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18042:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18043:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18046:    win = ctx->current;
../lib/public/nuklear.h:18047:    layout = win->layout;
../lib/public/nuklear.h:18048:    NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
../lib/public/nuklear.h:18049:    NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
../lib/public/nuklear.h:18050:    if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
../lib/public/nuklear.h:18051:    if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
../lib/public/nuklear.h:18052:    layout->row.templates[layout->row.columns++] = -min_width;
../lib/public/nuklear.h:18061:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18062:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18063:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18066:    win = ctx->current;
../lib/public/nuklear.h:18067:    layout = win->layout;
../lib/public/nuklear.h:18068:    NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
../lib/public/nuklear.h:18069:    NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
../lib/public/nuklear.h:18070:    if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
../lib/public/nuklear.h:18071:    if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
../lib/public/nuklear.h:18072:    layout->row.templates[layout->row.columns++] = width;
../lib/public/nuklear.h:18088:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18089:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18090:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18093:    win = ctx->current;
../lib/public/nuklear.h:18094:    layout = win->layout;
../lib/public/nuklear.h:18095:    NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
../lib/public/nuklear.h:18096:    if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
../lib/public/nuklear.h:18097:    for (i = 0; i < layout->row.columns; ++i) {
../lib/public/nuklear.h:18098:        float width = layout->row.templates[i];
../lib/public/nuklear.h:18102:        } else if (width < -1.0f) {
../lib/public/nuklear.h:18103:            width = -width;
../lib/public/nuklear.h:18113:        float space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type,
../lib/public/nuklear.h:18114:                            layout->bounds.w, layout->row.columns);
../lib/public/nuklear.h:18115:        float var_width = (NK_MAX(space-min_fixed_width,0.0f)) / (float)variable_count;
../lib/public/nuklear.h:18118:            var_width = (NK_MAX(space-total_fixed_width,0)) / (float)min_variable_count;
../lib/public/nuklear.h:18119:        for (i = 0; i < layout->row.columns; ++i) {
../lib/public/nuklear.h:18120:            float *width = &layout->row.templates[i];
../lib/public/nuklear.h:18121:            *width = (*width >= 0.0f)? *width: (*width < -1.0f && !enough_space)? -(*width): var_width;
../lib/public/nuklear.h:18133:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18134:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18135:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18138:    win = ctx->current;
../lib/public/nuklear.h:18139:    layout = win->layout;
../lib/public/nuklear.h:18142:        layout->row.type = NK_LAYOUT_STATIC_FREE;
../lib/public/nuklear.h:18143:    else layout->row.type = NK_LAYOUT_DYNAMIC_FREE;
../lib/public/nuklear.h:18145:    layout->row.ratio = 0;
../lib/public/nuklear.h:18146:    layout->row.filled = 0;
../lib/public/nuklear.h:18147:    layout->row.item_width = 0;
../lib/public/nuklear.h:18148:    layout->row.item_offset = 0;
../lib/public/nuklear.h:18157:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18158:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18159:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18162:    win = ctx->current;
../lib/public/nuklear.h:18163:    layout = win->layout;
../lib/public/nuklear.h:18164:    layout->row.item_width = 0;
../lib/public/nuklear.h:18165:    layout->row.item_height = 0;
../lib/public/nuklear.h:18166:    layout->row.item_offset = 0;
../lib/public/nuklear.h:18167:    nk_zero(&layout->row.item, sizeof(layout->row.item));
../lib/public/nuklear.h:18176:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18177:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18178:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18181:    win = ctx->current;
../lib/public/nuklear.h:18182:    layout = win->layout;
../lib/public/nuklear.h:18183:    layout->row.item = rect;
../lib/public/nuklear.h:18193:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18194:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18195:    win = ctx->current;
../lib/public/nuklear.h:18196:    layout = win->layout;
../lib/public/nuklear.h:18198:    ret.x = layout->clip.x;
../lib/public/nuklear.h:18199:    ret.y = layout->clip.y;
../lib/public/nuklear.h:18200:    ret.w = layout->clip.w;
../lib/public/nuklear.h:18201:    ret.h = layout->row.height;
../lib/public/nuklear.h:18212:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18213:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18214:    win = ctx->current;
../lib/public/nuklear.h:18215:    layout = win->layout;
../lib/public/nuklear.h:18217:    ret.x = layout->at_x;
../lib/public/nuklear.h:18218:    ret.y = layout->at_y;
../lib/public/nuklear.h:18219:    ret.w = layout->bounds.w - NK_MAX(layout->at_x - layout->bounds.x,0);
../lib/public/nuklear.h:18220:    ret.h = layout->row.height;
../lib/public/nuklear.h:18230:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18231:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18232:    win = ctx->current;
../lib/public/nuklear.h:18233:    layout = win->layout;
../lib/public/nuklear.h:18235:    ret.x += layout->at_x - (float)*layout->offset_x;
../lib/public/nuklear.h:18236:    ret.y += layout->at_y - (float)*layout->offset_y;
../lib/public/nuklear.h:18246:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18247:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18248:    win = ctx->current;
../lib/public/nuklear.h:18249:    layout = win->layout;
../lib/public/nuklear.h:18251:    ret.x += -layout->at_x + (float)*layout->offset_x;
../lib/public/nuklear.h:18252:    ret.y += -layout->at_y + (float)*layout->offset_y;
../lib/public/nuklear.h:18262:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18263:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18264:    win = ctx->current;
../lib/public/nuklear.h:18265:    layout = win->layout;
../lib/public/nuklear.h:18267:    ret.x += layout->at_x - (float)*layout->offset_x;
../lib/public/nuklear.h:18268:    ret.y += layout->at_y - (float)*layout->offset_y;
../lib/public/nuklear.h:18278:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18279:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18280:    win = ctx->current;
../lib/public/nuklear.h:18281:    layout = win->layout;
../lib/public/nuklear.h:18283:    ret.x += -layout->at_x + (float)*layout->offset_x;
../lib/public/nuklear.h:18284:    ret.y += -layout->at_y + (float)*layout->offset_y;
../lib/public/nuklear.h:18290:    struct nk_panel *layout = win->layout;
../lib/public/nuklear.h:18291:    struct nk_vec2 spacing = ctx->style.window.spacing;
../lib/public/nuklear.h:18292:    const float row_height = layout->row.height - spacing.y;
../lib/public/nuklear.h:18293:    nk_panel_layout(ctx, win, row_height, layout->row.columns);
../lib/public/nuklear.h:18311:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18312:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18313:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18316:    win = ctx->current;
../lib/public/nuklear.h:18317:    layout = win->layout;
../lib/public/nuklear.h:18318:    style = &ctx->style;
../lib/public/nuklear.h:18321:    spacing = style->window.spacing;
../lib/public/nuklear.h:18322:    padding = nk_panel_get_padding(style, layout->type);
../lib/public/nuklear.h:18323:    panel_space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type,
../lib/public/nuklear.h:18324:                                            layout->bounds.w, layout->row.columns);
../lib/public/nuklear.h:18326:    #define NK_FRAC(x) (x - (int)x) /* will be used to remove fookin gaps */
../lib/public/nuklear.h:18328:    switch (layout->row.type) {
../lib/public/nuklear.h:18331:        float w = NK_MAX(1.0f,panel_space) / (float)layout->row.columns;
../lib/public/nuklear.h:18332:        item_offset = (float)layout->row.index * w;
../lib/public/nuklear.h:18334:        item_spacing = (float)layout->row.index * spacing.x;
../lib/public/nuklear.h:18338:        float w = layout->row.item_width * panel_space;
../lib/public/nuklear.h:18339:        item_offset = layout->row.item_offset;
../lib/public/nuklear.h:18344:            layout->row.item_offset += w + spacing.x;
../lib/public/nuklear.h:18345:            layout->row.filled += layout->row.item_width;
../lib/public/nuklear.h:18346:            layout->row.index = 0;
../lib/public/nuklear.h:18351:        bounds->x = layout->at_x + (layout->bounds.w * layout->row.item.x);
../lib/public/nuklear.h:18352:        bounds->x -= (float)*layout->offset_x;
../lib/public/nuklear.h:18353:        bounds->y = layout->at_y + (layout->row.height * layout->row.item.y);
../lib/public/nuklear.h:18354:        bounds->y -= (float)*layout->offset_y;
../lib/public/nuklear.h:18355:        bounds->w = layout->bounds.w  * layout->row.item.w + NK_FRAC(bounds->x);
../lib/public/nuklear.h:18356:        bounds->h = layout->row.height * layout->row.item.h + NK_FRAC(bounds->y);
../lib/public/nuklear.h:18362:        NK_ASSERT(layout->row.ratio);
../lib/public/nuklear.h:18363:        ratio = (layout->row.ratio[layout->row.index] < 0) ?
../lib/public/nuklear.h:18364:            layout->row.item_width : layout->row.ratio[layout->row.index];
../lib/public/nuklear.h:18367:        item_spacing = (float)layout->row.index * spacing.x;
../lib/public/nuklear.h:18368:        item_offset = layout->row.item_offset;
../lib/public/nuklear.h:18372:            layout->row.item_offset += w;
../lib/public/nuklear.h:18373:            layout->row.filled += ratio;
../lib/public/nuklear.h:18377:        /* non-scaling fixed widgets item width */
../lib/public/nuklear.h:18378:        item_width = layout->row.item_width;
../lib/public/nuklear.h:18379:        item_offset = (float)layout->row.index * item_width;
../lib/public/nuklear.h:18380:        item_spacing = (float)layout->row.index * spacing.x;
../lib/public/nuklear.h:18384:        item_width = layout->row.item_width;
../lib/public/nuklear.h:18385:        item_offset = layout->row.item_offset;
../lib/public/nuklear.h:18386:        item_spacing = (float)layout->row.index * spacing.x;
../lib/public/nuklear.h:18387:        if (modify) layout->row.item_offset += item_width;
../lib/public/nuklear.h:18391:        bounds->x = layout->at_x + layout->row.item.x;
../lib/public/nuklear.h:18392:        bounds->w = layout->row.item.w;
../lib/public/nuklear.h:18393:        if (((bounds->x + bounds->w) > layout->max_x) && modify)
../lib/public/nuklear.h:18394:            layout->max_x = (bounds->x + bounds->w);
../lib/public/nuklear.h:18395:        bounds->x -= (float)*layout->offset_x;
../lib/public/nuklear.h:18396:        bounds->y = layout->at_y + layout->row.item.y;
../lib/public/nuklear.h:18397:        bounds->y -= (float)*layout->offset_y;
../lib/public/nuklear.h:18398:        bounds->h = layout->row.item.h;
../lib/public/nuklear.h:18402:        /* non-scaling array of panel pixel width for every widget */
../lib/public/nuklear.h:18403:        item_spacing = (float)layout->row.index * spacing.x;
../lib/public/nuklear.h:18404:        item_width = layout->row.ratio[layout->row.index];
../lib/public/nuklear.h:18405:        item_offset = layout->row.item_offset;
../lib/public/nuklear.h:18406:        if (modify) layout->row.item_offset += item_width;
../lib/public/nuklear.h:18411:        NK_ASSERT(layout->row.index < layout->row.columns);
../lib/public/nuklear.h:18412:        NK_ASSERT(layout->row.index < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
../lib/public/nuklear.h:18413:        w = layout->row.templates[layout->row.index];
../lib/public/nuklear.h:18414:        item_offset = layout->row.item_offset;
../lib/public/nuklear.h:18416:        item_spacing = (float)layout->row.index * spacing.x;
../lib/public/nuklear.h:18417:        if (modify) layout->row.item_offset += w;
../lib/public/nuklear.h:18424:    bounds->w = item_width;
../lib/public/nuklear.h:18425:    bounds->h = layout->row.height - spacing.y;
../lib/public/nuklear.h:18426:    bounds->y = layout->at_y - (float)*layout->offset_y;
../lib/public/nuklear.h:18427:    bounds->x = layout->at_x + item_offset + item_spacing + padding.x;
../lib/public/nuklear.h:18428:    if (((bounds->x + bounds->w) > layout->max_x) && modify)
../lib/public/nuklear.h:18429:        layout->max_x = bounds->x + bounds->w;
../lib/public/nuklear.h:18430:    bounds->x -= (float)*layout->offset_x;
../lib/public/nuklear.h:18439:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18440:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18441:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18445:    win = ctx->current;
../lib/public/nuklear.h:18446:    layout = win->layout;
../lib/public/nuklear.h:18447:    if (layout->row.index >= layout->row.columns)
../lib/public/nuklear.h:18452:    layout->row.index++;
../lib/public/nuklear.h:18463:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18464:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18465:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18468:    win = ctx->current;
../lib/public/nuklear.h:18469:    layout = win->layout;
../lib/public/nuklear.h:18470:    y = layout->at_y;
../lib/public/nuklear.h:18471:    index = layout->row.index;
../lib/public/nuklear.h:18472:    if (layout->row.index >= layout->row.columns) {
../lib/public/nuklear.h:18473:        layout->at_y += layout->row.height;
../lib/public/nuklear.h:18474:        layout->row.index = 0;
../lib/public/nuklear.h:18477:    if (!layout->row.index) {
../lib/public/nuklear.h:18478:        bounds->x -= layout->row.item_offset;
../lib/public/nuklear.h:18480:    layout->at_y = y;
../lib/public/nuklear.h:18481:    layout->row.index = index;
../lib/public/nuklear.h:18515:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18516:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18517:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18521:    win = ctx->current;
../lib/public/nuklear.h:18522:    layout = win->layout;
../lib/public/nuklear.h:18523:    out = &win->buffer;
../lib/public/nuklear.h:18524:    style = &ctx->style;
../lib/public/nuklear.h:18525:    item_spacing = style->window.spacing;
../lib/public/nuklear.h:18528:    row_height = style->font->height + 2 * style->tab.padding.y;
../lib/public/nuklear.h:18535:        const struct nk_style_item *background = &style->tab.background;
../lib/public/nuklear.h:18536:        if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:18537:            nk_draw_image(out, header, &background->data.image, nk_white);
../lib/public/nuklear.h:18539:        } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:18540:            nk_draw_texpath(out, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:18543:            text.background = background->data.color;
../lib/public/nuklear.h:18544:            nk_fill_rect(out, header, 0, style->tab.border_color);
../lib/public/nuklear.h:18545:            nk_fill_rect(out, nk_shrink_rect(header, style->tab.border),
../lib/public/nuklear.h:18546:                style->tab.rounding, background->data.color);
../lib/public/nuklear.h:18548:    } else text.background = style->window.background;
../lib/public/nuklear.h:18551:    in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input: 0;
../lib/public/nuklear.h:18552:    in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;
../lib/public/nuklear.h:18558:        symbol = style->tab.sym_maximize;
../lib/public/nuklear.h:18560:            button = &style->tab.tab_maximize_button;
../lib/public/nuklear.h:18561:        else button = &style->tab.node_maximize_button;
../lib/public/nuklear.h:18563:        symbol = style->tab.sym_minimize;
../lib/public/nuklear.h:18565:            button = &style->tab.tab_minimize_button;
../lib/public/nuklear.h:18566:        else button = &style->tab.node_minimize_button;
../lib/public/nuklear.h:18570:    sym.w = sym.h = style->font->height;
../lib/public/nuklear.h:18571:    sym.y = header.y + style->tab.padding.y;
../lib/public/nuklear.h:18572:    sym.x = header.x + style->tab.padding.x;
../lib/public/nuklear.h:18573:    nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT,
../lib/public/nuklear.h:18574:        button, 0, style->font);
../lib/public/nuklear.h:18579:        nk_draw_image(&win->buffer, sym, img, nk_white);
../lib/public/nuklear.h:18580:        sym.w = style->font->height + style->tab.spacing.x;}
../lib/public/nuklear.h:18588:    label.w = header.w - (sym.w + item_spacing.y + style->tab.indent);
../lib/public/nuklear.h:18589:    label.h = style->font->height;
../lib/public/nuklear.h:18590:    text.text = style->tab.text;
../lib/public/nuklear.h:18593:        NK_TEXT_LEFT, style->font);}
../lib/public/nuklear.h:18595:    /* increase x-axis cursor widget position pointer */
../lib/public/nuklear.h:18597:        layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
../lib/public/nuklear.h:18598:        layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
../lib/public/nuklear.h:18599:        layout->bounds.w -= (style->tab.indent + style->window.padding.x);
../lib/public/nuklear.h:18600:        layout->row.tree_depth++;
../lib/public/nuklear.h:18609:    struct nk_window *win = ctx->current;
../lib/public/nuklear.h:18645:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18646:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18647:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18650:    win = ctx->current;
../lib/public/nuklear.h:18651:    layout = win->layout;
../lib/public/nuklear.h:18652:    layout->at_x -= ctx->style.tab.indent + ctx->style.window.padding.x;
../lib/public/nuklear.h:18653:    layout->bounds.w += ctx->style.tab.indent + ctx->style.window.padding.x;
../lib/public/nuklear.h:18654:    NK_ASSERT(layout->row.tree_depth);
../lib/public/nuklear.h:18655:    layout->row.tree_depth--;
../lib/public/nuklear.h:18702:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18703:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18704:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:18708:    win = ctx->current;
../lib/public/nuklear.h:18709:    layout = win->layout;
../lib/public/nuklear.h:18710:    out = &win->buffer;
../lib/public/nuklear.h:18711:    style = &ctx->style;
../lib/public/nuklear.h:18712:    item_spacing = style->window.spacing;
../lib/public/nuklear.h:18713:    padding = style->selectable.padding;
../lib/public/nuklear.h:18716:    row_height = style->font->height + 2 * style->tab.padding.y;
../lib/public/nuklear.h:18723:        const struct nk_style_item *background = &style->tab.background;
../lib/public/nuklear.h:18724:        if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:18725:            nk_draw_image(out, header, &background->data.image, nk_white);
../lib/public/nuklear.h:18726:        } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:18727:            nk_draw_texpath(out, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:18729:            nk_fill_rect(out, header, 0, style->tab.border_color);
../lib/public/nuklear.h:18730:            nk_fill_rect(out, nk_shrink_rect(header, style->tab.border),
../lib/public/nuklear.h:18731:                style->tab.rounding, background->data.color);
../lib/public/nuklear.h:18735:    in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input: 0;
../lib/public/nuklear.h:18736:    in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;
../lib/public/nuklear.h:18740:        symbol = style->tab.sym_maximize;
../lib/public/nuklear.h:18742:            button = &style->tab.tab_maximize_button;
../lib/public/nuklear.h:18743:        else button = &style->tab.node_maximize_button;
../lib/public/nuklear.h:18745:        symbol = style->tab.sym_minimize;
../lib/public/nuklear.h:18747:            button = &style->tab.tab_minimize_button;
../lib/public/nuklear.h:18748:        else button = &style->tab.node_minimize_button;
../lib/public/nuklear.h:18751:    sym.w = sym.h = style->font->height;
../lib/public/nuklear.h:18752:    sym.y = header.y + style->tab.padding.y;
../lib/public/nuklear.h:18753:    sym.x = header.x + style->tab.padding.x;
../lib/public/nuklear.h:18754:    if (nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT, button, in, style->font))
../lib/public/nuklear.h:18762:    text_width = style->font->width(style->font->userdata, style->font->height, title, text_len);
../lib/public/nuklear.h:18768:    label.w = NK_MIN(header.w - (sym.w + item_spacing.y + style->tab.indent), text_width);
../lib/public/nuklear.h:18769:    label.h = style->font->height;
../lib/public/nuklear.h:18772:        nk_do_selectable_image(&dummy, &win->buffer, label, title, title_len, NK_TEXT_LEFT,
../lib/public/nuklear.h:18773:            selected, img, &style->selectable, in, style->font);
../lib/public/nuklear.h:18774:    } else nk_do_selectable(&dummy, &win->buffer, label, title, title_len, NK_TEXT_LEFT,
../lib/public/nuklear.h:18775:            selected, &style->selectable, in, style->font);
../lib/public/nuklear.h:18777:    /* increase x-axis cursor widget position pointer */
../lib/public/nuklear.h:18779:        layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
../lib/public/nuklear.h:18780:        layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
../lib/public/nuklear.h:18781:        layout->bounds.w -= (style->tab.indent + style->window.padding.x);
../lib/public/nuklear.h:18782:        layout->row.tree_depth++;
../lib/public/nuklear.h:18791:    struct nk_window *win = ctx->current;
../lib/public/nuklear.h:18845:    win = ctx->current;
../lib/public/nuklear.h:18847:    {const struct nk_rect *c = &win->layout->clip;
../lib/public/nuklear.h:18848:    if (!NK_INTERSECT(c->x, c->y, c->w, c->h, bounds.x, bounds.y, bounds.w, bounds.h) &&
../lib/public/nuklear.h:18852:    if (win->flags & NK_WINDOW_ROM)
../lib/public/nuklear.h:18861:    panel.buffer = win->buffer;
../lib/public/nuklear.h:18863:    ctx->current = &panel;
../lib/public/nuklear.h:18866:    win->buffer = panel.buffer;
../lib/public/nuklear.h:18867:    win->buffer.clip = panel.layout->clip;
../lib/public/nuklear.h:18868:    panel.layout->offset_x = x_offset;
../lib/public/nuklear.h:18869:    panel.layout->offset_y = y_offset;
../lib/public/nuklear.h:18870:    panel.layout->parent = win->layout;
../lib/public/nuklear.h:18871:    win->layout = panel.layout;
../lib/public/nuklear.h:18873:    ctx->current = win;
../lib/public/nuklear.h:18874:    if ((panel.layout->flags & NK_WINDOW_CLOSED) ||
../lib/public/nuklear.h:18875:        (panel.layout->flags & NK_WINDOW_MINIMIZED))
../lib/public/nuklear.h:18877:        nk_flags f = panel.layout->flags;
../lib/public/nuklear.h:18898:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18899:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:18903:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18904:    win = ctx->current;
../lib/public/nuklear.h:18905:    NK_ASSERT(win->layout);
../lib/public/nuklear.h:18906:    g = win->layout;
../lib/public/nuklear.h:18907:    NK_ASSERT(g->parent);
../lib/public/nuklear.h:18908:    parent = g->parent;
../lib/public/nuklear.h:18912:    panel_padding = nk_panel_get_padding(&ctx->style, NK_PANEL_GROUP);
../lib/public/nuklear.h:18913:    pan.bounds.y = g->bounds.y - (g->header_height + g->menu.h);
../lib/public/nuklear.h:18914:    pan.bounds.x = g->bounds.x - panel_padding.x;
../lib/public/nuklear.h:18915:    pan.bounds.w = g->bounds.w + 2 * panel_padding.x;
../lib/public/nuklear.h:18916:    pan.bounds.h = g->bounds.h + g->header_height + g->menu.h;
../lib/public/nuklear.h:18917:    if (g->flags & NK_WINDOW_BORDER) {
../lib/public/nuklear.h:18918:        pan.bounds.x -= g->border;
../lib/public/nuklear.h:18919:        pan.bounds.y -= g->border;
../lib/public/nuklear.h:18920:        pan.bounds.w += 2*g->border;
../lib/public/nuklear.h:18921:        pan.bounds.h += 2*g->border;
../lib/public/nuklear.h:18923:    if (!(g->flags & NK_WINDOW_NO_SCROLLBAR)) {
../lib/public/nuklear.h:18924:        pan.bounds.w += ctx->style.window.scrollbar_size.x;
../lib/public/nuklear.h:18925:        pan.bounds.h += ctx->style.window.scrollbar_size.y;
../lib/public/nuklear.h:18927:    pan.scrollbar.x = *g->offset_x;
../lib/public/nuklear.h:18928:    pan.scrollbar.y = *g->offset_y;
../lib/public/nuklear.h:18929:    pan.flags = g->flags;
../lib/public/nuklear.h:18930:    pan.buffer = win->buffer;
../lib/public/nuklear.h:18933:    ctx->current = &pan;
../lib/public/nuklear.h:18936:    nk_unify(&clip, &parent->clip, pan.bounds.x, pan.bounds.y,
../lib/public/nuklear.h:18941:    win->buffer = pan.buffer;
../lib/public/nuklear.h:18942:    nk_push_scissor(&win->buffer, parent->clip);
../lib/public/nuklear.h:18943:    ctx->current = win;
../lib/public/nuklear.h:18944:    win->layout = parent;
../lib/public/nuklear.h:18945:    g->bounds = pan.bounds;
../lib/public/nuklear.h:18952:    return nk_group_scrolled_offset_begin(ctx, &scroll->x, &scroll->y, title, flags);
../lib/public/nuklear.h:18966:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:18967:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:18968:    if (!ctx || !ctx->current || !ctx->current->layout || !id)
../lib/public/nuklear.h:18972:    win = ctx->current;
../lib/public/nuklear.h:19027:    win = ctx->current;
../lib/public/nuklear.h:19028:    style = &ctx->style;
../lib/public/nuklear.h:19029:    item_spacing = style->window.spacing;
../lib/public/nuklear.h:19045:    view->scroll_value = *y_offset;
../lib/public/nuklear.h:19046:    view->scroll_pointer = y_offset;
../lib/public/nuklear.h:19050:    win = ctx->current;
../lib/public/nuklear.h:19051:    layout = win->layout;
../lib/public/nuklear.h:19053:    view->total_height = row_height * NK_MAX(row_count,1);
../lib/public/nuklear.h:19054:    view->begin = (int)NK_MAX(((float)view->scroll_value / (float)row_height), 0.0f);
../lib/public/nuklear.h:19055:    view->count = (int)NK_MAX(nk_iceilf((layout->clip.h)/(float)row_height),0);
../lib/public/nuklear.h:19056:    view->count = NK_MIN(view->count, row_count - view->begin);
../lib/public/nuklear.h:19057:    view->end = view->begin + view->count;
../lib/public/nuklear.h:19058:    view->ctx = ctx;
../lib/public/nuklear.h:19069:    NK_ASSERT(view->ctx);
../lib/public/nuklear.h:19070:    NK_ASSERT(view->scroll_pointer);
../lib/public/nuklear.h:19071:    if (!view || !view->ctx) return;
../lib/public/nuklear.h:19073:    ctx = view->ctx;
../lib/public/nuklear.h:19074:    win = ctx->current;
../lib/public/nuklear.h:19075:    layout = win->layout;
../lib/public/nuklear.h:19076:    layout->at_y = layout->bounds.y + (float)view->total_height;
../lib/public/nuklear.h:19077:    *view->scroll_pointer = *view->scroll_pointer + view->scroll_value;
../lib/public/nuklear.h:19078:    nk_group_end(view->ctx);
../lib/public/nuklear.h:19095:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19096:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:19106:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19107:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:19118:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19119:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:19130:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19131:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:19142:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19143:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:19155:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19156:    if (!ctx || !ctx->current || ctx->active != ctx->current)
../lib/public/nuklear.h:19159:    c = ctx->current->layout->clip;
../lib/public/nuklear.h:19169:    return nk_input_is_mouse_hovering_rect(&ctx->input, bounds);
../lib/public/nuklear.h:19177:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19178:    if (!ctx || !ctx->current || ctx->active != ctx->current)
../lib/public/nuklear.h:19181:    c = ctx->current->layout->clip;
../lib/public/nuklear.h:19191:    return nk_input_mouse_clicked(&ctx->input, btn, bounds);
../lib/public/nuklear.h:19199:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19200:    if (!ctx || !ctx->current || ctx->active != ctx->current)
../lib/public/nuklear.h:19203:    c = ctx->current->layout->clip;
../lib/public/nuklear.h:19213:    return nk_input_has_mouse_click_down_in_rect(&ctx->input, btn, bounds, down);
../lib/public/nuklear.h:19224:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19225:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19226:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:19231:    win = ctx->current;
../lib/public/nuklear.h:19232:    layout = win->layout;
../lib/public/nuklear.h:19233:    in = &ctx->input;
../lib/public/nuklear.h:19234:    c = layout->clip;
../lib/public/nuklear.h:19241:    NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
../lib/public/nuklear.h:19242:    NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
../lib/public/nuklear.h:19243:    NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));
../lib/public/nuklear.h:19246:    bounds->x = (float)((int)bounds->x);
../lib/public/nuklear.h:19247:    bounds->y = (float)((int)bounds->y);
../lib/public/nuklear.h:19248:    bounds->w = (float)((int)bounds->w);
../lib/public/nuklear.h:19249:    bounds->h = (float)((int)bounds->h);
../lib/public/nuklear.h:19256:    nk_unify(&v, &c, bounds->x, bounds->y, bounds->x + bounds->w, bounds->y + bounds->h);
../lib/public/nuklear.h:19257:    if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds->x, bounds->y, bounds->w, bounds->h))
../lib/public/nuklear.h:19259:    if (!NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, v.x, v.y, v.w, v.h))
../lib/public/nuklear.h:19275:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19276:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19277:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:19280:    win = ctx->current;
../lib/public/nuklear.h:19281:    style = &ctx->style;
../lib/public/nuklear.h:19282:    layout = win->layout;
../lib/public/nuklear.h:19285:    panel_padding = nk_panel_get_padding(style, layout->type);
../lib/public/nuklear.h:19286:    if (layout->row.index == 1) {
../lib/public/nuklear.h:19287:        bounds->w += panel_padding.x;
../lib/public/nuklear.h:19288:        bounds->x -= panel_padding.x;
../lib/public/nuklear.h:19289:    } else bounds->x -= item_padding.x;
../lib/public/nuklear.h:19291:    if (layout->row.index == layout->row.columns)
../lib/public/nuklear.h:19292:        bounds->w += panel_padding.x;
../lib/public/nuklear.h:19293:    else bounds->w += item_padding.x;
../lib/public/nuklear.h:19305:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19306:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19307:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:19311:    win = ctx->current;
../lib/public/nuklear.h:19312:    layout = win->layout;
../lib/public/nuklear.h:19313:    index = (layout->row.index + cols) % layout->row.columns;
../lib/public/nuklear.h:19314:    rows = (layout->row.index + cols) / layout->row.columns;
../lib/public/nuklear.h:19321:    if (layout->row.type != NK_LAYOUT_DYNAMIC_FIXED &&
../lib/public/nuklear.h:19322:        layout->row.type != NK_LAYOUT_STATIC_FIXED) {
../lib/public/nuklear.h:19325:    } layout->row.index = index;
../lib/public/nuklear.h:19349:    b.h = NK_MAX(b.h, 2 * t->padding.y);
../lib/public/nuklear.h:19351:    label.y = b.y + t->padding.y;
../lib/public/nuklear.h:19352:    label.h = NK_MIN(f->height, b.h - 2 * t->padding.y);
../lib/public/nuklear.h:19354:    text_width = f->width(f->userdata, f->height, (const char*)string, len);
../lib/public/nuklear.h:19355:    text_width += (2.0f * t->padding.x);
../lib/public/nuklear.h:19357:    /* align in x-axis */
../lib/public/nuklear.h:19359:        label.x = b.x + t->padding.x;
../lib/public/nuklear.h:19360:        label.w = NK_MAX(0, b.w - 2 * t->padding.x);
../lib/public/nuklear.h:19362:        label.w = NK_MAX(1, 2 * t->padding.x + (float)text_width);
../lib/public/nuklear.h:19363:        label.x = (b.x + t->padding.x + ((b.w - 2 * t->padding.x) - label.w) / 2);
../lib/public/nuklear.h:19364:        label.x = NK_MAX(b.x + t->padding.x, label.x);
../lib/public/nuklear.h:19366:        if (label.w >= label.x) label.w -= label.x;
../lib/public/nuklear.h:19368:        label.x = NK_MAX(b.x + t->padding.x, (b.x + b.w) - (2 * t->padding.x + (float)text_width));
../lib/public/nuklear.h:19369:        label.w = (float)text_width + 2 * t->padding.x;
../lib/public/nuklear.h:19372:    /* align in y-axis */
../lib/public/nuklear.h:19374:        label.y = b.y + b.h/2.0f - (float)f->height/2.0f;
../lib/public/nuklear.h:19375:        label.h = NK_MAX(b.h/2.0f, b.h - (b.h/2.0f + f->height/2.0f));
../lib/public/nuklear.h:19377:        label.y = b.y + b.h - f->height;
../lib/public/nuklear.h:19378:        label.h = f->height;
../lib/public/nuklear.h:19380:    nk_draw_text(o, label, (const char*)string, len, f, t->background, t->text);
../lib/public/nuklear.h:19400:    text.background = t->background;
../lib/public/nuklear.h:19401:    text.text = t->text;
../lib/public/nuklear.h:19403:    b.w = NK_MAX(b.w, 2 * t->padding.x);
../lib/public/nuklear.h:19404:    b.h = NK_MAX(b.h, 2 * t->padding.y);
../lib/public/nuklear.h:19405:    b.h = b.h - 2 * t->padding.y;
../lib/public/nuklear.h:19407:    line.x = b.x + t->padding.x;
../lib/public/nuklear.h:19408:    line.y = b.y + t->padding.y;
../lib/public/nuklear.h:19409:    line.w = b.w - 2 * t->padding.x;
../lib/public/nuklear.h:19410:    line.h = 2 * t->padding.y + f->height;
../lib/public/nuklear.h:19417:        line.y += f->height + 2 * t->padding.y;
../lib/public/nuklear.h:19418:        fitting = nk_text_clamp(f, &string[done], len - done, line.w, &glyphs, &width, seperator,NK_LEN(seperator));
../lib/public/nuklear.h:19433:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19434:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19435:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:19437:    win = ctx->current;
../lib/public/nuklear.h:19438:    style = &ctx->style;
../lib/public/nuklear.h:19440:    item_padding = style->text.padding;
../lib/public/nuklear.h:19444:    text.background = style->window.background;
../lib/public/nuklear.h:19446:    nk_widget_text(&win->buffer, bounds, str, len, &text, alignment, style->font);
../lib/public/nuklear.h:19460:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19461:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19462:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:19464:    win = ctx->current;
../lib/public/nuklear.h:19465:    style = &ctx->style;
../lib/public/nuklear.h:19467:    item_padding = style->text.padding;
../lib/public/nuklear.h:19471:    text.background = style->window.background;
../lib/public/nuklear.h:19473:    nk_widget_text_wrap(&win->buffer, bounds, str, len, &text, style->font);
../lib/public/nuklear.h:19480:    struct nk_style *style = &ctx->style;
../lib/public/nuklear.h:19484:    text.background = style->window.background;
../lib/public/nuklear.h:19485:    text.text = style->text.color;
../lib/public/nuklear.h:19488:    bounds.w = NK_MAX(bounds.w - 2 * ctx->style.window.padding.x, 2 * text.padding.x);
../lib/public/nuklear.h:19495:    line.w = bounds.w - 2 * text.padding.x;
../lib/public/nuklear.h:19496:    line.h = 2 * text.padding.y + style->font->height;
../lib/public/nuklear.h:19503:    fitting = nk_text_clamp(style->font, str, len, line.w, &glyphs, &width, separator, NK_LEN(separator));
../lib/public/nuklear.h:19508:        line.y += style->font->height + 2 * text.padding.y;
../lib/public/nuklear.h:19509:        fitting = nk_text_clamp(style->font, &str[done], len - done, line.w, &glyphs, &width, 
../lib/public/nuklear.h:19520:    struct nk_style *style = &ctx->style;
../lib/public/nuklear.h:19524:    text.background = style->window.background;
../lib/public/nuklear.h:19525:    text.text = style->text.color;
../lib/public/nuklear.h:19528:    bounds.w = NK_MAX(widget_width - 2 * ctx->style.window.padding.x, 2 * text.padding.x);
../lib/public/nuklear.h:19535:    line.w = bounds.w - 2 * text.padding.x;
../lib/public/nuklear.h:19536:    line.h = 2 * text.padding.y + style->font->height;
../lib/public/nuklear.h:19543:    fitting = nk_text_clamp(style->font, str, len, line.w, &glyphs, &width, separator, NK_LEN(separator));
../lib/public/nuklear.h:19548:        line.y += style->font->height + 2 * text.padding.y;
../lib/public/nuklear.h:19549:        fitting = nk_text_clamp(style->font, &str[done], len - done, line.w, &glyphs, &width, 
../lib/public/nuklear.h:19671:    nk_text_colored(ctx, str, len, alignment, ctx->style.text.color);
../lib/public/nuklear.h:19678:    nk_text_wrap_colored(ctx, str, len, ctx->style.text.color);
../lib/public/nuklear.h:19810:    return !(img->w == 0 && img->h == 0);
../lib/public/nuklear.h:19819:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19820:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19821:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:19823:    win = ctx->current;
../lib/public/nuklear.h:19825:    nk_draw_image(&win->buffer, bounds, &img, nk_white);
../lib/public/nuklear.h:19834:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19835:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19836:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:19838:    win = ctx->current;
../lib/public/nuklear.h:19840:    nk_draw_texpath(&win->buffer, bounds, texpath, nk_white);
../lib/public/nuklear.h:19849:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:19850:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:19851:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:19853:    win = ctx->current;
../lib/public/nuklear.h:19855:    nk_draw_image(&win->buffer, bounds, &img, col);
../lib/public/nuklear.h:19880:            (type == NK_SYMBOL_PLUS) ? "+": "-";
../lib/public/nuklear.h:19954:        background = &style->hover;
../lib/public/nuklear.h:19956:        background = &style->active;
../lib/public/nuklear.h:19957:    else background = &style->normal;
../lib/public/nuklear.h:19959:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:19960:        nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:19961:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:19962:        nk_draw_texpath(out, *bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:19964:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:19965:        nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:19982:    content->x = r.x + style->padding.x + style->border + style->rounding;
../lib/public/nuklear.h:19983:    content->y = r.y + style->padding.y + style->border + style->rounding;
../lib/public/nuklear.h:19984:    content->w = r.w - (2 * style->padding.x + style->border + style->rounding*2);
../lib/public/nuklear.h:19985:    content->h = r.h - (2 * style->padding.y + style->border + style->rounding*2);
../lib/public/nuklear.h:19988:    bounds.x = r.x - style->touch_padding.x;
../lib/public/nuklear.h:19989:    bounds.y = r.y - style->touch_padding.y;
../lib/public/nuklear.h:19990:    bounds.w = r.w + 2 * style->touch_padding.x;
../lib/public/nuklear.h:19991:    bounds.h = r.h + 2 * style->touch_padding.y;
../lib/public/nuklear.h:20005:    if (background->type == NK_STYLE_ITEM_COLOR)
../lib/public/nuklear.h:20006:        text.background = background->data.color;
../lib/public/nuklear.h:20007:    else text.background = style->text_background;
../lib/public/nuklear.h:20009:        text.text = style->text_hover;
../lib/public/nuklear.h:20011:        text.text = style->text_active;
../lib/public/nuklear.h:20012:    else text.text = style->text_normal;
../lib/public/nuklear.h:20036:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20038:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20052:    if (background->type == NK_STYLE_ITEM_COLOR)
../lib/public/nuklear.h:20053:        bg = background->data.color;
../lib/public/nuklear.h:20054:    else bg = style->text_background;
../lib/public/nuklear.h:20057:        sym = style->text_hover;
../lib/public/nuklear.h:20059:        sym = style->text_active;
../lib/public/nuklear.h:20060:    else sym = style->text_normal;
../lib/public/nuklear.h:20081:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20083:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20110:    content.x += style->image_padding.x;
../lib/public/nuklear.h:20111:    content.y += style->image_padding.y;
../lib/public/nuklear.h:20112:    content.w -= 2 * style->image_padding.x;
../lib/public/nuklear.h:20113:    content.h -= 2 * style->image_padding.y;
../lib/public/nuklear.h:20115:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20117:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20133:    if (background->type == NK_STYLE_ITEM_COLOR)
../lib/public/nuklear.h:20134:        text.background = background->data.color;
../lib/public/nuklear.h:20135:    else text.background = style->text_background;
../lib/public/nuklear.h:20139:        sym = style->text_hover;
../lib/public/nuklear.h:20140:        text.text = style->text_hover;
../lib/public/nuklear.h:20142:        sym = style->text_active;
../lib/public/nuklear.h:20143:        text.text = style->text_active;
../lib/public/nuklear.h:20145:        sym = style->text_normal;
../lib/public/nuklear.h:20146:        text.text = style->text_normal;
../lib/public/nuklear.h:20150:    nk_draw_symbol(out, type, *symbol, style->text_background, sym, 0, font);
../lib/public/nuklear.h:20171:    tri.y = content.y + (content.h/2) - font->height/2;
../lib/public/nuklear.h:20172:    tri.w = font->height; tri.h = font->height;
../lib/public/nuklear.h:20174:        tri.x = (content.x + content.w) - (2 * style->padding.x + tri.w);
../lib/public/nuklear.h:20176:    } else tri.x = content.x + 2 * style->padding.x;
../lib/public/nuklear.h:20179:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20182:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20197:    if (background->type == NK_STYLE_ITEM_COLOR)
../lib/public/nuklear.h:20198:        text.background = background->data.color;
../lib/public/nuklear.h:20199:    else text.background = style->text_background;
../lib/public/nuklear.h:20201:        text.text = style->text_hover;
../lib/public/nuklear.h:20203:        text.text = style->text_active;
../lib/public/nuklear.h:20204:    else text.text = style->text_normal;
../lib/public/nuklear.h:20222:    if (background->type == NK_STYLE_ITEM_COLOR)
../lib/public/nuklear.h:20223:        text.background = background->data.color;
../lib/public/nuklear.h:20224:    else text.background = style->text_background;
../lib/public/nuklear.h:20226:        text.text = style->text_hover;
../lib/public/nuklear.h:20228:        text.text = style->text_active;
../lib/public/nuklear.h:20229:    else text.text = style->text_normal;
../lib/public/nuklear.h:20254:    icon.y = bounds.y + style->padding.y;
../lib/public/nuklear.h:20255:    icon.w = icon.h = bounds.h - 2 * style->padding.y;
../lib/public/nuklear.h:20257:        icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
../lib/public/nuklear.h:20259:    } else icon.x = bounds.x + 2 * style->padding.x;
../lib/public/nuklear.h:20261:    icon.x += style->image_padding.x;
../lib/public/nuklear.h:20262:    icon.y += style->image_padding.y;
../lib/public/nuklear.h:20263:    icon.w -= 2 * style->image_padding.x;
../lib/public/nuklear.h:20264:    icon.h -= 2 * style->image_padding.y;
../lib/public/nuklear.h:20266:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20268:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20290:    icon.y = bounds.y + style->padding.y;
../lib/public/nuklear.h:20291:    icon.w = icon.h = bounds.h - 2 * style->padding.y;
../lib/public/nuklear.h:20293:        icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
../lib/public/nuklear.h:20295:    } else icon.x = bounds.x + 2 * style->padding.x;
../lib/public/nuklear.h:20297:    icon.x += style->image_padding.x;
../lib/public/nuklear.h:20298:    icon.y += style->image_padding.y;
../lib/public/nuklear.h:20299:    icon.w -= 2 * style->image_padding.x;
../lib/public/nuklear.h:20300:    icon.h -= 2 * style->image_padding.y;
../lib/public/nuklear.h:20302:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20304:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20312:    ctx->button_behavior = behavior;
../lib/public/nuklear.h:20323:    button_stack = &ctx->stacks.button_behaviors;
../lib/public/nuklear.h:20324:    NK_ASSERT(button_stack->head < (int)NK_LEN(button_stack->elements));
../lib/public/nuklear.h:20325:    if (button_stack->head >= (int)NK_LEN(button_stack->elements))
../lib/public/nuklear.h:20328:    element = &button_stack->elements[button_stack->head++];
../lib/public/nuklear.h:20329:    element->address = &ctx->button_behavior;
../lib/public/nuklear.h:20330:    element->old_value = ctx->button_behavior;
../lib/public/nuklear.h:20331:    ctx->button_behavior = behavior;
../lib/public/nuklear.h:20343:    button_stack = &ctx->stacks.button_behaviors;
../lib/public/nuklear.h:20344:    NK_ASSERT(button_stack->head > 0);
../lib/public/nuklear.h:20345:    if (button_stack->head < 1)
../lib/public/nuklear.h:20348:    element = &button_stack->elements[--button_stack->head];
../lib/public/nuklear.h:20349:    *element->address = element->old_value;
../lib/public/nuklear.h:20365:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20366:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20367:    if (!style || !ctx || !ctx->current || !ctx->current->layout) return 0;
../lib/public/nuklear.h:20369:    win = ctx->current;
../lib/public/nuklear.h:20370:    layout = win->layout;
../lib/public/nuklear.h:20374:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20375:    return nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:20376:                    title, len, style->text_alignment, ctx->button_behavior,
../lib/public/nuklear.h:20377:                    style, in, ctx->style.font);
../lib/public/nuklear.h:20384:    return nk_button_text_styled(ctx, &ctx->style.button, title, len);
../lib/public/nuklear.h:20409:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20410:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20411:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20414:    win = ctx->current;
../lib/public/nuklear.h:20415:    layout = win->layout;
../lib/public/nuklear.h:20419:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20421:    button = ctx->style.button;
../lib/public/nuklear.h:20425:    ret = nk_do_button(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:20426:                &button, in, ctx->button_behavior, &content);
../lib/public/nuklear.h:20427:    nk_draw_button(&win->buffer, &bounds, ctx->last_widget_state, &button);
../lib/public/nuklear.h:20442:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20443:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20444:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20447:    win = ctx->current;
../lib/public/nuklear.h:20448:    layout = win->layout;
../lib/public/nuklear.h:20451:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20452:    return nk_do_button_symbol(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:20453:            symbol, ctx->button_behavior, style, in, ctx->style.font);
../lib/public/nuklear.h:20460:    return nk_button_symbol_styled(ctx, &ctx->style.button, symbol);
../lib/public/nuklear.h:20474:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20475:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20476:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20479:    win = ctx->current;
../lib/public/nuklear.h:20480:    layout = win->layout;
../lib/public/nuklear.h:20484:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20485:    return nk_do_button_image(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:20486:                img, ctx->button_behavior, style, in);
../lib/public/nuklear.h:20493:    return nk_button_image_styled(ctx, &ctx->style.button, img);
../lib/public/nuklear.h:20508:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20509:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20510:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20513:    win = ctx->current;
../lib/public/nuklear.h:20514:    layout = win->layout;
../lib/public/nuklear.h:20518:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20519:    return nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:20520:                symbol, text, len, align, ctx->button_behavior,
../lib/public/nuklear.h:20521:                style, ctx->style.font, in);
../lib/public/nuklear.h:20529:    return nk_button_symbol_text_styled(ctx, &ctx->style.button, symbol, text, len, align);
../lib/public/nuklear.h:20555:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20556:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20557:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20560:    win = ctx->current;
../lib/public/nuklear.h:20561:    layout = win->layout;
../lib/public/nuklear.h:20565:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20566:    return nk_do_button_text_image(&ctx->last_widget_state, &win->buffer,
../lib/public/nuklear.h:20567:            bounds, img, text, len, align, ctx->button_behavior,
../lib/public/nuklear.h:20568:            style, ctx->style.font, in);
../lib/public/nuklear.h:20583:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20584:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20585:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20588:    win = ctx->current;
../lib/public/nuklear.h:20589:    layout = win->layout;
../lib/public/nuklear.h:20593:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20594:    return nk_do_button_text_texpath(&ctx->last_widget_state, &win->buffer,
../lib/public/nuklear.h:20595:            bounds, texpath, text, len, align, ctx->button_behavior,
../lib/public/nuklear.h:20596:            style, ctx->style.font, in);
../lib/public/nuklear.h:20602:    return nk_button_image_text_styled(ctx, &ctx->style.button,img, text, len, align);
../lib/public/nuklear.h:20608:    return nk_button_texpath_text_styled(ctx, &ctx->style.button, texpath, text, len, align);
../lib/public/nuklear.h:20664:        background = &style->hover;
../lib/public/nuklear.h:20665:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:20666:        text.text = style->text_hover;
../lib/public/nuklear.h:20668:        background = &style->hover;
../lib/public/nuklear.h:20669:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:20670:        text.text = style->text_active;
../lib/public/nuklear.h:20672:        background = &style->normal;
../lib/public/nuklear.h:20673:        cursor = &style->cursor_normal;
../lib/public/nuklear.h:20674:        text.text = style->text_normal;
../lib/public/nuklear.h:20678:    if (background->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:20679:        nk_fill_rect(out, *selector, 0, style->border_color);
../lib/public/nuklear.h:20680:        nk_fill_rect(out, nk_shrink_rect(*selector, style->border), 0, background->data.color);
../lib/public/nuklear.h:20681:    } else if(background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:20682:        nk_draw_texpath(out, *selector, background->data.texpath, nk_white);
../lib/public/nuklear.h:20683:    } else nk_draw_image(out, *selector, &background->data.image, nk_white); 
../lib/public/nuklear.h:20686:        if (cursor->type == NK_STYLE_ITEM_IMAGE)
../lib/public/nuklear.h:20687:            nk_draw_image(out, *cursors, &cursor->data.image, nk_white);
../lib/public/nuklear.h:20688:        else if (cursor->type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:20689:            nk_draw_texpath(out, *cursors, cursor->data.texpath, nk_white);
../lib/public/nuklear.h:20690:        else nk_fill_rect(out, *cursors, 0, cursor->data.color);
../lib/public/nuklear.h:20695:    text.background = style->text_background;
../lib/public/nuklear.h:20711:        background = &style->hover;
../lib/public/nuklear.h:20712:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:20713:        text.text = style->text_hover;
../lib/public/nuklear.h:20715:        background = &style->hover;
../lib/public/nuklear.h:20716:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:20717:        text.text = style->text_active;
../lib/public/nuklear.h:20719:        background = &style->normal;
../lib/public/nuklear.h:20720:        cursor = &style->cursor_normal;
../lib/public/nuklear.h:20721:        text.text = style->text_normal;
../lib/public/nuklear.h:20725:    if (background->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:20726:        nk_fill_circle(out, *selector, style->border_color);
../lib/public/nuklear.h:20727:        nk_fill_circle(out, nk_shrink_rect(*selector, style->border), background->data.color);
../lib/public/nuklear.h:20728:    } else if(background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:20729:        nk_draw_texpath(out, *selector, background->data.texpath, nk_white);
../lib/public/nuklear.h:20730:    }else nk_draw_image(out, *selector, &background->data.image, nk_white);
../lib/public/nuklear.h:20733:        if (cursor->type == NK_STYLE_ITEM_IMAGE)
../lib/public/nuklear.h:20734:            nk_draw_image(out, *cursors, &cursor->data.image, nk_white);
../lib/public/nuklear.h:20735:        else if (cursor->type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:20736:            nk_draw_texpath(out, *cursors, cursor->data.texpath, nk_white);
../lib/public/nuklear.h:20737:        else nk_fill_circle(out, *cursors, cursor->data.color);
../lib/public/nuklear.h:20742:    text.background = style->text_background;
../lib/public/nuklear.h:20764:    r.w = NK_MAX(r.w, font->height + 2 * style->padding.x);
../lib/public/nuklear.h:20765:    r.h = NK_MAX(r.h, font->height + 2 * style->padding.y);
../lib/public/nuklear.h:20768:    bounds.x = r.x - style->touch_padding.x;
../lib/public/nuklear.h:20769:    bounds.y = r.y - style->touch_padding.y;
../lib/public/nuklear.h:20770:    bounds.w = r.w + 2 * style->touch_padding.x;
../lib/public/nuklear.h:20771:    bounds.h = r.h + 2 * style->touch_padding.y;
../lib/public/nuklear.h:20774:    select.w = font->height;
../lib/public/nuklear.h:20776:    select.y = r.y + r.h/2.0f - select.h/2.0f;
../lib/public/nuklear.h:20780:    cursor.x = select.x + style->padding.x + style->border;
../lib/public/nuklear.h:20781:    cursor.y = select.y + style->padding.y + style->border;
../lib/public/nuklear.h:20782:    cursor.w = select.w - (2 * style->padding.x + 2 * style->border);
../lib/public/nuklear.h:20783:    cursor.h = select.h - (2 * style->padding.y + 2 * style->border);
../lib/public/nuklear.h:20786:    label.x = select.x + select.w + style->spacing;
../lib/public/nuklear.h:20788:    label.w = NK_MAX(r.x + r.w, label.x) - label.x;
../lib/public/nuklear.h:20796:    if (style->draw_begin)
../lib/public/nuklear.h:20797:        style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:20803:    if (style->draw_end)
../lib/public/nuklear.h:20804:        style->draw_end(out, style->userdata);
../lib/public/nuklear.h:20807:/*----------------------------------------------------------------
../lib/public/nuklear.h:20811: * --------------------------------------------------------------*/
../lib/public/nuklear.h:20824:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20825:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20826:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20829:    win = ctx->current;
../lib/public/nuklear.h:20830:    style = &ctx->style;
../lib/public/nuklear.h:20831:    layout = win->layout;
../lib/public/nuklear.h:20835:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20836:    nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &active,
../lib/public/nuklear.h:20837:        text, len, NK_TOGGLE_CHECK, &style->checkbox, in, style->font);
../lib/public/nuklear.h:20902:/*----------------------------------------------------------------
../lib/public/nuklear.h:20906: * --------------------------------------------------------------*/
../lib/public/nuklear.h:20919:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:20920:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:20921:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:20924:    win = ctx->current;
../lib/public/nuklear.h:20925:    style = &ctx->style;
../lib/public/nuklear.h:20926:    layout = win->layout;
../lib/public/nuklear.h:20930:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:20931:    nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &is_active,
../lib/public/nuklear.h:20932:        text, len, NK_TOGGLE_OPTION, &style->option, in, style->font);
../lib/public/nuklear.h:20976:    text.padding = style->padding;
../lib/public/nuklear.h:20981:            background = &style->pressed;
../lib/public/nuklear.h:20982:            text.text = style->text_pressed;
../lib/public/nuklear.h:20984:            background = &style->hover;
../lib/public/nuklear.h:20985:            text.text = style->text_hover;
../lib/public/nuklear.h:20987:            background = &style->normal;
../lib/public/nuklear.h:20988:            text.text = style->text_normal;
../lib/public/nuklear.h:20992:            background = &style->pressed_active;
../lib/public/nuklear.h:20993:            text.text = style->text_pressed_active;
../lib/public/nuklear.h:20995:            background = &style->hover_active;
../lib/public/nuklear.h:20996:            text.text = style->text_hover_active;
../lib/public/nuklear.h:20998:            background = &style->normal_active;
../lib/public/nuklear.h:20999:            text.text = style->text_normal_active;
../lib/public/nuklear.h:21003:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:21004:        nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:21006:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:21007:        nk_draw_texpath(out, *bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:21010:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:21011:        text.background = background->data.color;
../lib/public/nuklear.h:21020:        bounds->x += icon->w + 2 * style->image_padding.x + 2 * style->padding.x;
../lib/public/nuklear.h:21021:        bounds->w -= icon->w + 2 * style->image_padding.x + 2 * style->padding.x;
../lib/public/nuklear.h:21035:    text.padding = style->padding;
../lib/public/nuklear.h:21040:            background = &style->pressed;
../lib/public/nuklear.h:21041:            text.text = style->text_pressed;
../lib/public/nuklear.h:21043:            background = &style->hover;
../lib/public/nuklear.h:21044:            text.text = style->text_hover;
../lib/public/nuklear.h:21046:            background = &style->normal;
../lib/public/nuklear.h:21047:            text.text = style->text_normal;
../lib/public/nuklear.h:21051:            background = &style->pressed_active;
../lib/public/nuklear.h:21052:            text.text = style->text_pressed_active;
../lib/public/nuklear.h:21054:            background = &style->hover_active;
../lib/public/nuklear.h:21055:            text.text = style->text_hover_active;
../lib/public/nuklear.h:21057:            background = &style->normal_active;
../lib/public/nuklear.h:21058:            text.text = style->text_normal_active;
../lib/public/nuklear.h:21062:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:21063:        nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:21065:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:21066:        nk_draw_texpath(out, *bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:21069:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:21070:        text.background = background->data.color;
../lib/public/nuklear.h:21079:        bounds->x += icon->w + 2 * style->image_padding.x + 2 * style->padding.x;
../lib/public/nuklear.h:21080:        bounds->w -= icon->w + 2 * style->image_padding.x + 2 * style->padding.x;
../lib/public/nuklear.h:21106:    touch.x = bounds.x - style->touch_padding.x;
../lib/public/nuklear.h:21107:    touch.y = bounds.y - style->touch_padding.y;
../lib/public/nuklear.h:21108:    touch.w = bounds.w + style->touch_padding.x * 2;
../lib/public/nuklear.h:21109:    touch.h = bounds.h + style->touch_padding.y * 2;
../lib/public/nuklear.h:21116:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:21118:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:21143:    touch.x = bounds.x - style->touch_padding.x;
../lib/public/nuklear.h:21144:    touch.y = bounds.y - style->touch_padding.y;
../lib/public/nuklear.h:21145:    touch.w = bounds.w + style->touch_padding.x * 2;
../lib/public/nuklear.h:21146:    touch.h = bounds.h + style->touch_padding.y * 2;
../lib/public/nuklear.h:21150:    icon.y = bounds.y + style->padding.y;
../lib/public/nuklear.h:21151:    icon.w = icon.h = bounds.h - 2 * style->padding.y;
../lib/public/nuklear.h:21152:    icon.x = bounds.x + 2 * style->padding.x;
../lib/public/nuklear.h:21154:    icon.x += style->image_padding.x;
../lib/public/nuklear.h:21155:    icon.y += style->image_padding.y;
../lib/public/nuklear.h:21156:    icon.w -= 2 * style->image_padding.x;
../lib/public/nuklear.h:21157:    icon.h -= 2 * style->image_padding.y;
../lib/public/nuklear.h:21160:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:21162:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:21187:    touch.x = bounds.x - style->touch_padding.x;
../lib/public/nuklear.h:21188:    touch.y = bounds.y - style->touch_padding.y;
../lib/public/nuklear.h:21189:    touch.w = bounds.w + style->touch_padding.x * 2;
../lib/public/nuklear.h:21190:    touch.h = bounds.h + style->touch_padding.y * 2;
../lib/public/nuklear.h:21194:    icon.y = bounds.y + style->padding.y;
../lib/public/nuklear.h:21195:    icon.w = icon.h = bounds.h - 2 * style->padding.y;
../lib/public/nuklear.h:21196:    icon.x = bounds.x + 2 * style->padding.x;
../lib/public/nuklear.h:21198:    icon.x += style->image_padding.x;
../lib/public/nuklear.h:21199:    icon.y += style->image_padding.y;
../lib/public/nuklear.h:21200:    icon.w -= 2 * style->image_padding.x;
../lib/public/nuklear.h:21201:    icon.h -= 2 * style->image_padding.y;
../lib/public/nuklear.h:21204:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:21206:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:21231:    touch.x = bounds.x - style->touch_padding.x;
../lib/public/nuklear.h:21232:    touch.y = bounds.y - style->touch_padding.y;
../lib/public/nuklear.h:21233:    touch.w = bounds.w + style->touch_padding.x * 2;
../lib/public/nuklear.h:21234:    touch.h = bounds.h + style->touch_padding.y * 2;
../lib/public/nuklear.h:21238:    icon.y = bounds.y + style->padding.y;
../lib/public/nuklear.h:21239:    icon.w = icon.h = bounds.h - 2 * style->padding.y;
../lib/public/nuklear.h:21241:        icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
../lib/public/nuklear.h:21243:    } else icon.x = bounds.x + 2 * style->padding.x;
../lib/public/nuklear.h:21245:    icon.x += style->image_padding.x;
../lib/public/nuklear.h:21246:    icon.y += style->image_padding.y;
../lib/public/nuklear.h:21247:    icon.w -= 2 * style->image_padding.x;
../lib/public/nuklear.h:21248:    icon.h -= 2 * style->image_padding.y;
../lib/public/nuklear.h:21251:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:21253:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:21271:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21272:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21273:    if (!ctx || !ctx->current || !ctx->current->layout || !value)
../lib/public/nuklear.h:21276:    win = ctx->current;
../lib/public/nuklear.h:21277:    layout = win->layout;
../lib/public/nuklear.h:21278:    style = &ctx->style;
../lib/public/nuklear.h:21282:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21283:    return nk_do_selectable(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:21284:                str, len, align, value, &style->selectable, in, style->font);
../lib/public/nuklear.h:21300:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21301:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21302:    if (!ctx || !ctx->current || !ctx->current->layout || !value)
../lib/public/nuklear.h:21305:    win = ctx->current;
../lib/public/nuklear.h:21306:    layout = win->layout;
../lib/public/nuklear.h:21307:    style = &ctx->style;
../lib/public/nuklear.h:21311:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21312:    return nk_do_selectable_image(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:21313:                str, len, align, value, &img, &style->selectable, in, style->font);
../lib/public/nuklear.h:21329:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21330:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21331:    if (!ctx || !ctx->current || !ctx->current->layout || !value)
../lib/public/nuklear.h:21334:    win = ctx->current;
../lib/public/nuklear.h:21335:    layout = win->layout;
../lib/public/nuklear.h:21336:    style = &ctx->style;
../lib/public/nuklear.h:21340:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21341:    return nk_do_selectable_texpath(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:21342:                str, len, align, value, texpath, &style->selectable, in, style->font);
../lib/public/nuklear.h:21358:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21359:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21360:    if (!ctx || !ctx->current || !ctx->current->layout || !value)
../lib/public/nuklear.h:21363:    win = ctx->current;
../lib/public/nuklear.h:21364:    layout = win->layout;
../lib/public/nuklear.h:21365:    style = &ctx->style;
../lib/public/nuklear.h:21369:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21370:    return nk_do_selectable_symbol(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:21371:                str, len, align, value, sym, &style->selectable, in, style->font);
../lib/public/nuklear.h:21445:    left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
../lib/public/nuklear.h:21451:        const float d = in->mouse.pos.x - (visual_cursor->x+visual_cursor->w*0.5f);
../lib/public/nuklear.h:21458:            slider_value += (d > 0) ? (slider_step*steps) : -(slider_step*steps);
../lib/public/nuklear.h:21460:            ratio = (slider_value - slider_min)/slider_step;
../lib/public/nuklear.h:21461:            logical_cursor->x = bounds.x + (logical_cursor->w * ratio);
../lib/public/nuklear.h:21462:            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = logical_cursor->x;
../lib/public/nuklear.h:21494:        background = &style->active;
../lib/public/nuklear.h:21495:        bar_color = style->bar_active;
../lib/public/nuklear.h:21496:        cursor = &style->cursor_active;
../lib/public/nuklear.h:21498:        background = &style->hover;
../lib/public/nuklear.h:21499:        bar_color = style->bar_hover;
../lib/public/nuklear.h:21500:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:21502:        background = &style->normal;
../lib/public/nuklear.h:21503:        bar_color = style->bar_normal;
../lib/public/nuklear.h:21504:        cursor = &style->cursor_normal;
../lib/public/nuklear.h:21507:    bar.x = bounds->x;
../lib/public/nuklear.h:21508:    bar.y = (visual_cursor->y + visual_cursor->h/2) - bounds->h/12;
../lib/public/nuklear.h:21509:    bar.w = bounds->w;
../lib/public/nuklear.h:21510:    bar.h = bounds->h/6;
../lib/public/nuklear.h:21513:    fill.w = (visual_cursor->x + (visual_cursor->w/2.0f)) - bar.x;
../lib/public/nuklear.h:21519:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:21520:        nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:21521:    }else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:21522:        nk_draw_texpath(out, *bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:21524:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:21525:        nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:21529:    nk_fill_rect(out, bar, style->rounding, bar_color);
../lib/public/nuklear.h:21530:    nk_fill_rect(out, fill, style->rounding, style->bar_filled);
../lib/public/nuklear.h:21533:    if (cursor->type == NK_STYLE_ITEM_IMAGE)
../lib/public/nuklear.h:21534:        nk_draw_image(out, *visual_cursor, &cursor->data.image, nk_white);
../lib/public/nuklear.h:21535:    else if (cursor->type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:21536:        nk_draw_texpath(out, *visual_cursor, cursor->data.texpath, nk_white);
../lib/public/nuklear.h:21537:    else nk_fill_circle(out, *visual_cursor, cursor->data.color);
../lib/public/nuklear.h:21562:    bounds.x = bounds.x + style->padding.x;
../lib/public/nuklear.h:21563:    bounds.y = bounds.y + style->padding.y;
../lib/public/nuklear.h:21564:    bounds.h = NK_MAX(bounds.h, 2*style->padding.y);
../lib/public/nuklear.h:21565:    bounds.w = NK_MAX(bounds.w, 2*style->padding.x + style->cursor_size.x);
../lib/public/nuklear.h:21566:    bounds.w -= 2 * style->padding.x;
../lib/public/nuklear.h:21567:    bounds.h -= 2 * style->padding.y;
../lib/public/nuklear.h:21570:    if (style->show_buttons) {
../lib/public/nuklear.h:21579:        if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_DEFAULT,
../lib/public/nuklear.h:21580:            &style->dec_button, in, font))
../lib/public/nuklear.h:21581:            val -= step;
../lib/public/nuklear.h:21584:        button.x = (bounds.x + bounds.w) - button.w;
../lib/public/nuklear.h:21585:        if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_DEFAULT,
../lib/public/nuklear.h:21586:            &style->inc_button, in, font))
../lib/public/nuklear.h:21589:        bounds.x = bounds.x + button.w + style->spacing.x;
../lib/public/nuklear.h:21590:        bounds.w = bounds.w - (2*button.w + 2*style->spacing.x);
../lib/public/nuklear.h:21594:    bounds.x += style->cursor_size.x*0.5f;
../lib/public/nuklear.h:21595:    bounds.w -= style->cursor_size.x;
../lib/public/nuklear.h:21601:    slider_range = slider_max - slider_min;
../lib/public/nuklear.h:21603:    cursor_offset = (slider_value - slider_min) / step;
../lib/public/nuklear.h:21613:    visual_cursor.h = style->cursor_size.y;
../lib/public/nuklear.h:21614:    visual_cursor.w = style->cursor_size.x;
../lib/public/nuklear.h:21615:    visual_cursor.y = (bounds.y + bounds.h*0.5f) - visual_cursor.h*0.5f;
../lib/public/nuklear.h:21616:    visual_cursor.x = logical_cursor.x - visual_cursor.w*0.5f;
../lib/public/nuklear.h:21620:    visual_cursor.x = logical_cursor.x - visual_cursor.w*0.5f;
../lib/public/nuklear.h:21623:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:21625:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:21643:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21644:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21646:    if (!ctx || !ctx->current || !ctx->current->layout || !value)
../lib/public/nuklear.h:21649:    win = ctx->current;
../lib/public/nuklear.h:21650:    style = &ctx->style;
../lib/public/nuklear.h:21651:    layout = win->layout;
../lib/public/nuklear.h:21655:    in = (/*state == NK_WIDGET_ROM || */ layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21658:    *value = nk_do_slider(&ctx->last_widget_state, &win->buffer, bounds, min_value,
../lib/public/nuklear.h:21659:                old_value, max_value, value_step, &style->slider, in, style->font);
../lib/public/nuklear.h:21702:    left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
../lib/public/nuklear.h:21710:            float ratio = NK_MAX(0, (float)(in->mouse.pos.x - cursor.x)) / (float)cursor.w;
../lib/public/nuklear.h:21712:            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor.x + cursor.w/2.0f;
../lib/public/nuklear.h:21736:        background = &style->active;
../lib/public/nuklear.h:21737:        cursor = &style->cursor_active;
../lib/public/nuklear.h:21739:        background = &style->hover;
../lib/public/nuklear.h:21740:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:21742:        background = &style->normal;
../lib/public/nuklear.h:21743:        cursor = &style->cursor_normal;
../lib/public/nuklear.h:21747:    if (background->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:21748:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:21749:        nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:21750:    } else nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:21753:    if (cursor->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:21754:        nk_fill_rect(out, *scursor, style->rounding, cursor->data.color);
../lib/public/nuklear.h:21755:        nk_stroke_rect(out, *scursor, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:21756:    } else nk_draw_image(out, *scursor, &cursor->data.image, nk_white);
../lib/public/nuklear.h:21773:    cursor.w = NK_MAX(bounds.w, 2 * style->padding.x + 2 * style->border);
../lib/public/nuklear.h:21774:    cursor.h = NK_MAX(bounds.h, 2 * style->padding.y + 2 * style->border);
../lib/public/nuklear.h:21775:    cursor = nk_pad_rect(bounds, nk_vec2(style->padding.x + style->border, style->padding.y + style->border));
../lib/public/nuklear.h:21784:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:21786:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:21803:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21804:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21805:    if (!ctx || !ctx->current || !ctx->current->layout || !cur)
../lib/public/nuklear.h:21808:    win = ctx->current;
../lib/public/nuklear.h:21809:    style = &ctx->style;
../lib/public/nuklear.h:21810:    layout = win->layout;
../lib/public/nuklear.h:21814:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21816:    *cur = nk_do_progress(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:21817:            *cur, max, is_modifyable, &style->progress, in);
../lib/public/nuklear.h:21845:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:21846:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:21847:    if (!ctx || !ctx->current || !ctx->current->layout || !cur)
../lib/public/nuklear.h:21850:    win = ctx->current;
../lib/public/nuklear.h:21851:    style = &ctx->style;
../lib/public/nuklear.h:21852:    layout = win->layout;
../lib/public/nuklear.h:21856:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:21858:    *cur = nk_do_progress(&ctx->last_widget_state, &win->buffer, bounds,
../lib/public/nuklear.h:21859:            *cur, max, modifyable, &style->progress, in);
../lib/public/nuklear.h:21861:    item_padding = style->text.padding;
../lib/public/nuklear.h:21864:    text.background = style->window.background;
../lib/public/nuklear.h:21866:    nk_widget_text(&win->buffer, bounds, str, len, &text, NK_TEXT_CENTERED, style->font);
../lib/public/nuklear.h:21901:    left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
../lib/public/nuklear.h:21902:    left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;
../lib/public/nuklear.h:21908:    scroll_delta = (o == NK_VERTICAL) ? in->mouse.scroll_delta.y: in->mouse.scroll_delta.x;
../lib/public/nuklear.h:21915:            pixel = in->mouse.delta.y;
../lib/public/nuklear.h:21916:            delta = (pixel / scroll->h) * target;
../lib/public/nuklear.h:21917:            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->h);
../lib/public/nuklear.h:21918:            cursor_y = scroll->y + ((scroll_offset/target) * scroll->h);
../lib/public/nuklear.h:21919:            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = cursor_y + cursor->h/2.0f;
../lib/public/nuklear.h:21922:            pixel = in->mouse.delta.x;
../lib/public/nuklear.h:21923:            delta = (pixel / scroll->w) * target;
../lib/public/nuklear.h:21924:            scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->w);
../lib/public/nuklear.h:21925:            cursor_x = scroll->x + ((scroll_offset/target) * scroll->w);
../lib/public/nuklear.h:21926:            in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor_x + cursor->w/2.0f;
../lib/public/nuklear.h:21932:            scroll_offset = NK_MAX(0, scroll_offset - scroll->h);
../lib/public/nuklear.h:21933:        else scroll_offset = NK_MAX(0, scroll_offset - scroll->w);
../lib/public/nuklear.h:21938:            scroll_offset = NK_MIN(scroll_offset + scroll->h, target - scroll->h);
../lib/public/nuklear.h:21939:        else scroll_offset = NK_MIN(scroll_offset + scroll->w, target - scroll->w);
../lib/public/nuklear.h:21943:            scroll_offset = scroll_offset + scroll_step * (-scroll_delta);
../lib/public/nuklear.h:21945:                scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->h);
../lib/public/nuklear.h:21946:            else scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->w);
../lib/public/nuklear.h:21952:            if (o == NK_VERTICAL) scroll_offset = target - scroll->h;
../lib/public/nuklear.h:21971:        background = &style->active;
../lib/public/nuklear.h:21972:        cursor = &style->cursor_active;
../lib/public/nuklear.h:21974:        background = &style->hover;
../lib/public/nuklear.h:21975:        cursor = &style->cursor_hover;
../lib/public/nuklear.h:21977:        background = &style->normal;
../lib/public/nuklear.h:21978:        cursor = &style->cursor_normal;
../lib/public/nuklear.h:21982:    if (background->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:21983:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:21984:        nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:21985:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:21986:        nk_draw_texpath(out, *bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:21988:        nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:21992:    if (cursor->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:21993:        nk_fill_rect(out, *scroll, style->rounding_cursor, cursor->data.color);
../lib/public/nuklear.h:21994:        nk_stroke_rect(out, *scroll, style->rounding_cursor, style->border_cursor, style->cursor_border_color);
../lib/public/nuklear.h:21995:    } else if (cursor->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:21996:        nk_draw_texpath(out, *scroll, cursor->data.texpath, nk_white);
../lib/public/nuklear.h:21998:        nk_draw_image(out, *scroll, &cursor->data.image, nk_white);
../lib/public/nuklear.h:22027:    if (style->show_buttons) {
../lib/public/nuklear.h:22036:        scroll_h = NK_MAX(scroll.h - 2 * button.h,0);
../lib/public/nuklear.h:22041:        if (nk_do_button_symbol(&ws, out, button, style->dec_symbol,
../lib/public/nuklear.h:22042:            NK_BUTTON_REPEATER, &style->dec_button, in, font))
../lib/public/nuklear.h:22043:            offset = offset - scroll_step;
../lib/public/nuklear.h:22046:        button.y = scroll.y + scroll.h - button.h;
../lib/public/nuklear.h:22047:        if (nk_do_button_symbol(&ws, out, button, style->inc_symbol,
../lib/public/nuklear.h:22048:            NK_BUTTON_REPEATER, &style->inc_button, in, font))
../lib/public/nuklear.h:22057:    scroll_offset = NK_CLAMP(0, offset, target - scroll.h);
../lib/public/nuklear.h:22062:    cursor.h = NK_MAX((scroll_ratio * scroll.h) - (2*style->border + 2*style->padding.y), 0);
../lib/public/nuklear.h:22063:    cursor.y = scroll.y + (scroll_off * scroll.h) + style->border + style->padding.y;
../lib/public/nuklear.h:22064:    cursor.w = scroll.w - (2 * style->border + 2 * style->padding.x);
../lib/public/nuklear.h:22065:    cursor.x = scroll.x + style->border + style->padding.x;
../lib/public/nuklear.h:22071:    empty_north.h = NK_MAX(cursor.y - scroll.y, 0);
../lib/public/nuklear.h:22076:    empty_south.h = NK_MAX((scroll.y + scroll.h) - (cursor.y + cursor.h), 0);
../lib/public/nuklear.h:22082:    cursor.y = scroll.y + (scroll_off * scroll.h) + style->border_cursor + style->padding.y;
../lib/public/nuklear.h:22085:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:22087:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:22116:    if (style->show_buttons) {
../lib/public/nuklear.h:22124:        scroll_w = scroll.w - 2 * button.w;
../lib/public/nuklear.h:22129:        if (nk_do_button_symbol(&ws, out, button, style->dec_symbol,
../lib/public/nuklear.h:22130:            NK_BUTTON_REPEATER, &style->dec_button, in, font))
../lib/public/nuklear.h:22131:            offset = offset - scroll_step;
../lib/public/nuklear.h:22134:        button.x = scroll.x + scroll.w - button.w;
../lib/public/nuklear.h:22135:        if (nk_do_button_symbol(&ws, out, button, style->inc_symbol,
../lib/public/nuklear.h:22136:            NK_BUTTON_REPEATER, &style->inc_button, in, font))
../lib/public/nuklear.h:22145:    scroll_offset = NK_CLAMP(0, offset, target - scroll.w);
../lib/public/nuklear.h:22150:    cursor.w = (scroll_ratio * scroll.w) - (2*style->border + 2*style->padding.x);
../lib/public/nuklear.h:22151:    cursor.x = scroll.x + (scroll_off * scroll.w) + style->border + style->padding.x;
../lib/public/nuklear.h:22152:    cursor.h = scroll.h - (2 * style->border + 2 * style->padding.y);
../lib/public/nuklear.h:22153:    cursor.y = scroll.y + style->border + style->padding.y;
../lib/public/nuklear.h:22158:    empty_west.w = cursor.x - scroll.x;
../lib/public/nuklear.h:22163:    empty_east.w = (scroll.x + scroll.w) - (cursor.x + cursor.w);
../lib/public/nuklear.h:22173:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:22175:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:22188:/* stb_textedit.h - v1.8  - public domain - Sean Barrett */
../lib/public/nuklear.h:22210:#define NK_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)
../lib/public/nuklear.h:22218:    const char *str = nk_str_at_const(&edit->string, line_start + char_id, &unicode, &len);
../lib/public/nuklear.h:22219:    return font->width(font->userdata, font->height, str, len);
../lib/public/nuklear.h:22229:    int len = nk_str_len_char(&edit->string);
../lib/public/nuklear.h:22230:    const char *end = nk_str_get_const(&edit->string) + len;
../lib/public/nuklear.h:22231:    const char *text = nk_str_at_const(&edit->string, line_start_id, &unicode, &l);
../lib/public/nuklear.h:22233:        text, (int)(end - text), row_height, &remaining, 0, &glyphs, NK_STOP_ON_NEW_LINE);
../lib/public/nuklear.h:22235:    r->x0 = 0.0f;
../lib/public/nuklear.h:22236:    r->x1 = size.x;
../lib/public/nuklear.h:22237:    r->baseline_y_delta = size.y;
../lib/public/nuklear.h:22238:    r->ymin = 0.0f;
../lib/public/nuklear.h:22239:    r->ymax = size.y;
../lib/public/nuklear.h:22240:    r->num_chars = glyphs;
../lib/public/nuklear.h:22247:    int n = edit->string.len;
../lib/public/nuklear.h:22293:        /* shouldn't happen, but if it does, fall through to end-of-line case */
../lib/public/nuklear.h:22298:    if (nk_str_rune_at(&edit->string, i+r.num_chars-1) == '\n')
../lib/public/nuklear.h:22299:        return i+r.num_chars-1;
../lib/public/nuklear.h:22308:    state->cursor = nk_textedit_locate_coord(state, x, y, font, row_height);
../lib/public/nuklear.h:22309:    state->select_start = state->cursor;
../lib/public/nuklear.h:22310:    state->select_end = state->cursor;
../lib/public/nuklear.h:22311:    state->has_preferred_x = 0;
../lib/public/nuklear.h:22320:    if (state->select_start == state->select_end)
../lib/public/nuklear.h:22321:        state->select_start = state->cursor;
../lib/public/nuklear.h:22322:    state->cursor = state->select_end = p;
../lib/public/nuklear.h:22329:     * row in case we get a move-up event (for page up, we'll have to rescan) */
../lib/public/nuklear.h:22332:    int z = state->string.len;
../lib/public/nuklear.h:22337:        /* if it's at the end, then find the last line -- simpler than trying to
../lib/public/nuklear.h:22341:            find->first_char = 0;
../lib/public/nuklear.h:22342:            find->length = z;
../lib/public/nuklear.h:22350:            find->first_char = i;
../lib/public/nuklear.h:22351:            find->length = r.num_chars;
../lib/public/nuklear.h:22353:        find->x = r.x1;
../lib/public/nuklear.h:22354:        find->y = r.ymin;
../lib/public/nuklear.h:22355:        find->height = r.ymax - r.ymin;
../lib/public/nuklear.h:22356:        find->prev_first = prev_start;
../lib/public/nuklear.h:22361:    find->y = 0;
../lib/public/nuklear.h:22368:        find->y += r.baseline_y_delta;
../lib/public/nuklear.h:22371:    find->first_char = first = i;
../lib/public/nuklear.h:22372:    find->length = r.num_chars;
../lib/public/nuklear.h:22373:    find->height = r.ymax - r.ymin;
../lib/public/nuklear.h:22374:    find->prev_first = prev_start;
../lib/public/nuklear.h:22377:    find->x = r.x0;
../lib/public/nuklear.h:22379:        find->x += nk_textedit_get_width(state, first, i, font);
../lib/public/nuklear.h:22385:    int n = state->string.len;
../lib/public/nuklear.h:22387:        if (state->select_start > n) state->select_start = n;
../lib/public/nuklear.h:22388:        if (state->select_end   > n) state->select_end = n;
../lib/public/nuklear.h:22390:        if (state->select_start == state->select_end)
../lib/public/nuklear.h:22391:            state->cursor = state->select_start;
../lib/public/nuklear.h:22393:    if (state->cursor > n) state->cursor = n;
../lib/public/nuklear.h:22400:    nk_str_delete_runes(&state->string, where, len);
../lib/public/nuklear.h:22401:    state->has_preferred_x = 0;
../lib/public/nuklear.h:22409:        if (state->select_start < state->select_end) {
../lib/public/nuklear.h:22410:            nk_textedit_delete(state, state->select_start,
../lib/public/nuklear.h:22411:                state->select_end - state->select_start);
../lib/public/nuklear.h:22412:            state->select_end = state->cursor = state->select_start;
../lib/public/nuklear.h:22414:            nk_textedit_delete(state, state->select_end,
../lib/public/nuklear.h:22415:                state->select_start - state->select_end);
../lib/public/nuklear.h:22416:            state->select_start = state->cursor = state->select_end;
../lib/public/nuklear.h:22418:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22425:    if (state->select_end < state->select_start) {
../lib/public/nuklear.h:22426:        int temp = state->select_end;
../lib/public/nuklear.h:22427:        state->select_end = state->select_start;
../lib/public/nuklear.h:22428:        state->select_start = temp;
../lib/public/nuklear.h:22437:        state->cursor = state->select_start;
../lib/public/nuklear.h:22438:        state->select_end = state->select_start;
../lib/public/nuklear.h:22439:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22449:        state->cursor = state->select_end;
../lib/public/nuklear.h:22450:        state->select_start = state->select_end;
../lib/public/nuklear.h:22451:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22460:    if (!nk_str_at_rune(&state->string, idx, &c, &len)) return 1;
../lib/public/nuklear.h:22468:   int c = state->cursor - 1;
../lib/public/nuklear.h:22470:      --c;
../lib/public/nuklear.h:22480:   const int len = state->string.len;
../lib/public/nuklear.h:22481:   int c = state->cursor+1;
../lib/public/nuklear.h:22495:        state->select_start = state->select_end = state->cursor;
../lib/public/nuklear.h:22496:    else state->cursor = state->select_end;
../lib/public/nuklear.h:22502:    if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
../lib/public/nuklear.h:22506:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22514:    /* API paste: replace existing selection with passed-in text */
../lib/public/nuklear.h:22517:    if (state->mode == NK_TEXT_EDIT_MODE_VIEW) return 0;
../lib/public/nuklear.h:22525:    if (nk_str_insert_text_char(&state->string, state->cursor, text, len)) {
../lib/public/nuklear.h:22526:        nk_textedit_makeundo_insert(state, state->cursor, glyphs);
../lib/public/nuklear.h:22527:        state->cursor += len;
../lib/public/nuklear.h:22528:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22532:    if (state->undo.undo_point)
../lib/public/nuklear.h:22533:        --state->undo.undo_point;
../lib/public/nuklear.h:22545:    if (!text || !total_len || state->mode == NK_TEXT_EDIT_MODE_VIEW) return;
../lib/public/nuklear.h:22552:        /* can't add newline in single-line mode */
../lib/public/nuklear.h:22553:        if (unicode == '\n' && state->single_line) goto next;
../lib/public/nuklear.h:22555:        if (state->filter && !state->filter(state, unicode)) goto next;
../lib/public/nuklear.h:22558:            state->cursor < state->string.len)
../lib/public/nuklear.h:22560:            if (state->mode == NK_TEXT_EDIT_MODE_REPLACE) {
../lib/public/nuklear.h:22561:                nk_textedit_makeundo_replace(state, state->cursor, 1, 1);
../lib/public/nuklear.h:22562:                nk_str_delete_runes(&state->string, state->cursor, 1);
../lib/public/nuklear.h:22564:            if (nk_str_insert_text_utf8(&state->string, state->cursor,
../lib/public/nuklear.h:22567:                ++state->cursor;
../lib/public/nuklear.h:22568:                state->has_preferred_x = 0;
../lib/public/nuklear.h:22572:            if (nk_str_insert_text_utf8(&state->string, state->cursor,
../lib/public/nuklear.h:22575:                nk_textedit_makeundo_insert(state, state->cursor, 1);
../lib/public/nuklear.h:22576:                ++state->cursor;
../lib/public/nuklear.h:22577:                state->has_preferred_x = 0;
../lib/public/nuklear.h:22582:        glyph_len = nk_utf_decode(text + text_len, &unicode, total_len-text_len);
../lib/public/nuklear.h:22604:         state->has_preferred_x = 0;
../lib/public/nuklear.h:22609:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22614:        state->has_preferred_x = 0;
../lib/public/nuklear.h:22618:        if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
../lib/public/nuklear.h:22619:            state->mode = NK_TEXT_EDIT_MODE_INSERT;
../lib/public/nuklear.h:22622:        if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
../lib/public/nuklear.h:22623:            state->mode = NK_TEXT_EDIT_MODE_REPLACE;
../lib/public/nuklear.h:22626:        if (state->mode == NK_TEXT_EDIT_MODE_INSERT ||
../lib/public/nuklear.h:22627:            state->mode == NK_TEXT_EDIT_MODE_REPLACE)
../lib/public/nuklear.h:22628:            state->mode = NK_TEXT_EDIT_MODE_VIEW;
../lib/public/nuklear.h:22636:            if (state->select_end > 0)
../lib/public/nuklear.h:22637:                --state->select_end;
../lib/public/nuklear.h:22638:            state->cursor = state->select_end;
../lib/public/nuklear.h:22639:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22645:            else if (state->cursor > 0)
../lib/public/nuklear.h:22646:               --state->cursor;
../lib/public/nuklear.h:22647:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22654:            ++state->select_end;
../lib/public/nuklear.h:22656:            state->cursor = state->select_end;
../lib/public/nuklear.h:22657:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22663:            else ++state->cursor;
../lib/public/nuklear.h:22665:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22672:            state->cursor = nk_textedit_move_to_word_previous(state);
../lib/public/nuklear.h:22673:            state->select_end = state->cursor;
../lib/public/nuklear.h:22679:                state->cursor = nk_textedit_move_to_word_previous(state);
../lib/public/nuklear.h:22688:            state->cursor = nk_textedit_move_to_word_next(state);
../lib/public/nuklear.h:22689:            state->select_end = state->cursor;
../lib/public/nuklear.h:22695:                state->cursor = nk_textedit_move_to_word_next(state);
../lib/public/nuklear.h:22705:        if (state->single_line) {
../lib/public/nuklear.h:22706:            /* on windows, up&down in single-line behave like left&right */
../lib/public/nuklear.h:22718:        nk_textedit_find_charpos(&find, state, state->cursor, state->single_line,
../lib/public/nuklear.h:22725:            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
../lib/public/nuklear.h:22728:            state->cursor = start;
../lib/public/nuklear.h:22729:            nk_textedit_layout_row(&row, state, state->cursor, row_height, font);
../lib/public/nuklear.h:22737:                ++state->cursor;
../lib/public/nuklear.h:22741:            state->has_preferred_x = 1;
../lib/public/nuklear.h:22742:            state->preferred_x = goal_x;
../lib/public/nuklear.h:22744:                state->select_end = state->cursor;
../lib/public/nuklear.h:22753:        if (state->single_line) {
../lib/public/nuklear.h:22766:         nk_textedit_find_charpos(&find, state, state->cursor, state->single_line,
../lib/public/nuklear.h:22773:            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
../lib/public/nuklear.h:22775:            state->cursor = find.prev_first;
../lib/public/nuklear.h:22776:            nk_textedit_layout_row(&row, state, state->cursor, row_height, font);
../lib/public/nuklear.h:22784:                ++state->cursor;
../lib/public/nuklear.h:22788:            state->has_preferred_x = 1;
../lib/public/nuklear.h:22789:            state->preferred_x = goal_x;
../lib/public/nuklear.h:22790:            if (sel) state->select_end = state->cursor;
../lib/public/nuklear.h:22795:        if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
../lib/public/nuklear.h:22800:            int n = state->string.len;
../lib/public/nuklear.h:22801:            if (state->cursor < n)
../lib/public/nuklear.h:22802:                nk_textedit_delete(state, state->cursor, 1);
../lib/public/nuklear.h:22804:         state->has_preferred_x = 0;
../lib/public/nuklear.h:22808:        if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
../lib/public/nuklear.h:22814:            if (state->cursor > 0) {
../lib/public/nuklear.h:22815:                nk_textedit_delete(state, state->cursor-1, 1);
../lib/public/nuklear.h:22816:                --state->cursor;
../lib/public/nuklear.h:22819:         state->has_preferred_x = 0;
../lib/public/nuklear.h:22825:            state->cursor = state->select_end = 0;
../lib/public/nuklear.h:22826:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22828:            state->cursor = state->select_start = state->select_end = 0;
../lib/public/nuklear.h:22829:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22836:            state->cursor = state->select_end = state->string.len;
../lib/public/nuklear.h:22837:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22839:            state->cursor = state->string.len;
../lib/public/nuklear.h:22840:            state->select_start = state->select_end = 0;
../lib/public/nuklear.h:22841:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22850:            if (state->string.len && state->cursor == state->string.len)
../lib/public/nuklear.h:22851:                --state->cursor;
../lib/public/nuklear.h:22852:            nk_textedit_find_charpos(&find, state,state->cursor, state->single_line,
../lib/public/nuklear.h:22854:            state->cursor = state->select_end = find.first_char;
../lib/public/nuklear.h:22855:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22858:            if (state->string.len && state->cursor == state->string.len)
../lib/public/nuklear.h:22859:                --state->cursor;
../lib/public/nuklear.h:22862:            nk_textedit_find_charpos(&find, state, state->cursor, state->single_line,
../lib/public/nuklear.h:22864:            state->cursor = find.first_char;
../lib/public/nuklear.h:22865:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22874:            nk_textedit_find_charpos(&find, state, state->cursor, state->single_line,
../lib/public/nuklear.h:22876:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22877:            state->cursor = find.first_char + find.length;
../lib/public/nuklear.h:22878:            if (find.length > 0 && nk_str_rune_at(&state->string, state->cursor-1) == '\n')
../lib/public/nuklear.h:22879:                --state->cursor;
../lib/public/nuklear.h:22880:            state->select_end = state->cursor;
../lib/public/nuklear.h:22885:            nk_textedit_find_charpos(&find, state, state->cursor, state->single_line,
../lib/public/nuklear.h:22888:            state->has_preferred_x = 0;
../lib/public/nuklear.h:22889:            state->cursor = find.first_char + find.length;
../lib/public/nuklear.h:22890:            if (find.length > 0 && nk_str_rune_at(&state->string, state->cursor-1) == '\n')
../lib/public/nuklear.h:22891:                --state->cursor;
../lib/public/nuklear.h:22898:    state->redo_point = NK_TEXTEDIT_UNDOSTATECOUNT;
../lib/public/nuklear.h:22899:    state->redo_char_point = NK_TEXTEDIT_UNDOCHARCOUNT;
../lib/public/nuklear.h:22905:    if (state->undo_point > 0) {
../lib/public/nuklear.h:22907:        if (state->undo_rec[0].char_storage >= 0) {
../lib/public/nuklear.h:22908:            int n = state->undo_rec[0].insert_length, i;
../lib/public/nuklear.h:22910:            state->undo_char_point = (short)(state->undo_char_point - n);
../lib/public/nuklear.h:22911:            NK_MEMCPY(state->undo_char, state->undo_char + n,
../lib/public/nuklear.h:22912:                (nk_size)state->undo_char_point*sizeof(nk_rune));
../lib/public/nuklear.h:22913:            for (i=0; i < state->undo_point; ++i) {
../lib/public/nuklear.h:22914:                if (state->undo_rec[i].char_storage >= 0)
../lib/public/nuklear.h:22915:                state->undo_rec[i].char_storage = (short)
../lib/public/nuklear.h:22916:                    (state->undo_rec[i].char_storage - n);
../lib/public/nuklear.h:22919:        --state->undo_point;
../lib/public/nuklear.h:22920:        NK_MEMCPY(state->undo_rec, state->undo_rec+1,
../lib/public/nuklear.h:22921:            (nk_size)((nk_size)state->undo_point * sizeof(state->undo_rec[0])));
../lib/public/nuklear.h:22927:/*  discard the oldest entry in the redo list--it's bad if this
../lib/public/nuklear.h:22932:    int k = NK_TEXTEDIT_UNDOSTATECOUNT-1;
../lib/public/nuklear.h:22933:    if (state->redo_point <= k) {
../lib/public/nuklear.h:22935:        if (state->undo_rec[k].char_storage >= 0) {
../lib/public/nuklear.h:22936:            int n = state->undo_rec[k].insert_length, i;
../lib/public/nuklear.h:22938:            state->redo_char_point = (short)(state->redo_char_point + n);
../lib/public/nuklear.h:22939:            num = (nk_size)(NK_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point);
../lib/public/nuklear.h:22940:            NK_MEMCPY(state->undo_char + state->redo_char_point,
../lib/public/nuklear.h:22941:                state->undo_char + state->redo_char_point-n, num * sizeof(char));
../lib/public/nuklear.h:22942:            for (i = state->redo_point; i < k; ++i) {
../lib/public/nuklear.h:22943:                if (state->undo_rec[i].char_storage >= 0) {
../lib/public/nuklear.h:22944:                    state->undo_rec[i].char_storage = (short)
../lib/public/nuklear.h:22945:                        (state->undo_rec[i].char_storage + n);
../lib/public/nuklear.h:22949:        ++state->redo_point;
../lib/public/nuklear.h:22950:        num = (nk_size)(NK_TEXTEDIT_UNDOSTATECOUNT - state->redo_point);
../lib/public/nuklear.h:22951:        if (num) NK_MEMCPY(state->undo_rec + state->redo_point-1,
../lib/public/nuklear.h:22952:            state->undo_rec + state->redo_point, num * sizeof(state->undo_rec[0]));
../lib/public/nuklear.h:22963:    if (state->undo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
../lib/public/nuklear.h:22969:        state->undo_point = 0;
../lib/public/nuklear.h:22970:        state->undo_char_point = 0;
../lib/public/nuklear.h:22976:    while (state->undo_char_point + numchars > NK_TEXTEDIT_UNDOCHARCOUNT)
../lib/public/nuklear.h:22978:    return &state->undo_rec[state->undo_point++];
../lib/public/nuklear.h:22988:    r->where = pos;
../lib/public/nuklear.h:22989:    r->insert_length = (short) insert_len;
../lib/public/nuklear.h:22990:    r->delete_length = (short) delete_len;
../lib/public/nuklear.h:22993:        r->char_storage = -1;
../lib/public/nuklear.h:22996:        r->char_storage = state->undo_char_point;
../lib/public/nuklear.h:22997:        state->undo_char_point = (short)(state->undo_char_point +  insert_len);
../lib/public/nuklear.h:22998:        return &state->undo_char[r->char_storage];
../lib/public/nuklear.h:23004:    struct nk_text_undo_state *s = &state->undo;
../lib/public/nuklear.h:23006:    if (s->undo_point == 0)
../lib/public/nuklear.h:23010:    u = s->undo_rec[s->undo_point-1];
../lib/public/nuklear.h:23011:    r = &s->undo_rec[s->redo_point-1];
../lib/public/nuklear.h:23012:    r->char_storage = -1;
../lib/public/nuklear.h:23014:    r->insert_length = u.delete_length;
../lib/public/nuklear.h:23015:    r->delete_length = u.insert_length;
../lib/public/nuklear.h:23016:    r->where = u.where;
../lib/public/nuklear.h:23021:            need to re-insert the characters that get deleted, so we need to store
../lib/public/nuklear.h:23024:                - there's enough room to store the characters
../lib/public/nuklear.h:23025:                - characters stored for *redoing* don't leave room for redo
../lib/public/nuklear.h:23026:                - characters stored for *undoing* don't leave room for redo
../lib/public/nuklear.h:23028:        if (s->undo_char_point + u.delete_length >= NK_TEXTEDIT_UNDOCHARCOUNT) {
../lib/public/nuklear.h:23031:            r->insert_length = 0;
../lib/public/nuklear.h:23035:            while (s->undo_char_point + u.delete_length > s->redo_char_point) {
../lib/public/nuklear.h:23039:                if (s->redo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
../lib/public/nuklear.h:23043:            r = &s->undo_rec[s->redo_point-1];
../lib/public/nuklear.h:23044:            r->char_storage = (short)(s->redo_char_point - u.delete_length);
../lib/public/nuklear.h:23045:            s->redo_char_point = (short)(s->redo_char_point -  u.delete_length);
../lib/public/nuklear.h:23049:                s->undo_char[r->char_storage + i] =
../lib/public/nuklear.h:23050:                    nk_str_rune_at(&state->string, u.where + i);
../lib/public/nuklear.h:23053:        nk_str_delete_runes(&state->string, u.where, u.delete_length);
../lib/public/nuklear.h:23059:        nk_str_insert_text_runes(&state->string, u.where,
../lib/public/nuklear.h:23060:            &s->undo_char[u.char_storage], u.insert_length);
../lib/public/nuklear.h:23061:        s->undo_char_point = (short)(s->undo_char_point - u.insert_length);
../lib/public/nuklear.h:23063:    state->cursor = (short)(u.where + u.insert_length);
../lib/public/nuklear.h:23065:    s->undo_point--;
../lib/public/nuklear.h:23066:    s->redo_point--;
../lib/public/nuklear.h:23071:    struct nk_text_undo_state *s = &state->undo;
../lib/public/nuklear.h:23073:    if (s->redo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
../lib/public/nuklear.h:23077:    u = &s->undo_rec[s->undo_point];
../lib/public/nuklear.h:23078:    r = s->undo_rec[s->redo_point];
../lib/public/nuklear.h:23082:    u->delete_length = r.insert_length;
../lib/public/nuklear.h:23083:    u->insert_length = r.delete_length;
../lib/public/nuklear.h:23084:    u->where = r.where;
../lib/public/nuklear.h:23085:    u->char_storage = -1;
../lib/public/nuklear.h:23090:        if (s->undo_char_point + u->insert_length > s->redo_char_point) {
../lib/public/nuklear.h:23091:            u->insert_length = 0;
../lib/public/nuklear.h:23092:            u->delete_length = 0;
../lib/public/nuklear.h:23095:            u->char_storage = s->undo_char_point;
../lib/public/nuklear.h:23096:            s->undo_char_point = (short)(s->undo_char_point + u->insert_length);
../lib/public/nuklear.h:23099:            for (i=0; i < u->insert_length; ++i) {
../lib/public/nuklear.h:23100:                s->undo_char[u->char_storage + i] =
../lib/public/nuklear.h:23101:                    nk_str_rune_at(&state->string, u->where + i);
../lib/public/nuklear.h:23104:        nk_str_delete_runes(&state->string, r.where, r.delete_length);
../lib/public/nuklear.h:23109:        nk_str_insert_text_runes(&state->string, r.where,
../lib/public/nuklear.h:23110:            &s->undo_char[r.char_storage], r.insert_length);
../lib/public/nuklear.h:23112:    state->cursor = r.where + r.insert_length;
../lib/public/nuklear.h:23114:    s->undo_point++;
../lib/public/nuklear.h:23115:    s->redo_point++;
../lib/public/nuklear.h:23120:    nk_textedit_createundo(&state->undo, where, 0, length);
../lib/public/nuklear.h:23126:    nk_rune *p = nk_textedit_createundo(&state->undo, where, length, 0);
../lib/public/nuklear.h:23129:            p[i] = nk_str_rune_at(&state->string, where+i);
../lib/public/nuklear.h:23137:    nk_rune *p = nk_textedit_createundo(&state->undo, where, old_length, new_length);
../lib/public/nuklear.h:23140:            p[i] = nk_str_rune_at(&state->string, where+i);
../lib/public/nuklear.h:23148:   state->undo.undo_point = 0;
../lib/public/nuklear.h:23149:   state->undo.undo_char_point = 0;
../lib/public/nuklear.h:23150:   state->undo.redo_point = NK_TEXTEDIT_UNDOSTATECOUNT;
../lib/public/nuklear.h:23151:   state->undo.redo_char_point = NK_TEXTEDIT_UNDOCHARCOUNT;
../lib/public/nuklear.h:23152:   state->select_end = state->select_start = 0;
../lib/public/nuklear.h:23153:   state->cursor = 0;
../lib/public/nuklear.h:23154:   state->has_preferred_x = 0;
../lib/public/nuklear.h:23155:   state->preferred_x = 0;
../lib/public/nuklear.h:23156:   state->cursor_at_end_of_line = 0;
../lib/public/nuklear.h:23157:   state->initialized = 1;
../lib/public/nuklear.h:23158:   state->single_line = (unsigned char)(type == NK_TEXT_EDIT_SINGLE_LINE);
../lib/public/nuklear.h:23159:   state->mode = NK_TEXT_EDIT_MODE_VIEW;
../lib/public/nuklear.h:23160:   state->filter = filter;
../lib/public/nuklear.h:23161:   state->scrollbar = nk_vec2(0,0);
../lib/public/nuklear.h:23171:    nk_str_init_fixed(&state->string, memory, size);
../lib/public/nuklear.h:23181:    nk_str_init(&state->string, alloc, size);
../lib/public/nuklear.h:23191:    nk_str_init_default(&state->string);
../lib/public/nuklear.h:23198:    state->select_start = 0;
../lib/public/nuklear.h:23199:    state->select_end = state->string.len;
../lib/public/nuklear.h:23206:    nk_str_free(&state->string);
../lib/public/nuklear.h:23236:    if ((unicode < '0' || unicode > '9') && unicode != '.' && unicode != '-')
../lib/public/nuklear.h:23244:    if ((unicode < '0' || unicode > '9') && unicode != '-')
../lib/public/nuklear.h:23306:    glyph_len = nk_utf_decode(text+text_len, &unicode, byte_len-text_len);
../lib/public/nuklear.h:23322:            nk_widget_text(out, label, line, (int)((text + text_len) - line),
../lib/public/nuklear.h:23330:            glyph_len = nk_utf_decode(text + text_len, &unicode, (int)(byte_len-text_len));
../lib/public/nuklear.h:23335:            glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len-text_len);
../lib/public/nuklear.h:23338:        glyph_width = font->width(font->userdata, font->height, text+text_len, glyph_len);
../lib/public/nuklear.h:23341:        glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len-text_len);
../lib/public/nuklear.h:23356:        nk_widget_text(out, label, line, (int)((text + text_len) - line),
../lib/public/nuklear.h:23383:    area.x = bounds.x + style->padding.x + style->border;
../lib/public/nuklear.h:23384:    area.y = bounds.y + style->padding.y + style->border;
../lib/public/nuklear.h:23385:    area.w = bounds.w - (2.0f * style->padding.x + 2 * style->border);
../lib/public/nuklear.h:23386:    area.h = bounds.h - (2.0f * style->padding.y + 2 * style->border);
../lib/public/nuklear.h:23388:        area.w = NK_MAX(0, area.w - style->scrollbar_size.x);
../lib/public/nuklear.h:23389:    row_height = (flags & NK_EDIT_MULTILINE)? font->height + style->row_padding: area.h;
../lib/public/nuklear.h:23392:    old_clip = out->clip;
../lib/public/nuklear.h:23396:    prev_state = (char)edit->active;
../lib/public/nuklear.h:23398:    if (in && in->mouse.buttons[NK_BUTTON_LEFT].clicked && in->mouse.buttons[NK_BUTTON_LEFT].down) {
../lib/public/nuklear.h:23399:        edit->active = NK_INBOX(in->mouse.pos.x, in->mouse.pos.y,
../lib/public/nuklear.h:23404:    if (!prev_state && edit->active) {
../lib/public/nuklear.h:23411:            edit->cursor = edit->string.len;
../lib/public/nuklear.h:23414:    } else if (!edit->active) edit->mode = NK_TEXT_EDIT_MODE_VIEW;
../lib/public/nuklear.h:23416:        edit->mode = NK_TEXT_EDIT_MODE_VIEW;
../lib/public/nuklear.h:23418:        edit->mode = NK_TEXT_EDIT_MODE_INSERT;
../lib/public/nuklear.h:23420:    ret = (edit->active) ? NK_EDIT_ACTIVE: NK_EDIT_INACTIVE;
../lib/public/nuklear.h:23421:    if (prev_state != edit->active)
../lib/public/nuklear.h:23422:        ret |= (edit->active) ? NK_EDIT_ACTIVATED: NK_EDIT_DEACTIVATED;
../lib/public/nuklear.h:23425:    if (edit->active && in)
../lib/public/nuklear.h:23427:        int shift_mod = in->keyboard.keys[NK_KEY_SHIFT].down;
../lib/public/nuklear.h:23428:        const float mouse_x = (in->mouse.pos.x - area.x) + edit->scrollbar.x;
../lib/public/nuklear.h:23429:        const float mouse_y = (in->mouse.pos.y - area.y) + edit->scrollbar.y;
../lib/public/nuklear.h:23435:        } else if (is_hovered && in->mouse.buttons[NK_BUTTON_LEFT].down &&
../lib/public/nuklear.h:23436:            in->mouse.buttons[NK_BUTTON_LEFT].clicked) {
../lib/public/nuklear.h:23438:        } else if (is_hovered && in->mouse.buttons[NK_BUTTON_LEFT].down &&
../lib/public/nuklear.h:23439:            (in->mouse.delta.x != 0.0f || in->mouse.delta.y != 0.0f)) {
../lib/public/nuklear.h:23442:        } else if (is_hovered && in->mouse.buttons[NK_BUTTON_RIGHT].clicked &&
../lib/public/nuklear.h:23443:            in->mouse.buttons[NK_BUTTON_RIGHT].down) {
../lib/public/nuklear.h:23450:        int old_mode = edit->mode;
../lib/public/nuklear.h:23458:        if (old_mode != edit->mode) {
../lib/public/nuklear.h:23459:            in->keyboard.text_len = 0;
../lib/public/nuklear.h:23463:        edit->filter = filter;
../lib/public/nuklear.h:23464:        if (in->keyboard.text_len) {
../lib/public/nuklear.h:23465:            nk_textedit_text(edit, in->keyboard.text, in->keyboard.text_len);
../lib/public/nuklear.h:23467:            in->keyboard.text_len = 0;
../lib/public/nuklear.h:23488:            int b = edit->select_start;
../lib/public/nuklear.h:23489:            int e = edit->select_end;
../lib/public/nuklear.h:23493:            text = nk_str_at_const(&edit->string, begin, &unicode, &glyph_len);
../lib/public/nuklear.h:23494:            if (edit->clip.copy)
../lib/public/nuklear.h:23495:                edit->clip.copy(edit->clip.userdata, text, end - begin);
../lib/public/nuklear.h:23504:        if (paste && (flags & NK_EDIT_CLIPBOARD) && edit->clip.paste) {
../lib/public/nuklear.h:23505:            edit->clip.paste(edit->clip.userdata, edit);
../lib/public/nuklear.h:23518:    if (edit->active)
../lib/public/nuklear.h:23526:    {const char *text = nk_str_get_const(&edit->string);
../lib/public/nuklear.h:23527:    int len = nk_str_len_char(&edit->string);
../lib/public/nuklear.h:23532:        background = &style->active;
../lib/public/nuklear.h:23534:        background = &style->hover;
../lib/public/nuklear.h:23535:    else background = &style->normal;
../lib/public/nuklear.h:23538:    if (background->type == NK_STYLE_ITEM_COLOR) {
../lib/public/nuklear.h:23539:        nk_stroke_rect(out, bounds, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:23540:        nk_fill_rect(out, bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:23541:    } else nk_draw_image(out, bounds, &background->data.image, nk_white);}
../lib/public/nuklear.h:23543:    area.w = NK_MAX(0, area.w - style->cursor_size);
../lib/public/nuklear.h:23544:    if (edit->active)
../lib/public/nuklear.h:23559:        int selection_begin = NK_MIN(edit->select_start, edit->select_end);
../lib/public/nuklear.h:23560:        int selection_end = NK_MAX(edit->select_start, edit->select_end);
../lib/public/nuklear.h:23575:            glyph_width = font->width(font->userdata, font->height, text, glyph_len);
../lib/public/nuklear.h:23582:                if (!cursor_ptr && glyphs == edit->cursor)
../lib/public/nuklear.h:23590:                    cursor_pos.y = (float)(total_lines-1) * row_height;
../lib/public/nuklear.h:23592:                                text_len-row_begin, row_height, &remaining,
../lib/public/nuklear.h:23599:                if (!select_begin_ptr && edit->select_start != edit->select_end &&
../lib/public/nuklear.h:23608:                    selection_offset_start.y = (float)(NK_MAX(total_lines-1,0)) * row_height;
../lib/public/nuklear.h:23610:                                text_len-row_begin, row_height, &remaining,
../lib/public/nuklear.h:23617:                if (!select_end_ptr && edit->select_start != edit->select_end &&
../lib/public/nuklear.h:23626:                    selection_offset_end.y = (float)(total_lines-1) * row_height;
../lib/public/nuklear.h:23628:                                text_len-row_begin, row_height, &remaining,
../lib/public/nuklear.h:23640:                    glyph_len = nk_utf_decode(text + text_len, &unicode, len-text_len);
../lib/public/nuklear.h:23641:                    glyph_width = font->width(font->userdata, font->height, text+text_len, glyph_len);
../lib/public/nuklear.h:23649:                glyph_len = nk_utf_decode(text + text_len, &unicode, len-text_len);
../lib/public/nuklear.h:23650:                glyph_width = font->width(font->userdata, font->height,
../lib/public/nuklear.h:23657:            if (!cursor_ptr && edit->cursor == edit->string.len) {
../lib/public/nuklear.h:23659:                cursor_pos.y = text_size.y - row_height;
../lib/public/nuklear.h:23670:                    if (cursor_pos.x < edit->scrollbar.x)
../lib/public/nuklear.h:23671:                        edit->scrollbar.x = (float)(int)NK_MAX(0.0f, cursor_pos.x - scroll_increment);
../lib/public/nuklear.h:23672:                    if (cursor_pos.x >= edit->scrollbar.x + area.w)
../lib/public/nuklear.h:23673:                        edit->scrollbar.x = (float)(int)NK_MAX(0.0f, edit->scrollbar.x + scroll_increment);
../lib/public/nuklear.h:23674:                } else edit->scrollbar.x = 0;
../lib/public/nuklear.h:23678:                    if (cursor_pos.y < edit->scrollbar.y)
../lib/public/nuklear.h:23679:                        edit->scrollbar.y = NK_MAX(0.0f, cursor_pos.y - row_height);
../lib/public/nuklear.h:23680:                    if (cursor_pos.y >= edit->scrollbar.y + area.h)
../lib/public/nuklear.h:23681:                        edit->scrollbar.y = edit->scrollbar.y + row_height;
../lib/public/nuklear.h:23682:                } else edit->scrollbar.y = 0;
../lib/public/nuklear.h:23696:                scroll.x = (bounds.x + bounds.w - style->border) - style->scrollbar_size.x;
../lib/public/nuklear.h:23697:                scroll.w = style->scrollbar_size.x;
../lib/public/nuklear.h:23699:                scroll_offset = edit->scrollbar.y;
../lib/public/nuklear.h:23703:                edit->scrollbar.y = nk_do_scrollbarv(&ws, out, scroll, 0,
../lib/public/nuklear.h:23705:                        &style->scrollbar, in, font);
../lib/public/nuklear.h:23721:            background = &style->active;
../lib/public/nuklear.h:23722:            text_color = style->text_active;
../lib/public/nuklear.h:23723:            sel_text_color = style->selected_text_hover;
../lib/public/nuklear.h:23724:            sel_background_color = style->selected_hover;
../lib/public/nuklear.h:23725:            cursor_color = style->cursor_hover;
../lib/public/nuklear.h:23726:            cursor_text_color = style->cursor_text_hover;
../lib/public/nuklear.h:23728:            background = &style->hover;
../lib/public/nuklear.h:23729:            text_color = style->text_hover;
../lib/public/nuklear.h:23730:            sel_text_color = style->selected_text_hover;
../lib/public/nuklear.h:23731:            sel_background_color = style->selected_hover;
../lib/public/nuklear.h:23732:            cursor_text_color = style->cursor_text_hover;
../lib/public/nuklear.h:23733:            cursor_color = style->cursor_hover;
../lib/public/nuklear.h:23735:            background = &style->normal;
../lib/public/nuklear.h:23736:            text_color = style->text_normal;
../lib/public/nuklear.h:23737:            sel_text_color = style->selected_text_normal;
../lib/public/nuklear.h:23738:            sel_background_color = style->selected_normal;
../lib/public/nuklear.h:23739:            cursor_color = style->cursor_normal;
../lib/public/nuklear.h:23740:            cursor_text_color = style->cursor_text_normal;
../lib/public/nuklear.h:23742:        if (background->type == NK_STYLE_ITEM_IMAGE
../lib/public/nuklear.h:23743:        ||  background->type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:23745:        else background_color = background->data.color;
../lib/public/nuklear.h:23748:        if (edit->select_start == edit->select_end) {
../lib/public/nuklear.h:23750:            const char *begin = nk_str_get_const(&edit->string);
../lib/public/nuklear.h:23751:            int l = nk_str_len_char(&edit->string);
../lib/public/nuklear.h:23752:            nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
../lib/public/nuklear.h:23753:                area.y - edit->scrollbar.y, 0, begin, l, row_height, font,
../lib/public/nuklear.h:23756:            /* edit has selection so draw 1-3 text chunks */
../lib/public/nuklear.h:23757:            if (edit->select_start != edit->select_end && selection_begin > 0){
../lib/public/nuklear.h:23759:                const char *begin = nk_str_get_const(&edit->string);
../lib/public/nuklear.h:23761:                nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
../lib/public/nuklear.h:23762:                    area.y - edit->scrollbar.y, 0, begin, (int)(select_begin_ptr - begin),
../lib/public/nuklear.h:23765:            if (edit->select_start != edit->select_end) {
../lib/public/nuklear.h:23769:                    const char *begin = nk_str_get_const(&edit->string);
../lib/public/nuklear.h:23770:                    select_end_ptr = begin + nk_str_len_char(&edit->string);
../lib/public/nuklear.h:23773:                    area.x - edit->scrollbar.x,
../lib/public/nuklear.h:23774:                    area.y + selection_offset_start.y - edit->scrollbar.y,
../lib/public/nuklear.h:23776:                    select_begin_ptr, (int)(select_end_ptr - select_begin_ptr),
../lib/public/nuklear.h:23779:            if ((edit->select_start != edit->select_end &&
../lib/public/nuklear.h:23780:                selection_end < edit->string.len))
../lib/public/nuklear.h:23784:                const char *end = nk_str_get_const(&edit->string) +
../lib/public/nuklear.h:23785:                                    nk_str_len_char(&edit->string);
../lib/public/nuklear.h:23788:                    area.x - edit->scrollbar.x,
../lib/public/nuklear.h:23789:                    area.y + selection_offset_end.y - edit->scrollbar.y,
../lib/public/nuklear.h:23791:                    begin, (int)(end - begin), row_height, font,
../lib/public/nuklear.h:23797:        if (edit->select_start == edit->select_end)
../lib/public/nuklear.h:23799:            if (edit->cursor >= nk_str_len(&edit->string) ||
../lib/public/nuklear.h:23803:                cursor.w = style->cursor_size;
../lib/public/nuklear.h:23804:                cursor.h = font->height;
../lib/public/nuklear.h:23805:                cursor.x = area.x + cursor_pos.x - edit->scrollbar.x;
../lib/public/nuklear.h:23806:                cursor.y = area.y + cursor_pos.y + row_height/2.0f - cursor.h/2.0f;
../lib/public/nuklear.h:23807:                cursor.y -= edit->scrollbar.y;
../lib/public/nuklear.h:23819:                label.x = area.x + cursor_pos.x - edit->scrollbar.x;
../lib/public/nuklear.h:23820:                label.y = area.y + cursor_pos.y - edit->scrollbar.y;
../lib/public/nuklear.h:23821:                label.w = font->width(font->userdata, font->height, cursor_ptr, glyph_len);
../lib/public/nuklear.h:23833:        int l = nk_str_len_char(&edit->string);
../lib/public/nuklear.h:23834:        const char *begin = nk_str_get_const(&edit->string);
../lib/public/nuklear.h:23841:            background = &style->active;
../lib/public/nuklear.h:23842:            text_color = style->text_active;
../lib/public/nuklear.h:23844:            background = &style->hover;
../lib/public/nuklear.h:23845:            text_color = style->text_hover;
../lib/public/nuklear.h:23847:            background = &style->normal;
../lib/public/nuklear.h:23848:            text_color = style->text_normal;
../lib/public/nuklear.h:23850:        if (background->type == NK_STYLE_ITEM_IMAGE
../lib/public/nuklear.h:23851:        ||  background->type == NK_STYLE_ITEM_TEXPATH)
../lib/public/nuklear.h:23853:        else background_color = background->data.color;
../lib/public/nuklear.h:23854:        nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
../lib/public/nuklear.h:23855:            area.y - edit->scrollbar.y, 0, begin, l, row_height, font,
../lib/public/nuklear.h:23868:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:23869:    if (!ctx || !ctx->current) return;
../lib/public/nuklear.h:23871:    win = ctx->current;
../lib/public/nuklear.h:23872:    hash = win->edit.seq;
../lib/public/nuklear.h:23873:    win->edit.active = nk_true;
../lib/public/nuklear.h:23874:    win->edit.name = hash;
../lib/public/nuklear.h:23876:        win->edit.mode = NK_TEXT_EDIT_MODE_INSERT;
../lib/public/nuklear.h:23883:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:23884:    if (!ctx || !ctx->current) return;
../lib/public/nuklear.h:23886:    win = ctx->current;
../lib/public/nuklear.h:23887:    win->edit.active = nk_false;
../lib/public/nuklear.h:23888:    win->edit.name = 0;
../lib/public/nuklear.h:23906:    win = ctx->current;
../lib/public/nuklear.h:23907:    hash = win->edit.seq;
../lib/public/nuklear.h:23908:    edit = &ctx->text_edit;
../lib/public/nuklear.h:23909:    nk_textedit_clear_state(&ctx->text_edit, (flags & NK_EDIT_MULTILINE)?
../lib/public/nuklear.h:23912:    if (win->edit.active && hash == win->edit.name) {
../lib/public/nuklear.h:23914:            edit->cursor = nk_utf_len(memory, *len);
../lib/public/nuklear.h:23915:        else edit->cursor = win->edit.cursor;
../lib/public/nuklear.h:23917:            edit->select_start = win->edit.cursor;
../lib/public/nuklear.h:23918:            edit->select_end = win->edit.cursor;
../lib/public/nuklear.h:23920:            edit->select_start = win->edit.sel_start;
../lib/public/nuklear.h:23921:            edit->select_end = win->edit.sel_end;
../lib/public/nuklear.h:23923:        edit->mode = win->edit.mode;
../lib/public/nuklear.h:23924:        edit->scrollbar.x = (float)win->edit.scrollbar.x;
../lib/public/nuklear.h:23925:        edit->scrollbar.y = (float)win->edit.scrollbar.y;
../lib/public/nuklear.h:23926:        edit->active = nk_true;
../lib/public/nuklear.h:23927:    } else edit->active = nk_false;
../lib/public/nuklear.h:23930:    *len = NK_MIN(*len, max-1);
../lib/public/nuklear.h:23931:    nk_str_init_fixed(&edit->string, memory, (nk_size)max);
../lib/public/nuklear.h:23932:    edit->string.buffer.allocated = (nk_size)*len;
../lib/public/nuklear.h:23933:    edit->string.len = nk_utf_len(memory, *len);
../lib/public/nuklear.h:23935:    *len = (int)edit->string.buffer.allocated;
../lib/public/nuklear.h:23937:    if (edit->active) {
../lib/public/nuklear.h:23938:        win->edit.cursor = edit->cursor;
../lib/public/nuklear.h:23939:        win->edit.sel_start = edit->select_start;
../lib/public/nuklear.h:23940:        win->edit.sel_end = edit->select_end;
../lib/public/nuklear.h:23941:        win->edit.mode = edit->mode;
../lib/public/nuklear.h:23942:        win->edit.scrollbar.x = (nk_uint)edit->scrollbar.x;
../lib/public/nuklear.h:23943:        win->edit.scrollbar.y = (nk_uint)edit->scrollbar.y;
../lib/public/nuklear.h:23964:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:23965:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:23966:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:23969:    win = ctx->current;
../lib/public/nuklear.h:23970:    style = &ctx->style;
../lib/public/nuklear.h:23973:    in = (win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:23976:    hash = win->edit.seq++;
../lib/public/nuklear.h:23977:    if (win->edit.active && hash == win->edit.name) {
../lib/public/nuklear.h:23979:            edit->cursor = edit->string.len;
../lib/public/nuklear.h:23981:            edit->select_start = edit->cursor;
../lib/public/nuklear.h:23982:            edit->select_end = edit->cursor;
../lib/public/nuklear.h:23985:            edit->clip = ctx->clip;
../lib/public/nuklear.h:23986:        edit->active = (unsigned char)win->edit.active;
../lib/public/nuklear.h:23987:    } else edit->active = nk_false;
../lib/public/nuklear.h:23988:    edit->mode = win->edit.mode;
../lib/public/nuklear.h:23991:    prev_state = (unsigned char)edit->active;
../lib/public/nuklear.h:23993:    ret_flags = nk_do_edit(&ctx->last_widget_state, &win->buffer, bounds, flags,
../lib/public/nuklear.h:23994:                    filter, edit, &style->edit, in, style->font);
../lib/public/nuklear.h:23996:    if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:23997:        ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_TEXT];
../lib/public/nuklear.h:23998:    if (edit->active && prev_state != edit->active) {
../lib/public/nuklear.h:24000:        win->edit.active = nk_true;
../lib/public/nuklear.h:24001:        win->edit.name = hash;
../lib/public/nuklear.h:24002:    } else if (prev_state && !edit->active) {
../lib/public/nuklear.h:24004:        win->edit.active = nk_false;
../lib/public/nuklear.h:24014:    buffer[NK_MIN(NK_MAX(max-1,0), len)] = '\0';
../lib/public/nuklear.h:24032:    int left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
../lib/public/nuklear.h:24042:        pixels = in->mouse.delta.x;
../lib/public/nuklear.h:24044:        switch (variant->kind) {
../lib/public/nuklear.h:24047:            variant->value.i = variant->value.i + (int)delta;
../lib/public/nuklear.h:24048:            variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i, variant->max_value.i);
../lib/public/nuklear.h:24051:            variant->value.f = variant->value.f + (float)delta;
../lib/public/nuklear.h:24052:            variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f, variant->max_value.f);
../lib/public/nuklear.h:24055:            variant->value.d = variant->value.d + (double)delta;
../lib/public/nuklear.h:24056:            variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d, variant->max_value.d);
../lib/public/nuklear.h:24095:        background = &style->active;
../lib/public/nuklear.h:24096:        text.text = style->label_active;
../lib/public/nuklear.h:24098:        background = &style->hover;
../lib/public/nuklear.h:24099:        text.text = style->label_hover;
../lib/public/nuklear.h:24101:        background = &style->normal;
../lib/public/nuklear.h:24102:        text.text = style->label_normal;
../lib/public/nuklear.h:24106:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:24107:        nk_draw_image(out, *bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:24109:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:24110:        nk_draw_texpath(out, *bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:24113:        text.background = background->data.color;
../lib/public/nuklear.h:24114:        nk_fill_rect(out, *bounds, style->rounding, background->data.color);
../lib/public/nuklear.h:24115:        nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
../lib/public/nuklear.h:24152:    left.h = font->height/2;
../lib/public/nuklear.h:24154:    left.x = property.x + style->border + style->padding.x;
../lib/public/nuklear.h:24155:    left.y = property.y + style->border + property.h/2.0f - left.h/2;
../lib/public/nuklear.h:24159:    size = font->width(font->userdata, font->height, name, name_len);
../lib/public/nuklear.h:24160:    label.x = left.x + left.w + style->padding.x;
../lib/public/nuklear.h:24161:    label.w = (float)size + 2 * style->padding.x;
../lib/public/nuklear.h:24162:    label.y = property.y + style->border + style->padding.y;
../lib/public/nuklear.h:24163:    label.h = property.h - (2 * style->border + 2 * style->padding.y);
../lib/public/nuklear.h:24169:    right.x = property.x + property.w - (right.w + style->padding.x);
../lib/public/nuklear.h:24173:        size = font->width(font->userdata, font->height, buffer, *len);
../lib/public/nuklear.h:24174:        size += style->edit.cursor_size;
../lib/public/nuklear.h:24178:        switch (variant->kind) {
../lib/public/nuklear.h:24180:            nk_itoa(string, variant->value.i);
../lib/public/nuklear.h:24184:            NK_DTOA(string, (double)variant->value.f);
../lib/public/nuklear.h:24188:            NK_DTOA(string, variant->value.d);
../lib/public/nuklear.h:24195:        size = font->width(font->userdata, font->height, string, num_len);
../lib/public/nuklear.h:24200:    edit.w =  (float)size + 2 * style->padding.x;
../lib/public/nuklear.h:24201:    edit.w = NK_MIN(edit.w, right.x - (label.x + label.w));
../lib/public/nuklear.h:24202:    edit.x = right.x - (edit.w + style->padding.x);
../lib/public/nuklear.h:24203:    edit.y = property.y + style->border;
../lib/public/nuklear.h:24204:    edit.h = property.h - (2 * style->border);
../lib/public/nuklear.h:24207:    empty.w = edit.x - (label.x + label.w);
../lib/public/nuklear.h:24217:    if (style->draw_begin) style->draw_begin(out, style->userdata);
../lib/public/nuklear.h:24219:    if (style->draw_end) style->draw_end(out, style->userdata);
../lib/public/nuklear.h:24222:    if (nk_do_button_symbol(ws, out, left, style->sym_left, behavior, &style->dec_button, in, font)) {
../lib/public/nuklear.h:24223:        switch (variant->kind) {
../lib/public/nuklear.h:24226:            variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i - variant->step.i, variant->max_value.i); break;
../lib/public/nuklear.h:24228:            variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f - variant->step.f, variant->max_value.f); break;
../lib/public/nuklear.h:24230:            variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d - variant->step.d, variant->max_value.d); break;
../lib/public/nuklear.h:24234:    if (nk_do_button_symbol(ws, out, right, style->sym_right, behavior, &style->inc_button, in, font)) {
../lib/public/nuklear.h:24235:        switch (variant->kind) {
../lib/public/nuklear.h:24238:            variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i + variant->step.i, variant->max_value.i); break;
../lib/public/nuklear.h:24240:            variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f + variant->step.f, variant->max_value.f); break;
../lib/public/nuklear.h:24242:            variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d + variant->step.d, variant->max_value.d); break;
../lib/public/nuklear.h:24257:    text_edit->active = (unsigned char)active;
../lib/public/nuklear.h:24258:    text_edit->string.len = *length;
../lib/public/nuklear.h:24259:    text_edit->cursor = NK_CLAMP(0, *cursor, *length);
../lib/public/nuklear.h:24260:    text_edit->select_start = NK_CLAMP(0,*select_begin, *length);
../lib/public/nuklear.h:24261:    text_edit->select_end = NK_CLAMP(0,*select_end, *length);
../lib/public/nuklear.h:24262:    text_edit->string.buffer.allocated = (nk_size)*length;
../lib/public/nuklear.h:24263:    text_edit->string.buffer.memory.size = NK_MAX_NUMBER_BUFFER;
../lib/public/nuklear.h:24264:    text_edit->string.buffer.memory.ptr = dst;
../lib/public/nuklear.h:24265:    text_edit->string.buffer.size = NK_MAX_NUMBER_BUFFER;
../lib/public/nuklear.h:24266:    text_edit->mode = NK_TEXT_EDIT_MODE_INSERT;
../lib/public/nuklear.h:24268:        filters[filter], text_edit, &style->edit, (*state == NK_PROPERTY_EDIT) ? in: 0, font);
../lib/public/nuklear.h:24270:    *length = text_edit->string.len;
../lib/public/nuklear.h:24271:    *cursor = text_edit->cursor;
../lib/public/nuklear.h:24272:    *select_begin = text_edit->select_start;
../lib/public/nuklear.h:24273:    *select_end = text_edit->select_end;
../lib/public/nuklear.h:24274:    if (text_edit->active && nk_input_is_key_pressed(in, NK_KEY_ENTER))
../lib/public/nuklear.h:24275:        text_edit->active = nk_false;
../lib/public/nuklear.h:24277:    if (active && !text_edit->active) {
../lib/public/nuklear.h:24281:        switch (variant->kind) {
../lib/public/nuklear.h:24284:            variant->value.i = nk_strtoi(buffer, 0);
../lib/public/nuklear.h:24285:            variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i, variant->max_value.i);
../lib/public/nuklear.h:24289:            variant->value.f = nk_strtof(buffer, 0);
../lib/public/nuklear.h:24290:            variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f, variant->max_value.f);
../lib/public/nuklear.h:24294:            variant->value.d = nk_strtod(buffer, 0);
../lib/public/nuklear.h:24295:            variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d, variant->max_value.d);
../lib/public/nuklear.h:24363:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:24364:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:24365:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:24368:    win = ctx->current;
../lib/public/nuklear.h:24369:    layout = win->layout;
../lib/public/nuklear.h:24370:    style = &ctx->style;
../lib/public/nuklear.h:24376:        hash = nk_murmur_hash(name, (int)nk_strlen(name), win->property.seq++);
../lib/public/nuklear.h:24381:    if (win->property.active && hash == win->property.name) {
../lib/public/nuklear.h:24382:        buffer = win->property.buffer;
../lib/public/nuklear.h:24383:        len = &win->property.length;
../lib/public/nuklear.h:24384:        cursor = &win->property.cursor;
../lib/public/nuklear.h:24385:        state = &win->property.state;
../lib/public/nuklear.h:24386:        select_begin = &win->property.select_start;
../lib/public/nuklear.h:24387:        select_end = &win->property.select_end;
../lib/public/nuklear.h:24399:    ctx->text_edit.clip = ctx->clip;
../lib/public/nuklear.h:24400:    in = ((s == NK_WIDGET_ROM && !win->property.active) ||
../lib/public/nuklear.h:24401:        layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:24402:    nk_do_property(&ctx->last_widget_state, &win->buffer, bounds, name,
../lib/public/nuklear.h:24404:        select_end, &style->property, filter, in, style->font, &ctx->text_edit,
../lib/public/nuklear.h:24405:        ctx->button_behavior);
../lib/public/nuklear.h:24407:    if (in && *state != NK_PROPERTY_DEFAULT && !win->property.active) {
../lib/public/nuklear.h:24409:        win->property.active = 1;
../lib/public/nuklear.h:24410:        NK_MEMCPY(win->property.buffer, buffer, (nk_size)*len);
../lib/public/nuklear.h:24411:        win->property.length = *len;
../lib/public/nuklear.h:24412:        win->property.cursor = *cursor;
../lib/public/nuklear.h:24413:        win->property.state = *state;
../lib/public/nuklear.h:24414:        win->property.name = hash;
../lib/public/nuklear.h:24415:        win->property.select_start = *select_begin;
../lib/public/nuklear.h:24416:        win->property.select_end = *select_end;
../lib/public/nuklear.h:24418:            ctx->input.mouse.grab = nk_true;
../lib/public/nuklear.h:24419:            ctx->input.mouse.grabbed = nk_true;
../lib/public/nuklear.h:24425:            ctx->input.mouse.grab = nk_false;
../lib/public/nuklear.h:24426:            ctx->input.mouse.grabbed = nk_false;
../lib/public/nuklear.h:24427:            ctx->input.mouse.ungrab = nk_true;
../lib/public/nuklear.h:24429:        win->property.select_start = 0;
../lib/public/nuklear.h:24430:        win->property.select_end = 0;
../lib/public/nuklear.h:24431:        win->property.active = 0;
../lib/public/nuklear.h:24443:    if (!ctx || !ctx->current || !name || !val) return;
../lib/public/nuklear.h:24457:    if (!ctx || !ctx->current || !name || !val) return;
../lib/public/nuklear.h:24471:    if (!ctx || !ctx->current || !name || !val) return;
../lib/public/nuklear.h:24484:    if (!ctx || !ctx->current || !name) return val;
../lib/public/nuklear.h:24498:    if (!ctx || !ctx->current || !name) return val;
../lib/public/nuklear.h:24512:    if (!ctx || !ctx->current || !name) return val;
../lib/public/nuklear.h:24542:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:24543:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:24545:    if (!ctx || !ctx->current || !ctx->current->layout) return 0;
../lib/public/nuklear.h:24547:        chart = &ctx->current->layout->chart;
../lib/public/nuklear.h:24552:    win = ctx->current;
../lib/public/nuklear.h:24553:    config = &ctx->style;
../lib/public/nuklear.h:24554:    chart = &win->layout->chart;
../lib/public/nuklear.h:24555:    style = &config->chart;
../lib/public/nuklear.h:24559:    chart->x = bounds.x + style->padding.x;
../lib/public/nuklear.h:24560:    chart->y = bounds.y + style->padding.y;
../lib/public/nuklear.h:24561:    chart->w = bounds.w - 2 * style->padding.x;
../lib/public/nuklear.h:24562:    chart->h = bounds.h - 2 * style->padding.y;
../lib/public/nuklear.h:24563:    chart->w = NK_MAX(chart->w, 2 * style->padding.x);
../lib/public/nuklear.h:24564:    chart->h = NK_MAX(chart->h, 2 * style->padding.y);
../lib/public/nuklear.h:24567:    {struct nk_chart_slot *slot = &chart->slots[chart->slot++];
../lib/public/nuklear.h:24568:    slot->type = type;
../lib/public/nuklear.h:24569:    slot->count = count;
../lib/public/nuklear.h:24570:    slot->color = color;
../lib/public/nuklear.h:24571:    slot->highlight = highlight;
../lib/public/nuklear.h:24572:    slot->min = NK_MIN(min_value, max_value);
../lib/public/nuklear.h:24573:    slot->max = NK_MAX(min_value, max_value);
../lib/public/nuklear.h:24574:    slot->range = slot->max - slot->min;}
../lib/public/nuklear.h:24577:    background = &style->background;
../lib/public/nuklear.h:24578:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:24579:        nk_draw_image(&win->buffer, bounds, &background->data.image, nk_white);
../lib/public/nuklear.h:24580:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:24581:        nk_draw_texpath(&win->buffer, bounds, background->data.texpath, nk_white);
../lib/public/nuklear.h:24583:        nk_fill_rect(&win->buffer, bounds, style->rounding, style->border_color);
../lib/public/nuklear.h:24584:        nk_fill_rect(&win->buffer, nk_shrink_rect(bounds, style->border),
../lib/public/nuklear.h:24585:            style->rounding, style->background.data.color);
../lib/public/nuklear.h:24593:    return nk_chart_begin_colored(ctx, type, ctx->style.chart.color,
../lib/public/nuklear.h:24594:                ctx->style.chart.selected_color, count, min_value, max_value);
../lib/public/nuklear.h:24602:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:24603:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:24604:    NK_ASSERT(ctx->current->layout->chart.slot < NK_CHART_MAX_SLOT);
../lib/public/nuklear.h:24605:    if (!ctx || !ctx->current || !ctx->current->layout) return;
../lib/public/nuklear.h:24606:    if (ctx->current->layout->chart.slot >= NK_CHART_MAX_SLOT) return;
../lib/public/nuklear.h:24609:    {struct nk_chart *chart = &ctx->current->layout->chart;
../lib/public/nuklear.h:24610:    struct nk_chart_slot *slot = &chart->slots[chart->slot++];
../lib/public/nuklear.h:24611:    slot->type = type;
../lib/public/nuklear.h:24612:    slot->count = count;
../lib/public/nuklear.h:24613:    slot->color = color;
../lib/public/nuklear.h:24614:    slot->highlight = highlight;
../lib/public/nuklear.h:24615:    slot->min = NK_MIN(min_value, max_value);
../lib/public/nuklear.h:24616:    slot->max = NK_MAX(min_value, max_value);
../lib/public/nuklear.h:24617:    slot->range = slot->max - slot->min;}
../lib/public/nuklear.h:24623:    nk_chart_add_slot_colored(ctx, type, ctx->style.chart.color,
../lib/public/nuklear.h:24624:        ctx->style.chart.selected_color, count, min_value, max_value);
../lib/public/nuklear.h:24630:    struct nk_panel *layout = win->layout;
../lib/public/nuklear.h:24631:    const struct nk_input *i = &ctx->input;
../lib/public/nuklear.h:24632:    struct nk_command_buffer *out = &win->buffer;
../lib/public/nuklear.h:24643:    step = g->w / (float)g->slots[slot].count;
../lib/public/nuklear.h:24644:    range = g->slots[slot].max - g->slots[slot].min;
../lib/public/nuklear.h:24645:    ratio = (value - g->slots[slot].min) / range;
../lib/public/nuklear.h:24647:    if (g->slots[slot].index == 0) {
../lib/public/nuklear.h:24649:        g->slots[slot].last.x = g->x;
../lib/public/nuklear.h:24650:        g->slots[slot].last.y = (g->y + g->h) - ratio * (float)g->h;
../lib/public/nuklear.h:24652:        bounds.x = g->slots[slot].last.x - 2;
../lib/public/nuklear.h:24653:        bounds.y = g->slots[slot].last.y - 2;
../lib/public/nuklear.h:24656:        color = g->slots[slot].color;
../lib/public/nuklear.h:24657:        if (!(layout->flags & NK_WINDOW_ROM) &&
../lib/public/nuklear.h:24658:            NK_INBOX(i->mouse.pos.x,i->mouse.pos.y, g->slots[slot].last.x-3, g->slots[slot].last.y-3, 6, 6)){
../lib/public/nuklear.h:24660:            ret |= (i->mouse.buttons[NK_BUTTON_LEFT].down &&
../lib/public/nuklear.h:24661:                i->mouse.buttons[NK_BUTTON_LEFT].clicked) ? NK_CHART_CLICKED: 0;
../lib/public/nuklear.h:24662:            color = g->slots[slot].highlight;
../lib/public/nuklear.h:24665:        g->slots[slot].index += 1;
../lib/public/nuklear.h:24670:    color = g->slots[slot].color;
../lib/public/nuklear.h:24671:    cur.x = g->x + (float)(step * (float)g->slots[slot].index);
../lib/public/nuklear.h:24672:    cur.y = (g->y + g->h) - (ratio * (float)g->h);
../lib/public/nuklear.h:24673:    nk_stroke_line(out, g->slots[slot].last.x, g->slots[slot].last.y, cur.x, cur.y, 1.0f, color);
../lib/public/nuklear.h:24675:    bounds.x = cur.x - 3;
../lib/public/nuklear.h:24676:    bounds.y = cur.y - 3;
../lib/public/nuklear.h:24680:    if (!(layout->flags & NK_WINDOW_ROM)) {
../lib/public/nuklear.h:24683:            ret |= (!i->mouse.buttons[NK_BUTTON_LEFT].down &&
../lib/public/nuklear.h:24684:                i->mouse.buttons[NK_BUTTON_LEFT].clicked) ? NK_CHART_CLICKED: 0;
../lib/public/nuklear.h:24685:            color = g->slots[slot].highlight;
../lib/public/nuklear.h:24688:    nk_fill_rect(out, nk_rect(cur.x - 2, cur.y - 2, 4, 4), 0, color);
../lib/public/nuklear.h:24691:    g->slots[slot].last.x = cur.x;
../lib/public/nuklear.h:24692:    g->slots[slot].last.y = cur.y;
../lib/public/nuklear.h:24693:    g->slots[slot].index  += 1;
../lib/public/nuklear.h:24700:    struct nk_command_buffer *out = &win->buffer;
../lib/public/nuklear.h:24701:    const struct nk_input *in = &ctx->input;
../lib/public/nuklear.h:24702:    struct nk_panel *layout = win->layout;
../lib/public/nuklear.h:24710:    if (chart->slots[slot].index  >= chart->slots[slot].count)
../lib/public/nuklear.h:24712:    if (chart->slots[slot].count) {
../lib/public/nuklear.h:24713:        float padding = (float)(chart->slots[slot].count-1);
../lib/public/nuklear.h:24714:        item.w = (chart->w - padding) / (float)(chart->slots[slot].count);
../lib/public/nuklear.h:24718:    color = chart->slots[slot].color;;
../lib/public/nuklear.h:24719:    item.h = chart->h * NK_ABS((value/chart->slots[slot].range));
../lib/public/nuklear.h:24721:        ratio = (value + NK_ABS(chart->slots[slot].min)) / NK_ABS(chart->slots[slot].range);
../lib/public/nuklear.h:24722:        item.y = (chart->y + chart->h) - chart->h * ratio;
../lib/public/nuklear.h:24724:        ratio = (value - chart->slots[slot].max) / chart->slots[slot].range;
../lib/public/nuklear.h:24725:        item.y = chart->y + (chart->h * NK_ABS(ratio)) - item.h;
../lib/public/nuklear.h:24727:    item.x = chart->x + ((float)chart->slots[slot].index * item.w);
../lib/public/nuklear.h:24728:    item.x = item.x + ((float)chart->slots[slot].index);
../lib/public/nuklear.h:24731:    if (!(layout->flags & NK_WINDOW_ROM) &&
../lib/public/nuklear.h:24732:        NK_INBOX(in->mouse.pos.x,in->mouse.pos.y,item.x,item.y,item.w,item.h)) {
../lib/public/nuklear.h:24734:        ret |= (!in->mouse.buttons[NK_BUTTON_LEFT].down &&
../lib/public/nuklear.h:24735:                in->mouse.buttons[NK_BUTTON_LEFT].clicked) ? NK_CHART_CLICKED: 0;
../lib/public/nuklear.h:24736:        color = chart->slots[slot].highlight;
../lib/public/nuklear.h:24739:    chart->slots[slot].index += 1;
../lib/public/nuklear.h:24749:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:24751:    NK_ASSERT(slot < ctx->current->layout->chart.slot);
../lib/public/nuklear.h:24752:    if (!ctx || !ctx->current || slot >= NK_CHART_MAX_SLOT) return nk_false;
../lib/public/nuklear.h:24753:    if (slot >= ctx->current->layout->chart.slot) return nk_false;
../lib/public/nuklear.h:24755:    win = ctx->current;
../lib/public/nuklear.h:24756:    if (win->layout->chart.slot < slot) return nk_false;
../lib/public/nuklear.h:24757:    switch (win->layout->chart.slots[slot].type) {
../lib/public/nuklear.h:24759:        flags = nk_chart_push_line(ctx, win, &win->layout->chart, value, slot); break;
../lib/public/nuklear.h:24761:        flags = nk_chart_push_column(ctx, win, &win->layout->chart, value, slot); break;
../lib/public/nuklear.h:24780:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:24781:    if (!ctx || !ctx->current)
../lib/public/nuklear.h:24784:    win = ctx->current;
../lib/public/nuklear.h:24785:    chart = &win->layout->chart;
../lib/public/nuklear.h:24867:        hsva[1] = NK_SATURATE((in->mouse.pos.x - matrix->x) / (matrix->w-1));
../lib/public/nuklear.h:24868:        hsva[2] = 1.0f - NK_SATURATE((in->mouse.pos.y - matrix->y) / (matrix->h-1));
../lib/public/nuklear.h:24873:        hsva[0] = NK_SATURATE((in->mouse.pos.y - hue_bar->y) / (hue_bar->h-1));
../lib/public/nuklear.h:24879:            hsva[3] = 1.0f - NK_SATURATE((in->mouse.pos.y - alpha_bar->y) / (alpha_bar->h-1));
../lib/public/nuklear.h:24889:        color->a = hsva[3];
../lib/public/nuklear.h:24928:            nk_rect(hue_bar->x, hue_bar->y + (float)i * (hue_bar->h/6.0f) + 0.5f,
../lib/public/nuklear.h:24929:                hue_bar->w, (hue_bar->h/6.0f) + 0.5f), hue_colors[i], hue_colors[i],
../lib/public/nuklear.h:24932:    line_y = (float)(int)(hue_bar->y + hsva[0] * matrix->h + 0.5f);
../lib/public/nuklear.h:24933:    nk_stroke_line(o, hue_bar->x-1, line_y, hue_bar->x + hue_bar->w + 2,
../lib/public/nuklear.h:24939:        line_y = (float)(int)(alpha_bar->y +  (1.0f - alpha) * matrix->h + 0.5f);
../lib/public/nuklear.h:24942:        nk_stroke_line(o, alpha_bar->x-1, line_y, alpha_bar->x + alpha_bar->w + 2,
../lib/public/nuklear.h:24951:    /* draw cross-hair */
../lib/public/nuklear.h:24953:    p.x = (float)(int)(matrix->x + S * matrix->w);
../lib/public/nuklear.h:24954:    p.y = (float)(int)(matrix->y + (1.0f - V) * matrix->h);
../lib/public/nuklear.h:24955:    nk_stroke_line(o, p.x - crosshair_size, p.y, p.x-2, p.y, 1.0f, white);
../lib/public/nuklear.h:24958:    nk_stroke_line(o, p.x, p.y - crosshair_size, p.x, p.y-2, 1.0f, white);}
../lib/public/nuklear.h:24980:    bar_w = font->height;
../lib/public/nuklear.h:24983:    bounds.w -= 2 * padding.x;
../lib/public/nuklear.h:24984:    bounds.h -= 2 * padding.y;
../lib/public/nuklear.h:24989:    matrix.w = bounds.w - (3 * padding.x + 2 * bar_w);
../lib/public/nuklear.h:25020:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25021:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25022:    if (!ctx || !ctx->current || !ctx->current->layout || !color)
../lib/public/nuklear.h:25025:    win = ctx->current;
../lib/public/nuklear.h:25026:    config = &ctx->style;
../lib/public/nuklear.h:25027:    layout = win->layout;
../lib/public/nuklear.h:25030:    in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
../lib/public/nuklear.h:25031:    return nk_do_color_picker(&ctx->last_widget_state, &win->buffer, color, fmt, bounds,
../lib/public/nuklear.h:25032:                nk_vec2(0,0), in, config->font);
../lib/public/nuklear.h:25062:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25063:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25064:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25067:    popup = win->popup.win;
../lib/public/nuklear.h:25070:    body.y = header.y + header.h-ctx->style.window.combo_border;
../lib/public/nuklear.h:25073:    hash = win->popup.combo_count++;
../lib/public/nuklear.h:25075:    is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_COMBO);
../lib/public/nuklear.h:25081:    win->popup.type = NK_PANEL_COMBO;
../lib/public/nuklear.h:25082:    win->popup.name = hash;
../lib/public/nuklear.h:25101:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25102:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25103:    if (!ctx || !ctx->current || !ctx->current->layout || !selected)
../lib/public/nuklear.h:25106:    win = ctx->current;
../lib/public/nuklear.h:25107:    style = &ctx->style;
../lib/public/nuklear.h:25112:    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
../lib/public/nuklear.h:25113:    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
../lib/public/nuklear.h:25117:    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
../lib/public/nuklear.h:25118:        background = &style->combo.active;
../lib/public/nuklear.h:25119:        text.text = style->combo.label_active;
../lib/public/nuklear.h:25120:    } else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
../lib/public/nuklear.h:25121:        background = &style->combo.hover;
../lib/public/nuklear.h:25122:        text.text = style->combo.label_hover;
../lib/public/nuklear.h:25124:        background = &style->combo.normal;
../lib/public/nuklear.h:25125:        text.text = style->combo.label_normal;
../lib/public/nuklear.h:25127:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:25129:        nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
../lib/public/nuklear.h:25130:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:25132:        nk_draw_texpath(&win->buffer, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:25134:        text.background = background->data.color;
../lib/public/nuklear.h:25135:        nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
../lib/public/nuklear.h:25136:        nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
../lib/public/nuklear.h:25145:        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25146:            sym = style->combo.sym_hover;
../lib/public/nuklear.h:25148:            sym = style->combo.sym_active;
../lib/public/nuklear.h:25149:        else sym = style->combo.sym_normal;
../lib/public/nuklear.h:25152:        button.w = header.h - 2 * style->combo.button_padding.y;
../lib/public/nuklear.h:25153:        button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
../lib/public/nuklear.h:25154:        button.y = header.y + style->combo.button_padding.y;
../lib/public/nuklear.h:25157:        content.x = button.x + style->combo.button.padding.x;
../lib/public/nuklear.h:25158:        content.y = button.y + style->combo.button.padding.y;
../lib/public/nuklear.h:25159:        content.w = button.w - 2 * style->combo.button.padding.x;
../lib/public/nuklear.h:25160:        content.h = button.h - 2 * style->combo.button.padding.y;
../lib/public/nuklear.h:25164:        label.x = header.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25165:        label.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25166:        label.w = button.x - (style->combo.content_padding.x + style->combo.spacing.x) - label.x;;
../lib/public/nuklear.h:25167:        label.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25168:        nk_widget_text(&win->buffer, label, selected, len, &text,
../lib/public/nuklear.h:25169:            NK_TEXT_LEFT, ctx->style.font);
../lib/public/nuklear.h:25172:        nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state,
../lib/public/nuklear.h:25173:            &ctx->style.combo.button, sym, style->font);
../lib/public/nuklear.h:25195:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25196:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25197:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25200:    win = ctx->current;
../lib/public/nuklear.h:25201:    style = &ctx->style;
../lib/public/nuklear.h:25206:    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
../lib/public/nuklear.h:25207:    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
../lib/public/nuklear.h:25211:    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED)
../lib/public/nuklear.h:25212:        background = &style->combo.active;
../lib/public/nuklear.h:25213:    else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25214:        background = &style->combo.hover;
../lib/public/nuklear.h:25215:    else background = &style->combo.normal;
../lib/public/nuklear.h:25217:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:25218:        nk_draw_image(&win->buffer, header, &background->data.image,nk_white);
../lib/public/nuklear.h:25219:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:25220:        nk_draw_texpath(&win->buffer, header, background->data.texpath ,nk_white);
../lib/public/nuklear.h:25222:        nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
../lib/public/nuklear.h:25223:        nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
../lib/public/nuklear.h:25231:        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25232:            sym = style->combo.sym_hover;
../lib/public/nuklear.h:25234:            sym = style->combo.sym_active;
../lib/public/nuklear.h:25235:        else sym = style->combo.sym_normal;
../lib/public/nuklear.h:25238:        button.w = header.h - 2 * style->combo.button_padding.y;
../lib/public/nuklear.h:25239:        button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
../lib/public/nuklear.h:25240:        button.y = header.y + style->combo.button_padding.y;
../lib/public/nuklear.h:25243:        content.x = button.x + style->combo.button.padding.x;
../lib/public/nuklear.h:25244:        content.y = button.y + style->combo.button.padding.y;
../lib/public/nuklear.h:25245:        content.w = button.w - 2 * style->combo.button.padding.x;
../lib/public/nuklear.h:25246:        content.h = button.h - 2 * style->combo.button.padding.y;
../lib/public/nuklear.h:25249:        bounds.h = header.h - 4 * style->combo.content_padding.y;
../lib/public/nuklear.h:25250:        bounds.y = header.y + 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25251:        bounds.x = header.x + 2 * style->combo.content_padding.x;
../lib/public/nuklear.h:25252:        bounds.w = (button.x - (style->combo.content_padding.x + style->combo.spacing.x)) - bounds.x;
../lib/public/nuklear.h:25253:        nk_fill_rect(&win->buffer, bounds, 0, color);
../lib/public/nuklear.h:25256:        nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state,
../lib/public/nuklear.h:25257:            &ctx->style.combo.button, sym, style->font);
../lib/public/nuklear.h:25276:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25277:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25278:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25281:    win = ctx->current;
../lib/public/nuklear.h:25282:    style = &ctx->style;
../lib/public/nuklear.h:25287:    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
../lib/public/nuklear.h:25288:    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
../lib/public/nuklear.h:25292:    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
../lib/public/nuklear.h:25293:        background = &style->combo.active;
../lib/public/nuklear.h:25294:        symbol_color = style->combo.symbol_active;
../lib/public/nuklear.h:25295:    } else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
../lib/public/nuklear.h:25296:        background = &style->combo.hover;
../lib/public/nuklear.h:25297:        symbol_color = style->combo.symbol_hover;
../lib/public/nuklear.h:25299:        background = &style->combo.normal;
../lib/public/nuklear.h:25300:        symbol_color = style->combo.symbol_hover;
../lib/public/nuklear.h:25303:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:25305:        nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
../lib/public/nuklear.h:25306:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:25308:        nk_draw_texpath(&win->buffer, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:25310:        sym_background = background->data.color;
../lib/public/nuklear.h:25311:        nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
../lib/public/nuklear.h:25312:        nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
../lib/public/nuklear.h:25320:        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25321:            sym = style->combo.sym_hover;
../lib/public/nuklear.h:25323:            sym = style->combo.sym_active;
../lib/public/nuklear.h:25324:        else sym = style->combo.sym_normal;
../lib/public/nuklear.h:25327:        button.w = header.h - 2 * style->combo.button_padding.y;
../lib/public/nuklear.h:25328:        button.x = (header.x + header.w - header.h) - style->combo.button_padding.y;
../lib/public/nuklear.h:25329:        button.y = header.y + style->combo.button_padding.y;
../lib/public/nuklear.h:25332:        content.x = button.x + style->combo.button.padding.x;
../lib/public/nuklear.h:25333:        content.y = button.y + style->combo.button.padding.y;
../lib/public/nuklear.h:25334:        content.w = button.w - 2 * style->combo.button.padding.x;
../lib/public/nuklear.h:25335:        content.h = button.h - 2 * style->combo.button.padding.y;
../lib/public/nuklear.h:25338:        bounds.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25339:        bounds.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25340:        bounds.x = header.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25341:        bounds.w = (button.x - style->combo.content_padding.y) - bounds.x;
../lib/public/nuklear.h:25342:        nk_draw_symbol(&win->buffer, symbol, bounds, sym_background, symbol_color,
../lib/public/nuklear.h:25343:            1.0f, style->font);
../lib/public/nuklear.h:25346:        nk_draw_button_symbol(&win->buffer, &bounds, &content, ctx->last_widget_state,
../lib/public/nuklear.h:25347:            &ctx->style.combo.button, sym, style->font);
../lib/public/nuklear.h:25367:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25368:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25369:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25372:    win = ctx->current;
../lib/public/nuklear.h:25373:    style = &ctx->style;
../lib/public/nuklear.h:25377:    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
../lib/public/nuklear.h:25378:    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
../lib/public/nuklear.h:25382:    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
../lib/public/nuklear.h:25383:        background = &style->combo.active;
../lib/public/nuklear.h:25384:        symbol_color = style->combo.symbol_active;
../lib/public/nuklear.h:25385:        text.text = style->combo.label_active;
../lib/public/nuklear.h:25386:    } else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
../lib/public/nuklear.h:25387:        background = &style->combo.hover;
../lib/public/nuklear.h:25388:        symbol_color = style->combo.symbol_hover;
../lib/public/nuklear.h:25389:        text.text = style->combo.label_hover;
../lib/public/nuklear.h:25391:        background = &style->combo.normal;
../lib/public/nuklear.h:25392:        symbol_color = style->combo.symbol_normal;
../lib/public/nuklear.h:25393:        text.text = style->combo.label_normal;
../lib/public/nuklear.h:25395:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:25397:        nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
../lib/public/nuklear.h:25398:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:25400:        nk_draw_texpath(&win->buffer, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:25402:        text.background = background->data.color;
../lib/public/nuklear.h:25403:        nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
../lib/public/nuklear.h:25404:        nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
../lib/public/nuklear.h:25413:        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25414:            sym = style->combo.sym_hover;
../lib/public/nuklear.h:25416:            sym = style->combo.sym_active;
../lib/public/nuklear.h:25417:        else sym = style->combo.sym_normal;
../lib/public/nuklear.h:25420:        button.w = header.h - 2 * style->combo.button_padding.y;
../lib/public/nuklear.h:25421:        button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
../lib/public/nuklear.h:25422:        button.y = header.y + style->combo.button_padding.y;
../lib/public/nuklear.h:25425:        content.x = button.x + style->combo.button.padding.x;
../lib/public/nuklear.h:25426:        content.y = button.y + style->combo.button.padding.y;
../lib/public/nuklear.h:25427:        content.w = button.w - 2 * style->combo.button.padding.x;
../lib/public/nuklear.h:25428:        content.h = button.h - 2 * style->combo.button.padding.y;
../lib/public/nuklear.h:25429:        nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state,
../lib/public/nuklear.h:25430:            &ctx->style.combo.button, sym, style->font);
../lib/public/nuklear.h:25433:        image.x = header.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25434:        image.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25435:        image.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25437:        nk_draw_symbol(&win->buffer, symbol, image, text.background, symbol_color,
../lib/public/nuklear.h:25438:            1.0f, style->font);
../lib/public/nuklear.h:25442:        label.x = image.x + image.w + style->combo.spacing.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25443:        label.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25444:        label.w = (button.x - style->combo.content_padding.x) - label.x;
../lib/public/nuklear.h:25445:        label.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25446:        nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, style->font);
../lib/public/nuklear.h:25463:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25464:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25465:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25468:    win = ctx->current;
../lib/public/nuklear.h:25469:    style = &ctx->style;
../lib/public/nuklear.h:25474:    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
../lib/public/nuklear.h:25475:    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
../lib/public/nuklear.h:25479:    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED)
../lib/public/nuklear.h:25480:        background = &style->combo.active;
../lib/public/nuklear.h:25481:    else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25482:        background = &style->combo.hover;
../lib/public/nuklear.h:25483:    else background = &style->combo.normal;
../lib/public/nuklear.h:25485:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:25486:        nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
../lib/public/nuklear.h:25487:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:25488:        nk_draw_texpath(&win->buffer, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:25490:        nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
../lib/public/nuklear.h:25491:        nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
../lib/public/nuklear.h:25499:        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25500:            sym = style->combo.sym_hover;
../lib/public/nuklear.h:25502:            sym = style->combo.sym_active;
../lib/public/nuklear.h:25503:        else sym = style->combo.sym_normal;
../lib/public/nuklear.h:25506:        button.w = header.h - 2 * style->combo.button_padding.y;
../lib/public/nuklear.h:25507:        button.x = (header.x + header.w - header.h) - style->combo.button_padding.y;
../lib/public/nuklear.h:25508:        button.y = header.y + style->combo.button_padding.y;
../lib/public/nuklear.h:25511:        content.x = button.x + style->combo.button.padding.x;
../lib/public/nuklear.h:25512:        content.y = button.y + style->combo.button.padding.y;
../lib/public/nuklear.h:25513:        content.w = button.w - 2 * style->combo.button.padding.x;
../lib/public/nuklear.h:25514:        content.h = button.h - 2 * style->combo.button.padding.y;
../lib/public/nuklear.h:25517:        bounds.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25518:        bounds.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25519:        bounds.x = header.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25520:        bounds.w = (button.x - style->combo.content_padding.y) - bounds.x;
../lib/public/nuklear.h:25521:        nk_draw_image(&win->buffer, bounds, &img, nk_white);
../lib/public/nuklear.h:25524:        nk_draw_button_symbol(&win->buffer, &bounds, &content, ctx->last_widget_state,
../lib/public/nuklear.h:25525:            &ctx->style.combo.button, sym, style->font);
../lib/public/nuklear.h:25544:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25545:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25546:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25549:    win = ctx->current;
../lib/public/nuklear.h:25550:    style = &ctx->style;
../lib/public/nuklear.h:25554:    in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM)? 0: &ctx->input;
../lib/public/nuklear.h:25555:    if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
../lib/public/nuklear.h:25559:    if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
../lib/public/nuklear.h:25560:        background = &style->combo.active;
../lib/public/nuklear.h:25561:        text.text = style->combo.label_active;
../lib/public/nuklear.h:25562:    } else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
../lib/public/nuklear.h:25563:        background = &style->combo.hover;
../lib/public/nuklear.h:25564:        text.text = style->combo.label_hover;
../lib/public/nuklear.h:25566:        background = &style->combo.normal;
../lib/public/nuklear.h:25567:        text.text = style->combo.label_normal;
../lib/public/nuklear.h:25569:    if (background->type == NK_STYLE_ITEM_IMAGE) {
../lib/public/nuklear.h:25571:        nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
../lib/public/nuklear.h:25572:    } else if (background->type == NK_STYLE_ITEM_TEXPATH) {
../lib/public/nuklear.h:25574:        nk_draw_texpath(&win->buffer, header, background->data.texpath, nk_white);
../lib/public/nuklear.h:25576:        text.background = background->data.color;
../lib/public/nuklear.h:25577:        nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
../lib/public/nuklear.h:25578:        nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
../lib/public/nuklear.h:25587:        if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
../lib/public/nuklear.h:25588:            sym = style->combo.sym_hover;
../lib/public/nuklear.h:25590:            sym = style->combo.sym_active;
../lib/public/nuklear.h:25591:        else sym = style->combo.sym_normal;
../lib/public/nuklear.h:25594:        button.w = header.h - 2 * style->combo.button_padding.y;
../lib/public/nuklear.h:25595:        button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
../lib/public/nuklear.h:25596:        button.y = header.y + style->combo.button_padding.y;
../lib/public/nuklear.h:25599:        content.x = button.x + style->combo.button.padding.x;
../lib/public/nuklear.h:25600:        content.y = button.y + style->combo.button.padding.y;
../lib/public/nuklear.h:25601:        content.w = button.w - 2 * style->combo.button.padding.x;
../lib/public/nuklear.h:25602:        content.h = button.h - 2 * style->combo.button.padding.y;
../lib/public/nuklear.h:25603:        nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state,
../lib/public/nuklear.h:25604:            &ctx->style.combo.button, sym, style->font);
../lib/public/nuklear.h:25607:        image.x = header.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25608:        image.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25609:        image.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25611:        nk_draw_image(&win->buffer, image, &img, nk_white);
../lib/public/nuklear.h:25615:        label.x = image.x + image.w + style->combo.spacing.x + style->combo.content_padding.x;
../lib/public/nuklear.h:25616:        label.y = header.y + style->combo.content_padding.y;
../lib/public/nuklear.h:25617:        label.w = (button.x - style->combo.content_padding.x) - label.x;
../lib/public/nuklear.h:25618:        label.h = header.h - 2 * style->combo.content_padding.y;
../lib/public/nuklear.h:25619:        nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, style->font);
../lib/public/nuklear.h:25688:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25692:    item_spacing = ctx->style.window.spacing;
../lib/public/nuklear.h:25693:    window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
../lib/public/nuklear.h:25725:    item_spacing = ctx->style.window.spacing;
../lib/public/nuklear.h:25726:    window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
../lib/public/nuklear.h:25736:        length = (int)(iter - current_item);
../lib/public/nuklear.h:25747:            length = (int)(iter - current_item);
../lib/public/nuklear.h:25778:    item_spacing = ctx->style.window.spacing;
../lib/public/nuklear.h:25779:    window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
../lib/public/nuklear.h:25841:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25842:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25843:    if (!ctx || !ctx->current || !ctx->current->layout)
../lib/public/nuklear.h:25847:    win = ctx->current;
../lib/public/nuklear.h:25848:    in = &ctx->input;
../lib/public/nuklear.h:25849:    if (win->popup.win && (win->popup.type & NK_PANEL_SET_NONBLOCK))
../lib/public/nuklear.h:25854:    x = nk_ifloorf(in->mouse.pos.x + 1) - (int)win->layout->clip.x;
../lib/public/nuklear.h:25855:    y = nk_ifloorf(in->mouse.pos.y + 1) - (int)win->layout->clip.y;
../lib/public/nuklear.h:25864:    if (ret) win->layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
../lib/public/nuklear.h:25865:    win->popup.type = NK_PANEL_TOOLTIP;
../lib/public/nuklear.h:25866:    ctx->current->layout->type = NK_PANEL_TOOLTIP;
../lib/public/nuklear.h:25874:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25875:    if (!ctx || !ctx->current) return;
../lib/public/nuklear.h:25876:    ctx->current->seq--;
../lib/public/nuklear.h:25892:    NK_ASSERT(ctx->current);
../lib/public/nuklear.h:25893:    NK_ASSERT(ctx->current->layout);
../lib/public/nuklear.h:25895:    if (!ctx || !ctx->current || !ctx->current->layout || !text)
../lib/public/nuklear.h:25899:    style = &ctx->style;
../lib/public/nuklear.h:25900:    padding = style->window.padding;
../lib/public/nuklear.h:25901:    spacing = style->window.spacing;
../lib/public/nuklear.h:25905:    text_width = style->font->width(style->font->userdata,
../lib/public/nuklear.h:25906:                    style->font->height, text, text_len);
../lib/public/nuklear.h:25907:    text_width += (4 * padding.x + spacing.x + 4 * style->window.tooltip_padding.x);
../lib/public/nuklear.h:25908:    text_height = (style->font->height + 2 * padding.y);
../lib/public/nuklear.h:25942:///    ------------------------------------------------------------------------------
../lib/public/nuklear.h:25943:///    This software is available under 2 licenses -- choose whichever you prefer.
../lib/public/nuklear.h:25944:///    ------------------------------------------------------------------------------
../lib/public/nuklear.h:25945:///    ALTERNATIVE A - MIT License
../lib/public/nuklear.h:25946:///    Copyright (c) 2016-2018 Micha Mettke
../lib/public/nuklear.h:25962:///    ------------------------------------------------------------------------------
../lib/public/nuklear.h:25963:///    ALTERNATIVE B - Public Domain (www.unlicense.org)
../lib/public/nuklear.h:25967:///    commercial or non-commercial, and by any means.
../lib/public/nuklear.h:25980:///    ------------------------------------------------------------------------------
../lib/public/nuklear.h:25985:/// [date][x.yy.zz]-[description]
../lib/public/nuklear.h:25986:/// -[date]: date on which the change has been pushed
../lib/public/nuklear.h:25987:/// -[x.yy.zz]: Numerical version string representation. Each version number on the right
../lib/public/nuklear.h:25989:///    - [x]: Major version with API and library breaking changes
../lib/public/nuklear.h:25990:///    - [yy]: Minor version with non-breaking API and library changes
../lib/public/nuklear.h:25991:///    - [zz]: Bug fix version with no direct changes to API
../lib/public/nuklear.h:25993:/// - 2018/10/31 (4.00.2) - Added NK_KEYSTATE_BASED_INPUT to "fix" state based backends
../lib/public/nuklear.h:25995:/// - 2018/04/01 (4.00.1) - Fixed calling `nk_convert` multiple time per single frame
../lib/public/nuklear.h:25996:/// - 2018/04/01 (4.00.0) - BREAKING CHANGE: nk_draw_list_clear no longer tries to
../lib/public/nuklear.h:25999:/// - 2018/02/23 (3.00.6) - Fixed slider dragging behavior
../lib/public/nuklear.h:26000:/// - 2018/01/31 (3.00.5) - Fixed overcalculation of cursor data in font baking process
../lib/public/nuklear.h:26001:/// - 2018/01/31 (3.00.4) - Removed name collision with stb_truetype
../lib/public/nuklear.h:26002:/// - 2018/01/28 (3.00.3) - Fixed panel window border drawing bug
../lib/public/nuklear.h:26003:/// - 2018/01/12 (3.00.2) - Added `nk_group_begin_titled` for separed group identifier and title
../lib/public/nuklear.h:26004:/// - 2018/01/07 (3.00.1) - Started to change documentation style
../lib/public/nuklear.h:26005:/// - 2018/01/05 (3.00.0) - BREAKING CHANGE: The previous color picker API was broken
../lib/public/nuklear.h:26011:/// - 2017/12/23 (2.00.7) - Fixed small warning
../lib/public/nuklear.h:26012:/// - 2017/12/23 (2.00.7) - Fixed nk_edit_buffer behavior if activated to allow input
../lib/public/nuklear.h:26013:/// - 2017/12/23 (2.00.7) - Fixed modifyable progressbar dragging visuals and input behavior
../lib/public/nuklear.h:26014:/// - 2017/12/04 (2.00.6) - Added formated string tooltip widget
../lib/public/nuklear.h:26015:/// - 2017/11/18 (2.00.5) - Fixed window becoming hidden with flag NK_WINDOW_NO_INPUT
../lib/public/nuklear.h:26016:/// - 2017/11/15 (2.00.4) - Fixed font merging
../lib/public/nuklear.h:26017:/// - 2017/11/07 (2.00.3) - Fixed window size and position modifier functions
../lib/public/nuklear.h:26018:/// - 2017/09/14 (2.00.2) - Fixed nk_edit_buffer and nk_edit_focus behavior
../lib/public/nuklear.h:26019:/// - 2017/09/14 (2.00.1) - Fixed window closing behavior
../lib/public/nuklear.h:26020:/// - 2017/09/14 (2.00.0) - BREAKING CHANGE: Modifing window position and size funtions now
../lib/public/nuklear.h:26023:/// - 2017/09/11 (1.40.9) - Fixed window background flag if background window is declared last
../lib/public/nuklear.h:26024:/// - 2017/08/27 (1.40.8) - Fixed `nk_item_is_any_active` for hidden windows
../lib/public/nuklear.h:26025:/// - 2017/08/27 (1.40.7) - Fixed window background flag
../lib/public/nuklear.h:26026:/// - 2017/07/07 (1.40.6) - Fixed missing clipping rect check for hovering/clicked
../lib/public/nuklear.h:26028:/// - 2017/07/07 (1.40.5) - Fixed drawing bug for vertex output for lines and stroked
../lib/public/nuklear.h:26030:/// - 2017/07/07 (1.40.4) - Fixed bug in nk_convert trying to add windows that are in
../lib/public/nuklear.h:26032:/// - 2017/07/07 (1.40.3) - Fixed table internal bug caused by storing table size in
../lib/public/nuklear.h:26034:/// - 2017/06/30 (1.40.2) - Removed unneeded semicolon in C++ NK_ALIGNOF macro
../lib/public/nuklear.h:26035:/// - 2017/06/30 (1.40.1) - Fixed drawing lines smaller or equal zero
../lib/public/nuklear.h:26036:/// - 2017/06/08 (1.40.0) - Removed the breaking part of last commit. Auto layout now only
../lib/public/nuklear.h:26038:/// - 2017/06/08 (1.40.0) - BREAKING CHANGE: while not directly API breaking it will change
../lib/public/nuklear.h:26043:/// - 2017/06/08 (1.39.1) - Fixed property text edit handling bug caused by past `nk_widget` fix
../lib/public/nuklear.h:26044:/// - 2017/06/08 (1.39.0) - Added function to retrieve window space without calling a nk_layout_xxx function
../lib/public/nuklear.h:26045:/// - 2017/06/06 (1.38.5) - Fixed `nk_convert` return flag for command buffer
../lib/public/nuklear.h:26046:/// - 2017/05/23 (1.38.4) - Fixed activation behavior for widgets partially clipped
../lib/public/nuklear.h:26047:/// - 2017/05/10 (1.38.3) - Fixed wrong min window size mouse scaling over boundries
../lib/public/nuklear.h:26048:/// - 2017/05/09 (1.38.2) - Fixed vertical scrollbar drawing with not enough space
../lib/public/nuklear.h:26049:/// - 2017/05/09 (1.38.1) - Fixed scaler dragging behavior if window size hits minimum size
../lib/public/nuklear.h:26050:/// - 2017/05/06 (1.38.0) - Added platform double-click support
../lib/public/nuklear.h:26051:/// - 2017/04/20 (1.37.1) - Fixed key repeat found inside glfw demo backends
../lib/public/nuklear.h:26052:/// - 2017/04/20 (1.37.0) - Extended properties with selection and clipbard support
../lib/public/nuklear.h:26053:/// - 2017/04/20 (1.36.2) - Fixed #405 overlapping rows with zero padding and spacing
../lib/public/nuklear.h:26054:/// - 2017/04/09 (1.36.1) - Fixed #403 with another widget float error
../lib/public/nuklear.h:26055:/// - 2017/04/09 (1.36.0) - Added window `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NOT_INTERACTIVE` flags
../lib/public/nuklear.h:26056:/// - 2017/04/09 (1.35.3) - Fixed buffer heap corruption
../lib/public/nuklear.h:26057:/// - 2017/03/25 (1.35.2) - Fixed popup overlapping for `NK_WINDOW_BACKGROUND` windows
../lib/public/nuklear.h:26058:/// - 2017/03/25 (1.35.1) - Fixed windows closing behavior
../lib/public/nuklear.h:26059:/// - 2017/03/18 (1.35.0) - Added horizontal scroll requested in #377
../lib/public/nuklear.h:26060:/// - 2017/03/18 (1.34.3) - Fixed long window header titles
../lib/public/nuklear.h:26061:/// - 2017/03/04 (1.34.2) - Fixed text edit filtering
../lib/public/nuklear.h:26062:/// - 2017/03/04 (1.34.1) - Fixed group closable flag
../lib/public/nuklear.h:26063:/// - 2017/02/25 (1.34.0) - Added custom draw command for better language binding support
../lib/public/nuklear.h:26064:/// - 2017/01/24 (1.33.0) - Added programatic way of remove edit focus
../lib/public/nuklear.h:26065:/// - 2017/01/24 (1.32.3) - Fixed wrong define for basic type definitions for windows
../lib/public/nuklear.h:26066:/// - 2017/01/21 (1.32.2) - Fixed input capture from hidden or closed windows
../lib/public/nuklear.h:26067:/// - 2017/01/21 (1.32.1) - Fixed slider behavior and drawing
../lib/public/nuklear.h:26068:/// - 2017/01/13 (1.32.0) - Added flag to put scaler into the bottom left corner
../lib/public/nuklear.h:26069:/// - 2017/01/13 (1.31.0) - Added additional row layouting method to combine both
../lib/public/nuklear.h:26071:/// - 2016/12/31 (1.30.0) - Extended scrollbar offset from 16-bit to 32-bit
../lib/public/nuklear.h:26072:/// - 2016/12/31 (1.29.2)- Fixed closing window bug of minimized windows
../lib/public/nuklear.h:26073:/// - 2016/12/03 (1.29.1)- Fixed wrapped text with no seperator and C89 error
../lib/public/nuklear.h:26074:/// - 2016/12/03 (1.29.0) - Changed text wrapping to process words not characters
../lib/public/nuklear.h:26075:/// - 2016/11/22 (1.28.6)- Fixed window minimized closing bug
../lib/public/nuklear.h:26076:/// - 2016/11/19 (1.28.5)- Fixed abstract combo box closing behavior
../lib/public/nuklear.h:26077:/// - 2016/11/19 (1.28.4)- Fixed tooltip flickering
../lib/public/nuklear.h:26078:/// - 2016/11/19 (1.28.3)- Fixed memory leak caused by popup repeated closing
../lib/public/nuklear.h:26079:/// - 2016/11/18 (1.28.2)- Fixed memory leak caused by popup panel allocation
../lib/public/nuklear.h:26080:/// - 2016/11/10 (1.28.1)- Fixed some warnings and C++ error
../lib/public/nuklear.h:26081:/// - 2016/11/10 (1.28.0)- Added additional `nk_button` versions which allows to directly
../lib/public/nuklear.h:26083:/// - 2016/11/10 (1.27.0)- Added additional 'nk_tree' versions to support external state
../lib/public/nuklear.h:26087:/// - 2016/11/09 (1.26.0)- Added additional `nk_group` version to support external scrollbar
../lib/public/nuklear.h:26094:/// - 2016/10/30 (1.25.1)- Fixed clipping rectangle bug inside `nk_draw_list`
../lib/public/nuklear.h:26095:/// - 2016/10/29 (1.25.0)- Pulled `nk_panel` memory management into nuklear and out of
../lib/public/nuklear.h:26099:/// - 2016/10/21 (1.24.0)- Changed widget border drawing to stroked rectangle from filled
../lib/public/nuklear.h:26101:/// - 2016/10/18 (1.23.0)- Added `nk_edit_focus` for manually edit widget focus control
../lib/public/nuklear.h:26102:/// - 2016/09/29 (1.22.7)- Fixed deduction of basic type in non `<stdint.h>` compilation
../lib/public/nuklear.h:26103:/// - 2016/09/29 (1.22.6)- Fixed edit widget UTF-8 text cursor drawing bug
../lib/public/nuklear.h:26104:/// - 2016/09/28 (1.22.5)- Fixed edit widget UTF-8 text appending/inserting/removing
../lib/public/nuklear.h:26105:/// - 2016/09/28 (1.22.4)- Fixed drawing bug inside edit widgets which offset all text
../lib/public/nuklear.h:26107:/// - 2016/09/28 (1.22.3)- Fixed small bug in edit widgets if not active. The wrong
../lib/public/nuklear.h:26110:/// - 2016/09/20 (1.22.2)- Fixed color button size calculation
../lib/public/nuklear.h:26111:/// - 2016/09/20 (1.22.1)- Fixed some `nk_vsnprintf` behavior bugs and removed
../lib/public/nuklear.h:26113:/// - 2016/09/18 (1.22.0)- C89 does not support vsnprintf only C99 and newer as well
../lib/public/nuklear.h:26120:/// - 2016/09/15 (1.21.2)- Fixed panel `close` behavior for deeper panel levels
../lib/public/nuklear.h:26121:/// - 2016/09/15 (1.21.1)- Fixed C++ errors and wrong argument to `nk_panel_get_xxxx`
../lib/public/nuklear.h:26122:/// - 2016/09/13 (1.21.0) - !BREAKING! Fixed nonblocking popup behavior in menu, combo,
../lib/public/nuklear.h:26123:///                        and contextual which prevented closing in y-direction if
../lib/public/nuklear.h:26127:/// - 2016/09/13 (1.20.3) - Cleaned up and extended type selection
../lib/public/nuklear.h:26128:/// - 2016/09/13 (1.20.2)- Fixed slider behavior hopefully for the last time. This time
../lib/public/nuklear.h:26130:/// - 2016/09/13 (1.20.1)- Internal change to divide window/panel flags into panel flags and types.
../lib/public/nuklear.h:26133:/// - 2016/09/08 (1.20.0)- Added additional helper function to make it easier to just
../lib/public/nuklear.h:26139:/// - 2016/09/08 (1.19.0)- Added additional asserts to make sure every `nk_xxx_begin` call
../lib/public/nuklear.h:26142:/// - 2016/09/08 (1.18.0)- Changed confusing name for `NK_SYMBOL_RECT_FILLED`, `NK_SYMBOL_RECT`
../lib/public/nuklear.h:26145:/// - 2016/09/08 (1.17.0)- Changed confusing name for `NK_SYMBOL_CIRLCE_FILLED`, `NK_SYMBOL_CIRCLE`
../lib/public/nuklear.h:26148:/// - 2016/09/08 (1.16.0)- Added additional checks to select correct types if `NK_INCLUDE_FIXED_TYPES`
../lib/public/nuklear.h:26150:/// - 2016/09/07 (1.15.3)- Fixed `NK_INCLUDE_COMMAND_USERDATA` define to not cause an error
../lib/public/nuklear.h:26151:/// - 2016/09/04 (1.15.2)- Fixed wrong combobox height calculation
../lib/public/nuklear.h:26152:/// - 2016/09/03 (1.15.1)- Fixed gaps inside combo boxes in OpenGL
../lib/public/nuklear.h:26153:/// - 2016/09/02 (1.15.0) - Changed nuklear to not have any default vertex layout and
../lib/public/nuklear.h:26157:/// - 2016/08/30 (1.14.2) - Removed unused variables
../lib/public/nuklear.h:26158:/// - 2016/08/30 (1.14.1) - Fixed C++ build errors
../lib/public/nuklear.h:26159:/// - 2016/08/30 (1.14.0) - Removed mouse dragging from SDL demo since it does not work correctly
../lib/public/nuklear.h:26160:/// - 2016/08/30 (1.13.4) - Tweaked some default styling variables
../lib/public/nuklear.h:26161:/// - 2016/08/30 (1.13.3) - Hopefully fixed drawing bug in slider, in general I would
../lib/public/nuklear.h:26163:/// - 2016/08/30 (1.13.2) - Fixed close and minimize button which would fire even if the
../lib/public/nuklear.h:26165:/// - 2016/08/30 (1.13.1) - Fixed popup panel padding handling which was previously just
../lib/public/nuklear.h:26167:/// - 2016/08/30 (1.13.0) - Removed `NK_WINDOW_DYNAMIC` flag from public API since
../lib/public/nuklear.h:26169:/// - 2016/08/30 (1.12.0) - Removed scaler size. The size of the scaler is now
../lib/public/nuklear.h:26171:/// - 2016/08/30 (1.11.2) - Fixed some drawing bugs caused by changes from 1.11
../lib/public/nuklear.h:26172:/// - 2016/08/30 (1.11.1) - Fixed overlapping minimized window selection
../lib/public/nuklear.h:26173:/// - 2016/08/30 (1.11.0) - Removed some internal complexity and overly complex code
../lib/public/nuklear.h:26175:/// - 2016/08/29 (1.10.0) - Added additional height parameter to `nk_combobox_xxx`
../lib/public/nuklear.h:26176:/// - 2016/08/29 (1.10.0) - Fixed drawing bug in dynamic popups
../lib/public/nuklear.h:26177:/// - 2016/08/29 (1.10.0) - Added experimental mouse scrolling to popups, menus and comboboxes
../lib/public/nuklear.h:26178:/// - 2016/08/26 (1.10.0) - Added window name string prepresentation to account for
../lib/public/nuklear.h:26181:/// - 2016/08/26 (1.10.0) - Added stacks for temporary style/UI changes in code
../lib/public/nuklear.h:26182:/// - 2016/08/25 (1.10.0) - Changed `nk_input_is_key_pressed` and 'nk_input_is_key_released'
../lib/public/nuklear.h:26184:/// - 2016/08/25 (1.10.0) - Added additional nk_edit flag to directly jump to the end on activate
../lib/public/nuklear.h:26185:/// - 2016/08/17 (1.09.6)- Removed invalid check for value zero in nk_propertyx
../lib/public/nuklear.h:26186:/// - 2016/08/16 (1.09.5)- Fixed ROM mode for deeper levels of popup windows parents.
../lib/public/nuklear.h:26187:/// - 2016/08/15 (1.09.4)- Editbox are now still active if enter was pressed with flag
../lib/public/nuklear.h:26190:/// - 2016/08/15 (1.09.4)- Removed redundant code
../lib/public/nuklear.h:26191:/// - 2016/08/15 (1.09.4)- Fixed negative numbers in `nk_strtoi` and remove unused variable
../lib/public/nuklear.h:26192:/// - 2016/08/15 (1.09.3)- Fixed `NK_WINDOW_BACKGROUND` flag behavior to select a background
../lib/public/nuklear.h:26194:/// - 2016/08/14 (1.09.2)- Fixed a bug in font atlas which caused wrong loading
../lib/public/nuklear.h:26196:/// - 2016/08/12 (1.09.1)- Added additional function to check if window is currently
../lib/public/nuklear.h:26198:/// - 2016/08/12 (1.09.1)- nk_window_is_closed now queries the correct flag `NK_WINDOW_CLOSED`
../lib/public/nuklear.h:26200:/// - 2016/08/09 (1.09.0) - Added additional double version to nk_property and changed
../lib/public/nuklear.h:26203:/// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
../lib/public/nuklear.h:26206:/// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
../lib/public/nuklear.h:26209:/// - 2016/08/08 (1.07.2)- Fixed compiling error without define NK_INCLUDE_FIXED_TYPE
../lib/public/nuklear.h:26210:/// - 2016/08/08 (1.07.1)- Fixed possible floating point error inside `nk_widget` leading
../lib/public/nuklear.h:26213:/// - 2016/08/08 (1.07.0) - Nuklear now differentiates between hiding a window (NK_WINDOW_HIDDEN) and
../lib/public/nuklear.h:26219:/// - 2016/08/08 (1.06.0) - Added `nk_edit_string_zero_terminated` as a second option to
../lib/public/nuklear.h:26221:/// - 2016/08/08 (1.05.4)- Fixed scrollbar auto hiding behavior
../lib/public/nuklear.h:26222:/// - 2016/08/08 (1.05.3)- Fixed wrong panel padding selection in `nk_layout_widget_space`
../lib/public/nuklear.h:26223:/// - 2016/08/07 (1.05.2)- Fixed old bug in dynamic immediate mode layout API, calculating
../lib/public/nuklear.h:26225:///- 2016/08/07 (1.05.1)- Hopefully finally fixed combobox popup drawing bug
../lib/public/nuklear.h:26226:///- 2016/08/07 (1.05.0) - Split varargs away from NK_INCLUDE_STANDARD_IO into own
../lib/public/nuklear.h:26229:/// - 2016/08/06 (1.04.5)- Changed memset calls to NK_MEMSET
../lib/public/nuklear.h:26230:/// - 2016/08/04 (1.04.4)- Fixed fast window scaling behavior
../lib/public/nuklear.h:26231:/// - 2016/08/04 (1.04.3)- Fixed window scaling, movement bug which appears if you
../lib/public/nuklear.h:26236:/// - 2016/08/04 (1.04.2)- Fixed changing fonts
../lib/public/nuklear.h:26237:/// - 2016/08/03 (1.04.1)- Fixed `NK_WINDOW_BACKGROUND` behavior
../lib/public/nuklear.h:26238:/// - 2016/08/03 (1.04.0) - Added color parameter to `nk_draw_image`
../lib/public/nuklear.h:26239:/// - 2016/08/03 (1.04.0) - Added additional window padding style attributes for
../lib/public/nuklear.h:26241:/// - 2016/08/03 (1.04.0) - Added functions to show/hide software cursor
../lib/public/nuklear.h:26242:/// - 2016/08/03 (1.04.0) - Added `NK_WINDOW_BACKGROUND` flag to force a window
../lib/public/nuklear.h:26244:/// - 2016/08/03 (1.03.2)- Removed invalid assert macro for NK_RGB color picker
../lib/public/nuklear.h:26245:/// - 2016/08/01 (1.03.1)- Added helper macros into header include guard
../lib/public/nuklear.h:26246:/// - 2016/07/29 (1.03.0) - Moved the window/table pool into the header part to
../lib/public/nuklear.h:26249:/// - 2016/07/29 (1.02.0) - Added auto scrollbar hiding window flag which if enabled
../lib/public/nuklear.h:26253:/// - 2016/07/25 (1.01.1) - Fixed small panel and panel border drawing bugs
../lib/public/nuklear.h:26254:/// - 2016/07/15 (1.01.0) - Added software cursor to `nk_style` and `nk_context`
../lib/public/nuklear.h:26255:/// - 2016/07/15 (1.01.0) - Added const correctness to `nk_buffer_push' data argument
../lib/public/nuklear.h:26256:/// - 2016/07/15 (1.01.0) - Removed internal font baking API and simplified
../lib/public/nuklear.h:26259:/// - 2016/07/15 (1.00.0) - Changed button API to use context dependend button
../lib/public/nuklear.h:26264:/// ![Figure [blue]: Feature overview with blue color styling](https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png)
../lib/public/nuklear.h:26265:/// ![Figure [red]: Feature overview with red color styling](https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png)
../lib/public/nuklear.h:26266:/// ![Figure [widgets]: Widget overview](https://cloud.githubusercontent.com/assets/8057201/11282359/3325e3c6-8eff-11e5-86cb-cf02b0596087.png)
../lib/public/nuklear.h:26267:/// ![Figure [blackwhite]: Black and white](https://cloud.githubusercontent.com/assets/8057201/11033668/59ab5d04-86e5-11e5-8091-c56f16411565.png)
../lib/public/nuklear.h:26268:/// ![Figure [filexp]: File explorer](https://cloud.githubusercontent.com/assets/8057201/10718115/02a9ba08-7b6b-11e5-950f-adacdd637739.png)
../lib/public/nuklear.h:26269:/// ![Figure [opengl]: OpenGL Editor](https://cloud.githubusercontent.com/assets/8057201/12779619/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png)
../lib/public/nuklear.h:26270:/// ![Figure [nodedit]: Node Editor](https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif)
../lib/public/nuklear.h:26271:/// ![Figure [skinning]: Using skinning in Nuklear](https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png)
../lib/public/nuklear.h:26272:/// ![Figure [bf]: Heavy modified version](https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png)
../lib/public/nuklear.h:26278:/// Uses [stddoc.c](https://github.com/r-lyeh/stddoc.c) from r-lyeh@github.com for documentation generation <br /><br />
../lib/public/pf_malloc.h:42:/* Allows allocating variable-sized chunks 
../lib/public/pf_malloc.h:43: * from a single fixed-sized slab. */
../lib/public/pf_malloc.h:52: * slab buffer, or -1 if the allocation failed. */
../lib/public/pf_nuklear.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../lib/public/pf_string.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/public/pqueue.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../lib/public/pqueue.h:70:    ((pqueue)->size)
../lib/public/pqueue.h:73:    for(int i = 1; i <= (_pqueue)->size; i++) {                                                 \
../lib/public/pqueue.h:74:        _entry = (_pqueue)->nodes[i].data;                                                      \
../lib/public/pqueue.h:103:        while(root_idx != pqueue->size + 1) {                                                   \
../lib/public/pqueue.h:105:            int target_idx = pqueue->size + 1;                                                  \
../lib/public/pqueue.h:109:            if(left_child_idx <= pqueue->size                                                   \
../lib/public/pqueue.h:110:            && pqueue->nodes[left_child_idx].priority < pqueue->nodes[target_idx].priority) {   \
../lib/public/pqueue.h:114:            if(right_child_idx <= pqueue->size                                                  \
../lib/public/pqueue.h:115:            && pqueue->nodes[right_child_idx].priority < pqueue->nodes[target_idx].priority) {  \
../lib/public/pqueue.h:119:            pqueue->nodes[root_idx] = pqueue->nodes[target_idx];                                \
../lib/public/pqueue.h:126:        pqueue->nodes = NULL;                                                                   \
../lib/public/pqueue.h:127:        pqueue->capacity = 0;                                                                   \
../lib/public/pqueue.h:128:        pqueue->size = 0;                                                                       \
../lib/public/pqueue.h:129:        pqueue->prealloc = realloc;                                                             \
../lib/public/pqueue.h:130:        pqueue->pfree = free;                                                                   \
../lib/public/pqueue.h:137:        pqueue->nodes = NULL;                                                                   \
../lib/public/pqueue.h:138:        pqueue->capacity = 0;                                                                   \
../lib/public/pqueue.h:139:        pqueue->size = 0;                                                                       \
../lib/public/pqueue.h:140:        pqueue->prealloc = prealloc;                                                            \
../lib/public/pqueue.h:141:        pqueue->pfree = pfree;                                                                  \
../lib/public/pqueue.h:146:        free(pqueue->nodes);                                                                    \
../lib/public/pqueue.h:152:        if(pqueue->size + 1 >= pqueue->capacity) {                                              \
../lib/public/pqueue.h:154:            pqueue->capacity = pqueue->capacity ? pqueue->capacity * 2 : 32;                    \
../lib/public/pqueue.h:155:            void *nodes = pqueue->prealloc(pqueue->nodes,                                       \
../lib/public/pqueue.h:156:                pqueue->capacity * sizeof(pq_##name##_node_t));                                 \
../lib/public/pqueue.h:159:            pqueue->nodes = nodes;                                                              \
../lib/public/pqueue.h:162:        int curr_idx = pqueue->size + 1;                                                        \
../lib/public/pqueue.h:165:        while(curr_idx > 1 && pqueue->nodes[parent_idx].priority > in_prio) {                   \
../lib/public/pqueue.h:166:            pqueue->nodes[curr_idx] = pqueue->nodes[parent_idx];                                \
../lib/public/pqueue.h:171:        pqueue->nodes[curr_idx].priority = in_prio;                                             \
../lib/public/pqueue.h:172:        pqueue->nodes[curr_idx].data = in;                                                      \
../lib/public/pqueue.h:173:        pqueue->size++;                                                                         \
../lib/public/pqueue.h:179:        if(pqueue->size == 0)                                                                   \
../lib/public/pqueue.h:182:        *out = pqueue->nodes[1].data;                                                           \
../lib/public/pqueue.h:183:        pqueue->nodes[1] = pqueue->nodes[pqueue->size--];                                       \
../lib/public/pqueue.h:191:        if(pqueue->size == 0)                                                                   \
../lib/public/pqueue.h:194:        int idx = -1;                                                                           \
../lib/public/pqueue.h:195:        for(int i = 1; i <= pqueue->size; i++) {                                                \
../lib/public/pqueue.h:196:            if(0 == compare(&pqueue->nodes[i].data, &t)) {                                      \
../lib/public/pqueue.h:201:        if(idx == -1)                                                                           \
../lib/public/pqueue.h:204:        pqueue->nodes[idx] = pqueue->nodes[pqueue->size--];                                     \
../lib/public/pqueue.h:211:        for(int i = 1; i <= pqueue->size; i++) {                                                \
../lib/public/pqueue.h:212:            if(0 == compare(&pqueue->nodes[i].data, &t))                                        \
../lib/public/pqueue.h:220:        if(pqueue->capacity < cap) {                                                            \
../lib/public/pqueue.h:222:            pqueue->capacity = cap;                                                             \
../lib/public/pqueue.h:223:            void *nodes = pqueue->prealloc(pqueue->nodes,                                       \
../lib/public/pqueue.h:224:                pqueue->capacity * sizeof(pq_##name##_node_t));                                 \
../lib/public/pqueue.h:227:            pqueue->nodes = nodes;                                                              \
../lib/public/pqueue.h:234:        if(pqueue->size == 0)                                                                   \
../lib/public/pqueue.h:236:        *out = pqueue->nodes[1].priority;                                                       \
../lib/public/pqueue.h:242:        pqueue->size = 0;                                                                       \
../lib/public/pqueue.h:247:        if(!pq_##name##_reserve(dst, src->size))                                                \
../lib/public/pqueue.h:250:        memcpy(dst->nodes + 1, src->nodes + 1, src->size * sizeof(pq_##name##_node_t));         \
../lib/public/pqueue.h:251:        dst->size = src->size;                                                                  \
../lib/public/quadtree.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/public/quadtree.h:54:        /* Head of singly-linked list of leaf nodes, each one holding an additional */          \
../lib/public/quadtree.h:85:#define QT_EQ(a, b) (fabs(a - b) < QT_EPSILON)
../lib/public/quadtree.h:137:        return (0 == node->nw                                                                   \
../lib/public/quadtree.h:138:            &&  0 == node->ne                                                                   \
../lib/public/quadtree.h:139:            &&  0 == node->sw                                                                   \
../lib/public/quadtree.h:140:            &&  0 == node->se);                                                                 \
../lib/public/quadtree.h:145:        node->depth = depth;                                                                    \
../lib/public/quadtree.h:146:        node->nw = node->ne = node->sw = node->se = 0;                                          \
../lib/public/quadtree.h:147:        node->has_record = false;                                                               \
../lib/public/quadtree.h:148:        node->parent = 0;                                                                       \
../lib/public/quadtree.h:149:        node->sibling_next = 0;                                                                 \
../lib/public/quadtree.h:155:        mp_ref_t curr = node->sibling_next;                                                     \
../lib/public/quadtree.h:157:            qt_node(name) *curr_node = mp_##name##_entry(&qt->node_pool, curr);                 \
../lib/public/quadtree.h:158:            curr = curr_node->sibling_next;                                                     \
../lib/public/quadtree.h:166:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:170:            printf("|-> ");                                                                     \
../lib/public/quadtree.h:172:        printf("[%12.6f, %12.6f]", node->x, node->y);                                           \
../lib/public/quadtree.h:173:        if(node->has_record)                                                                    \
../lib/public/quadtree.h:180:        _qt_##name##_node_print(qt, node->nw, indent + 1);                                      \
../lib/public/quadtree.h:181:        _qt_##name##_node_print(qt, node->ne, indent + 1);                                      \
../lib/public/quadtree.h:182:        _qt_##name##_node_print(qt, node->sw, indent + 1);                                      \
../lib/public/quadtree.h:183:        _qt_##name##_node_print(qt, node->se, indent + 1);                                      \
../lib/public/quadtree.h:190:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:192:        assert(qt->root > 0);                                                                   \
../lib/public/quadtree.h:193:        if(!node->parent) {                                                                     \
../lib/public/quadtree.h:195:            assert(node->depth == 0);                                                           \
../lib/public/quadtree.h:196:            *out_xmin = qt->xmin;                                                               \
../lib/public/quadtree.h:197:            *out_xmax = qt->xmax;                                                               \
../lib/public/quadtree.h:198:            *out_ymin = qt->ymin;                                                               \
../lib/public/quadtree.h:199:            *out_ymax = qt->ymax;                                                               \
../lib/public/quadtree.h:203:        qt_node(name) *parent = mp_##name##_entry(&qt->node_pool, node->parent);                \
../lib/public/quadtree.h:205:        _qt_##name##_node_bounds(qt, node->parent, &pxmin, &pxmax, &pymin, &pymax);             \
../lib/public/quadtree.h:207:        if(parent->nw == ref) {                                                                 \
../lib/public/quadtree.h:212:        }else if(parent->ne == ref) {                                                           \
../lib/public/quadtree.h:217:        }else if(parent->sw == ref) {                                                           \
../lib/public/quadtree.h:222:        }else if(parent->se == ref) {                                                           \
../lib/public/quadtree.h:235:        *inout_xmin -= border;                                                                  \
../lib/public/quadtree.h:237:        *inout_ymin -= border;                                                                  \
../lib/public/quadtree.h:270:        return sqrt(pow(x2-x1, 2) + pow(y2-y1, 2));                                             \
../lib/public/quadtree.h:292:            qt_node(name) *curr = mp_##name##_entry(&qt->node_pool, ref);                       \
../lib/public/quadtree.h:308:            if(root->has_record                                                                 \
../lib/public/quadtree.h:309:            && _qt_##name##_point_in_circle(x, y, range, root->x, root->y)) {                   \
../lib/public/quadtree.h:311:                *out++ = root->record;                                                          \
../lib/public/quadtree.h:312:                *inout_maxout -= 1;                                                             \
../lib/public/quadtree.h:314:                while(root->sibling_next && *inout_maxout) {                                    \
../lib/public/quadtree.h:315:                    root = mp_##name##_entry(&qt->node_pool, root->sibling_next);               \
../lib/public/quadtree.h:316:                    *out++ = root->record;                                                      \
../lib/public/quadtree.h:317:                    *inout_maxout -= 1;                                                         \
../lib/public/quadtree.h:319:                return (orig_maxout - *inout_maxout);                                           \
../lib/public/quadtree.h:325:        out += _qt_##name##_node_add_circle(qt, root->nw, x, y, range, out, inout_maxout);      \
../lib/public/quadtree.h:326:        out += _qt_##name##_node_add_circle(qt, root->ne, x, y, range, out, inout_maxout);      \
../lib/public/quadtree.h:327:        out += _qt_##name##_node_add_circle(qt, root->sw, x, y, range, out, inout_maxout);      \
../lib/public/quadtree.h:328:        out += _qt_##name##_node_add_circle(qt, root->se, x, y, range, out, inout_maxout);      \
../lib/public/quadtree.h:331:        return (orig_maxout - *inout_maxout);                                                   \
../lib/public/quadtree.h:347:            qt_node(name) *curr = mp_##name##_entry(&qt->node_pool, ref);                       \
../lib/public/quadtree.h:364:            if(root->has_record                                                                 \
../lib/public/quadtree.h:365:            && _qt_##name##_point_in_bounds(xmin, xmax, ymin, ymax, root->x, root->y)) {        \
../lib/public/quadtree.h:367:                *out++ = root->record;                                                          \
../lib/public/quadtree.h:368:                *inout_maxout -= 1;                                                             \
../lib/public/quadtree.h:370:                while(root->sibling_next && *inout_maxout) {                                    \
../lib/public/quadtree.h:371:                    root = mp_##name##_entry(&qt->node_pool, root->sibling_next);               \
../lib/public/quadtree.h:372:                    *out++ = root->record;                                                      \
../lib/public/quadtree.h:373:                    *inout_maxout -= 1;                                                         \
../lib/public/quadtree.h:375:                return (orig_maxout - *inout_maxout);                                           \
../lib/public/quadtree.h:381:        out += _qt_##name##_node_add_rect(qt, root->nw,                                         \
../lib/public/quadtree.h:383:        out += _qt_##name##_node_add_rect(qt, root->ne,                                         \
../lib/public/quadtree.h:385:        out += _qt_##name##_node_add_rect(qt, root->sw,                                         \
../lib/public/quadtree.h:387:        out += _qt_##name##_node_add_rect(qt, root->se,                                         \
../lib/public/quadtree.h:391:        return (orig_maxout - *inout_maxout);                                                   \
../lib/public/quadtree.h:396:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:398:        mp_ref_t sib = mp_##name##_alloc(&qt->node_pool);                                       \
../lib/public/quadtree.h:401:        qt_node(name) *sib_node = mp_##name##_entry(&qt->node_pool, sib);                       \
../lib/public/quadtree.h:402:        _qt_##name##_node_init(sib_node, node->depth);                                          \
../lib/public/quadtree.h:403:        sib_node->x = node->x;                                                                  \
../lib/public/quadtree.h:404:        sib_node->y = node->y;                                                                  \
../lib/public/quadtree.h:405:        sib_node->parent = node->parent;                                                        \
../lib/public/quadtree.h:407:        mp_ref_t curr = node->sibling_next;                                                     \
../lib/public/quadtree.h:411:            node = mp_##name##_entry(&qt->node_pool, curr);                                     \
../lib/public/quadtree.h:413:            curr = node->sibling_next;                                                          \
../lib/public/quadtree.h:416:        node = mp_##name##_entry(&qt->node_pool, prev);                                         \
../lib/public/quadtree.h:417:        assert(!node->sibling_next);                                                            \
../lib/public/quadtree.h:419:        sib_node->record = record;                                                              \
../lib/public/quadtree.h:420:        sib_node->has_record = true;                                                            \
../lib/public/quadtree.h:421:        node->sibling_next = sib;                                                               \
../lib/public/quadtree.h:422:        ++qt->nrecs;                                                                            \
../lib/public/quadtree.h:429:        qt_node(name) *head_node = mp_##name##_entry(&qt->node_pool, head);                     \
../lib/public/quadtree.h:431:        if(!head_node->sibling_next)                                                            \
../lib/public/quadtree.h:434:        mp_ref_t curr = head_node->sibling_next;                                                \
../lib/public/quadtree.h:438:            curr_node = mp_##name##_entry(&qt->node_pool, curr);                                \
../lib/public/quadtree.h:439:            prev_node = mp_##name##_entry(&qt->node_pool, prev);                                \
../lib/public/quadtree.h:441:            if(qt->comparator(&record, &curr_node->record)) {                                   \
../lib/public/quadtree.h:442:                prev_node->sibling_next = curr_node->sibling_next;                              \
../lib/public/quadtree.h:443:                mp_##name##_free(&qt->node_pool, curr);                                         \
../lib/public/quadtree.h:444:                --qt->nrecs;                                                                    \
../lib/public/quadtree.h:448:            curr = curr_node->sibling_next;                                                     \
../lib/public/quadtree.h:455:        if(x <= node->x && y >= node->y)                                                        \
../lib/public/quadtree.h:456:            return node->nw;                                                                    \
../lib/public/quadtree.h:457:        if(x >= node->x && y >= node->y)                                                        \
../lib/public/quadtree.h:458:            return node->ne;                                                                    \
../lib/public/quadtree.h:459:        if(x <= node->x && y <= node->y)                                                        \
../lib/public/quadtree.h:460:            return node->sw;                                                                    \
../lib/public/quadtree.h:461:        if(x >= node->x && y <= node->y)                                                        \
../lib/public/quadtree.h:462:            return node->se;                                                                    \
../lib/public/quadtree.h:469:        if(qt->root == 0)                                                                       \
../lib/public/quadtree.h:472:        assert(qt->root > 0);                                                                   \
../lib/public/quadtree.h:473:        mp_ref_t curr_ref = qt->root;                                                           \
../lib/public/quadtree.h:474:        qt_node(name) *curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                 \
../lib/public/quadtree.h:478:            assert(curr_node->nw && curr_node->ne                                               \
../lib/public/quadtree.h:479:                && curr_node->sw && curr_node->se);                                             \
../lib/public/quadtree.h:482:            curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                            \
../lib/public/quadtree.h:492:        qt_node(name) *child = mp_##name##_entry(&qt->node_pool, child_ref);                    \
../lib/public/quadtree.h:494:        const float x_len = qt->xmax - qt->xmin;                                                \
../lib/public/quadtree.h:495:        const float y_len = qt->ymax - qt->ymin;                                                \
../lib/public/quadtree.h:497:        const float region_x_len = x_len * 1.0f/pow(2, child->depth + 1);                       \
../lib/public/quadtree.h:498:        const float region_y_len = y_len * 1.0f/pow(2, child->depth + 1);                       \
../lib/public/quadtree.h:500:        if(parent->nw == child_ref) {                                                           \
../lib/public/quadtree.h:501:            child->x = parent->x - region_x_len;                                                \
../lib/public/quadtree.h:502:            child->y = parent->y + region_y_len;                                                \
../lib/public/quadtree.h:503:        }else if(parent->ne == child_ref) {                                                     \
../lib/public/quadtree.h:504:            child->x = parent->x + region_x_len;                                                \
../lib/public/quadtree.h:505:            child->y = parent->y + region_y_len;                                                \
../lib/public/quadtree.h:506:        }else if(parent->sw == child_ref) {                                                     \
../lib/public/quadtree.h:507:            child->x = parent->x - region_x_len;                                                \
../lib/public/quadtree.h:508:            child->y = parent->y - region_y_len;                                                \
../lib/public/quadtree.h:509:        }else if(parent->se == child_ref) {                                                     \
../lib/public/quadtree.h:510:            child->x = parent->x + region_x_len;                                                \
../lib/public/quadtree.h:511:            child->y = parent->y - region_y_len;                                                \
../lib/public/quadtree.h:518:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:522:        assert(node->has_record);                                                               \
../lib/public/quadtree.h:524:        float saved_x = node->x;                                                                \
../lib/public/quadtree.h:525:        float saved_y = node->y;                                                                \
../lib/public/quadtree.h:526:        type saved_record = node->record;                                                       \
../lib/public/quadtree.h:527:        mp_ref_t saved_sibnext = node->sibling_next;                                            \
../lib/public/quadtree.h:529:        node->sibling_next = 0;                                                                 \
../lib/public/quadtree.h:530:        node->has_record = false;                                                               \
../lib/public/quadtree.h:532:        if(!node->parent) {                                                                     \
../lib/public/quadtree.h:534:            assert(node->depth == 0);                                                           \
../lib/public/quadtree.h:535:            node->x = 0.0f;                                                                     \
../lib/public/quadtree.h:536:            node->y = 0.0f;                                                                     \
../lib/public/quadtree.h:539:            qt_node(name) *parent = mp_##name##_entry(&qt->node_pool, node->parent);            \
../lib/public/quadtree.h:543:        _CHK_TRUE_JMP((node->nw = mp_##name##_alloc(&qt->node_pool)), fail);                    \
../lib/public/quadtree.h:544:        _CHK_TRUE_JMP((node->ne = mp_##name##_alloc(&qt->node_pool)), fail);                    \
../lib/public/quadtree.h:545:        _CHK_TRUE_JMP((node->sw = mp_##name##_alloc(&qt->node_pool)), fail);                    \
../lib/public/quadtree.h:546:        _CHK_TRUE_JMP((node->se = mp_##name##_alloc(&qt->node_pool)), fail);                    \
../lib/public/quadtree.h:549:        curr = mp_##name##_entry(&qt->node_pool, node->nw);                                     \
../lib/public/quadtree.h:550:        _qt_##name##_node_init(curr, node->depth + 1);                                          \
../lib/public/quadtree.h:551:        _qt_##name##_set_divide_coords(qt, node, node->nw);                                     \
../lib/public/quadtree.h:552:        curr->parent = ref;                                                                     \
../lib/public/quadtree.h:555:        curr = mp_##name##_entry(&qt->node_pool, node->ne);                                     \
../lib/public/quadtree.h:556:        _qt_##name##_node_init(curr, node->depth + 1);                                          \
../lib/public/quadtree.h:557:        _qt_##name##_set_divide_coords(qt, node, node->ne);                                     \
../lib/public/quadtree.h:558:        curr->parent = ref;                                                                     \
../lib/public/quadtree.h:561:        curr = mp_##name##_entry(&qt->node_pool, node->sw);                                     \
../lib/public/quadtree.h:562:        _qt_##name##_node_init(curr, node->depth + 1);                                          \
../lib/public/quadtree.h:563:        _qt_##name##_set_divide_coords(qt, node, node->sw);                                     \
../lib/public/quadtree.h:564:        curr->parent = ref;                                                                     \
../lib/public/quadtree.h:567:        curr = mp_##name##_entry(&qt->node_pool, node->se);                                     \
../lib/public/quadtree.h:568:        _qt_##name##_node_init(curr, node->depth + 1);                                          \
../lib/public/quadtree.h:569:        _qt_##name##_set_divide_coords(qt, node, node->se);                                     \
../lib/public/quadtree.h:570:        curr->parent = ref;                                                                     \
../lib/public/quadtree.h:574:        qt_node(name) *rec_node = mp_##name##_entry(&qt->node_pool, rec_ref);                   \
../lib/public/quadtree.h:575:        rec_node->x = saved_x;                                                                  \
../lib/public/quadtree.h:576:        rec_node->y = saved_y;                                                                  \
../lib/public/quadtree.h:577:        rec_node->record = saved_record;                                                        \
../lib/public/quadtree.h:578:        rec_node->has_record = true;                                                            \
../lib/public/quadtree.h:579:        rec_node->sibling_next = saved_sibnext;                                                 \
../lib/public/quadtree.h:581:        mp_ref_t sib = rec_node->sibling_next;                                                  \
../lib/public/quadtree.h:583:            qt_node(name) *sib_node = mp_##name##_entry(&qt->node_pool, sib);                   \
../lib/public/quadtree.h:584:            sib_node->depth = rec_node->depth;                                                  \
../lib/public/quadtree.h:585:            sib_node->parent = rec_node->parent;                                                \
../lib/public/quadtree.h:586:            sib = sib_node->sibling_next;                                                       \
../lib/public/quadtree.h:592:        node->nw ? mp_##name##_free(&qt->node_pool, node->nw), 0 : 0;                           \
../lib/public/quadtree.h:593:        node->ne ? mp_##name##_free(&qt->node_pool, node->ne), 0 : 0;                           \
../lib/public/quadtree.h:594:        node->sw ? mp_##name##_free(&qt->node_pool, node->sw), 0 : 0;                           \
../lib/public/quadtree.h:595:        node->se ? mp_##name##_free(&qt->node_pool, node->se), 0 : 0;                           \
../lib/public/quadtree.h:601:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:604:        return (node->has_record);                                                              \
../lib/public/quadtree.h:610:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:613:        int nrecs = !!_qt_##name##_rec_node(qt, node->nw)                                       \
../lib/public/quadtree.h:614:                  + !!_qt_##name##_rec_node(qt, node->ne)                                       \
../lib/public/quadtree.h:615:                  + !!_qt_##name##_rec_node(qt, node->sw)                                       \
../lib/public/quadtree.h:616:                  + !!_qt_##name##_rec_node(qt, node->se);                                      \
../lib/public/quadtree.h:622:        mp_ref_t rec = _qt_##name##_rec_node(qt, node->nw) ? node->nw                           \
../lib/public/quadtree.h:623:                     : _qt_##name##_rec_node(qt, node->ne) ? node->ne                           \
../lib/public/quadtree.h:624:                     : _qt_##name##_rec_node(qt, node->sw) ? node->sw                           \
../lib/public/quadtree.h:625:                     : _qt_##name##_rec_node(qt, node->se) ? node->se                           \
../lib/public/quadtree.h:628:        qt_node(name) *rec_node = mp_##name##_entry(&qt->node_pool, rec);                       \
../lib/public/quadtree.h:632:        mp_##name##_free(&qt->node_pool, node->nw);                                             \
../lib/public/quadtree.h:633:        mp_##name##_free(&qt->node_pool, node->ne);                                             \
../lib/public/quadtree.h:634:        mp_##name##_free(&qt->node_pool, node->sw);                                             \
../lib/public/quadtree.h:635:        mp_##name##_free(&qt->node_pool, node->se);                                             \
../lib/public/quadtree.h:637:        node->nw = node->ne = node->sw = node->se = 0;                                          \
../lib/public/quadtree.h:638:        node->has_record = true;                                                                \
../lib/public/quadtree.h:639:        node->record = rec_node->record;                                                        \
../lib/public/quadtree.h:640:        node->x = mp_##name##_entry(&qt->node_pool, rec)->x;                                    \
../lib/public/quadtree.h:641:        node->y = mp_##name##_entry(&qt->node_pool, rec)->y;                                    \
../lib/public/quadtree.h:642:        node->sibling_next = rec_node->sibling_next;                                            \
../lib/public/quadtree.h:644:        mp_ref_t curr = node->sibling_next;                                                     \
../lib/public/quadtree.h:646:            qt_node(name) *curr_sib_node = mp_##name##_entry(&qt->node_pool, curr);             \
../lib/public/quadtree.h:647:            curr_sib_node->depth = node->depth;                                                 \
../lib/public/quadtree.h:648:            curr_sib_node->parent = node->parent;                                               \
../lib/public/quadtree.h:649:            curr = curr_sib_node->sibling_next;                                                 \
../lib/public/quadtree.h:657:        if(node->nw == oldref) node->nw = newref;                                               \
../lib/public/quadtree.h:658:        if(node->ne == oldref) node->ne = newref;                                               \
../lib/public/quadtree.h:659:        if(node->sw == oldref) node->sw = newref;                                               \
../lib/public/quadtree.h:660:        if(node->se == oldref) node->se = newref;                                               \
../lib/public/quadtree.h:665:        qt_node(name) *node = mp_##name##_entry(&qt->node_pool, ref);                           \
../lib/public/quadtree.h:669:        if(!(xmin <= node->x)                                                                   \
../lib/public/quadtree.h:670:        || !(xmax >= node->x)                                                                   \
../lib/public/quadtree.h:671:        || !(ymin <= node->y)                                                                   \
../lib/public/quadtree.h:672:        || !(ymax >= node->y)) {                                                                \
../lib/public/quadtree.h:673:            printf("Inconsistent Quadtree: [node (%f, %f) misplaced]\n", node->x, node->y);     \
../lib/public/quadtree.h:678:        assert(xmin <= node->x);                                                                \
../lib/public/quadtree.h:679:        assert(xmax >= node->x);                                                                \
../lib/public/quadtree.h:680:        assert(ymin <= node->y);                                                                \
../lib/public/quadtree.h:681:        assert(ymax >= node->y);                                                                \
../lib/public/quadtree.h:683:        mp_ref_t sib = node->sibling_next;                                                      \
../lib/public/quadtree.h:685:            qt_node(name) *sib_node = mp_##name##_entry(&qt->node_pool, sib);                   \
../lib/public/quadtree.h:686:            if(sib_node->depth != node->depth || sib_node->parent != node->parent) {            \
../lib/public/quadtree.h:689:                    node->x, node->y, (int)node->depth, sib_node->x, sib_node->y,               \
../lib/public/quadtree.h:690:                        (int)sib_node->depth);                                                  \
../lib/public/quadtree.h:694:            assert(sib_node->depth == node->depth);                                             \
../lib/public/quadtree.h:695:            assert(sib_node->parent == node->parent);                                           \
../lib/public/quadtree.h:696:            sib = sib_node->sibling_next;                                                       \
../lib/public/quadtree.h:699:        if(node->parent) {                                                                      \
../lib/public/quadtree.h:700:            qt_node(name) *parent = mp_##name##_entry(&qt->node_pool, node->parent);            \
../lib/public/quadtree.h:701:            if(node->depth - parent->depth != 1) {                                              \
../lib/public/quadtree.h:704:                    node->x, node->y, (int)node->depth, parent->x, parent->y,                   \
../lib/public/quadtree.h:705:                        (int)parent->depth);                                                    \
../lib/public/quadtree.h:709:            assert(node->depth - parent->depth == 1);                                           \
../lib/public/quadtree.h:715:        _qt_##name##_node_check_consistent(qt, node->nw);                                       \
../lib/public/quadtree.h:716:        _qt_##name##_node_check_consistent(qt, node->ne);                                       \
../lib/public/quadtree.h:717:        _qt_##name##_node_check_consistent(qt, node->sw);                                       \
../lib/public/quadtree.h:718:        _qt_##name##_node_check_consistent(qt, node->se);                                       \
../lib/public/quadtree.h:723:        if(!qt->root)                                                                           \
../lib/public/quadtree.h:725:        _qt_##name##_node_check_consistent(qt, qt->root);                                       \
../lib/public/quadtree.h:733:        mp_##name##_init(&qt->node_pool, true);                                                 \
../lib/public/quadtree.h:734:        qt->root = 0;                                                                           \
../lib/public/quadtree.h:735:        qt->nrecs = 0;                                                                          \
../lib/public/quadtree.h:736:        qt->xmin = xmin;                                                                        \
../lib/public/quadtree.h:737:        qt->xmax = xmax;                                                                        \
../lib/public/quadtree.h:738:        qt->ymin = ymin;                                                                        \
../lib/public/quadtree.h:739:        qt->ymax = ymax;                                                                        \
../lib/public/quadtree.h:740:        qt->comparator = comparator;                                                            \
../lib/public/quadtree.h:747:        mp_##name##_destroy(&qt->node_pool);                                                    \
../lib/public/quadtree.h:753:        mp_##name##_clear(&qt->node_pool);                                                      \
../lib/public/quadtree.h:754:        qt->root = 0;                                                                           \
../lib/public/quadtree.h:755:        qt->nrecs = 0;                                                                          \
../lib/public/quadtree.h:760:        if(qt->root == 0) {                                                                     \
../lib/public/quadtree.h:762:            assert(qt->nrecs == 0);                                                             \
../lib/public/quadtree.h:764:            _CHK_TRUE_RET((qt->root = mp_##name##_alloc(&qt->node_pool)), false);               \
../lib/public/quadtree.h:765:            qt_node(name) *node = mp_##name##_entry(&qt->node_pool, qt->root);                  \
../lib/public/quadtree.h:768:            node->x = x;                                                                        \
../lib/public/quadtree.h:769:            node->y = y;                                                                        \
../lib/public/quadtree.h:770:            node->has_record = true;                                                            \
../lib/public/quadtree.h:771:            node->record = record;                                                              \
../lib/public/quadtree.h:774:            qt->nrecs++;                                                                        \
../lib/public/quadtree.h:778:        assert(qt->root > 0);                                                                   \
../lib/public/quadtree.h:780:        qt_node(name) *curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                 \
../lib/public/quadtree.h:784:        if(!curr_node->has_record) {                                                            \
../lib/public/quadtree.h:786:            curr_node->x = x;                                                                   \
../lib/public/quadtree.h:787:            curr_node->y = y;                                                                   \
../lib/public/quadtree.h:788:            curr_node->has_record = true;                                                       \
../lib/public/quadtree.h:789:            curr_node->record = record;                                                         \
../lib/public/quadtree.h:790:            qt->nrecs++;                                                                        \
../lib/public/quadtree.h:793:        assert(curr_node->has_record);                                                          \
../lib/public/quadtree.h:795:        if(QT_EQ(x, curr_node->x) && QT_EQ(y, curr_node->y))                                    \
../lib/public/quadtree.h:802:            assert(!curr_node->has_record);                                                     \
../lib/public/quadtree.h:806:            curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                            \
../lib/public/quadtree.h:808:        }while(curr_node->has_record);                                                          \
../lib/public/quadtree.h:810:        /* curr_node is now a record-less leaf node. Set its' record. */                        \
../lib/public/quadtree.h:811:        curr_node->record = record;                                                             \
../lib/public/quadtree.h:812:        curr_node->has_record = true;                                                           \
../lib/public/quadtree.h:813:        curr_node->x = x;                                                                       \
../lib/public/quadtree.h:814:        curr_node->y = y;                                                                       \
../lib/public/quadtree.h:816:        qt->nrecs++;                                                                            \
../lib/public/quadtree.h:826:        qt_node(name) *curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                 \
../lib/public/quadtree.h:827:        if(!curr_node->has_record)                                                              \
../lib/public/quadtree.h:829:        if(!QT_EQ(curr_node->x, x) || !QT_EQ(curr_node->y, y))                                  \
../lib/public/quadtree.h:833:        if(!qt->comparator(&record, &curr_node->record))                                        \
../lib/public/quadtree.h:836:        --qt->nrecs;                                                                            \
../lib/public/quadtree.h:839:        if(curr_node->sibling_next) {                                                           \
../lib/public/quadtree.h:841:            mp_ref_t new_head = curr_node->sibling_next;                                        \
../lib/public/quadtree.h:842:            qt_node(name) *new_head_node = mp_##name##_entry(&qt->node_pool, new_head);         \
../lib/public/quadtree.h:843:            assert(new_head_node->has_record);                                                  \
../lib/public/quadtree.h:846:            new_head_node->nw = curr_node->nw;                                                  \
../lib/public/quadtree.h:847:            new_head_node->ne = curr_node->ne;                                                  \
../lib/public/quadtree.h:848:            new_head_node->sw = curr_node->sw;                                                  \
../lib/public/quadtree.h:849:            new_head_node->se = curr_node->se;                                                  \
../lib/public/quadtree.h:850:            new_head_node->parent = curr_node->parent;                                          \
../lib/public/quadtree.h:852:            mp_##name##_free(&qt->node_pool, curr_ref);                                         \
../lib/public/quadtree.h:854:            if(!curr_node->parent) {                                                            \
../lib/public/quadtree.h:855:                assert(qt->root == curr_ref);                                                   \
../lib/public/quadtree.h:856:                qt->root = new_head;                                                            \
../lib/public/quadtree.h:860:            qt_node(name) *parent = mp_##name##_entry(&qt->node_pool, curr_node->parent);       \
../lib/public/quadtree.h:865:        if(!curr_node->parent) {                                                                \
../lib/public/quadtree.h:866:            mp_##name##_free(&qt->node_pool, curr_ref);                                         \
../lib/public/quadtree.h:867:            assert(qt->root == curr_ref);                                                       \
../lib/public/quadtree.h:868:            qt->root = 0;                                                                       \
../lib/public/quadtree.h:872:        qt_node(name) *parent = mp_##name##_entry(&qt->node_pool, curr_node->parent);           \
../lib/public/quadtree.h:874:        curr_node->has_record = false;                                                          \
../lib/public/quadtree.h:877:            curr_ref = curr_node->parent;                                                       \
../lib/public/quadtree.h:880:            curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                            \
../lib/public/quadtree.h:893:        qt_node(name) *curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                 \
../lib/public/quadtree.h:894:        if(!curr_node->has_record)                                                              \
../lib/public/quadtree.h:896:        if(!QT_EQ(curr_node->x, x) || !QT_EQ(curr_node->y, y))                                  \
../lib/public/quadtree.h:899:        if(!curr_node->sibling_next)                                                            \
../lib/public/quadtree.h:900:            return qt_##name##_delete(qt, x, y, curr_node->record);                             \
../lib/public/quadtree.h:902:        mp_ref_t curr_sib = curr_node->sibling_next;                                            \
../lib/public/quadtree.h:904:            qt_node(name) *curr_sib_node = mp_##name##_entry(&qt->node_pool, curr_sib);         \
../lib/public/quadtree.h:905:            bool ret = _qt_##name##_delete_sib(qt, curr_ref, x, y, curr_sib_node->record);      \
../lib/public/quadtree.h:908:            curr_sib = curr_sib_node->sibling_next;                                             \
../lib/public/quadtree.h:911:        assert(!curr_node->sibling_next);                                                       \
../lib/public/quadtree.h:912:        return qt_##name##_delete(qt, x, y, curr_node->record);                                 \
../lib/public/quadtree.h:921:        qt_node(name) *curr_node = mp_##name##_entry(&qt->node_pool, curr_ref);                 \
../lib/public/quadtree.h:922:        if(!curr_node->has_record)                                                              \
../lib/public/quadtree.h:924:        if(!QT_EQ(curr_node->x, x) || !QT_EQ(curr_node->y, y))                                  \
../lib/public/quadtree.h:927:        *out = curr_node->record;                                                               \
../lib/public/quadtree.h:941:        if(!qt->root)                                                                           \
../lib/public/quadtree.h:943:        qt_node(name) *root = mp_##name##_entry(&qt->node_pool, qt->root);                      \
../lib/public/quadtree.h:952:        if(!qt->root)                                                                           \
../lib/public/quadtree.h:954:        qt_node(name) *root = mp_##name##_entry(&qt->node_pool, qt->root);                      \
../lib/public/quadtree.h:960:        printf("number of records: %u\n", (unsigned)qt->nrecs);                                 \
../lib/public/quadtree.h:961:        printf("mempool nodes: %u\n", (unsigned)qt->node_pool.num_allocd);                      \
../lib/public/quadtree.h:962:        if(qt->root == 0) {                                                                     \
../lib/public/quadtree.h:966:        _qt_##name##_node_print(qt, qt->root, 0);                                               \
../lib/public/quadtree.h:971:        return mp_##name##_reserve(&qt->node_pool, new_cap);                                    \
../lib/public/queue.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../lib/public/queue.h:81:        type *new_mem = realloc((void*)queue->mem, sizeof(type) * new_cap);                     \
../lib/public/queue.h:85:        if(queue->ihead > queue->itail) {                                                       \
../lib/public/queue.h:87:            /* +-----+ <--mem    ^   */                                                         \
../lib/public/queue.h:90:            /* +-----+ <--tail   |   */                                                         \
../lib/public/queue.h:91:            /* +-----+           v   */                                                         \
../lib/public/queue.h:94:            /* +-----+ <--head   ^   */                                                         \
../lib/public/queue.h:95:            /* +-----+           |   */                                                         \
../lib/public/queue.h:97:            /* +-----+           v   */                                                         \
../lib/public/queue.h:100:            size_t top = queue->itail + 1;                                                      \
../lib/public/queue.h:101:            size_t bot = queue->capacity - queue->ihead;                                        \
../lib/public/queue.h:102:            assert(top + bot == queue->size);                                                   \
../lib/public/queue.h:106:            memmove(new_mem, new_mem + queue->ihead, sizeof(type) * bot);                       \
../lib/public/queue.h:109:            queue->ihead = 0;                                                                   \
../lib/public/queue.h:110:            queue->itail = top + bot - 1;                                                       \
../lib/public/queue.h:113:        queue->mem = new_mem;                                                                   \
../lib/public/queue.h:114:        queue->capacity = new_cap;                                                              \
../lib/public/queue.h:121:        queue->itail = -1;                                                                      \
../lib/public/queue.h:127:        free((void*)queue->mem);                                                                \
../lib/public/queue.h:133:        if(queue->size == queue->capacity) {                                                    \
../lib/public/queue.h:134:            if(!_queue_##name##_resize(queue, queue->capacity ? queue->capacity * 2 : 32))      \
../lib/public/queue.h:138:        ++queue->itail;                                                                         \
../lib/public/queue.h:139:        if(queue->itail >= queue->capacity) {                                                   \
../lib/public/queue.h:140:            queue->itail = 0;  /* Wrap around back to top */                                    \
../lib/public/queue.h:143:        queue->mem[queue->itail] = *entry;                                                      \
../lib/public/queue.h:144:        ++queue->size;                                                                          \
../lib/public/queue.h:150:        if(queue->size == 0)                                                                    \
../lib/public/queue.h:153:        *out = queue->mem[queue->ihead];                                                        \
../lib/public/queue.h:154:        ++queue->ihead;                                                                         \
../lib/public/queue.h:155:        if(queue->ihead >= queue->capacity) {                                                   \
../lib/public/queue.h:156:            queue->ihead = 0;  /* Wrap around back to top */                                    \
../lib/public/queue.h:159:        --queue->size;                                                                          \
../lib/public/queue.h:165:        queue->itail = -1;                                                                      \
../lib/public/queue.h:166:        queue->ihead = 0;                                                                       \
../lib/public/queue.h:167:        queue->size = 0;                                                                        \
../lib/public/stalloc.h:46:/* The memstack allows variable-sized allocations from larger pre-allocated 
../lib/public/stalloc.h:53: * prior allocations, which would be required with a 'realloc'-based approach. 
../lib/public/stb_image.h:3:/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
../lib/public/stb_image.h:26:      PNG 1/2/4/8/16-bit-per-channel
../lib/public/stb_image.h:29:      BMP non-1bpp, non-RLE
../lib/public/stb_image.h:30:      PSD (composited view only, no extra channels, 8/16 bit-per-channel)
../lib/public/stb_image.h:32:      GIF (*comp always reports as 4-channel)
../lib/public/stb_image.h:40:      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
../lib/public/stb_image.h:41:      - decode from arbitrary I/O callbacks
../lib/public/stb_image.h:42:      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
../lib/public/stb_image.h:53:      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
../lib/public/stb_image.h:54:      2.26  (2020-07-13) many minor fixes
../lib/public/stb_image.h:55:      2.25  (2020-02-02) fix warnings
../lib/public/stb_image.h:56:      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
../lib/public/stb_image.h:57:      2.23  (2019-08-11) fix clang static analysis warning
../lib/public/stb_image.h:58:      2.22  (2019-03-04) gif fixes, fix warnings
../lib/public/stb_image.h:59:      2.21  (2019-02-25) fix typo in comment
../lib/public/stb_image.h:60:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
../lib/public/stb_image.h:61:      2.19  (2018-02-11) fix warning
../lib/public/stb_image.h:62:      2.18  (2018-01-30) fix warnings
../lib/public/stb_image.h:63:      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
../lib/public/stb_image.h:64:      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
../lib/public/stb_image.h:65:      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
../lib/public/stb_image.h:66:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
../lib/public/stb_image.h:67:      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
../lib/public/stb_image.h:68:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
../lib/public/stb_image.h:69:      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
../lib/public/stb_image.h:70:                         RGB-format JPEG; remove white matting in PSD;
../lib/public/stb_image.h:73:      2.10  (2016-01-22) avoid warning introduced in 2.09
../lib/public/stb_image.h:74:      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED
../lib/public/stb_image.h:85:    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
../lib/public/stb_image.h:86:    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
../lib/public/stb_image.h:88:    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
../lib/public/stb_image.h:90:    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
../lib/public/stb_image.h:91:                                           socks-the-fox (16-bit PNG)
../lib/public/stb_image.h:93: Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
../lib/public/stb_image.h:94:    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
../lib/public/stb_image.h:95:    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
../lib/public/stb_image.h:96:    John-Mark Allen
../lib/public/stb_image.h:97:    Carmelo J Fdez-Aguera
../lib/public/stb_image.h:134://    - no 12-bit-per-channel JPEG
../lib/public/stb_image.h:135://    - no JPEGs with arithmetic coding
../lib/public/stb_image.h:136://    - GIF always returns *comp=4
../lib/public/stb_image.h:142://    // ... x = width, y = height, n = # 8-bit components per pixel ...
../lib/public/stb_image.h:148://    int *x                 -- outputs image width in pixels
../lib/public/stb_image.h:149://    int *y                 -- outputs image height in pixels
../lib/public/stb_image.h:150://    int *channels_in_file  -- outputs # of image components in image file
../lib/public/stb_image.h:151://    int desired_channels   -- if non-zero, # of image components requested in result
../lib/public/stb_image.h:156:// with each pixel consisting of N interleaved 8-bit components; the first
../lib/public/stb_image.h:157:// pixel pointed to is top-left-most in the image. There is no padding between
../lib/public/stb_image.h:159:// components N is 'desired_channels' if desired_channels is non-zero, or
../lib/public/stb_image.h:160:// *channels_in_file otherwise. If desired_channels is non-zero,
../lib/public/stb_image.h:177:// stbi_failure_reason() can be queried for an extremely brief, end-user
../lib/public/stb_image.h:180:// more user-friendly ones.
../lib/public/stb_image.h:217://   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
../lib/public/stb_image.h:231:// and for best performance I may provide less-easy-to-use APIs that give higher
../lib/public/stb_image.h:232:// performance, in addition to the easy-to-use ones. Nevertheless, it's important
../lib/public/stb_image.h:239://    - Portable ("ease of use")
../lib/public/stb_image.h:240://    - Small source code footprint ("easy to maintain")
../lib/public/stb_image.h:241://    - No dependencies ("ease of use")
../lib/public/stb_image.h:263:// (The old do-it-yourself SIMD API is no longer supported in the current
../lib/public/stb_image.h:266:// On x86, SSE2 will automatically be used when available based on a run-time
../lib/public/stb_image.h:267:// test; if not, the generic C versions are used as a fall-back. On ARM targets,
../lib/public/stb_image.h:268:// the typical path is to have separate builds for NEON and non-NEON devices
../lib/public/stb_image.h:304:// Finally, given a filename (or an open file or memory block--see header
../lib/public/stb_image.h:315:// We optionally support converting iPhone-formatted PNGs (which store
../lib/public/stb_image.h:323:// and only if iPhone convert-to-rgb processing is on).
../lib/public/stb_image.h:329://  - You can suppress implementation of any of the decoders to reduce
../lib/public/stb_image.h:343://  - You can request *only* certain decoders and suppress all other ones
../lib/public/stb_image.h:344://    (this will be more forward-compatible, as addition of new decoders
../lib/public/stb_image.h:357://   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
../lib/public/stb_image.h:360://  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
../lib/public/stb_image.h:363://    denial-of-service attacks on untrusted data, as one could generate a
../lib/public/stb_image.h:403:// PRIMARY API - works on images of any type
../lib/public/stb_image.h:413:   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
../lib/public/stb_image.h:419:// 8-bits-per-channel interface
../lib/public/stb_image.h:441:// 16-bits-per-channel interface
../lib/public/stb_image.h:454:// float-per-channel interface
../lib/public/stb_image.h:489:// free the loaded image -- this is just free()
../lib/public/stb_image.h:513:// or just pass them through "as-is"
../lib/public/stb_image.h:520:// this function is only available if your compiler supports thread-local variables;
../lib/public/stb_image.h:526:// ZLIB client - used by PNG, available for other purposes
../lib/public/stb_image.h:654:typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
../lib/public/stb_image.h:669:   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
../lib/public/stb_image.h:698:// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
../lib/public/stb_image.h:702:// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
../lib/public/stb_image.h:703:// New behavior: if compiled with -msse2, we use SSE2 without any
../lib/public/stb_image.h:709:// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
../lib/public/stb_image.h:711:// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
../lib/public/stb_image.h:713:// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
../lib/public/stb_image.h:714:// simultaneously enabling "-mstackrealign".
../lib/public/stb_image.h:718:// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
../lib/public/stb_image.h:719:// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
../lib/public/stb_image.h:760:#else // assume GCC-style if not VC++
../lib/public/stb_image.h:767:   // -msse2 is on, which means the compiler is allowed to use SSE2
../lib/public/stb_image.h:824:// initialize a memory-decode context
../lib/public/stb_image.h:827:   s->io.read = NULL;
../lib/public/stb_image.h:828:   s->read_from_callbacks = 0;
../lib/public/stb_image.h:829:   s->callback_already_read = 0;
../lib/public/stb_image.h:830:   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
../lib/public/stb_image.h:831:   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
../lib/public/stb_image.h:834:// initialize a callback-based context
../lib/public/stb_image.h:837:   s->io = *c;
../lib/public/stb_image.h:838:   s->io_user_data = user;
../lib/public/stb_image.h:839:   s->buflen = sizeof(s->buffer_start);
../lib/public/stb_image.h:840:   s->read_from_callbacks = 1;
../lib/public/stb_image.h:841:   s->callback_already_read = 0;
../lib/public/stb_image.h:842:   s->img_buffer = s->img_buffer_original = s->buffer_start;
../lib/public/stb_image.h:844:   s->img_buffer_original_end = s->img_buffer_end;
../lib/public/stb_image.h:890:   s->img_buffer = s->img_buffer_original;
../lib/public/stb_image.h:891:   s->img_buffer_end = s->img_buffer_original_end;
../lib/public/stb_image.h:991:// current code, even on 64-bit targets, is INT_MAX. this is not a
../lib/public/stb_image.h:996:// multiply integers together, making sure that they're non-negative
../lib/public/stb_image.h:1005:   // 0 <= INT_MAX - b <= INTMAX.
../lib/public/stb_image.h:1007:   // same as a <= INT_MAX - b (no overflow)
../lib/public/stb_image.h:1008:   return a <= INT_MAX - b;
../lib/public/stb_image.h:1016:   if (b == 0) return 1; // mul-by-0 is always safe
../lib/public/stb_image.h:1068:// stbi__err - error
../lib/public/stb_image.h:1069:// stbi__errpf - error returning pointer to float
../lib/public/stb_image.h:1070:// stbi__errpuc - error returning pointer to unsigned char
../lib/public/stb_image.h:1122:   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
../lib/public/stb_image.h:1123:   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
../lib/public/stb_image.h:1124:   ri->num_channels = 0;
../lib/public/stb_image.h:1182:      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
../lib/public/stb_image.h:1198:      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
../lib/public/stb_image.h:1213:      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
../lib/public/stb_image.h:1223:         bytes_left -= bytes_copy;
../lib/public/stb_image.h:1285:   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
../lib/public/stb_image.h:1315:	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
../lib/public/stb_image.h:1325:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
../lib/public/stb_image.h:1328:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
../lib/public/stb_image.h:1366:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
../lib/public/stb_image.h:1379:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
../lib/public/stb_image.h:1495:// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
../lib/public/stb_image.h:1581:   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
../lib/public/stb_image.h:1582:   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
../lib/public/stb_image.h:1585:      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
../lib/public/stb_image.h:1586:      s->read_from_callbacks = 0;
../lib/public/stb_image.h:1587:      s->img_buffer = s->buffer_start;
../lib/public/stb_image.h:1588:      s->img_buffer_end = s->buffer_start+1;
../lib/public/stb_image.h:1589:      *s->img_buffer = 0;
../lib/public/stb_image.h:1591:      s->img_buffer = s->buffer_start;
../lib/public/stb_image.h:1592:      s->img_buffer_end = s->buffer_start + n;
../lib/public/stb_image.h:1598:   if (s->img_buffer < s->img_buffer_end)
../lib/public/stb_image.h:1599:      return *s->img_buffer++;
../lib/public/stb_image.h:1600:   if (s->read_from_callbacks) {
../lib/public/stb_image.h:1602:      return *s->img_buffer++;
../lib/public/stb_image.h:1612:   if (s->io.read) {
../lib/public/stb_image.h:1613:      if (!(s->io.eof)(s->io_user_data)) return 0;
../lib/public/stb_image.h:1616:      if (s->read_from_callbacks == 0) return 1;
../lib/public/stb_image.h:1619:   return s->img_buffer >= s->img_buffer_end;
../lib/public/stb_image.h:1630:      s->img_buffer = s->img_buffer_end;
../lib/public/stb_image.h:1633:   if (s->io.read) {
../lib/public/stb_image.h:1634:      int blen = (int) (s->img_buffer_end - s->img_buffer);
../lib/public/stb_image.h:1636:         s->img_buffer = s->img_buffer_end;
../lib/public/stb_image.h:1637:         (s->io.skip)(s->io_user_data, n - blen);
../lib/public/stb_image.h:1641:   s->img_buffer += n;
../lib/public/stb_image.h:1650:   if (s->io.read) {
../lib/public/stb_image.h:1651:      int blen = (int) (s->img_buffer_end - s->img_buffer);
../lib/public/stb_image.h:1655:         memcpy(buffer, s->img_buffer, blen);
../lib/public/stb_image.h:1657:         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
../lib/public/stb_image.h:1658:         res = (count == (n-blen));
../lib/public/stb_image.h:1659:         s->img_buffer = s->img_buffer_end;
../lib/public/stb_image.h:1664:   if (s->img_buffer+n <= s->img_buffer_end) {
../lib/public/stb_image.h:1665:      memcpy(buffer, s->img_buffer, n);
../lib/public/stb_image.h:1666:      s->img_buffer += n;
../lib/public/stb_image.h:1719://  generic converter from built-in img_n to req_comp
../lib/public/stb_image.h:1756:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
../lib/public/stb_image.h:1813:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
../lib/public/stb_image.h:1847:   // compute number of non-alpha components
../lib/public/stb_image.h:1848:   if (comp & 1) n = comp; else n = comp-1;
../lib/public/stb_image.h:1873:   // compute number of non-alpha components
../lib/public/stb_image.h:1874:   if (comp & 1) n = comp; else n = comp-1;
../lib/public/stb_image.h:1899://      - doesn't support delayed output of y-dimension
../lib/public/stb_image.h:1900://      - simple interface (only one output format: 8-bit interleaved RGB)
../lib/public/stb_image.h:1901://      - doesn't try to recover corrupt jpegs
../lib/public/stb_image.h:1902://      - doesn't allow partial loading, loading multiple at once
../lib/public/stb_image.h:1903://      - still fast on x86 (copying globals into locals doesn't help x86)
../lib/public/stb_image.h:1904://      - allocates lots of intermediate memory (full size of all components)
../lib/public/stb_image.h:1905://        - non-interleaved case requires this anyway
../lib/public/stb_image.h:1906://        - allows good upsampling (see next)
../lib/public/stb_image.h:1907://    high-quality
../lib/public/stb_image.h:1908://      - upsampled channels are bilinearly interpolated, even across blocks
../lib/public/stb_image.h:1909://      - quality integer IDCT derived from IJG's 'slow'
../lib/public/stb_image.h:1911://      - fast huffman; reasonable integer IDCT
../lib/public/stb_image.h:1912://      - some SIMD kernels for common paths on targets with SSE2/NEON
../lib/public/stb_image.h:1913://      - uses a lot of intermediate memory, could cache poorly
../lib/public/stb_image.h:1928:   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
../lib/public/stb_image.h:1961:   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
../lib/public/stb_image.h:1992:         h->size[k++] = (stbi_uc) (i+1);
../lib/public/stb_image.h:1993:   h->size[k] = 0;
../lib/public/stb_image.h:2000:      h->delta[j] = k - code;
../lib/public/stb_image.h:2001:      if (h->size[k] == j) {
../lib/public/stb_image.h:2002:         while (h->size[k] == j)
../lib/public/stb_image.h:2003:            h->code[k++] = (stbi__uint16) (code++);
../lib/public/stb_image.h:2004:         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
../lib/public/stb_image.h:2007:      h->maxcode[j] = code << (16-j);
../lib/public/stb_image.h:2010:   h->maxcode[j] = 0xffffffff;
../lib/public/stb_image.h:2012:   // build non-spec acceleration table; 255 is flag for not-accelerated
../lib/public/stb_image.h:2013:   memset(h->fast, 255, 1 << FAST_BITS);
../lib/public/stb_image.h:2015:      int s = h->size[i];
../lib/public/stb_image.h:2017:         int c = h->code[i] << (FAST_BITS-s);
../lib/public/stb_image.h:2018:         int m = 1 << (FAST_BITS-s);
../lib/public/stb_image.h:2020:            h->fast[c+j] = (stbi_uc) i;
../lib/public/stb_image.h:2033:      stbi_uc fast = h->fast[i];
../lib/public/stb_image.h:2036:         int rs = h->values[fast];
../lib/public/stb_image.h:2039:         int len = h->size[fast];
../lib/public/stb_image.h:2043:            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
../lib/public/stb_image.h:2044:            int m = 1 << (magbits - 1);
../lib/public/stb_image.h:2047:            if (k >= -128 && k <= 127)
../lib/public/stb_image.h:2057:      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
../lib/public/stb_image.h:2059:         int c = stbi__get8(j->s);
../lib/public/stb_image.h:2060:         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
../lib/public/stb_image.h:2062:            j->marker = (unsigned char) c;
../lib/public/stb_image.h:2063:            j->nomore = 1;
../lib/public/stb_image.h:2067:      j->code_buffer |= b << (24 - j->code_bits);
../lib/public/stb_image.h:2068:      j->code_bits += 8;
../lib/public/stb_image.h:2069:   } while (j->code_bits <= 24);
../lib/public/stb_image.h:2072:// (1 << n) - 1
../lib/public/stb_image.h:2081:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2085:   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
../lib/public/stb_image.h:2086:   k = h->fast[c];
../lib/public/stb_image.h:2088:      int s = h->size[k];
../lib/public/stb_image.h:2089:      if (s > j->code_bits)
../lib/public/stb_image.h:2090:         return -1;
../lib/public/stb_image.h:2091:      j->code_buffer <<= s;
../lib/public/stb_image.h:2092:      j->code_bits -= s;
../lib/public/stb_image.h:2093:      return h->values[k];
../lib/public/stb_image.h:2098:   // preshifted maxcode left so that it has (16-k) 0s at the
../lib/public/stb_image.h:2102:   temp = j->code_buffer >> 16;
../lib/public/stb_image.h:2104:      if (temp < h->maxcode[k])
../lib/public/stb_image.h:2108:      j->code_bits -= 16;
../lib/public/stb_image.h:2109:      return -1;
../lib/public/stb_image.h:2112:   if (k > j->code_bits)
../lib/public/stb_image.h:2113:      return -1;
../lib/public/stb_image.h:2116:   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
../lib/public/stb_image.h:2117:   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
../lib/public/stb_image.h:2120:   j->code_bits -= k;
../lib/public/stb_image.h:2121:   j->code_buffer <<= k;
../lib/public/stb_image.h:2122:   return h->values[c];
../lib/public/stb_image.h:2125:// bias[n] = (-1<<n) + 1
../lib/public/stb_image.h:2126:static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
../lib/public/stb_image.h:2134:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2136:   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
../lib/public/stb_image.h:2137:   k = stbi_lrot(j->code_buffer, n);
../lib/public/stb_image.h:2138:   j->code_buffer = k & ~stbi__bmask[n];
../lib/public/stb_image.h:2140:   j->code_bits -= n;
../lib/public/stb_image.h:2141:   return k + (stbi__jbias[n] & (sgn - 1));
../lib/public/stb_image.h:2148:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2149:   k = stbi_lrot(j->code_buffer, n);
../lib/public/stb_image.h:2150:   j->code_buffer = k & ~stbi__bmask[n];
../lib/public/stb_image.h:2152:   j->code_bits -= n;
../lib/public/stb_image.h:2159:   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2160:   k = j->code_buffer;
../lib/public/stb_image.h:2161:   j->code_buffer <<= 1;
../lib/public/stb_image.h:2162:   --j->code_bits;
../lib/public/stb_image.h:2167:// where does it appear in the 8x8 matrix coded as row-major?
../lib/public/stb_image.h:2183:// decode one 64-entry block--
../lib/public/stb_image.h:2189:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2193:   // 0 all the ac values now so we can do it 32-bits at a time
../lib/public/stb_image.h:2197:   dc = j->img_comp[b].dc_pred + diff;
../lib/public/stb_image.h:2198:   j->img_comp[b].dc_pred = dc;
../lib/public/stb_image.h:2206:      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2207:      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
../lib/public/stb_image.h:2209:      if (r) { // fast-AC path
../lib/public/stb_image.h:2212:         j->code_buffer <<= s;
../lib/public/stb_image.h:2213:         j->code_bits -= s;
../lib/public/stb_image.h:2240:   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
../lib/public/stb_image.h:2242:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2244:   if (j->succ_high == 0) {
../lib/public/stb_image.h:2251:      dc = j->img_comp[b].dc_pred + diff;
../lib/public/stb_image.h:2252:      j->img_comp[b].dc_pred = dc;
../lib/public/stb_image.h:2253:      data[0] = (short) (dc * (1 << j->succ_low));
../lib/public/stb_image.h:2257:         data[0] += (short) (1 << j->succ_low);
../lib/public/stb_image.h:2262:// @OPTIMIZE: store non-zigzagged during the decode passes,
../lib/public/stb_image.h:2263:// and only de-zigzag when dequantizing
../lib/public/stb_image.h:2267:   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
../lib/public/stb_image.h:2269:   if (j->succ_high == 0) {
../lib/public/stb_image.h:2270:      int shift = j->succ_low;
../lib/public/stb_image.h:2272:      if (j->eob_run) {
../lib/public/stb_image.h:2273:         --j->eob_run;
../lib/public/stb_image.h:2277:      k = j->spec_start;
../lib/public/stb_image.h:2281:         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
../lib/public/stb_image.h:2282:         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
../lib/public/stb_image.h:2284:         if (r) { // fast-AC path
../lib/public/stb_image.h:2287:            j->code_buffer <<= s;
../lib/public/stb_image.h:2288:            j->code_bits -= s;
../lib/public/stb_image.h:2298:                  j->eob_run = (1 << r);
../lib/public/stb_image.h:2300:                     j->eob_run += stbi__jpeg_get_bits(j, r);
../lib/public/stb_image.h:2301:                  --j->eob_run;
../lib/public/stb_image.h:2311:      } while (k <= j->spec_end);
../lib/public/stb_image.h:2315:      short bit = (short) (1 << j->succ_low);
../lib/public/stb_image.h:2317:      if (j->eob_run) {
../lib/public/stb_image.h:2318:         --j->eob_run;
../lib/public/stb_image.h:2319:         for (k = j->spec_start; k <= j->spec_end; ++k) {
../lib/public/stb_image.h:2327:                        *p -= bit;
../lib/public/stb_image.h:2331:         k = j->spec_start;
../lib/public/stb_image.h:2334:            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
../lib/public/stb_image.h:2340:                  j->eob_run = (1 << r) - 1;
../lib/public/stb_image.h:2342:                     j->eob_run += stbi__jpeg_get_bits(j, r);
../lib/public/stb_image.h:2355:                  s = -bit;
../lib/public/stb_image.h:2359:            while (k <= j->spec_end) {
../lib/public/stb_image.h:2367:                           *p -= bit;
../lib/public/stb_image.h:2374:                  --r;
../lib/public/stb_image.h:2377:         } while (k <= j->spec_end);
../lib/public/stb_image.h:2383:// take a -128..127 value and stbi__clamp it and convert to 0..255
../lib/public/stb_image.h:2397:// derived from jidctint -- DCT_ISLOW
../lib/public/stb_image.h:2403:   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
../lib/public/stb_image.h:2408:   t1 = stbi__fsh(p2-p3);                      \
../lib/public/stb_image.h:2410:   x3 = t0-t3;                                 \
../lib/public/stb_image.h:2412:   x2 = t1-t2;                                 \
../lib/public/stb_image.h:2426:   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
../lib/public/stb_image.h:2427:   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
../lib/public/stb_image.h:2428:   p3 = p3*stbi__f2f(-1.961570560f);           \
../lib/public/stb_image.h:2429:   p4 = p4*stbi__f2f(-0.390180644f);           \
../lib/public/stb_image.h:2443:      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
../lib/public/stb_image.h:2448:         //    all separate               -0.047 seconds
../lib/public/stb_image.h:2449:         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
../lib/public/stb_image.h:2458:         v[56] = (x0-t3) >> 10;
../lib/public/stb_image.h:2460:         v[48] = (x1-t2) >> 10;
../lib/public/stb_image.h:2462:         v[40] = (x2-t1) >> 10;
../lib/public/stb_image.h:2464:         v[32] = (x3-t0) >> 10;
../lib/public/stb_image.h:2475:      // aka 65536. Also, we'll end up with -128 to 127 that we want
../lib/public/stb_image.h:2484:      o[7] = stbi__clamp((x0-t3) >> 17);
../lib/public/stb_image.h:2486:      o[6] = stbi__clamp((x1-t2) >> 17);
../lib/public/stb_image.h:2488:      o[5] = stbi__clamp((x2-t1) >> 17);
../lib/public/stb_image.h:2490:      o[4] = stbi__clamp((x3-t0) >> 17);
../lib/public/stb_image.h:2496:// produces bit-identical results to the generic C version so it's
../lib/public/stb_image.h:2507:   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
../lib/public/stb_image.h:2517:   // out = in << 12  (in 16-bit, out 32-bit)
../lib/public/stb_image.h:2543:   // 8-bit interleave step (for transposes)
../lib/public/stb_image.h:2549:   // 16-bit interleave step (for transposes)
../lib/public/stb_image.h:2583:   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
../lib/public/stb_image.h:2585:   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
../lib/public/stb_image.h:2586:   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
../lib/public/stb_image.h:2587:   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
../lib/public/stb_image.h:2588:   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
../lib/public/stb_image.h:2589:   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
../lib/public/stb_image.h:2590:   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
../lib/public/stb_image.h:2677:// NEON integer IDCT. should produce bit-identical
../lib/public/stb_image.h:2684:   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
../lib/public/stb_image.h:2687:   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
../lib/public/stb_image.h:2688:   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
../lib/public/stb_image.h:2689:   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
../lib/public/stb_image.h:2690:   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
../lib/public/stb_image.h:2816:   // 17. so do a non-rounding shift of 16 first then follow
../lib/public/stb_image.h:2839:      // 8x8 8-bit transpose pass 1
../lib/public/stb_image.h:2890:   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
../lib/public/stb_image.h:2891:   x = stbi__get8(j->s);
../lib/public/stb_image.h:2894:      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
../lib/public/stb_image.h:2906:   j->code_bits = 0;
../lib/public/stb_image.h:2907:   j->code_buffer = 0;
../lib/public/stb_image.h:2908:   j->nomore = 0;
../lib/public/stb_image.h:2909:   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
../lib/public/stb_image.h:2910:   j->marker = STBI__MARKER_none;
../lib/public/stb_image.h:2911:   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
../lib/public/stb_image.h:2912:   j->eob_run = 0;
../lib/public/stb_image.h:2920:   if (!z->progressive) {
../lib/public/stb_image.h:2921:      if (z->scan_n == 1) {
../lib/public/stb_image.h:2924:         int n = z->order[0];
../lib/public/stb_image.h:2925:         // non-interleaved data, we just need to process one block at a time,
../lib/public/stb_image.h:2929:         int w = (z->img_comp[n].x+7) >> 3;
../lib/public/stb_image.h:2930:         int h = (z->img_comp[n].y+7) >> 3;
../lib/public/stb_image.h:2933:               int ha = z->img_comp[n].ha;
../lib/public/stb_image.h:2934:               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
../lib/public/stb_image.h:2935:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
../lib/public/stb_image.h:2937:               if (--z->todo <= 0) {
../lib/public/stb_image.h:2938:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
../lib/public/stb_image.h:2941:                  if (!STBI__RESTART(z->marker)) return 1;
../lib/public/stb_image.h:2950:         for (j=0; j < z->img_mcu_y; ++j) {
../lib/public/stb_image.h:2951:            for (i=0; i < z->img_mcu_x; ++i) {
../lib/public/stb_image.h:2953:               for (k=0; k < z->scan_n; ++k) {
../lib/public/stb_image.h:2954:                  int n = z->order[k];
../lib/public/stb_image.h:2957:                  for (y=0; y < z->img_comp[n].v; ++y) {
../lib/public/stb_image.h:2958:                     for (x=0; x < z->img_comp[n].h; ++x) {
../lib/public/stb_image.h:2959:                        int x2 = (i*z->img_comp[n].h + x)*8;
../lib/public/stb_image.h:2960:                        int y2 = (j*z->img_comp[n].v + y)*8;
../lib/public/stb_image.h:2961:                        int ha = z->img_comp[n].ha;
../lib/public/stb_image.h:2962:                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
../lib/public/stb_image.h:2963:                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
../lib/public/stb_image.h:2969:               if (--z->todo <= 0) {
../lib/public/stb_image.h:2970:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
../lib/public/stb_image.h:2971:                  if (!STBI__RESTART(z->marker)) return 1;
../lib/public/stb_image.h:2979:      if (z->scan_n == 1) {
../lib/public/stb_image.h:2981:         int n = z->order[0];
../lib/public/stb_image.h:2982:         // non-interleaved data, we just need to process one block at a time,
../lib/public/stb_image.h:2986:         int w = (z->img_comp[n].x+7) >> 3;
../lib/public/stb_image.h:2987:         int h = (z->img_comp[n].y+7) >> 3;
../lib/public/stb_image.h:2990:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
../lib/public/stb_image.h:2991:               if (z->spec_start == 0) {
../lib/public/stb_image.h:2992:                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
../lib/public/stb_image.h:2995:                  int ha = z->img_comp[n].ha;
../lib/public/stb_image.h:2996:                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
../lib/public/stb_image.h:3000:               if (--z->todo <= 0) {
../lib/public/stb_image.h:3001:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
../lib/public/stb_image.h:3002:                  if (!STBI__RESTART(z->marker)) return 1;
../lib/public/stb_image.h:3010:         for (j=0; j < z->img_mcu_y; ++j) {
../lib/public/stb_image.h:3011:            for (i=0; i < z->img_mcu_x; ++i) {
../lib/public/stb_image.h:3013:               for (k=0; k < z->scan_n; ++k) {
../lib/public/stb_image.h:3014:                  int n = z->order[k];
../lib/public/stb_image.h:3017:                  for (y=0; y < z->img_comp[n].v; ++y) {
../lib/public/stb_image.h:3018:                     for (x=0; x < z->img_comp[n].h; ++x) {
../lib/public/stb_image.h:3019:                        int x2 = (i*z->img_comp[n].h + x);
../lib/public/stb_image.h:3020:                        int y2 = (j*z->img_comp[n].v + y);
../lib/public/stb_image.h:3021:                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
../lib/public/stb_image.h:3022:                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
../lib/public/stb_image.h:3029:               if (--z->todo <= 0) {
../lib/public/stb_image.h:3030:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
../lib/public/stb_image.h:3031:                  if (!STBI__RESTART(z->marker)) return 1;
../lib/public/stb_image.h:3050:   if (z->progressive) {
../lib/public/stb_image.h:3053:      for (n=0; n < z->s->img_n; ++n) {
../lib/public/stb_image.h:3054:         int w = (z->img_comp[n].x+7) >> 3;
../lib/public/stb_image.h:3055:         int h = (z->img_comp[n].y+7) >> 3;
../lib/public/stb_image.h:3058:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
../lib/public/stb_image.h:3059:               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
../lib/public/stb_image.h:3060:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
../lib/public/stb_image.h:3074:      case 0xDD: // DRI - specify restart interval
../lib/public/stb_image.h:3075:         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
../lib/public/stb_image.h:3076:         z->restart_interval = stbi__get16be(z->s);
../lib/public/stb_image.h:3079:      case 0xDB: // DQT - define quantization table
../lib/public/stb_image.h:3080:         L = stbi__get16be(z->s)-2;
../lib/public/stb_image.h:3082:            int q = stbi__get8(z->s);
../lib/public/stb_image.h:3089:               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
../lib/public/stb_image.h:3090:            L -= (sixteen ? 129 : 65);
../lib/public/stb_image.h:3094:      case 0xC4: // DHT - define huffman table
../lib/public/stb_image.h:3095:         L = stbi__get16be(z->s)-2;
../lib/public/stb_image.h:3099:            int q = stbi__get8(z->s);
../lib/public/stb_image.h:3104:               sizes[i] = stbi__get8(z->s);
../lib/public/stb_image.h:3107:            L -= 17;
../lib/public/stb_image.h:3109:               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
../lib/public/stb_image.h:3110:               v = z->huff_dc[th].values;
../lib/public/stb_image.h:3112:               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
../lib/public/stb_image.h:3113:               v = z->huff_ac[th].values;
../lib/public/stb_image.h:3116:               v[i] = stbi__get8(z->s);
../lib/public/stb_image.h:3118:               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
../lib/public/stb_image.h:3119:            L -= n;
../lib/public/stb_image.h:3126:      L = stbi__get16be(z->s);
../lib/public/stb_image.h:3133:      L -= 2;
../lib/public/stb_image.h:3140:            if (stbi__get8(z->s) != tag[i])
../lib/public/stb_image.h:3142:         L -= 5;
../lib/public/stb_image.h:3144:            z->jfif = 1;
../lib/public/stb_image.h:3150:            if (stbi__get8(z->s) != tag[i])
../lib/public/stb_image.h:3152:         L -= 6;
../lib/public/stb_image.h:3154:            stbi__get8(z->s); // version
../lib/public/stb_image.h:3155:            stbi__get16be(z->s); // flags0
../lib/public/stb_image.h:3156:            stbi__get16be(z->s); // flags1
../lib/public/stb_image.h:3157:            z->app14_color_transform = stbi__get8(z->s); // color transform
../lib/public/stb_image.h:3158:            L -= 6;
../lib/public/stb_image.h:3162:      stbi__skip(z->s, L);
../lib/public/stb_image.h:3173:   int Ls = stbi__get16be(z->s);
../lib/public/stb_image.h:3174:   z->scan_n = stbi__get8(z->s);
../lib/public/stb_image.h:3175:   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
../lib/public/stb_image.h:3176:   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
../lib/public/stb_image.h:3177:   for (i=0; i < z->scan_n; ++i) {
../lib/public/stb_image.h:3178:      int id = stbi__get8(z->s), which;
../lib/public/stb_image.h:3179:      int q = stbi__get8(z->s);
../lib/public/stb_image.h:3180:      for (which = 0; which < z->s->img_n; ++which)
../lib/public/stb_image.h:3181:         if (z->img_comp[which].id == id)
../lib/public/stb_image.h:3183:      if (which == z->s->img_n) return 0; // no match
../lib/public/stb_image.h:3184:      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
../lib/public/stb_image.h:3185:      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
../lib/public/stb_image.h:3186:      z->order[i] = which;
../lib/public/stb_image.h:3191:      z->spec_start = stbi__get8(z->s);
../lib/public/stb_image.h:3192:      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
../lib/public/stb_image.h:3193:      aa = stbi__get8(z->s);
../lib/public/stb_image.h:3194:      z->succ_high = (aa >> 4);
../lib/public/stb_image.h:3195:      z->succ_low  = (aa & 15);
../lib/public/stb_image.h:3196:      if (z->progressive) {
../lib/public/stb_image.h:3197:         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
../lib/public/stb_image.h:3200:         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
../lib/public/stb_image.h:3201:         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
../lib/public/stb_image.h:3202:         z->spec_end = 63;
../lib/public/stb_image.h:3213:      if (z->img_comp[i].raw_data) {
../lib/public/stb_image.h:3214:         STBI_FREE(z->img_comp[i].raw_data);
../lib/public/stb_image.h:3215:         z->img_comp[i].raw_data = NULL;
../lib/public/stb_image.h:3216:         z->img_comp[i].data = NULL;
../lib/public/stb_image.h:3218:      if (z->img_comp[i].raw_coeff) {
../lib/public/stb_image.h:3219:         STBI_FREE(z->img_comp[i].raw_coeff);
../lib/public/stb_image.h:3220:         z->img_comp[i].raw_coeff = 0;
../lib/public/stb_image.h:3221:         z->img_comp[i].coeff = 0;
../lib/public/stb_image.h:3223:      if (z->img_comp[i].linebuf) {
../lib/public/stb_image.h:3224:         STBI_FREE(z->img_comp[i].linebuf);
../lib/public/stb_image.h:3225:         z->img_comp[i].linebuf = NULL;
../lib/public/stb_image.h:3233:   stbi__context *s = z->s;
../lib/public/stb_image.h:3236:   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
../lib/public/stb_image.h:3237:   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
../lib/public/stb_image.h:3238:   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
../lib/public/stb_image.h:3239:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:3240:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:3243:   s->img_n = c;
../lib/public/stb_image.h:3245:      z->img_comp[i].data = NULL;
../lib/public/stb_image.h:3246:      z->img_comp[i].linebuf = NULL;
../lib/public/stb_image.h:3249:   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
../lib/public/stb_image.h:3251:   z->rgb = 0;
../lib/public/stb_image.h:3252:   for (i=0; i < s->img_n; ++i) {
../lib/public/stb_image.h:3254:      z->img_comp[i].id = stbi__get8(s);
../lib/public/stb_image.h:3255:      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
../lib/public/stb_image.h:3256:         ++z->rgb;
../lib/public/stb_image.h:3258:      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
../lib/public/stb_image.h:3259:      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
../lib/public/stb_image.h:3260:      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
../lib/public/stb_image.h:3265:   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
../lib/public/stb_image.h:3267:   for (i=0; i < s->img_n; ++i) {
../lib/public/stb_image.h:3268:      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
../lib/public/stb_image.h:3269:      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
../lib/public/stb_image.h:3273:   // and I've never seen a non-corrupted JPEG file actually use them
../lib/public/stb_image.h:3274:   for (i=0; i < s->img_n; ++i) {
../lib/public/stb_image.h:3275:      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
../lib/public/stb_image.h:3276:      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
../lib/public/stb_image.h:3280:   z->img_h_max = h_max;
../lib/public/stb_image.h:3281:   z->img_v_max = v_max;
../lib/public/stb_image.h:3282:   z->img_mcu_w = h_max * 8;
../lib/public/stb_image.h:3283:   z->img_mcu_h = v_max * 8;
../lib/public/stb_image.h:3285:   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
../lib/public/stb_image.h:3286:   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
../lib/public/stb_image.h:3288:   for (i=0; i < s->img_n; ++i) {
../lib/public/stb_image.h:3289:      // number of effective pixels (e.g. for non-interleaved MCU)
../lib/public/stb_image.h:3290:      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
../lib/public/stb_image.h:3291:      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
../lib/public/stb_image.h:3298:      // so these muls can't overflow with 32-bit ints (which we require)
../lib/public/stb_image.h:3299:      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
../lib/public/stb_image.h:3300:      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
../lib/public/stb_image.h:3301:      z->img_comp[i].coeff = 0;
../lib/public/stb_image.h:3302:      z->img_comp[i].raw_coeff = 0;
../lib/public/stb_image.h:3303:      z->img_comp[i].linebuf = NULL;
../lib/public/stb_image.h:3304:      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
../lib/public/stb_image.h:3305:      if (z->img_comp[i].raw_data == NULL)
../lib/public/stb_image.h:3308:      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
../lib/public/stb_image.h:3309:      if (z->progressive) {
../lib/public/stb_image.h:3311:         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
../lib/public/stb_image.h:3312:         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
../lib/public/stb_image.h:3313:         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
../lib/public/stb_image.h:3314:         if (z->img_comp[i].raw_coeff == NULL)
../lib/public/stb_image.h:3316:         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
../lib/public/stb_image.h:3335:   z->jfif = 0;
../lib/public/stb_image.h:3336:   z->app14_color_transform = -1; // valid values are 0,1,2
../lib/public/stb_image.h:3337:   z->marker = STBI__MARKER_none; // initialize cached marker to empty
../lib/public/stb_image.h:3347:         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
../lib/public/stb_image.h:3351:   z->progressive = stbi__SOF_progressive(m);
../lib/public/stb_image.h:3361:      j->img_comp[m].raw_data = NULL;
../lib/public/stb_image.h:3362:      j->img_comp[m].raw_coeff = NULL;
../lib/public/stb_image.h:3364:   j->restart_interval = 0;
../lib/public/stb_image.h:3371:         if (j->marker == STBI__MARKER_none ) {
../lib/public/stb_image.h:3373:            while (!stbi__at_eof(j->s)) {
../lib/public/stb_image.h:3374:               int x = stbi__get8(j->s);
../lib/public/stb_image.h:3376:                  j->marker = stbi__get8(j->s);
../lib/public/stb_image.h:3383:         int Ld = stbi__get16be(j->s);
../lib/public/stb_image.h:3384:         stbi__uint32 NL = stbi__get16be(j->s);
../lib/public/stb_image.h:3386:         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
../lib/public/stb_image.h:3392:   if (j->progressive)
../lib/public/stb_image.h:3397:// static jfif-centered resampling (across block boundaries)
../lib/public/stb_image.h:3437:   for (i=1; i < w-1; ++i) {
../lib/public/stb_image.h:3439:      out[i*2+0] = stbi__div4(n+input[i-1]);
../lib/public/stb_image.h:3442:   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
../lib/public/stb_image.h:3443:   out[i*2+1] = input[w-1];
../lib/public/stb_image.h:3467:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
../lib/public/stb_image.h:3470:   out[w*2-1] = stbi__div4(t1+2);
../lib/public/stb_image.h:3492:   for (; i < ((w-1) & ~7); i += 8) {
../lib/public/stb_image.h:3495:      // this uses 3*x + y = 4*x + (y - x)
../lib/public/stb_image.h:3516:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
../lib/public/stb_image.h:3517:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
../lib/public/stb_image.h:3538:      // this uses 3*x + y = 4*x + (y - x)
../lib/public/stb_image.h:3556:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
../lib/public/stb_image.h:3557:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
../lib/public/stb_image.h:3583:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
../lib/public/stb_image.h:3586:   out[w*2-1] = stbi__div4(t1+2);
../lib/public/stb_image.h:3596:   // resample with nearest-neighbor
../lib/public/stb_image.h:3605:// this is a reduced-precision calculation of YCbCr-to-RGB introduced
../lib/public/stb_image.h:3614:      int cr = pcr[i] - 128;
../lib/public/stb_image.h:3615:      int cb = pcb[i] - 128;
../lib/public/stb_image.h:3617:      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
../lib/public/stb_image.h:3643:      // this is a fairly straightforward implementation and not super-optimized.
../lib/public/stb_image.h:3644:      __m128i signflip  = _mm_set1_epi8(-0x80);
../lib/public/stb_image.h:3646:      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
../lib/public/stb_image.h:3647:      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
../lib/public/stb_image.h:3657:         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
../lib/public/stb_image.h:3658:         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
../lib/public/stb_image.h:3660:         // unpack to short (and left-shift cr, cb by 8)
../lib/public/stb_image.h:3702:      // this is a fairly straightforward implementation and not super-optimized.
../lib/public/stb_image.h:3705:      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
../lib/public/stb_image.h:3706:      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
../lib/public/stb_image.h:3748:      int cr = pcr[i] - 128;
../lib/public/stb_image.h:3749:      int cb = pcb[i] - 128;
../lib/public/stb_image.h:3751:      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
../lib/public/stb_image.h:3771:   j->idct_block_kernel = stbi__idct_block;
../lib/public/stb_image.h:3772:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
../lib/public/stb_image.h:3773:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
../lib/public/stb_image.h:3777:      j->idct_block_kernel = stbi__idct_simd;
../lib/public/stb_image.h:3778:      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
../lib/public/stb_image.h:3779:      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
../lib/public/stb_image.h:3784:   j->idct_block_kernel = stbi__idct_simd;
../lib/public/stb_image.h:3785:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
../lib/public/stb_image.h:3786:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
../lib/public/stb_image.h:3793:   stbi__free_jpeg_components(j, j->s->img_n, 0);
../lib/public/stb_image.h:3801:   int w_lores; // horizontal pixels pre-expansion
../lib/public/stb_image.h:3803:   int ypos;    // which pre-expansion row we're on
../lib/public/stb_image.h:3816:   z->s->img_n = 0; // make stbi__cleanup_jpeg safe
../lib/public/stb_image.h:3825:   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
../lib/public/stb_image.h:3827:   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
../lib/public/stb_image.h:3829:   if (z->s->img_n == 3 && n < 3 && !is_rgb)
../lib/public/stb_image.h:3832:      decode_n = z->s->img_n;
../lib/public/stb_image.h:3838:   // resample and color-convert
../lib/public/stb_image.h:3852:         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
../lib/public/stb_image.h:3853:         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
../lib/public/stb_image.h:3855:         r->hs      = z->img_h_max / z->img_comp[k].h;
../lib/public/stb_image.h:3856:         r->vs      = z->img_v_max / z->img_comp[k].v;
../lib/public/stb_image.h:3857:         r->ystep   = r->vs >> 1;
../lib/public/stb_image.h:3858:         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
../lib/public/stb_image.h:3859:         r->ypos    = 0;
../lib/public/stb_image.h:3860:         r->line0   = r->line1 = z->img_comp[k].data;
../lib/public/stb_image.h:3862:         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
../lib/public/stb_image.h:3863:         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
../lib/public/stb_image.h:3864:         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
../lib/public/stb_image.h:3865:         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
../lib/public/stb_image.h:3866:         else                               r->resample = stbi__resample_row_generic;
../lib/public/stb_image.h:3870:      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
../lib/public/stb_image.h:3874:      for (j=0; j < z->s->img_y; ++j) {
../lib/public/stb_image.h:3875:         stbi_uc *out = output + n * z->s->img_x * j;
../lib/public/stb_image.h:3878:            int y_bot = r->ystep >= (r->vs >> 1);
../lib/public/stb_image.h:3879:            coutput[k] = r->resample(z->img_comp[k].linebuf,
../lib/public/stb_image.h:3880:                                     y_bot ? r->line1 : r->line0,
../lib/public/stb_image.h:3881:                                     y_bot ? r->line0 : r->line1,
../lib/public/stb_image.h:3882:                                     r->w_lores, r->hs);
../lib/public/stb_image.h:3883:            if (++r->ystep >= r->vs) {
../lib/public/stb_image.h:3884:               r->ystep = 0;
../lib/public/stb_image.h:3885:               r->line0 = r->line1;
../lib/public/stb_image.h:3886:               if (++r->ypos < z->img_comp[k].y)
../lib/public/stb_image.h:3887:                  r->line1 += z->img_comp[k].w2;
../lib/public/stb_image.h:3892:            if (z->s->img_n == 3) {
../lib/public/stb_image.h:3894:                  for (i=0; i < z->s->img_x; ++i) {
../lib/public/stb_image.h:3902:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
../lib/public/stb_image.h:3904:            } else if (z->s->img_n == 4) {
../lib/public/stb_image.h:3905:               if (z->app14_color_transform == 0) { // CMYK
../lib/public/stb_image.h:3906:                  for (i=0; i < z->s->img_x; ++i) {
../lib/public/stb_image.h:3914:               } else if (z->app14_color_transform == 2) { // YCCK
../lib/public/stb_image.h:3915:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
../lib/public/stb_image.h:3916:                  for (i=0; i < z->s->img_x; ++i) {
../lib/public/stb_image.h:3918:                     out[0] = stbi__blinn_8x8(255 - out[0], m);
../lib/public/stb_image.h:3919:                     out[1] = stbi__blinn_8x8(255 - out[1], m);
../lib/public/stb_image.h:3920:                     out[2] = stbi__blinn_8x8(255 - out[2], m);
../lib/public/stb_image.h:3924:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
../lib/public/stb_image.h:3927:               for (i=0; i < z->s->img_x; ++i) {
../lib/public/stb_image.h:3935:                  for (i=0; i < z->s->img_x; ++i)
../lib/public/stb_image.h:3938:                  for (i=0; i < z->s->img_x; ++i, out += 2) {
../lib/public/stb_image.h:3943:            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
../lib/public/stb_image.h:3944:               for (i=0; i < z->s->img_x; ++i) {
../lib/public/stb_image.h:3953:            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
../lib/public/stb_image.h:3954:               for (i=0; i < z->s->img_x; ++i) {
../lib/public/stb_image.h:3955:                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
../lib/public/stb_image.h:3962:                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
../lib/public/stb_image.h:3964:                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
../lib/public/stb_image.h:3969:      *out_x = z->s->img_x;
../lib/public/stb_image.h:3970:      *out_y = z->s->img_y;
../lib/public/stb_image.h:3971:      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
../lib/public/stb_image.h:3982:   j->s = s;
../lib/public/stb_image.h:3994:   j->s = s;
../lib/public/stb_image.h:4005:      stbi__rewind( j->s );
../lib/public/stb_image.h:4008:   if (x) *x = j->s->img_x;
../lib/public/stb_image.h:4009:   if (y) *y = j->s->img_y;
../lib/public/stb_image.h:4010:   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
../lib/public/stb_image.h:4019:   j->s = s;
../lib/public/stb_image.h:4026:// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
../lib/public/stb_image.h:4028://      - all input must be provided in an upfront buffer
../lib/public/stb_image.h:4029://      - all output is written to a single output buffer (can malloc/realloc)
../lib/public/stb_image.h:4031://      - fast huffman
../lib/public/stb_image.h:4035:// fast-way is faster to check than jpeg huffman, but slow way is slower
../lib/public/stb_image.h:4037:#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
../lib/public/stb_image.h:4040:// zlib-style huffman encoding
../lib/public/stb_image.h:4066:   return stbi__bitreverse16(v) >> (16-bits);
../lib/public/stb_image.h:4076:   memset(z->fast, 0, sizeof(z->fast));
../lib/public/stb_image.h:4086:      z->firstcode[i] = (stbi__uint16) code;
../lib/public/stb_image.h:4087:      z->firstsymbol[i] = (stbi__uint16) k;
../lib/public/stb_image.h:4090:         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
../lib/public/stb_image.h:4091:      z->maxcode[i] = code << (16-i); // preshift for inner loop
../lib/public/stb_image.h:4095:   z->maxcode[16] = 0x10000; // sentinel
../lib/public/stb_image.h:4099:         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
../lib/public/stb_image.h:4101:         z->size [c] = (stbi_uc     ) s;
../lib/public/stb_image.h:4102:         z->value[c] = (stbi__uint16) i;
../lib/public/stb_image.h:4106:               z->fast[j] = fastv;
../lib/public/stb_image.h:4116:// zlib-from-memory implementation for PNG reading
../lib/public/stb_image.h:4138:   return (z->zbuffer >= z->zbuffer_end);
../lib/public/stb_image.h:4143:   return stbi__zeof(z) ? 0 : *z->zbuffer++;
../lib/public/stb_image.h:4149:      if (z->code_buffer >= (1U << z->num_bits)) {
../lib/public/stb_image.h:4150:        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
../lib/public/stb_image.h:4153:      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
../lib/public/stb_image.h:4154:      z->num_bits += 8;
../lib/public/stb_image.h:4155:   } while (z->num_bits <= 24);
../lib/public/stb_image.h:4161:   if (z->num_bits < n) stbi__fill_bits(z);
../lib/public/stb_image.h:4162:   k = z->code_buffer & ((1 << n) - 1);
../lib/public/stb_image.h:4163:   z->code_buffer >>= n;
../lib/public/stb_image.h:4164:   z->num_bits -= n;
../lib/public/stb_image.h:4173:   k = stbi__bit_reverse(a->code_buffer, 16);
../lib/public/stb_image.h:4175:      if (k < z->maxcode[s])
../lib/public/stb_image.h:4177:   if (s >= 16) return -1; // invalid code!
../lib/public/stb_image.h:4179:   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
../lib/public/stb_image.h:4180:   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
../lib/public/stb_image.h:4181:   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
../lib/public/stb_image.h:4182:   a->code_buffer >>= s;
../lib/public/stb_image.h:4183:   a->num_bits -= s;
../lib/public/stb_image.h:4184:   return z->value[b];
../lib/public/stb_image.h:4190:   if (a->num_bits < 16) {
../lib/public/stb_image.h:4192:         return -1;   /* report error for unexpected end of data. */
../lib/public/stb_image.h:4196:   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
../lib/public/stb_image.h:4199:      a->code_buffer >>= s;
../lib/public/stb_image.h:4200:      a->num_bits -= s;
../lib/public/stb_image.h:4210:   z->zout = zout;
../lib/public/stb_image.h:4211:   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
../lib/public/stb_image.h:4212:   cur   = (unsigned int) (z->zout - z->zout_start);
../lib/public/stb_image.h:4213:   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
../lib/public/stb_image.h:4214:   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
../lib/public/stb_image.h:4219:   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
../lib/public/stb_image.h:4222:   z->zout_start = q;
../lib/public/stb_image.h:4223:   z->zout       = q + cur;
../lib/public/stb_image.h:4224:   z->zout_end   = q + limit;
../lib/public/stb_image.h:4244:   char *zout = a->zout;
../lib/public/stb_image.h:4246:      int z = stbi__zhuffman_decode(a, &a->z_length);
../lib/public/stb_image.h:4249:         if (zout >= a->zout_end) {
../lib/public/stb_image.h:4251:            zout = a->zout;
../lib/public/stb_image.h:4258:            a->zout = zout;
../lib/public/stb_image.h:4261:         z -= 257;
../lib/public/stb_image.h:4264:         z = stbi__zhuffman_decode(a, &a->z_distance);
../lib/public/stb_image.h:4268:         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
../lib/public/stb_image.h:4269:         if (zout + len > a->zout_end) {
../lib/public/stb_image.h:4271:            zout = a->zout;
../lib/public/stb_image.h:4273:         p = (stbi_uc *) (zout - dist);
../lib/public/stb_image.h:4276:            if (len) { do *zout++ = v; while (--len); }
../lib/public/stb_image.h:4278:            if (len) { do *zout++ = *p++; while (--len); }
../lib/public/stb_image.h:4315:            fill = lencodes[n-1];
../lib/public/stb_image.h:4323:         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
../lib/public/stb_image.h:4329:   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
../lib/public/stb_image.h:4330:   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
../lib/public/stb_image.h:4338:   if (a->num_bits & 7)
../lib/public/stb_image.h:4339:      stbi__zreceive(a, a->num_bits & 7); // discard
../lib/public/stb_image.h:4340:   // drain the bit-packed data into header
../lib/public/stb_image.h:4342:   while (a->num_bits > 0) {
../lib/public/stb_image.h:4343:      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
../lib/public/stb_image.h:4344:      a->code_buffer >>= 8;
../lib/public/stb_image.h:4345:      a->num_bits -= 8;
../lib/public/stb_image.h:4347:   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
../lib/public/stb_image.h:4354:   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
../lib/public/stb_image.h:4355:   if (a->zout + len > a->zout_end)
../lib/public/stb_image.h:4356:      if (!stbi__zexpand(a, a->zout, len)) return 0;
../lib/public/stb_image.h:4357:   memcpy(a->zout, a->zbuffer, len);
../lib/public/stb_image.h:4358:   a->zbuffer += len;
../lib/public/stb_image.h:4359:   a->zout += len;
../lib/public/stb_image.h:4411:   a->num_bits = 0;
../lib/public/stb_image.h:4412:   a->code_buffer = 0;
../lib/public/stb_image.h:4423:            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
../lib/public/stb_image.h:4424:            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
../lib/public/stb_image.h:4436:   a->zout_start = obuf;
../lib/public/stb_image.h:4437:   a->zout       = obuf;
../lib/public/stb_image.h:4438:   a->zout_end   = obuf + olen;
../lib/public/stb_image.h:4439:   a->z_expandable = exp;
../lib/public/stb_image.h:4452:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
../lib/public/stb_image.h:4473:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
../lib/public/stb_image.h:4487:      return (int) (a.zout - a.zout_start);
../lib/public/stb_image.h:4489:      return -1;
../lib/public/stb_image.h:4500:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
../lib/public/stb_image.h:4514:      return (int) (a.zout - a.zout_start);
../lib/public/stb_image.h:4516:      return -1;
../lib/public/stb_image.h:4520:// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
../lib/public/stb_image.h:4522://      - only 8-bit samples
../lib/public/stb_image.h:4523://      - no CRC checking
../lib/public/stb_image.h:4524://      - allocates lots of intermediate memory
../lib/public/stb_image.h:4525://        - avoids problem of streaming data between subsystems
../lib/public/stb_image.h:4526://        - avoids explicit window management
../lib/public/stb_image.h:4528://      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
../lib/public/stb_image.h:4584:   int p = a + b - c;
../lib/public/stb_image.h:4585:   int pa = abs(p-a);
../lib/public/stb_image.h:4586:   int pb = abs(p-b);
../lib/public/stb_image.h:4587:   int pc = abs(p-c);
../lib/public/stb_image.h:4595:// create the png data from post-deflated data
../lib/public/stb_image.h:4599:   stbi__context *s = a->s;
../lib/public/stb_image.h:4603:   int img_n = s->img_n; // copy it into a local for later
../lib/public/stb_image.h:4609:   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
../lib/public/stb_image.h:4610:   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
../lib/public/stb_image.h:4611:   if (!a->out) return stbi__err("outofmem", "Out of memory");
../lib/public/stb_image.h:4617:   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
../lib/public/stb_image.h:4623:      stbi_uc *cur = a->out + stride*j;
../lib/public/stb_image.h:4632:         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
../lib/public/stb_image.h:4636:      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
../lib/public/stb_image.h:4674:      // this is a little gross, so that we don't switch per-pixel or per-component
../lib/public/stb_image.h:4676:         int nk = (width - 1)*filter_bytes;
../lib/public/stb_image.h:4683:            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
../lib/public/stb_image.h:4685:            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
../lib/public/stb_image.h:4686:            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
../lib/public/stb_image.h:4687:            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
../lib/public/stb_image.h:4688:            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
../lib/public/stb_image.h:4696:                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
../lib/public/stb_image.h:4700:            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
../lib/public/stb_image.h:4702:            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
../lib/public/stb_image.h:4703:            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
../lib/public/stb_image.h:4704:            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
../lib/public/stb_image.h:4705:            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
../lib/public/stb_image.h:4712:            cur = a->out + stride*j; // start at the beginning of the row again
../lib/public/stb_image.h:4725:         stbi_uc *cur = a->out + stride*j;
../lib/public/stb_image.h:4726:         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
../lib/public/stb_image.h:4727:         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
../lib/public/stb_image.h:4733:         // could also overwrite the next scanline. can it overwrite non-empty data
../lib/public/stb_image.h:4734:         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
../lib/public/stb_image.h:4738:            for (k=x*img_n; k >= 2; k-=2, ++in) {
../lib/public/stb_image.h:4744:            for (k=x*img_n; k >= 4; k-=4, ++in) {
../lib/public/stb_image.h:4754:            for (k=x*img_n; k >= 8; k-=8, ++in) {
../lib/public/stb_image.h:4775:            cur = a->out + stride*j;
../lib/public/stb_image.h:4777:               for (q=x-1; q >= 0; --q) {
../lib/public/stb_image.h:4783:               for (q=x-1; q >= 0; --q) {
../lib/public/stb_image.h:4793:      // force the image data from big-endian to platform-native.
../lib/public/stb_image.h:4796:      // per-line during decode if care is taken.
../lib/public/stb_image.h:4797:      stbi_uc *cur = a->out;
../lib/public/stb_image.h:4815:      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
../lib/public/stb_image.h:4817:   // de-interlacing
../lib/public/stb_image.h:4818:   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
../lib/public/stb_image.h:4827:      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
../lib/public/stb_image.h:4828:      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
../lib/public/stb_image.h:4830:         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
../lib/public/stb_image.h:4839:               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
../lib/public/stb_image.h:4840:                      a->out + (j*x+i)*out_bytes, out_bytes);
../lib/public/stb_image.h:4843:         STBI_FREE(a->out);
../lib/public/stb_image.h:4845:         image_data_len -= img_len;
../lib/public/stb_image.h:4848:   a->out = final;
../lib/public/stb_image.h:4855:   stbi__context *s = z->s;
../lib/public/stb_image.h:4856:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
../lib/public/stb_image.h:4857:   stbi_uc *p = z->out;
../lib/public/stb_image.h:4859:   // compute color-based transparency, assuming we've
../lib/public/stb_image.h:4880:   stbi__context *s = z->s;
../lib/public/stb_image.h:4881:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
../lib/public/stb_image.h:4882:   stbi__uint16 *p = (stbi__uint16*) z->out;
../lib/public/stb_image.h:4884:   // compute color-based transparency, assuming we've
../lib/public/stb_image.h:4905:   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
../lib/public/stb_image.h:4906:   stbi_uc *p, *temp_out, *orig = a->out;
../lib/public/stb_image.h:4932:   STBI_FREE(a->out);
../lib/public/stb_image.h:4933:   a->out = temp_out;
../lib/public/stb_image.h:4982:   stbi__context *s = z->s;
../lib/public/stb_image.h:4983:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
../lib/public/stb_image.h:4984:   stbi_uc *p = z->out;
../lib/public/stb_image.h:4986:   if (s->img_out_n == 3) {  // convert bgr to rgb
../lib/public/stb_image.h:4994:      STBI_ASSERT(s->img_out_n == 4);
../lib/public/stb_image.h:5032:   stbi__context *s = z->s;
../lib/public/stb_image.h:5034:   z->expanded = NULL;
../lib/public/stb_image.h:5035:   z->idata = NULL;
../lib/public/stb_image.h:5036:   z->out = NULL;
../lib/public/stb_image.h:5054:            s->img_x = stbi__get32be(s);
../lib/public/stb_image.h:5055:            s->img_y = stbi__get32be(s);
../lib/public/stb_image.h:5056:            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:5057:            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:5058:            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
../lib/public/stb_image.h:5060:            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
../lib/public/stb_image.h:5065:            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
../lib/public/stb_image.h:5067:               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
../lib/public/stb_image.h:5068:               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
../lib/public/stb_image.h:5073:               s->img_n = 1;
../lib/public/stb_image.h:5074:               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
../lib/public/stb_image.h:5096:            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
../lib/public/stb_image.h:5098:               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
../lib/public/stb_image.h:5105:               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
../lib/public/stb_image.h:5106:               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
../lib/public/stb_image.h:5108:               if (z->depth == 16) {
../lib/public/stb_image.h:5109:                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
../lib/public/stb_image.h:5111:                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
../lib/public/stb_image.h:5120:            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
../lib/public/stb_image.h:5129:               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
../lib/public/stb_image.h:5130:               z->idata = p;
../lib/public/stb_image.h:5132:            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
../lib/public/stb_image.h:5141:            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
../lib/public/stb_image.h:5143:            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
../lib/public/stb_image.h:5144:            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
../lib/public/stb_image.h:5145:            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
../lib/public/stb_image.h:5146:            if (z->expanded == NULL) return 0; // zlib should set error
../lib/public/stb_image.h:5147:            STBI_FREE(z->idata); z->idata = NULL;
../lib/public/stb_image.h:5148:            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
../lib/public/stb_image.h:5149:               s->img_out_n = s->img_n+1;
../lib/public/stb_image.h:5151:               s->img_out_n = s->img_n;
../lib/public/stb_image.h:5152:            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
../lib/public/stb_image.h:5154:               if (z->depth == 16) {
../lib/public/stb_image.h:5155:                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
../lib/public/stb_image.h:5157:                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
../lib/public/stb_image.h:5160:            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
../lib/public/stb_image.h:5164:               s->img_n = pal_img_n; // record the actual colors we had
../lib/public/stb_image.h:5165:               s->img_out_n = pal_img_n;
../lib/public/stb_image.h:5166:               if (req_comp >= 3) s->img_out_n = req_comp;
../lib/public/stb_image.h:5167:               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
../lib/public/stb_image.h:5170:               // non-paletted image with tRNS -> source image has (constant) alpha
../lib/public/stb_image.h:5171:               ++s->img_n;
../lib/public/stb_image.h:5173:            STBI_FREE(z->expanded); z->expanded = NULL;
../lib/public/stb_image.h:5206:      if (p->depth <= 8)
../lib/public/stb_image.h:5207:         ri->bits_per_channel = 8;
../lib/public/stb_image.h:5208:      else if (p->depth == 16)
../lib/public/stb_image.h:5209:         ri->bits_per_channel = 16;
../lib/public/stb_image.h:5212:      result = p->out;
../lib/public/stb_image.h:5213:      p->out = NULL;
../lib/public/stb_image.h:5214:      if (req_comp && req_comp != p->s->img_out_n) {
../lib/public/stb_image.h:5215:         if (ri->bits_per_channel == 8)
../lib/public/stb_image.h:5216:            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
../lib/public/stb_image.h:5218:            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
../lib/public/stb_image.h:5219:         p->s->img_out_n = req_comp;
../lib/public/stb_image.h:5222:      *x = p->s->img_x;
../lib/public/stb_image.h:5223:      *y = p->s->img_y;
../lib/public/stb_image.h:5224:      if (n) *n = p->s->img_n;
../lib/public/stb_image.h:5226:   STBI_FREE(p->out);      p->out      = NULL;
../lib/public/stb_image.h:5227:   STBI_FREE(p->expanded); p->expanded = NULL;
../lib/public/stb_image.h:5228:   STBI_FREE(p->idata);    p->idata    = NULL;
../lib/public/stb_image.h:5251:      stbi__rewind( p->s );
../lib/public/stb_image.h:5254:   if (x) *x = p->s->img_x;
../lib/public/stb_image.h:5255:   if (y) *y = p->s->img_y;
../lib/public/stb_image.h:5256:   if (comp) *comp = p->s->img_n;
../lib/public/stb_image.h:5311:   if (z == 0) return -1;
../lib/public/stb_image.h:5330:// extract an arbitrarily-aligned N-bit value (N=bits)
../lib/public/stb_image.h:5331:// from v, and then make it 8-bits long and fractionally
../lib/public/stb_image.h:5344:      v <<= -shift;
../lib/public/stb_image.h:5348:   v >>= (8-bits);
../lib/public/stb_image.h:5367:      if (info->bpp == 16) {
../lib/public/stb_image.h:5368:         info->mr = 31u << 10;
../lib/public/stb_image.h:5369:         info->mg = 31u <<  5;
../lib/public/stb_image.h:5370:         info->mb = 31u <<  0;
../lib/public/stb_image.h:5371:      } else if (info->bpp == 32) {
../lib/public/stb_image.h:5372:         info->mr = 0xffu << 16;
../lib/public/stb_image.h:5373:         info->mg = 0xffu <<  8;
../lib/public/stb_image.h:5374:         info->mb = 0xffu <<  0;
../lib/public/stb_image.h:5375:         info->ma = 0xffu << 24;
../lib/public/stb_image.h:5376:         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
../lib/public/stb_image.h:5378:         // otherwise, use defaults, which is all-0
../lib/public/stb_image.h:5379:         info->mr = info->mg = info->mb = info->ma = 0;
../lib/public/stb_image.h:5393:   info->offset = stbi__get32le(s);
../lib/public/stb_image.h:5394:   info->hsz = hsz = stbi__get32le(s);
../lib/public/stb_image.h:5395:   info->mr = info->mg = info->mb = info->ma = 0;
../lib/public/stb_image.h:5396:   info->extra_read = 14;
../lib/public/stb_image.h:5398:   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
../lib/public/stb_image.h:5402:      s->img_x = stbi__get16le(s);
../lib/public/stb_image.h:5403:      s->img_y = stbi__get16le(s);
../lib/public/stb_image.h:5405:      s->img_x = stbi__get32le(s);
../lib/public/stb_image.h:5406:      s->img_y = stbi__get32le(s);
../lib/public/stb_image.h:5409:   info->bpp = stbi__get16le(s);
../lib/public/stb_image.h:5414:      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
../lib/public/stb_image.h:5427:         if (info->bpp == 16 || info->bpp == 32) {
../lib/public/stb_image.h:5431:               info->mr = stbi__get32le(s);
../lib/public/stb_image.h:5432:               info->mg = stbi__get32le(s);
../lib/public/stb_image.h:5433:               info->mb = stbi__get32le(s);
../lib/public/stb_image.h:5434:               info->extra_read += 12;
../lib/public/stb_image.h:5436:               if (info->mr == info->mg && info->mg == info->mb) {
../lib/public/stb_image.h:5448:         info->mr = stbi__get32le(s);
../lib/public/stb_image.h:5449:         info->mg = stbi__get32le(s);
../lib/public/stb_image.h:5450:         info->mb = stbi__get32le(s);
../lib/public/stb_image.h:5451:         info->ma = stbi__get32le(s);
../lib/public/stb_image.h:5483:   flip_vertically = ((int) s->img_y) > 0;
../lib/public/stb_image.h:5484:   s->img_y = abs((int) s->img_y);
../lib/public/stb_image.h:5486:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:5487:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:5497:         psize = (info.offset - info.extra_read - 24) / 3;
../lib/public/stb_image.h:5500:         psize = (info.offset - info.extra_read - info.hsz) >> 2;
../lib/public/stb_image.h:5503:      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
../lib/public/stb_image.h:5509:      s->img_n = 3;
../lib/public/stb_image.h:5511:      s->img_n = ma ? 4 : 3;
../lib/public/stb_image.h:5515:      target = s->img_n; // if they want monochrome, we'll post-convert
../lib/public/stb_image.h:5517:   // sanity-check size
../lib/public/stb_image.h:5518:   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
../lib/public/stb_image.h:5521:   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
../lib/public/stb_image.h:5533:      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
../lib/public/stb_image.h:5534:      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
../lib/public/stb_image.h:5535:      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
../lib/public/stb_image.h:5536:      else if (info.bpp == 8) width = s->img_x;
../lib/public/stb_image.h:5538:      pad = (-width)&3;
../lib/public/stb_image.h:5540:         for (j=0; j < (int) s->img_y; ++j) {
../lib/public/stb_image.h:5542:            for (i=0; i < (int) s->img_x; ++i) {
../lib/public/stb_image.h:5548:               if (i+1 == (int) s->img_x) break;
../lib/public/stb_image.h:5549:               if((--bit_offset) < 0) {
../lib/public/stb_image.h:5557:         for (j=0; j < (int) s->img_y; ++j) {
../lib/public/stb_image.h:5558:            for (i=0; i < (int) s->img_x; i += 2) {
../lib/public/stb_image.h:5568:               if (i+1 == (int) s->img_x) break;
../lib/public/stb_image.h:5582:      stbi__skip(s, info.offset - info.extra_read - info.hsz);
../lib/public/stb_image.h:5583:      if (info.bpp == 24) width = 3 * s->img_x;
../lib/public/stb_image.h:5584:      else if (info.bpp == 16) width = 2*s->img_x;
../lib/public/stb_image.h:5586:      pad = (-width) & 3;
../lib/public/stb_image.h:5596:         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
../lib/public/stb_image.h:5597:         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
../lib/public/stb_image.h:5598:         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
../lib/public/stb_image.h:5599:         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
../lib/public/stb_image.h:5602:      for (j=0; j < (int) s->img_y; ++j) {
../lib/public/stb_image.h:5604:            for (i=0; i < (int) s->img_x; ++i) {
../lib/public/stb_image.h:5616:            for (i=0; i < (int) s->img_x; ++i) {
../lib/public/stb_image.h:5633:      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
../lib/public/stb_image.h:5638:      for (j=0; j < (int) s->img_y>>1; ++j) {
../lib/public/stb_image.h:5639:         stbi_uc *p1 = out +      j     *s->img_x*target;
../lib/public/stb_image.h:5640:         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
../lib/public/stb_image.h:5641:         for (i=0; i < (int) s->img_x*target; ++i) {
../lib/public/stb_image.h:5648:      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
../lib/public/stb_image.h:5652:   *x = s->img_x;
../lib/public/stb_image.h:5653:   *y = s->img_y;
../lib/public/stb_image.h:5654:   if (comp) *comp = s->img_n;
../lib/public/stb_image.h:5659:// Targa Truevision - TGA
../lib/public/stb_image.h:5703:    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
../lib/public/stb_image.h:5706:            return 0; // only RGB or grey allowed, +/- RLE
../lib/public/stb_image.h:5759:      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
../lib/public/stb_image.h:5790:   // (possibly if an alpha-bit is set in the "image descriptor byte")
../lib/public/stb_image.h:5812:   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
../lib/public/stb_image.h:5831:      tga_image_type -= 8;
../lib/public/stb_image.h:5834:   tga_inverted = 1 - ((tga_inverted >> 5) & 1);
../lib/public/stb_image.h:5859:         int row = tga_inverted ? tga_height -i - 1 : i;
../lib/public/stb_image.h:5948:         --RLE_count;
../lib/public/stb_image.h:5956:            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
../lib/public/stb_image.h:5957:            for (i = tga_width * tga_comp; i > 0; --i)
../lib/public/stb_image.h:5974:   // swap RGB - if the source data was RGB16, it already is in the right order
../lib/public/stb_image.h:6002:// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
../lib/public/stb_image.h:6017:   while ((nleft = pixelCount - count) > 0) {
../lib/public/stb_image.h:6020:         // No-op.
../lib/public/stb_image.h:6029:            len--;
../lib/public/stb_image.h:6033:         // Next -len+1 bytes in the dest are replicated from next source byte.
../lib/public/stb_image.h:6034:         // (Interpret len as a negative 8-bit int.)
../lib/public/stb_image.h:6035:         len = 257 - len;
../lib/public/stb_image.h:6042:            len--;
../lib/public/stb_image.h:6126:      ri->bits_per_channel = 16;
../lib/public/stb_image.h:6142:      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
../lib/public/stb_image.h:6146:      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
../lib/public/stb_image.h:6170:      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
../lib/public/stb_image.h:6188:            if (ri->bits_per_channel == 16) {    // output bpc
../lib/public/stb_image.h:6208:      if (ri->bits_per_channel == 16) {
../lib/public/stb_image.h:6214:               float inv_a = 65535.0f * (1 - ra);
../lib/public/stb_image.h:6226:               float inv_a = 255.0f * (1 - ra);
../lib/public/stb_image.h:6237:      if (ri->bits_per_channel == 16)
../lib/public/stb_image.h:6330:      packet->size    = stbi__get8(s);
../lib/public/stb_image.h:6331:      packet->type    = stbi__get8(s);
../lib/public/stb_image.h:6332:      packet->channel = stbi__get8(s);
../lib/public/stb_image.h:6334:      act_comp |= packet->channel;
../lib/public/stb_image.h:6337:      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
../lib/public/stb_image.h:6349:         switch (packet->type) {
../lib/public/stb_image.h:6357:                  if (!stbi__readval(s,packet->channel,dest))
../lib/public/stb_image.h:6375:                     if (!stbi__readval(s,packet->channel,value))  return 0;
../lib/public/stb_image.h:6378:                        stbi__copyval(packet->channel,dest,value);
../lib/public/stb_image.h:6379:                     left -= count;
../lib/public/stb_image.h:6396:                        count -= 127;
../lib/public/stb_image.h:6400:                     if (!stbi__readval(s,packet->channel,value))
../lib/public/stb_image.h:6404:                        stbi__copyval(packet->channel,dest,value);
../lib/public/stb_image.h:6410:                        if (!stbi__readval(s,packet->channel,dest))
../lib/public/stb_image.h:6413:                  left-=count;
../lib/public/stb_image.h:6474:// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
../lib/public/stb_image.h:6543:   g->w = stbi__get16le(s);
../lib/public/stb_image.h:6544:   g->h = stbi__get16le(s);
../lib/public/stb_image.h:6545:   g->flags = stbi__get8(s);
../lib/public/stb_image.h:6546:   g->bgindex = stbi__get8(s);
../lib/public/stb_image.h:6547:   g->ratio = stbi__get8(s);
../lib/public/stb_image.h:6548:   g->transparent = -1;
../lib/public/stb_image.h:6550:   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:6551:   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:6557:   if (g->flags & 0x80)
../lib/public/stb_image.h:6558:      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
../lib/public/stb_image.h:6572:   if (x) *x = g->w;
../lib/public/stb_image.h:6573:   if (y) *y = g->h;
../lib/public/stb_image.h:6583:   // recurse to decode the prefixes, since the linked-list is backwards,
../lib/public/stb_image.h:6585:   if (g->codes[code].prefix >= 0)
../lib/public/stb_image.h:6586:      stbi__out_gif_code(g, g->codes[code].prefix);
../lib/public/stb_image.h:6588:   if (g->cur_y >= g->max_y) return;
../lib/public/stb_image.h:6590:   idx = g->cur_x + g->cur_y;
../lib/public/stb_image.h:6591:   p = &g->out[idx];
../lib/public/stb_image.h:6592:   g->history[idx / 4] = 1;
../lib/public/stb_image.h:6594:   c = &g->color_table[g->codes[code].suffix * 4];
../lib/public/stb_image.h:6601:   g->cur_x += 4;
../lib/public/stb_image.h:6603:   if (g->cur_x >= g->max_x) {
../lib/public/stb_image.h:6604:      g->cur_x = g->start_x;
../lib/public/stb_image.h:6605:      g->cur_y += g->step;
../lib/public/stb_image.h:6607:      while (g->cur_y >= g->max_y && g->parse > 0) {
../lib/public/stb_image.h:6608:         g->step = (1 << g->parse) * g->line_size;
../lib/public/stb_image.h:6609:         g->cur_y = g->start_y + (g->step >> 1);
../lib/public/stb_image.h:6610:         --g->parse;
../lib/public/stb_image.h:6628:   codemask = (1 << codesize) - 1;
../lib/public/stb_image.h:6632:      g->codes[init_code].prefix = -1;
../lib/public/stb_image.h:6633:      g->codes[init_code].first = (stbi_uc) init_code;
../lib/public/stb_image.h:6634:      g->codes[init_code].suffix = (stbi_uc) init_code;
../lib/public/stb_image.h:6639:   oldcode = -1;
../lib/public/stb_image.h:6647:               return g->out;
../lib/public/stb_image.h:6649:         --len;
../lib/public/stb_image.h:6655:         valid_bits -= codesize;
../lib/public/stb_image.h:6656:         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
../lib/public/stb_image.h:6659:            codemask = (1 << codesize) - 1;
../lib/public/stb_image.h:6661:            oldcode = -1;
../lib/public/stb_image.h:6667:            return g->out;
../lib/public/stb_image.h:6674:               p = &g->codes[avail++];
../lib/public/stb_image.h:6679:               p->prefix = (stbi__int16) oldcode;
../lib/public/stb_image.h:6680:               p->first = g->codes[oldcode].first;
../lib/public/stb_image.h:6681:               p->suffix = (code == avail) ? p->first : g->codes[code].first;
../lib/public/stb_image.h:6689:               codemask = (1 << codesize) - 1;
../lib/public/stb_image.h:6710:   // on first frame, any non-written pixels get the background colour (non-transparent)
../lib/public/stb_image.h:6712:   if (g->out == 0) {
../lib/public/stb_image.h:6714:      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
../lib/public/stb_image.h:6716:      pcount = g->w * g->h;
../lib/public/stb_image.h:6717:      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
../lib/public/stb_image.h:6718:      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
../lib/public/stb_image.h:6719:      g->history = (stbi_uc *) stbi__malloc(pcount);
../lib/public/stb_image.h:6720:      if (!g->out || !g->background || !g->history)
../lib/public/stb_image.h:6723:      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
../lib/public/stb_image.h:6726:      memset(g->out, 0x00, 4 * pcount);
../lib/public/stb_image.h:6727:      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
../lib/public/stb_image.h:6728:      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
../lib/public/stb_image.h:6731:      // second frame - how do we dispose of the previous one?
../lib/public/stb_image.h:6732:      dispose = (g->eflags & 0x1C) >> 2;
../lib/public/stb_image.h:6733:      pcount = g->w * g->h;
../lib/public/stb_image.h:6741:            if (g->history[pi]) {
../lib/public/stb_image.h:6742:               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
../lib/public/stb_image.h:6748:            if (g->history[pi]) {
../lib/public/stb_image.h:6749:               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
../lib/public/stb_image.h:6753:         // This is a non-disposal case eithe way, so just
../lib/public/stb_image.h:6760:      memcpy( g->background, g->out, 4 * g->w * g->h );
../lib/public/stb_image.h:6764:   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame
../lib/public/stb_image.h:6778:            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
../lib/public/stb_image.h:6781:            g->line_size = g->w * 4;
../lib/public/stb_image.h:6782:            g->start_x = x * 4;
../lib/public/stb_image.h:6783:            g->start_y = y * g->line_size;
../lib/public/stb_image.h:6784:            g->max_x   = g->start_x + w * 4;
../lib/public/stb_image.h:6785:            g->max_y   = g->start_y + h * g->line_size;
../lib/public/stb_image.h:6786:            g->cur_x   = g->start_x;
../lib/public/stb_image.h:6787:            g->cur_y   = g->start_y;
../lib/public/stb_image.h:6794:               g->cur_y = g->max_y;
../lib/public/stb_image.h:6796:            g->lflags = stbi__get8(s);
../lib/public/stb_image.h:6798:            if (g->lflags & 0x40) {
../lib/public/stb_image.h:6799:               g->step = 8 * g->line_size; // first interlaced spacing
../lib/public/stb_image.h:6800:               g->parse = 3;
../lib/public/stb_image.h:6802:               g->step = g->line_size;
../lib/public/stb_image.h:6803:               g->parse = 0;
../lib/public/stb_image.h:6806:            if (g->lflags & 0x80) {
../lib/public/stb_image.h:6807:               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
../lib/public/stb_image.h:6808:               g->color_table = (stbi_uc *) g->lpal;
../lib/public/stb_image.h:6809:            } else if (g->flags & 0x80) {
../lib/public/stb_image.h:6810:               g->color_table = (stbi_uc *) g->pal;
../lib/public/stb_image.h:6818:            pcount = g->w * g->h;
../lib/public/stb_image.h:6819:            if (first_frame && (g->bgindex > 0)) {
../lib/public/stb_image.h:6822:                  if (g->history[pi] == 0) {
../lib/public/stb_image.h:6823:                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
../lib/public/stb_image.h:6824:                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
../lib/public/stb_image.h:6839:                  g->eflags = stbi__get8(s);
../lib/public/stb_image.h:6840:                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.
../lib/public/stb_image.h:6843:                  if (g->transparent >= 0) {
../lib/public/stb_image.h:6844:                     g->pal[g->transparent][3] = 255;
../lib/public/stb_image.h:6846:                  if (g->eflags & 0x01) {
../lib/public/stb_image.h:6847:                     g->transparent = stbi__get8(s);
../lib/public/stb_image.h:6848:                     if (g->transparent >= 0) {
../lib/public/stb_image.h:6849:                        g->pal[g->transparent][3] = 0;
../lib/public/stb_image.h:6854:                     g->transparent = -1;
../lib/public/stb_image.h:6878:   STBI_FREE(g->out);
../lib/public/stb_image.h:6879:   STBI_FREE(g->history);
../lib/public/stb_image.h:6880:   STBI_FREE(g->background);
../lib/public/stb_image.h:6945:            memcpy( out + ((layers - 1) * stride), u, stride );
../lib/public/stb_image.h:6947:               two_back = out - 2 * stride;
../lib/public/stb_image.h:6951:               (*delays)[layers - 1U] = g.delay;
../lib/public/stb_image.h:7042:      if (len == STBI__HDR_BUFLEN-1) {
../lib/public/stb_image.h:7060:      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
../lib/public/stb_image.h:7105:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
../lib/public/stb_image.h:7113:   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
../lib/public/stb_image.h:7151:      // Read RLE-encoded data
../lib/public/stb_image.h:7159:            // not run-length encoded, so we have to actually use THIS data as a decoded
../lib/public/stb_image.h:7160:            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
../lib/public/stb_image.h:7186:            while ((nleft = width - i) > 0) {
../lib/public/stb_image.h:7191:                  count -= 128;
../lib/public/stb_image.h:7232:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
../lib/public/stb_image.h:7240:   if (strncmp(token, "-Y ", 3)) {
../lib/public/stb_image.h:7270:   if (x) *x = s->img_x;
../lib/public/stb_image.h:7271:   if (y) *y = s->img_y;
../lib/public/stb_image.h:7384:      packet->size    = stbi__get8(s);
../lib/public/stb_image.h:7385:      packet->type    = stbi__get8(s);
../lib/public/stb_image.h:7386:      packet->channel = stbi__get8(s);
../lib/public/stb_image.h:7387:      act_comp |= packet->channel;
../lib/public/stb_image.h:7393:      if (packet->size != 8) {
../lib/public/stb_image.h:7435:   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
../lib/public/stb_image.h:7436:   if (ri->bits_per_channel == 0)
../lib/public/stb_image.h:7439:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:7440:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
../lib/public/stb_image.h:7442:   *x = s->img_x;
../lib/public/stb_image.h:7443:   *y = s->img_y;
../lib/public/stb_image.h:7444:   if (comp) *comp = s->img_n;
../lib/public/stb_image.h:7446:   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
../lib/public/stb_image.h:7449:   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
../lib/public/stb_image.h:7451:   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));
../lib/public/stb_image.h:7453:   if (req_comp && req_comp != s->img_n) {
../lib/public/stb_image.h:7454:      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
../lib/public/stb_image.h:7489:      value = value*10 + (*c - '0');
../lib/public/stb_image.h:7515:   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
../lib/public/stb_image.h:7528:      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
../lib/public/stb_image.h:7677:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
../lib/public/stb_image.h:7678:      2.19  (2018-02-11) fix warning
../lib/public/stb_image.h:7679:      2.18  (2018-01-30) fix warnings
../lib/public/stb_image.h:7680:      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
../lib/public/stb_image.h:7681:                         1-bit BMP
../lib/public/stb_image.h:7684:      2.16  (2017-07-23) all functions have 16-bit variants;
../lib/public/stb_image.h:7691:      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
../lib/public/stb_image.h:7692:                         warning fixes; disable run-time SSE detection on gcc;
../lib/public/stb_image.h:7694:                         thread-safe initialization of zlib tables
../lib/public/stb_image.h:7695:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
../lib/public/stb_image.h:7696:      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
../lib/public/stb_image.h:7697:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
../lib/public/stb_image.h:7698:      2.11  (2016-04-02) allocate large structures on the stack
../lib/public/stb_image.h:7701:                         re-enable SSE2 in non-gcc 64-bit
../lib/public/stb_image.h:7702:                         support RGB-formatted JPEG
../lib/public/stb_image.h:7703:                         read 16-bit PNGs (only as 8-bit)
../lib/public/stb_image.h:7704:      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
../lib/public/stb_image.h:7705:      2.09  (2016-01-16) allow comments in PNM files
../lib/public/stb_image.h:7706:                         16-bit-per-pixel TGA (not bit-per-component)
../lib/public/stb_image.h:7711:      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
../lib/public/stb_image.h:7712:      2.07  (2015-09-13) fix compiler warnings
../lib/public/stb_image.h:7714:                         limited 16-bpc PSD support
../lib/public/stb_image.h:7717:      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
../lib/public/stb_image.h:7718:      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
../lib/public/stb_image.h:7719:      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
../lib/public/stb_image.h:7720:      2.03  (2015-04-12) extra corruption checking (mmozeiko)
../lib/public/stb_image.h:7723:      2.02  (2015-01-19) fix incorrect assert, fix warning
../lib/public/stb_image.h:7724:      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
../lib/public/stb_image.h:7725:      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
../lib/public/stb_image.h:7726:      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
../lib/public/stb_image.h:7730:                         GIF bugfix -- seemingly never worked
../lib/public/stb_image.h:7732:      1.48  (2014-12-14) fix incorrectly-named assert()
../lib/public/stb_image.h:7733:      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
../lib/public/stb_image.h:7735:                         fix bug in interlaced PNG with user-specified channel count (stb)
../lib/public/stb_image.h:7736:      1.46  (2014-08-26)
../lib/public/stb_image.h:7737:              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
../lib/public/stb_image.h:7738:      1.45  (2014-08-16)
../lib/public/stb_image.h:7739:              fix MSVC-ARM internal compiler error by wrapping malloc
../lib/public/stb_image.h:7740:      1.44  (2014-08-07)
../lib/public/stb_image.h:7742:      1.43  (2014-07-15)
../lib/public/stb_image.h:7743:              fix MSVC-only compiler problem in code changed in 1.42
../lib/public/stb_image.h:7744:      1.42  (2014-07-09)
../lib/public/stb_image.h:7748:      1.41  (2014-06-25)
../lib/public/stb_image.h:7750:      1.40  (2014-06-22)
../lib/public/stb_image.h:7751:              fix gcc struct-initialization warning
../lib/public/stb_image.h:7752:      1.39  (2014-06-15)
../lib/public/stb_image.h:7756:      1.38  (2014-06-06)
../lib/public/stb_image.h:7759:      1.37  (2014-06-04)
../lib/public/stb_image.h:7761:      1.36  (2014-06-03)
../lib/public/stb_image.h:7762:              convert to header file single-file library
../lib/public/stb_image.h:7763:              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
../lib/public/stb_image.h:7764:      1.35  (2014-05-27)
../lib/public/stb_image.h:7768:              fix broken non-easy path for 32-bit BMP (possibly never used)
../lib/public/stb_image.h:7772:      1.33  (2011-07-14)
../lib/public/stb_image.h:7773:              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
../lib/public/stb_image.h:7774:      1.32  (2011-07-13)
../lib/public/stb_image.h:7776:      1.31  (2011-06-20)
../lib/public/stb_image.h:7778:      1.30  (2011-06-11)
../lib/public/stb_image.h:7780:              removed deprecated format-specific test/load functions
../lib/public/stb_image.h:7781:              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
../lib/public/stb_image.h:7783:              fix inefficiency in decoding 32-bit BMP (David Woo)
../lib/public/stb_image.h:7784:      1.29  (2010-08-16)
../lib/public/stb_image.h:7786:      1.28  (2010-08-01)
../lib/public/stb_image.h:7788:      1.27  (2010-08-01)
../lib/public/stb_image.h:7789:              cast-to-stbi_uc to fix warnings
../lib/public/stb_image.h:7790:      1.26  (2010-07-24)
../lib/public/stb_image.h:7792:      1.25  (2010-07-17)
../lib/public/stb_image.h:7794:      1.24  (2010-07-12)
../lib/public/stb_image.h:7795:              perf improvements reading from files on platforms with lock-heavy fgetc()
../lib/public/stb_image.h:7797:              deprecated type-specific functions so we'll get feedback if they're needed
../lib/public/stb_image.h:7800:      1.22  (2010-07-10)
../lib/public/stb_image.h:7803:              GIF support from Jean-Marc Lienher
../lib/public/stb_image.h:7804:              iPhone PNG-extensions from James Brown
../lib/public/stb_image.h:7805:              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
../lib/public/stb_image.h:7809:      1.18  (2008-08-02)
../lib/public/stb_image.h:7812:      1.16    major bugfix - stbi__convert_format converted one too many pixels
../lib/public/stb_image.h:7815:              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
../lib/public/stb_image.h:7819:      1.10    Fixes for 64-bit (don't use "unsigned long")
../lib/public/stb_image.h:7821:      1.09    Fix format-conversion for PSD code (bad global variables!)
../lib/public/stb_image.h:7829:      1.01    fix bug: possible bug in handling right-side up bmps... not sure
../lib/public/stb_image.h:7835:      0.96    fix detection of invalid v value - particleman@mollyrocket forum
../lib/public/stb_image.h:7839:      0.92    read 4,8,16,24,32-bit BMP files of several formats
../lib/public/stb_image.h:7840:      0.91    output 24-bit Windows 3.0 BMP files
../lib/public/stb_image.h:7844:      0.59    fix warnings: merge Dave Moore's -Wall fixes
../lib/public/stb_image.h:7850:      0.53    fix bug in png 3->4; speedup png decoding
../lib/public/stb_image.h:7852:      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
../lib/public/stb_image.h:7854:      0.50  (2006-11-19)
../lib/public/stb_image.h:7860:------------------------------------------------------------------------------
../lib/public/stb_image.h:7861:This software is available under 2 licenses -- choose whichever you prefer.
../lib/public/stb_image.h:7862:------------------------------------------------------------------------------
../lib/public/stb_image.h:7863:ALTERNATIVE A - MIT License
../lib/public/stb_image.h:7880:------------------------------------------------------------------------------
../lib/public/stb_image.h:7881:ALTERNATIVE B - Public Domain (www.unlicense.org)
../lib/public/stb_image.h:7885:commercial or non-commercial, and by any means.
../lib/public/stb_image.h:7898:------------------------------------------------------------------------------
../lib/public/stb_image_resize.h:1:/* stb_image_resize - v0.97 - public domain image resizing
../lib/public/stb_image_resize.h:2:   by Jorge L Rodriguez (@VinoBS) - 2014
../lib/public/stb_image_resize.h:53:         Define STBIR_SATURATE_INT to compute clamp values in-range using
../lib/public/stb_image_resize.h:59:         to use, you can change the compile-time defaults with
../lib/public/stb_image_resize.h:64:         See stbir_filter in the header-file section for the list of filters.
../lib/public/stb_image_resize.h:73:         a progress-report callback:
../lib/public/stb_image_resize.h:101:         1. The best mathematically-behaved version of alpha to use is
../lib/public/stb_image_resize.h:107:         industry, it is still uncommon in the videogame/real-time world.
../lib/public/stb_image_resize.h:109:         If you linearly filter non-premultiplied alpha, strange effects
../lib/public/stb_image_resize.h:112:         non-premultiplied, whereas premultiplied it produces 50%
../lib/public/stb_image_resize.h:113:         transparent near-black. The former introduces green energy
../lib/public/stb_image_resize.h:116:         2. Artists should not edit premultiplied-alpha images; artists
../lib/public/stb_image_resize.h:117:         want non-premultiplied alpha images. Thus, art tools generally output
../lib/public/stb_image_resize.h:118:         non-premultiplied alpha images.
../lib/public/stb_image_resize.h:126:         the correct results for premultiplied-alpha images, but produces
../lib/public/stb_image_resize.h:127:         less-than-ideal results for non-premultiplied-alpha images.
../lib/public/stb_image_resize.h:146:         all-0-alpha pixels have 0 in all channels by #defining
../lib/public/stb_image_resize.h:162:      0.97 (2020-02-02) fixed warning
../lib/public/stb_image_resize.h:163:      0.96 (2019-03-04) fixed warnings
../lib/public/stb_image_resize.h:164:      0.95 (2017-07-23) fixed warnings
../lib/public/stb_image_resize.h:165:      0.94 (2017-03-18) fixed warnings
../lib/public/stb_image_resize.h:166:      0.93 (2017-03-03) fixed bug with certain combinations of heights
../lib/public/stb_image_resize.h:167:      0.92 (2017-01-02) fix integer overflow on large (>2GB) images
../lib/public/stb_image_resize.h:168:      0.91 (2016-04-02) fix warnings; fix handling of subpixel regions
../lib/public/stb_image_resize.h:169:      0.90 (2014-09-17) first released version
../lib/public/stb_image_resize.h:176:      Don't use full-width decode buffers when only processing a partial tile
../lib/public/stb_image_resize.h:181:         https://code.google.com/p/nvidia-texture-tools/source/browse/trunk/src/nvimage/FloatImage.cpp )
../lib/public/stb_image_resize.h:212:// Easy-to-use API:
../lib/public/stb_image_resize.h:215://     * input_w is input image width (x-axis), input_h is input image height (y-axis)
../lib/public/stb_image_resize.h:225://       you can change the compile-time defaults by #defining STBIR_DEFAULT_FILTER_UPSAMPLE
../lib/public/stb_image_resize.h:226://       and STBIR_DEFAULT_FILTER_DOWNSAMPLE, or you can use the medium-complexity API.
../lib/public/stb_image_resize.h:237:// The following functions interpret image data as gamma-corrected sRGB.
../lib/public/stb_image_resize.h:243:#define STBIR_ALPHA_CHANNEL_NONE       -1
../lib/public/stb_image_resize.h:246:// use alpha-weighted resampling (effectively premultiplying, resampling,
../lib/public/stb_image_resize.h:249:// The specified alpha channel should be handled as gamma-corrected value even
../lib/public/stb_image_resize.h:274:// Medium-complexity API
../lib/public/stb_image_resize.h:276:// This extends the easy-to-use API as follows:
../lib/public/stb_image_resize.h:278://     * Alpha-channel can be processed separately
../lib/public/stb_image_resize.h:289:    STBIR_FILTER_DEFAULT      = 0,  // use same filter type that easy-to-use API chooses
../lib/public/stb_image_resize.h:290:    STBIR_FILTER_BOX          = 1,  // A trapezoid w/1-pixel wide ramps, same result as box for integer scale ratios
../lib/public/stb_image_resize.h:292:    STBIR_FILTER_CUBICBSPLINE = 3,  // The cubic b-spline (aka Mitchell-Netrevalli with B=1,C=0), gaussian-esque
../lib/public/stb_image_resize.h:294:    STBIR_FILTER_MITCHELL     = 5,  // Mitchell-Netrevalli filter with B=1/3, C=1/3
../lib/public/stb_image_resize.h:329:// Full-complexity API
../lib/public/stb_image_resize.h:376:// (s0, t0) & (s1, t1) are the top-left and bottom right corner (uv addressing style: [0, 1]x[0, 1]) of a region of the input image to use.
../lib/public/stb_image_resize.h:418:typedef unsigned char stbir__validate_uint32[sizeof(stbir_uint32) == 4 ? 1 : -1];
../lib/public/stb_image_resize.h:446:// because we store the indices in 16-bit variables
../lib/public/stb_image_resize.h:450:// zeroing out color values. It is equivalent to 2^-80. If you don't want
../lib/public/stb_image_resize.h:549:    float* encode_buffer; // A temporary buffer to store floats so we don't lose precision while we do multiply-adds.
../lib/public/stb_image_resize.h:647:        return 1.055f * (float)pow(f, 1 / 2.4f) - 0.055f;
../lib/public/stb_image_resize.h:677:    static const stbir__FP32 almostone = { 0x3f7fffff }; // 1-eps
../lib/public/stb_image_resize.h:678:    static const stbir__FP32 minval = { (127-13) << 23 };
../lib/public/stb_image_resize.h:682:    // Clamp to [2^(-13), 1-eps]; these two values map to 0 and 1, respectively.
../lib/public/stb_image_resize.h:692:    tab = fp32_to_srgb8_tab4[(f.u - minval.u) >> 20];
../lib/public/stb_image_resize.h:696:    // Grab next-highest mantissa bits and perform linear interpolation
../lib/public/stb_image_resize.h:771:        float r = 0.5f - halfscale;
../lib/public/stb_image_resize.h:775:            return (t - x) / scale;
../lib/public/stb_image_resize.h:792:        return 1 - x;
../lib/public/stb_image_resize.h:804:        return (4 + x*x*(3*x - 6))/6;
../lib/public/stb_image_resize.h:806:        return (8 + x*(-12 + x*(6 - x)))/6;
../lib/public/stb_image_resize.h:818:        return 1 - x*x*(2.5f - 1.5f*x);
../lib/public/stb_image_resize.h:820:        return 2 - x*(4 + x*(0.5f*x - 2.5f));
../lib/public/stb_image_resize.h:832:        return (16 + x*x*(21 * x - 36))/18;
../lib/public/stb_image_resize.h:834:        return (32 + x*(-60 + x*(36 - 7*x)))/18;
../lib/public/stb_image_resize.h:873:    return stbir__use_upsampling(stbir_info->horizontal_scale);
../lib/public/stb_image_resize.h:878:    return stbir__use_upsampling(stbir_info->vertical_scale);
../lib/public/stb_image_resize.h:919:    return info->horizontal_num_contributors
../lib/public/stb_image_resize.h:920:         * stbir__get_coefficient_width      (info->horizontal_filter, info->horizontal_scale);
../lib/public/stb_image_resize.h:925:    return info->vertical_num_contributors
../lib/public/stb_image_resize.h:926:         * stbir__get_coefficient_width      (info->vertical_filter, info->vertical_scale);
../lib/public/stb_image_resize.h:954:            return max - 1;
../lib/public/stb_image_resize.h:963:                return -n;
../lib/public/stb_image_resize.h:965:                return max - 1;
../lib/public/stb_image_resize.h:974:                return max2 - n - 1;
../lib/public/stb_image_resize.h:985:            int m = (-n) % max;
../lib/public/stb_image_resize.h:988:                m = max - m;
../lib/public/stb_image_resize.h:1002:    // avoid per-pixel switch
../lib/public/stb_image_resize.h:1012:    float out_pixel_influence_lowerbound = out_pixel_center - out_filter_radius;
../lib/public/stb_image_resize.h:1020:    *in_last_pixel = (int)(floor(in_pixel_influence_upperbound - 0.5));
../lib/public/stb_image_resize.h:1027:    float in_pixel_influence_lowerbound = in_pixel_center - in_pixels_radius;
../lib/public/stb_image_resize.h:1030:    float out_pixel_influence_lowerbound = in_pixel_influence_lowerbound * scale_ratio - out_shift;
../lib/public/stb_image_resize.h:1031:    float out_pixel_influence_upperbound = in_pixel_influence_upperbound * scale_ratio - out_shift;
../lib/public/stb_image_resize.h:1033:    *out_center_of_in = in_pixel_center * scale_ratio - out_shift;
../lib/public/stb_image_resize.h:1035:    *out_last_pixel = (int)(floor(out_pixel_influence_upperbound - 0.5));
../lib/public/stb_image_resize.h:1044:    STBIR_ASSERT(in_last_pixel - in_first_pixel <= (int)ceil(stbir__filter_info_table[filter].support(1/scale) * 2)); // Taken directly from stbir__get_coefficient_width() which we can't call because we don't know if we're horizontal or vertical.
../lib/public/stb_image_resize.h:1046:    contributor->n0 = in_first_pixel;
../lib/public/stb_image_resize.h:1047:    contributor->n1 = in_last_pixel;
../lib/public/stb_image_resize.h:1049:    STBIR_ASSERT(contributor->n1 >= contributor->n0);
../lib/public/stb_image_resize.h:1051:    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
../lib/public/stb_image_resize.h:1054:        coefficient_group[i] = stbir__filter_info_table[filter].kernel(in_center_of_out - in_pixel_center, 1 / scale);
../lib/public/stb_image_resize.h:1059:            contributor->n0 = ++in_first_pixel;
../lib/public/stb_image_resize.h:1060:            i--;
../lib/public/stb_image_resize.h:1068:    // It would be true in exact math but is at best approximately true in floating-point math,
../lib/public/stb_image_resize.h:1071:    //STBIR_ASSERT(stbir__filter_info_table[filter].kernel((float)(in_last_pixel + 1) + 0.5f - in_center_of_out, 1/scale) == 0);
../lib/public/stb_image_resize.h:1079:    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
../lib/public/stb_image_resize.h:1082:    for (i = in_last_pixel - in_first_pixel; i >= 0; i--)
../lib/public/stb_image_resize.h:1088:        contributor->n1 = contributor->n0 + i - 1;
../lib/public/stb_image_resize.h:1096:    STBIR_ASSERT(out_last_pixel - out_first_pixel <= (int)ceil(stbir__filter_info_table[filter].support(scale_ratio) * 2)); // Taken directly from stbir__get_coefficient_width() which we can't call because we don't know if we're horizontal or vertical.
../lib/public/stb_image_resize.h:1098:    contributor->n0 = out_first_pixel;
../lib/public/stb_image_resize.h:1099:    contributor->n1 = out_last_pixel;
../lib/public/stb_image_resize.h:1101:    STBIR_ASSERT(contributor->n1 >= contributor->n0);
../lib/public/stb_image_resize.h:1103:    for (i = 0; i <= out_last_pixel - out_first_pixel; i++)
../lib/public/stb_image_resize.h:1106:        float x = out_pixel_center - out_center_of_in;
../lib/public/stb_image_resize.h:1111:    // It would be true in exact math but is at best approximately true in floating-point math,
../lib/public/stb_image_resize.h:1114:    //STBIR_ASSERT(stbir__filter_info_table[filter].kernel((float)(out_last_pixel + 1) + 0.5f - out_center_of_in, scale_ratio) == 0);
../lib/public/stb_image_resize.h:1116:    for (i = out_last_pixel - out_first_pixel; i >= 0; i--)
../lib/public/stb_image_resize.h:1122:        contributor->n1 = contributor->n0 + i - 1;
../lib/public/stb_image_resize.h:1142:                float coefficient = *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0);
../lib/public/stb_image_resize.h:1157:                *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0) *= scale;
../lib/public/stb_image_resize.h:1181:        range = contributors[j].n1 - contributors[j].n0 + 1;
../lib/public/stb_image_resize.h:1198:        contributors[i].n1 = stbir__min(contributors[i].n1, output_size - 1);
../lib/public/stb_image_resize.h:1232:            int n_adjusted = n - stbir__get_filter_pixel_margin(filter, scale_ratio);
../lib/public/stb_image_resize.h:1247:    return &stbir_info->decode_buffer[stbir_info->horizontal_filter_pixel_margin * stbir_info->channels];
../lib/public/stb_image_resize.h:1255:    int channels = stbir_info->channels;
../lib/public/stb_image_resize.h:1256:    int alpha_channel = stbir_info->alpha_channel;
../lib/public/stb_image_resize.h:1257:    int type = stbir_info->type;
../lib/public/stb_image_resize.h:1258:    int colorspace = stbir_info->colorspace;
../lib/public/stb_image_resize.h:1259:    int input_w = stbir_info->input_w;
../lib/public/stb_image_resize.h:1260:    size_t input_stride_bytes = stbir_info->input_stride_bytes;
../lib/public/stb_image_resize.h:1262:    stbir_edge edge_horizontal = stbir_info->edge_horizontal;
../lib/public/stb_image_resize.h:1263:    stbir_edge edge_vertical = stbir_info->edge_vertical;
../lib/public/stb_image_resize.h:1264:    size_t in_buffer_row_offset = stbir__edge_wrap(edge_vertical, n, stbir_info->input_h) * input_stride_bytes;
../lib/public/stb_image_resize.h:1265:    const void* input_data = (char *) stbir_info->input_data + in_buffer_row_offset;
../lib/public/stb_image_resize.h:1266:    int max_x = input_w + stbir_info->horizontal_filter_pixel_margin;
../lib/public/stb_image_resize.h:1269:    int x = -stbir_info->horizontal_filter_pixel_margin;
../lib/public/stb_image_resize.h:1273:    if (edge_vertical == STBIR_EDGE_ZERO && (n < 0 || n >= stbir_info->input_h))
../lib/public/stb_image_resize.h:1301:            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1324:            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1347:            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1370:            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1381:    if (!(stbir_info->flags & STBIR_FLAG_ALPHA_PREMULTIPLIED))
../lib/public/stb_image_resize.h:1383:        for (x = -stbir_info->horizontal_filter_pixel_margin; x < max_x; x++)
../lib/public/stb_image_resize.h:1390:            if (stbir_info->type != STBIR_TYPE_FLOAT) {
../lib/public/stb_image_resize.h:1407:        for (x = -stbir_info->horizontal_filter_pixel_margin; x < 0; x++)
../lib/public/stb_image_resize.h:1430:    stbir_info->ring_buffer_last_scanline = n;
../lib/public/stb_image_resize.h:1432:    if (stbir_info->ring_buffer_begin_index < 0)
../lib/public/stb_image_resize.h:1434:        ring_buffer_index = stbir_info->ring_buffer_begin_index = 0;
../lib/public/stb_image_resize.h:1435:        stbir_info->ring_buffer_first_scanline = n;
../lib/public/stb_image_resize.h:1439:        ring_buffer_index = (stbir_info->ring_buffer_begin_index + (stbir_info->ring_buffer_last_scanline - stbir_info->ring_buffer_first_scanline)) % stbir_info->ring_buffer_num_entries;
../lib/public/stb_image_resize.h:1440:        STBIR_ASSERT(ring_buffer_index != stbir_info->ring_buffer_begin_index);
../lib/public/stb_image_resize.h:1443:    ring_buffer = stbir__get_ring_buffer_entry(stbir_info->ring_buffer, ring_buffer_index, stbir_info->ring_buffer_length_bytes / sizeof(float));
../lib/public/stb_image_resize.h:1444:    memset(ring_buffer, 0, stbir_info->ring_buffer_length_bytes);
../lib/public/stb_image_resize.h:1453:    int output_w = stbir_info->output_w;
../lib/public/stb_image_resize.h:1454:    int channels = stbir_info->channels;
../lib/public/stb_image_resize.h:1456:    stbir__contributors* horizontal_contributors = stbir_info->horizontal_contributors;
../lib/public/stb_image_resize.h:1457:    float* horizontal_coefficients = stbir_info->horizontal_coefficients;
../lib/public/stb_image_resize.h:1458:    int coefficient_width = stbir_info->horizontal_coefficient_width;
../lib/public/stb_image_resize.h:1470:        STBIR_ASSERT(n0 >= -stbir_info->horizontal_filter_pixel_margin);
../lib/public/stb_image_resize.h:1471:        STBIR_ASSERT(n1 >= -stbir_info->horizontal_filter_pixel_margin);
../lib/public/stb_image_resize.h:1472:        STBIR_ASSERT(n0 < stbir_info->input_w + stbir_info->horizontal_filter_pixel_margin);
../lib/public/stb_image_resize.h:1473:        STBIR_ASSERT(n1 < stbir_info->input_w + stbir_info->horizontal_filter_pixel_margin);
../lib/public/stb_image_resize.h:1536:    int input_w = stbir_info->input_w;
../lib/public/stb_image_resize.h:1537:    int channels = stbir_info->channels;
../lib/public/stb_image_resize.h:1539:    stbir__contributors* horizontal_contributors = stbir_info->horizontal_contributors;
../lib/public/stb_image_resize.h:1540:    float* horizontal_coefficients = stbir_info->horizontal_coefficients;
../lib/public/stb_image_resize.h:1541:    int coefficient_width = stbir_info->horizontal_coefficient_width;
../lib/public/stb_image_resize.h:1542:    int filter_pixel_margin = stbir_info->horizontal_filter_pixel_margin;
../lib/public/stb_image_resize.h:1554:                int in_x = x - filter_pixel_margin;
../lib/public/stb_image_resize.h:1562:                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
../lib/public/stb_image_resize.h:1574:                int in_x = x - filter_pixel_margin;
../lib/public/stb_image_resize.h:1582:                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
../lib/public/stb_image_resize.h:1595:                int in_x = x - filter_pixel_margin;
../lib/public/stb_image_resize.h:1603:                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
../lib/public/stb_image_resize.h:1617:                int in_x = x - filter_pixel_margin;
../lib/public/stb_image_resize.h:1625:                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
../lib/public/stb_image_resize.h:1640:                int in_x = x - filter_pixel_margin;
../lib/public/stb_image_resize.h:1649:                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
../lib/public/stb_image_resize.h:1677:    memset(stbir_info->horizontal_buffer, 0, stbir_info->output_w * stbir_info->channels * sizeof(float));
../lib/public/stb_image_resize.h:1681:        stbir__resample_horizontal_upsample(stbir_info, stbir_info->horizontal_buffer);
../lib/public/stb_image_resize.h:1683:        stbir__resample_horizontal_downsample(stbir_info, stbir_info->horizontal_buffer);
../lib/public/stb_image_resize.h:1691:    int ring_buffer_index = (begin_index + (get_scanline - first_scanline)) % ring_buffer_num_entries;
../lib/public/stb_image_resize.h:1703:    if (!(stbir_info->flags&STBIR_FLAG_ALPHA_PREMULTIPLIED))
../lib/public/stb_image_resize.h:1712:            // unrolling this produced a 1% slowdown upscaling a large RGBA linear-space image on my machine - stb
../lib/public/stb_image_resize.h:1728:        if (x != alpha_channel || (stbir_info->flags & STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1771:                if (!(stbir_info->flags & STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1800:                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1830:                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1859:                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
../lib/public/stb_image_resize.h:1873:    int output_w = stbir_info->output_w;
../lib/public/stb_image_resize.h:1874:    stbir__contributors* vertical_contributors = stbir_info->vertical_contributors;
../lib/public/stb_image_resize.h:1875:    float* vertical_coefficients = stbir_info->vertical_coefficients;
../lib/public/stb_image_resize.h:1876:    int channels = stbir_info->channels;
../lib/public/stb_image_resize.h:1877:    int alpha_channel = stbir_info->alpha_channel;
../lib/public/stb_image_resize.h:1878:    int type = stbir_info->type;
../lib/public/stb_image_resize.h:1879:    int colorspace = stbir_info->colorspace;
../lib/public/stb_image_resize.h:1880:    int ring_buffer_entries = stbir_info->ring_buffer_num_entries;
../lib/public/stb_image_resize.h:1881:    void* output_data = stbir_info->output_data;
../lib/public/stb_image_resize.h:1882:    float* encode_buffer = stbir_info->encode_buffer;
../lib/public/stb_image_resize.h:1884:    int coefficient_width = stbir_info->vertical_coefficient_width;
../lib/public/stb_image_resize.h:1888:    float* ring_buffer = stbir_info->ring_buffer;
../lib/public/stb_image_resize.h:1889:    int ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;
../lib/public/stb_image_resize.h:1890:    int ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;
../lib/public/stb_image_resize.h:1891:    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);
../lib/public/stb_image_resize.h:1899:    output_row_start = n * stbir_info->output_stride_bytes;
../lib/public/stb_image_resize.h:1906:    // (using x_outer, k, x_inner), but it lost speed. -- stb
../lib/public/stb_image_resize.h:1990:    int output_w = stbir_info->output_w;
../lib/public/stb_image_resize.h:1991:    stbir__contributors* vertical_contributors = stbir_info->vertical_contributors;
../lib/public/stb_image_resize.h:1992:    float* vertical_coefficients = stbir_info->vertical_coefficients;
../lib/public/stb_image_resize.h:1993:    int channels = stbir_info->channels;
../lib/public/stb_image_resize.h:1994:    int ring_buffer_entries = stbir_info->ring_buffer_num_entries;
../lib/public/stb_image_resize.h:1995:    float* horizontal_buffer = stbir_info->horizontal_buffer;
../lib/public/stb_image_resize.h:1996:    int coefficient_width = stbir_info->vertical_coefficient_width;
../lib/public/stb_image_resize.h:1997:    int contributor = n + stbir_info->vertical_filter_pixel_margin;
../lib/public/stb_image_resize.h:1999:    float* ring_buffer = stbir_info->ring_buffer;
../lib/public/stb_image_resize.h:2000:    int ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;
../lib/public/stb_image_resize.h:2001:    int ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;
../lib/public/stb_image_resize.h:2002:    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);
../lib/public/stb_image_resize.h:2012:        int coefficient_index = k - n0;
../lib/public/stb_image_resize.h:2070:    float scale_ratio = stbir_info->vertical_scale;
../lib/public/stb_image_resize.h:2071:    float out_scanlines_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(1/scale_ratio) * scale_ratio;
../lib/public/stb_image_resize.h:2075:    for (y = 0; y < stbir_info->output_h; y++)
../lib/public/stb_image_resize.h:2080:        stbir__calculate_sample_range_upsample(y, out_scanlines_radius, scale_ratio, stbir_info->vertical_shift, &in_first_scanline, &in_last_scanline, &in_center_of_out);
../lib/public/stb_image_resize.h:2082:        STBIR_ASSERT(in_last_scanline - in_first_scanline + 1 <= stbir_info->ring_buffer_num_entries);
../lib/public/stb_image_resize.h:2084:        if (stbir_info->ring_buffer_begin_index >= 0)
../lib/public/stb_image_resize.h:2087:            while (in_first_scanline > stbir_info->ring_buffer_first_scanline)
../lib/public/stb_image_resize.h:2089:                if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)
../lib/public/stb_image_resize.h:2093:                    stbir_info->ring_buffer_begin_index = -1;
../lib/public/stb_image_resize.h:2094:                    stbir_info->ring_buffer_first_scanline = 0;
../lib/public/stb_image_resize.h:2095:                    stbir_info->ring_buffer_last_scanline = 0;
../lib/public/stb_image_resize.h:2100:                    stbir_info->ring_buffer_first_scanline++;
../lib/public/stb_image_resize.h:2101:                    stbir_info->ring_buffer_begin_index = (stbir_info->ring_buffer_begin_index + 1) % stbir_info->ring_buffer_num_entries;
../lib/public/stb_image_resize.h:2107:        if (stbir_info->ring_buffer_begin_index < 0)
../lib/public/stb_image_resize.h:2110:        while (in_last_scanline > stbir_info->ring_buffer_last_scanline)
../lib/public/stb_image_resize.h:2111:            stbir__decode_and_resample_upsample(stbir_info, stbir_info->ring_buffer_last_scanline + 1);
../lib/public/stb_image_resize.h:2116:        STBIR_PROGRESS_REPORT((float)y / stbir_info->output_h);
../lib/public/stb_image_resize.h:2122:    int output_stride_bytes = stbir_info->output_stride_bytes;
../lib/public/stb_image_resize.h:2123:    int channels = stbir_info->channels;
../lib/public/stb_image_resize.h:2124:    int alpha_channel = stbir_info->alpha_channel;
../lib/public/stb_image_resize.h:2125:    int type = stbir_info->type;
../lib/public/stb_image_resize.h:2126:    int colorspace = stbir_info->colorspace;
../lib/public/stb_image_resize.h:2127:    int output_w = stbir_info->output_w;
../lib/public/stb_image_resize.h:2128:    void* output_data = stbir_info->output_data;
../lib/public/stb_image_resize.h:2131:    float* ring_buffer = stbir_info->ring_buffer;
../lib/public/stb_image_resize.h:2132:    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);
../lib/public/stb_image_resize.h:2134:    if (stbir_info->ring_buffer_begin_index >= 0)
../lib/public/stb_image_resize.h:2137:        while (first_necessary_scanline > stbir_info->ring_buffer_first_scanline)
../lib/public/stb_image_resize.h:2139:            if (stbir_info->ring_buffer_first_scanline >= 0 && stbir_info->ring_buffer_first_scanline < stbir_info->output_h)
../lib/public/stb_image_resize.h:2141:                int output_row_start = stbir_info->ring_buffer_first_scanline * output_stride_bytes;
../lib/public/stb_image_resize.h:2142:                float* ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer, stbir_info->ring_buffer_begin_index, ring_buffer_length);
../lib/public/stb_image_resize.h:2144:                STBIR_PROGRESS_REPORT((float)stbir_info->ring_buffer_first_scanline / stbir_info->output_h);
../lib/public/stb_image_resize.h:2147:            if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)
../lib/public/stb_image_resize.h:2151:                stbir_info->ring_buffer_begin_index = -1;
../lib/public/stb_image_resize.h:2152:                stbir_info->ring_buffer_first_scanline = 0;
../lib/public/stb_image_resize.h:2153:                stbir_info->ring_buffer_last_scanline = 0;
../lib/public/stb_image_resize.h:2158:                stbir_info->ring_buffer_first_scanline++;
../lib/public/stb_image_resize.h:2159:                stbir_info->ring_buffer_begin_index = (stbir_info->ring_buffer_begin_index + 1) % stbir_info->ring_buffer_num_entries;
../lib/public/stb_image_resize.h:2168:    float scale_ratio = stbir_info->vertical_scale;
../lib/public/stb_image_resize.h:2169:    int output_h = stbir_info->output_h;
../lib/public/stb_image_resize.h:2170:    float in_pixels_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(scale_ratio) / scale_ratio;
../lib/public/stb_image_resize.h:2171:    int pixel_margin = stbir_info->vertical_filter_pixel_margin;
../lib/public/stb_image_resize.h:2172:    int max_y = stbir_info->input_h + pixel_margin;
../lib/public/stb_image_resize.h:2176:    for (y = -pixel_margin; y < max_y; y++)
../lib/public/stb_image_resize.h:2181:        stbir__calculate_sample_range_downsample(y, in_pixels_radius, scale_ratio, stbir_info->vertical_shift, &out_first_scanline, &out_last_scanline, &out_center_of_in);
../lib/public/stb_image_resize.h:2183:        STBIR_ASSERT(out_last_scanline - out_first_scanline + 1 <= stbir_info->ring_buffer_num_entries);
../lib/public/stb_image_resize.h:2193:        if (stbir_info->ring_buffer_begin_index < 0)
../lib/public/stb_image_resize.h:2196:        while (out_last_scanline > stbir_info->ring_buffer_last_scanline)
../lib/public/stb_image_resize.h:2197:            stbir__add_empty_ring_buffer_entry(stbir_info, stbir_info->ring_buffer_last_scanline + 1);
../lib/public/stb_image_resize.h:2203:    stbir__empty_ring_buffer(stbir_info, stbir_info->output_h);
../lib/public/stb_image_resize.h:2208:    info->input_w = input_w;
../lib/public/stb_image_resize.h:2209:    info->input_h = input_h;
../lib/public/stb_image_resize.h:2210:    info->output_w = output_w;
../lib/public/stb_image_resize.h:2211:    info->output_h = output_h;
../lib/public/stb_image_resize.h:2212:    info->channels = channels;
../lib/public/stb_image_resize.h:2217:    info->s0 = s0;
../lib/public/stb_image_resize.h:2218:    info->t0 = t0;
../lib/public/stb_image_resize.h:2219:    info->s1 = s1;
../lib/public/stb_image_resize.h:2220:    info->t1 = t1;
../lib/public/stb_image_resize.h:2224:        info->horizontal_scale = transform[0];
../lib/public/stb_image_resize.h:2225:        info->vertical_scale   = transform[1];
../lib/public/stb_image_resize.h:2226:        info->horizontal_shift = transform[2];
../lib/public/stb_image_resize.h:2227:        info->vertical_shift   = transform[3];
../lib/public/stb_image_resize.h:2231:        info->horizontal_scale = ((float)info->output_w / info->input_w) / (s1 - s0);
../lib/public/stb_image_resize.h:2232:        info->vertical_scale = ((float)info->output_h / info->input_h) / (t1 - t0);
../lib/public/stb_image_resize.h:2234:        info->horizontal_shift = s0 * info->output_w / (s1 - s0);
../lib/public/stb_image_resize.h:2235:        info->vertical_shift = t0 * info->output_h / (t1 - t0);
../lib/public/stb_image_resize.h:2242:        h_filter = stbir__use_upsampling(info->horizontal_scale) ? STBIR_DEFAULT_FILTER_UPSAMPLE : STBIR_DEFAULT_FILTER_DOWNSAMPLE;
../lib/public/stb_image_resize.h:2244:        v_filter = stbir__use_upsampling(info->vertical_scale)   ? STBIR_DEFAULT_FILTER_UPSAMPLE : STBIR_DEFAULT_FILTER_DOWNSAMPLE;
../lib/public/stb_image_resize.h:2245:    info->horizontal_filter = h_filter;
../lib/public/stb_image_resize.h:2246:    info->vertical_filter = v_filter;
../lib/public/stb_image_resize.h:2251:    int pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);
../lib/public/stb_image_resize.h:2252:    int filter_height = stbir__get_filter_pixel_width(info->vertical_filter, info->vertical_scale);
../lib/public/stb_image_resize.h:2254:    info->horizontal_num_contributors = stbir__get_contributors(info->horizontal_scale, info->horizontal_filter, info->input_w, info->output_w);
../lib/public/stb_image_resize.h:2255:    info->vertical_num_contributors   = stbir__get_contributors(info->vertical_scale  , info->vertical_filter  , info->input_h, info->output_h);
../lib/public/stb_image_resize.h:2258:    info->ring_buffer_num_entries = filter_height + 1;
../lib/public/stb_image_resize.h:2260:    info->horizontal_contributors_size = info->horizontal_num_contributors * sizeof(stbir__contributors);
../lib/public/stb_image_resize.h:2261:    info->horizontal_coefficients_size = stbir__get_total_horizontal_coefficients(info) * sizeof(float);
../lib/public/stb_image_resize.h:2262:    info->vertical_contributors_size = info->vertical_num_contributors * sizeof(stbir__contributors);
../lib/public/stb_image_resize.h:2263:    info->vertical_coefficients_size = stbir__get_total_vertical_coefficients(info) * sizeof(float);
../lib/public/stb_image_resize.h:2264:    info->decode_buffer_size = (info->input_w + pixel_margin * 2) * info->channels * sizeof(float);
../lib/public/stb_image_resize.h:2265:    info->horizontal_buffer_size = info->output_w * info->channels * sizeof(float);
../lib/public/stb_image_resize.h:2266:    info->ring_buffer_size = info->output_w * info->channels * info->ring_buffer_num_entries * sizeof(float);
../lib/public/stb_image_resize.h:2267:    info->encode_buffer_size = info->output_w * info->channels * sizeof(float);
../lib/public/stb_image_resize.h:2269:    STBIR_ASSERT(info->horizontal_filter != 0);
../lib/public/stb_image_resize.h:2270:    STBIR_ASSERT(info->horizontal_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table)); // this now happens too late
../lib/public/stb_image_resize.h:2271:    STBIR_ASSERT(info->vertical_filter != 0);
../lib/public/stb_image_resize.h:2272:    STBIR_ASSERT(info->vertical_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table)); // this now happens too late
../lib/public/stb_image_resize.h:2278:        info->horizontal_buffer_size = 0;
../lib/public/stb_image_resize.h:2282:        info->encode_buffer_size = 0;
../lib/public/stb_image_resize.h:2284:    return info->horizontal_contributors_size + info->horizontal_coefficients_size
../lib/public/stb_image_resize.h:2285:        + info->vertical_contributors_size + info->vertical_coefficients_size
../lib/public/stb_image_resize.h:2286:        + info->decode_buffer_size + info->horizontal_buffer_size
../lib/public/stb_image_resize.h:2287:        + info->ring_buffer_size + info->encode_buffer_size;
../lib/public/stb_image_resize.h:2299:    int width_stride_input = input_stride_in_bytes ? input_stride_in_bytes : info->channels * info->input_w * stbir__type_size[type];
../lib/public/stb_image_resize.h:2300:    int width_stride_output = output_stride_in_bytes ? output_stride_in_bytes : info->channels * info->output_w * stbir__type_size[type];
../lib/public/stb_image_resize.h:2309:    size_t begin_forbidden = width_stride_output * (info->output_h - 1) + info->output_w * info->channels * stbir__type_size[type];
../lib/public/stb_image_resize.h:2310:    memcpy(overwrite_output_before_pre, &((unsigned char*)output_data)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE);
../lib/public/stb_image_resize.h:2312:    memcpy(overwrite_tempmem_before_pre, &((unsigned char*)tempmem)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE);
../lib/public/stb_image_resize.h:2316:    STBIR_ASSERT(info->channels >= 0);
../lib/public/stb_image_resize.h:2317:    STBIR_ASSERT(info->channels <= STBIR_MAX_CHANNELS);
../lib/public/stb_image_resize.h:2319:    if (info->channels < 0 || info->channels > STBIR_MAX_CHANNELS)
../lib/public/stb_image_resize.h:2322:    STBIR_ASSERT(info->horizontal_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));
../lib/public/stb_image_resize.h:2323:    STBIR_ASSERT(info->vertical_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));
../lib/public/stb_image_resize.h:2325:    if (info->horizontal_filter >= STBIR__ARRAY_SIZE(stbir__filter_info_table))
../lib/public/stb_image_resize.h:2327:    if (info->vertical_filter >= STBIR__ARRAY_SIZE(stbir__filter_info_table))
../lib/public/stb_image_resize.h:2334:        STBIR_ASSERT(alpha_channel >= 0 && alpha_channel < info->channels);
../lib/public/stb_image_resize.h:2337:    if (alpha_channel >= info->channels)
../lib/public/stb_image_resize.h:2352:    info->input_data = input_data;
../lib/public/stb_image_resize.h:2353:    info->input_stride_bytes = width_stride_input;
../lib/public/stb_image_resize.h:2355:    info->output_data = output_data;
../lib/public/stb_image_resize.h:2356:    info->output_stride_bytes = width_stride_output;
../lib/public/stb_image_resize.h:2358:    info->alpha_channel = alpha_channel;
../lib/public/stb_image_resize.h:2359:    info->flags = flags;
../lib/public/stb_image_resize.h:2360:    info->type = type;
../lib/public/stb_image_resize.h:2361:    info->edge_horizontal = edge_horizontal;
../lib/public/stb_image_resize.h:2362:    info->edge_vertical = edge_vertical;
../lib/public/stb_image_resize.h:2363:    info->colorspace = colorspace;
../lib/public/stb_image_resize.h:2365:    info->horizontal_coefficient_width   = stbir__get_coefficient_width  (info->horizontal_filter, info->horizontal_scale);
../lib/public/stb_image_resize.h:2366:    info->vertical_coefficient_width     = stbir__get_coefficient_width  (info->vertical_filter  , info->vertical_scale  );
../lib/public/stb_image_resize.h:2367:    info->horizontal_filter_pixel_width  = stbir__get_filter_pixel_width (info->horizontal_filter, info->horizontal_scale);
../lib/public/stb_image_resize.h:2368:    info->vertical_filter_pixel_width    = stbir__get_filter_pixel_width (info->vertical_filter  , info->vertical_scale  );
../lib/public/stb_image_resize.h:2369:    info->horizontal_filter_pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);
../lib/public/stb_image_resize.h:2370:    info->vertical_filter_pixel_margin   = stbir__get_filter_pixel_margin(info->vertical_filter  , info->vertical_scale  );
../lib/public/stb_image_resize.h:2372:    info->ring_buffer_length_bytes = info->output_w * info->channels * sizeof(float);
../lib/public/stb_image_resize.h:2373:    info->decode_buffer_pixels = info->input_w + info->horizontal_filter_pixel_margin * 2;
../lib/public/stb_image_resize.h:2377:    info->horizontal_contributors = (stbir__contributors *) tempmem;
../lib/public/stb_image_resize.h:2378:    info->horizontal_coefficients = STBIR__NEXT_MEMPTR(info->horizontal_contributors, float);
../lib/public/stb_image_resize.h:2379:    info->vertical_contributors = STBIR__NEXT_MEMPTR(info->horizontal_coefficients, stbir__contributors);
../lib/public/stb_image_resize.h:2380:    info->vertical_coefficients = STBIR__NEXT_MEMPTR(info->vertical_contributors, float);
../lib/public/stb_image_resize.h:2381:    info->decode_buffer = STBIR__NEXT_MEMPTR(info->vertical_coefficients, float);
../lib/public/stb_image_resize.h:2385:        info->horizontal_buffer = NULL;
../lib/public/stb_image_resize.h:2386:        info->ring_buffer = STBIR__NEXT_MEMPTR(info->decode_buffer, float);
../lib/public/stb_image_resize.h:2387:        info->encode_buffer = STBIR__NEXT_MEMPTR(info->ring_buffer, float);
../lib/public/stb_image_resize.h:2389:        STBIR_ASSERT((size_t)STBIR__NEXT_MEMPTR(info->encode_buffer, unsigned char) == (size_t)tempmem + tempmem_size_in_bytes);
../lib/public/stb_image_resize.h:2393:        info->horizontal_buffer = STBIR__NEXT_MEMPTR(info->decode_buffer, float);
../lib/public/stb_image_resize.h:2394:        info->ring_buffer = STBIR__NEXT_MEMPTR(info->horizontal_buffer, float);
../lib/public/stb_image_resize.h:2395:        info->encode_buffer = NULL;
../lib/public/stb_image_resize.h:2397:        STBIR_ASSERT((size_t)STBIR__NEXT_MEMPTR(info->ring_buffer, unsigned char) == (size_t)tempmem + tempmem_size_in_bytes);
../lib/public/stb_image_resize.h:2403:    info->ring_buffer_begin_index = -1;
../lib/public/stb_image_resize.h:2405:    stbir__calculate_filters(info->horizontal_contributors, info->horizontal_coefficients, info->horizontal_filter, info->horizontal_scale, info->horizontal_shift, info->input_w, info->output_w);
../lib/public/stb_image_resize.h:2406:    stbir__calculate_filters(info->vertical_contributors, info->vertical_coefficients, info->vertical_filter, info->vertical_scale, info->vertical_shift, info->input_h, info->output_h);
../lib/public/stb_image_resize.h:2418:    STBIR_ASSERT(memcmp(overwrite_output_before_pre, &((unsigned char*)output_data)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE) == 0);
../lib/public/stb_image_resize.h:2420:    STBIR_ASSERT(memcmp(overwrite_tempmem_before_pre, &((unsigned char*)tempmem)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE) == 0);
../lib/public/stb_image_resize.h:2468:        0,0,1,1,NULL,num_channels,-1,0, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,
../lib/public/stb_image_resize.h:2478:        0,0,1,1,NULL,num_channels,-1,0, STBIR_TYPE_FLOAT, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,
../lib/public/stb_image_resize.h:2595:------------------------------------------------------------------------------
../lib/public/stb_image_resize.h:2596:This software is available under 2 licenses -- choose whichever you prefer.
../lib/public/stb_image_resize.h:2597:------------------------------------------------------------------------------
../lib/public/stb_image_resize.h:2598:ALTERNATIVE A - MIT License
../lib/public/stb_image_resize.h:2615:------------------------------------------------------------------------------
../lib/public/stb_image_resize.h:2616:ALTERNATIVE B - Public Domain (www.unlicense.org)
../lib/public/stb_image_resize.h:2620:commercial or non-commercial, and by any means.
../lib/public/stb_image_resize.h:2633:------------------------------------------------------------------------------
../lib/public/vec.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../lib/public/vec.h:64:    ((vec)->size)
../lib/public/vec.h:67:    ((vec)->array[i])
../lib/public/vec.h:94:        vec->size = 0;                                                                          \
../lib/public/vec.h:95:        vec->capacity = 0;                                                                      \
../lib/public/vec.h:96:        vec->array = NULL;                                                                      \
../lib/public/vec.h:97:        vec->vrealloc = realloc;                                                                \
../lib/public/vec.h:98:        vec->vfree = free;                                                                      \
../lib/public/vec.h:105:        vec->size = 0;                                                                          \
../lib/public/vec.h:106:        vec->capacity = 0;                                                                      \
../lib/public/vec.h:107:        vec->array = NULL;                                                                      \
../lib/public/vec.h:108:        vec->vrealloc = vrealloc;                                                               \
../lib/public/vec.h:109:        vec->vfree = vfree;                                                                     \
../lib/public/vec.h:114:        if(vec->capacity >= new_cap)                                                            \
../lib/public/vec.h:117:        type *new_array = vec->vrealloc(vec->array, new_cap * sizeof(type));                    \
../lib/public/vec.h:121:        vec->array = new_array;                                                                 \
../lib/public/vec.h:122:        vec->capacity = new_cap;                                                                \
../lib/public/vec.h:128:        vec->vfree(vec->array);                                                                 \
../lib/public/vec.h:134:        if(vec->size == vec->capacity                                                           \
../lib/public/vec.h:135:        && !vec_##name##_resize(vec, (vec->size == 0 ? 16 : vec->size * 2)))                    \
../lib/public/vec.h:138:        vec->array[vec->size++] = in;                                                           \
../lib/public/vec.h:144:        if(del_idx < 0 || del_idx >= vec->size)                                                 \
../lib/public/vec.h:147:        vec->array[del_idx] = vec->array[--vec->size];                                          \
../lib/public/vec.h:153:        int ret = -1;                                                                           \
../lib/public/vec.h:154:        for(int i = 0; i < vec->size; i++) {                                                    \
../lib/public/vec.h:155:            if(comparator(&vec->array[i], &t)) {                                                \
../lib/public/vec.h:165:        vec->size = 0;                                                                          \
../lib/public/vec.h:173:        memcpy(dst->array, src->array, src->size * sizeof(type));                               \
../lib/public/vec.h:174:        dst->size = src->size;                                                                  \
../lib/public/vec.h:180:        return vec->array[--vec->size];                                                         \
../lib/public/vec.h:185:        size_t total = a->size + b->size;                                                       \
../lib/public/vec.h:191:        memcpy(a->array + a->size, b->array, b->size * sizeof(type));                           \
../lib/public/vec.h:192:        a->size = total;                                                                        \
../lib/public/vec.h:198:        for(int i = 0; i < b->size; i++) {                                                      \
../lib/stalloc.c:49:    st->head = malloc(sizeof(struct st_mem));
../lib/stalloc.c:50:    if(!st->head)
../lib/stalloc.c:53:    st->head->next = NULL;
../lib/stalloc.c:54:    st->top = st->head->raw;
../lib/stalloc.c:55:    st->tail = st->head;
../lib/stalloc.c:61:    struct st_mem *curr = st->head, *tmp;
../lib/stalloc.c:63:        tmp = curr->next;
../lib/stalloc.c:74:    const size_t aligned_size = (size + (sizeof(intmax_t) - 1)) & ~(sizeof(intmax_t) - 1);
../lib/stalloc.c:75:    const size_t align_pad = aligned_size - size;
../lib/stalloc.c:77:    unsigned char *curr_end = st->tail->raw + MEMBLOCK_SZ;
../lib/stalloc.c:78:    size_t curr_left = curr_end - (unsigned char*)st->top;
../lib/stalloc.c:85:        void *ret = st->top;
../lib/stalloc.c:86:        st->top = (unsigned char*)st->top + aligned_size; 
../lib/stalloc.c:88:        assert((((uintptr_t)ret) & (sizeof(intmax_t)-1)) == 0);
../lib/stalloc.c:89:        memset(((char*)ret) + aligned_size - align_pad, 0, align_pad);
../lib/stalloc.c:93:    st->tail->next = malloc(sizeof(struct st_mem));
../lib/stalloc.c:94:    if(!st->tail->next)
../lib/stalloc.c:97:    st->tail = st->tail->next;
../lib/stalloc.c:98:    st->tail->next = NULL;
../lib/stalloc.c:100:    void *ret = st->tail->raw;
../lib/stalloc.c:101:    st->top = st->tail->raw + aligned_size;
../lib/stalloc.c:103:    assert((((uintptr_t)ret) & (sizeof(intmax_t)-1)) == 0);
../lib/stalloc.c:104:    memset(((char*)ret) + aligned_size - align_pad, 0, align_pad);
../lib/stalloc.c:111:    struct st_mem *curr = st->head->next, *tmp;
../lib/stalloc.c:113:        tmp = curr->next;
../lib/stalloc.c:118:    st->head->next = NULL;
../lib/stalloc.c:119:    st->top = st->head->raw;
../lib/stalloc.c:120:    st->tail = st->head;
../lib/stalloc.c:125:    st->top = st->mem;
../lib/stalloc.c:126:    memset(&st->extra, 0, sizeof(st->extra));
../lib/stalloc.c:132:    if(st->top)
../lib/stalloc.c:134:    stalloc_destroy(&st->extra);
../lib/stalloc.c:141:    const size_t aligned_size = (size + (sizeof(intmax_t) - 1)) & ~(sizeof(intmax_t) - 1);
../lib/stalloc.c:142:    const size_t align_pad = aligned_size - size;
../lib/stalloc.c:144:    if(!st->top)
../lib/stalloc.c:145:        return stalloc(&st->extra, size);
../lib/stalloc.c:147:    size_t local_left = STATIC_BUFF_SZ - ((unsigned char*)st->top - st->mem);
../lib/stalloc.c:149:        void *ret = st->top;
../lib/stalloc.c:150:        st->top = (unsigned char*)st->top + aligned_size;
../lib/stalloc.c:152:        assert((((uintptr_t)ret) & (sizeof(intmax_t)-1)) == 0);
../lib/stalloc.c:153:        memset(((char*)ret) + aligned_size - align_pad, 0, align_pad);
../lib/stalloc.c:157:    if(!stalloc_init(&st->extra))
../lib/stalloc.c:160:    st->top = NULL;
../lib/stalloc.c:161:    return stalloc(&st->extra, size);
../lib/stalloc.c:166:    if(!st->top)
../lib/stalloc.c:167:        stalloc_destroy(&st->extra);
../lib/stalloc.c:168:    st->top = st->mem;
../lib/string_intern.c:87:    if(status == -1) {
../lib/string_intern.c:94:    if(strlen(str) > sizeof(strbuff_t)-1) {
../main.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../main.c:81:const char                      *g_basepath; /* write-once - path of the base directory */
../main.c:84:threadID_t                       g_main_thread_id;   /* write-once */
../main.c:85:threadID_t                       g_render_thread_id; /* write-once */
../main.c:184:        E_Global_Notify(event->type, (void*)event, ES_ENGINE);
../main.c:198:    rstate->start = false;
../main.c:200:    rstate->sq_lock = SDL_CreateMutex();
../main.c:201:    if(!rstate->sq_lock)
../main.c:204:    rstate->sq_cond = SDL_CreateCond();
../main.c:205:    if(!rstate->sq_cond)
../main.c:208:    rstate->done = false;
../main.c:210:    rstate->done_lock = SDL_CreateMutex();
../main.c:211:    if(!rstate->done_lock)
../main.c:214:    rstate->done_cond = SDL_CreateCond();
../main.c:215:    if(!rstate->done_cond)
../main.c:218:    rstate->swap_buffers = false;
../main.c:222:    SDL_DestroyMutex(rstate->done_lock);
../main.c:224:    SDL_DestroyCond(rstate->sq_cond);
../main.c:226:    SDL_DestroyMutex(rstate->sq_lock);
../main.c:233:    SDL_DestroyCond(rstate->done_cond);
../main.c:234:    SDL_DestroyMutex(rstate->done_lock);
../main.c:235:    SDL_DestroyCond(rstate->sq_cond);
../main.c:236:    SDL_DestroyMutex(rstate->sq_lock);
../main.c:278:        ((void(*)(void*, SEL))objc_msgSend)(nscontext, NSSelectorFromString(aCFString)); // Call the `update` method on the current SDLOpenGLContext object (which inherits from NSOpenGLContext : https://developer.apple.com/documentation/appkit/nsopenglcontext/1436135-update?language=objc )
../main.c:290:     * it - this gives us a chance to handle this event without anyone 
../main.c:292:    if(((uint64_t)g_frame_idx) - Session_ChangeTick() <= 1)
../main.c:299:    SDL_KeyboardEvent *key = &((SDL_Event*)event)->key;
../main.c:300:    if(key->keysym.scancode != CONFIG_FRAME_STEP_HOTKEY)
../main.c:307:    return (new_val->type == ST_TYPE_BOOL);
../main.c:312:    if(new_val->as_bool) {
../main.c:359:    memcpy(ret->pixels, image, width * height * 3);
../main.c:391:    memcpy(surface->pixels, image, width * height * 4);
../main.c:478:    // FIXME: This causes crash when trying to create a gl context for this window, so I commented it out temporarily (maybe related to https://discourse.libsdl.org/t/sdl-createwindowfrom-with-opengl/19737/4 ) :
../main.c:502:    //assert(g_render_thread_id != 0); // https://wiki.libsdl.org/SDL_GetThreadID : "This thread identifier is as reported by the underlying operating system. If SDL is running on a platform that does not support threads the return value will always be zero." -- however, sometimes this works/doesn't work on macOS...
../main.c:524:        fprintf(stderr, "Failed to initialize asset-loading module.\n");
../main.c:793:        if(strstr(curr, "--") != curr)
../main.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../main.h:51:// Based on https://github.com/libsdl-org/SDL : SDL/src/thread/SDL_thread_c.h
../main.h:67:    size_t stacksize;  /* 0 for default, >0 for user-specified stack size. */
../main.h:74:    pthread_t pth = ((struct SDL_Thread_impl*)th)->handle;
../main.h:82://#define thisThreadID() (long long)pthread_self() //((struct _opaque_pthread_t *)pthread_self())->__sig //pthread_self()
../main.h:89:#define xstr(a) str(a) // https://stackoverflow.com/questions/2653214/stringification-of-a-macro-value
../main.h:132:#ifdef EXTERNAL_DRIVER // https://stackoverflow.com/questions/31519449/c99-call-main-function-from-another-main
../map/map.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/map.c:67:    int x_offset = -(p.c * chunk_x_dim);
../map/map.c:70:    out->x_max = map->pos.x + x_offset;
../map/map.c:71:    out->x_min = out->x_max - chunk_x_dim;
../map/map.c:73:    out->z_min = map->pos.z + z_offset;
../map/map.c:74:    out->z_max = out->z_min + chunk_z_dim;
../map/map.c:76:    out->y_min = 0.0f;
../map/map.c:77:    out->y_max = chunk_max_height;
../map/map.c:79:    assert(out->x_max >= out->x_min);
../map/map.c:80:    assert(out->y_max >= out->y_min);
../map/map.c:81:    assert(out->z_max >= out->z_min);
../map/map.c:90:    N_Update(map->nav_private);
../map/map.c:95:    ssize_t x_offset = -(p.c * TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE);
../map/map.c:97:    vec3_t chunk_pos = (vec3_t) {map->pos.x + x_offset, map->pos.y, map->pos.z + z_offset};
../map/map.c:104:    vec2_t pos = (vec2_t){map->pos.x, map->pos.z};
../map/map.c:116:    for(int r = 0; r < map->height; r++) {
../map/map.c:117:    for(int c = 0; c < map->width;  c++) {
../map/map.c:120:        const struct pfchunk *chunk = &map->chunks[r * map->width + c];
../map/map.c:129:                    chunk->render_private,
../map/map.c:139:                    chunk->render_private,
../map/map.c:157:    vec2_t pos = (vec2_t){map->pos.x, map->pos.z};
../map/map.c:169:    for(int r = 0; r < map->height; r++) {
../map/map.c:170:    for(int c = 0; c < map->width;  c++) {
../map/map.c:184:        const struct pfchunk *chunk = &map->chunks[r * map->width + c];
../map/map.c:193:                    chunk->render_private,
../map/map.c:203:                    chunk->render_private,
../map/map.c:220:    for(int r = 0; r < map->height; r++) {
../map/map.c:221:    for(int c = 0; c < map->width;  c++) {
../map/map.c:231:        N_RenderPathableChunk(map->nav_private, &chunk_model, map, r, c, layer); 
../map/map.c:240:    for(int r = 0; r < map->height; r++) {
../map/map.c:241:    for(int c = 0; c < map->width;  c++) {
../map/map.c:279:    for(int r = 0; r < map->height; r++) {
../map/map.c:280:    for(int c = 0; c < map->width;  c++) {
../map/map.c:296:    size_t width  = map->width * TILES_PER_CHUNK_WIDTH * X_COORDS_PER_TILE;
../map/map.c:297:    size_t height = map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE;
../map/map.c:299:    map->pos = (vec3_t) {(width / 2.0f), 0.0f, -(height / 2.0f)};
../map/map.c:308:     * not appear equal due to the camera tilt. For example, with yaw = 135 and pitch = -70, 
../map/map.c:320:    bounds.x = map->pos.x - cos(DEG_TO_RAD(Camera_GetYaw(cam))) * offset_mag;
../map/map.c:321:    bounds.z = map->pos.z + sin(DEG_TO_RAD(Camera_GetYaw(cam))) * offset_mag;
../map/map.c:322:    bounds.w = map->width  * TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE;
../map/map.c:323:    bounds.h = map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE;
../map/map.c:330:    float width  = map->width  * TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE;
../map/map.c:331:    float height = map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE;
../map/map.c:335:        -xz.raw[0] / (dim / 2.0f),
../map/map.c:342:    float width  = map->width  * TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE;
../map/map.c:343:    float height = map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE;
../map/map.c:345:    return (xz.x <= map->pos.x && xz.x >= map->pos.x - width)
../map/map.c:346:        && (xz.z >= map->pos.z && xz.z <= map->pos.z + height);
../map/map.c:354:    x = MIN(map->pos.x - EPSILON, xz.x);
../map/map.c:355:    x = MAX(map->pos.x - map->width * (TILES_PER_CHUNK_WIDTH * X_COORDS_PER_TILE) + EPSILON, x);
../map/map.c:357:    z = MAX(map->pos.z + EPSILON, xz.z);
../map/map.c:358:    z = MIN(map->pos.z + (map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE) - EPSILON, z);
../map/map.c:371:    chunk_r = CLAMP( (z - map->pos.z) / (TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE), 0, map->height-1);
../map/map.c:372:    chunk_c = CLAMP(-(x - map->pos.x) / (TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE), 0, map->width-1);
../map/map.c:374:    float chunk_off_r = fmod(z - map->pos.z, TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE);
../map/map.c:375:    float chunk_off_c = fmod(-(x - map->pos.x), TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE);
../map/map.c:379:    tile_r = CLAMP(chunk_off_r / Z_COORDS_PER_TILE, 0, TILES_PER_CHUNK_HEIGHT-1);
../map/map.c:380:    tile_c = CLAMP(chunk_off_c / X_COORDS_PER_TILE, 0, TILES_PER_CHUNK_WIDTH-1);
../map/map.c:388:    const struct tile *tile = &map->chunks[chunk_r * map->width + chunk_c].tiles[tile_r * TILES_PER_CHUNK_WIDTH + tile_c];
../map/map.c:395:        .chunk_w = map->width,
../map/map.c:396:        .chunk_h = map->height,
../map/map.c:400:    return M_Tile_DescForPoint2D(res, map->pos, point_xz, out);
../map/map.c:405:    N_CutoutStaticObject(map->nav_private, map->pos, obb);
../map/map.c:410:    N_UpdatePortals(map->nav_private);
../map/map.c:415:    N_UpdateIslandsField(map->nav_private);
../map/map.c:421:    return N_RequestPath(map->nav_private, xz_src, xz_dest, map->pos, layer, out_dest_id);
../map/map.c:430:    for(int r = 0; r < map->height; r++) {
../map/map.c:431:    for(int c = 0; c < map->width;  c++) {
../map/map.c:441:        N_RenderPathFlowField(map->nav_private, map, &chunk_model, r, c, id);
../map/map.c:442:        N_RenderLOSField(map->nav_private, map, &chunk_model, r, c, id);
../map/map.c:452:    for(int r = 0; r < map->height; r++) {
../map/map.c:453:    for(int c = 0; c < map->width;  c++) {
../map/map.c:463:        N_RenderEnemySeekField(map->nav_private, map, &chunk_model, r, c, layer, faction_id);
../map/map.c:473:    for(int r = 0; r < map->height; r++) {
../map/map.c:474:    for(int c = 0; c < map->width;  c++) {
../map/map.c:484:        N_RenderSurroundField(map->nav_private, map, &chunk_model, r, c, layer, ent);
../map/map.c:493:    for(int r = 0; r < map->height; r++) {
../map/map.c:494:    for(int c = 0; c < map->width;  c++) {
../map/map.c:504:        N_RenderNavigationBlockers(map->nav_private, map, &chunk_model, r, c, layer);
../map/map.c:514:    for(int r = 0; r < map->height; r++) {
../map/map.c:515:    for(int c = 0; c < map->width;  c++) {
../map/map.c:525:        N_RenderBuildableTiles(map->nav_private, map, &chunk_model, r, c, obb, layer);
../map/map.c:534:    for(int r = 0; r < map->height; r++) {
../map/map.c:535:    for(int c = 0; c < map->width;  c++) {
../map/map.c:545:        N_RenderNavigationPortals(map->nav_private, map, &chunk_model, r, c, layer);
../map/map.c:555:    for(int r = 0; r < map->height; r++) {
../map/map.c:556:    for(int c = 0; c < map->width;  c++) {
../map/map.c:566:        N_RenderIslandIDs(map->nav_private, map, cam, &chunk_model, r, c, layer);
../map/map.c:576:    for(int r = 0; r < map->height; r++) {
../map/map.c:577:    for(int c = 0; c < map->width;  c++) {
../map/map.c:587:        N_RenderLocalIslandIDs(map->nav_private, map, cam, &chunk_model, r, c, layer);
../map/map.c:593:    return N_DesiredPointSeekVelocity(id, curr_pos, xz_dest, map->nav_private, map->pos);
../map/map.c:599:    return N_DesiredEnemySeekVelocity(curr_pos, map->nav_private, layer, map->pos, faction_id);
../map/map.c:605:    return N_DesiredSurroundVelocity(curr_pos, map->nav_private, layer, map->pos, ent, faction_id);
../map/map.c:610:    return N_HasDestLOS(id, curr_pos, map->nav_private, map->pos);
../map/map.c:616:        map->pos.x,
../map/map.c:617:        map->pos.z,
../map/map.c:618:        map->width * TILES_PER_CHUNK_WIDTH * X_COORDS_PER_TILE,
../map/map.c:619:        map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE,
../map/map.c:625:    return N_PositionPathable(xz_pos, layer, map->nav_private, map->pos);
../map/map.c:631:        map->pos.x,
../map/map.c:632:        map->pos.z,
../map/map.c:633:        map->width * TILES_PER_CHUNK_WIDTH * X_COORDS_PER_TILE,
../map/map.c:634:        map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE,
../map/map.c:640:    return N_PositionBlocked(xz_pos, layer, map->nav_private, map->pos);
../map/map.c:646:    return N_ClosestReachableDest(map->nav_private, layer, map->pos, xz_src, xz_dst);
../map/map.c:652:    if(target->flags & ENTITY_FLAG_MOVABLE) {
../map/map.c:654:        return N_ClosestReachableAdjacentPosDynamic(map->nav_private, layer, map->pos, 
../map/map.c:655:            xz_src, G_Pos_GetXZ(target->uid), G_GetSelectionRadius(target->uid), out);
../map/map.c:660:        return N_ClosestReachableAdjacentPosStatic(map->nav_private, layer,
../map/map.c:661:            map->pos, xz_src, &obb, out);
../map/map.c:667:    return N_ClosestPathable(map->nav_private, layer, map->pos, xz_src, out);
../map/map.c:673:    return N_LocationsReachable(map->nav_private, layer, map->pos, a, b);
../map/map.c:678:    N_BlockersIncref(xz_pos, range, faction_id, map->pos, map->nav_private);
../map/map.c:683:    N_BlockersDecref(xz_pos, range, faction_id, map->pos, map->nav_private);
../map/map.c:688:    N_BlockersIncrefOBB(map->nav_private, faction_id, map->pos, obb);
../map/map.c:693:    N_BlockersDecrefOBB(map->nav_private, faction_id, map->pos, obb);
../map/map.c:698:    if(desc.chunk_r < 0 || desc.chunk_r >= map->height)
../map/map.c:700:    if(desc.chunk_c < 0 || desc.chunk_c >= map->width)
../map/map.c:707:    *out = (struct tile*)&map->chunks[desc.chunk_r * map->width + desc.chunk_c]
../map/map.c:714:    out->chunk_w = map->width;
../map/map.c:715:    out->chunk_h = map->height;
../map/map.c:716:    out->tile_w = TILES_PER_CHUNK_WIDTH;
../map/map.c:717:    out->tile_h = TILES_PER_CHUNK_HEIGHT;
../map/map.c:722:    for(int r = 0; r < map->height; r++) {
../map/map.c:723:    for(int c = 0; c < map->width;  c++) {
../map/map.c:725:        const struct pfchunk *chunk = &map->chunks[r * map->width + c];
../map/map.c:730:                chunk->render_private,
../map/map.c:742:        map->pos.x - (res.chunk_w * res.tile_w * X_COORDS_PER_TILE)/2.0f,
../map/map.c:743:        map->pos.y,
../map/map.c:744:        map->pos.z + (res.chunk_h * res.tile_h * Z_COORDS_PER_TILE)/2.0f,
../map/map.c:750:    return map->pos;
../map/map.c:756:    return N_IsMaximallyClose(map->nav_private, layer, map->pos, xz_pos, xz_dest, tolerance);
../map/map.c:761:    return N_IsAdjacentToImpassable(map->nav_private, layer, map->pos, xz_pos);
../map/map.c:766:    return N_DestIDForPos(map->nav_private, map->pos, xz_pos, layer);
../map/map.c:772:    return N_DestIDForPosAttacking(map->nav_private, map->pos, xz_pos, layer, faction_id);
../map/map.c:777:    if(target->flags & ENTITY_FLAG_MOVABLE) {
../map/map.c:779:        return N_ObjAdjacentToDynamic(map->nav_private, map->pos, ent, 
../map/map.c:780:            G_Pos_GetXZ(target->uid), G_GetSelectionRadius(target->uid));
../map/map.c:785:        return N_ObjAdjacentToStatic(map->nav_private, map->pos, ent, &obb);
../map/map.c:791:    return N_GetResolution(map->nav_private, out);
../map/map.c:796:    return N_ObjectBuildable(map->nav_private, layer, map->pos, obb);
../map/map.c:802:    return N_HasEntityLOS(xz_pos, ent, map->nav_private, layer, map->pos);
../map/map.c:808:    return N_ClosestReachableInRange(map->nav_private, map->pos, xz_src, xz_target, range, layer);
../map/map_asset_load.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/map_asset_load.c:52:/* ASCII to integer - argument must be an ascii digit */
../map/map_asset_load.c:53:#define A2I(_a) ((_a) - '0')
../map/map_asset_load.c:70:    out->type          = (enum tiletype) strtol(type_hexstr, NULL, 16);
../map/map_asset_load.c:71:    out->base_height   = (int)           (str[1] == '-' ? -1 : 1) * (10  * A2I(str[2]) + A2I(str[3]));
../map/map_asset_load.c:72:    out->ramp_height   = (int)           (10  * A2I(str[4]) + A2I(str[5]));
../map/map_asset_load.c:73:    out->top_mat_idx   = (int)           (100 * A2I(str[6]) + 10 * A2I(str[7 ]) + A2I(str[8 ]));
../map/map_asset_load.c:74:    out->sides_mat_idx = (int)           (100 * A2I(str[9]) + 10 * A2I(str[10]) + A2I(str[11]));
../map/map_asset_load.c:75:    out->pathable      = (bool)          A2I(str[12]);
../map/map_asset_load.c:76:    out->blend_mode    = (int)           A2I(str[13]);
../map/map_asset_load.c:77:    out->blend_normals = (bool)          A2I(str[14]);
../map/map_asset_load.c:86:        tile->type,
../map/map_asset_load.c:87:        tile->base_height >= 0 ? '+' : '-',
../map/map_asset_load.c:88:        abs(tile->base_height),
../map/map_asset_load.c:89:        tile->ramp_height,
../map/map_asset_load.c:90:        tile->top_mat_idx, 
../map/map_asset_load.c:91:        tile->sides_mat_idx,
../map/map_asset_load.c:92:        tile->pathable,
../map/map_asset_load.c:93:        tile->blend_mode,
../map/map_asset_load.c:94:        tile->blend_normals);
../map/map_asset_load.c:105:    /* String points to the first token - the first tile of this row */
../map/map_asset_load.c:130:        if(!m_al_read_row(stream, out->tiles + tiles_read, &tiles_in_row))
../map/map_asset_load.c:161:    for(int r = 0; r < map->height; r++) {
../map/map_asset_load.c:162:    for(int c = 0; c < map->width;  c++) {
../map/map_asset_load.c:164:        void *chunk_rprivate = map->chunks[r * map->width + c].render_private;
../map/map_asset_load.c:169:            const struct tile *tile = &map->chunks[r * map->width + c].tiles[tile_r * TILES_PER_CHUNK_WIDTH + tile_c];
../map/map_asset_load.c:181:            if(!tile->blend_normals)
../map/map_asset_load.c:199:    map->minimap_vres = (vec2_t){1920, 1080};
../map/map_asset_load.c:200:    map->minimap_sz = MINIMAP_DFLT_SZ;
../map/map_asset_load.c:201:    map->minimap_center_pos = (vec2_t){
../map/map_asset_load.c:203:        1080 - (MINIMAP_DFLT_SZ * cos(M_PI/4.0) + 10)};
../map/map_asset_load.c:204:    map->minimap_resize_mask = ANCHOR_X_LEFT | ANCHOR_Y_BOT;
../map/map_asset_load.c:216:    map->width = header->num_cols;
../map/map_asset_load.c:217:    map->height = header->num_rows;
../map/map_asset_load.c:218:    map->pos = (vec3_t) {0.0f, 0.0f, 0.0f};
../map/map_asset_load.c:222:    char texnames[header->num_materials][256];
../map/map_asset_load.c:223:    for(int i = 0; i < header->num_materials; i++) {
../map/map_asset_load.c:228:        strcpy(map->texnames[i], texnames[i]);
../map/map_asset_load.c:230:    map->num_mats = header->num_materials;
../map/map_asset_load.c:233:        header->num_cols,
../map/map_asset_load.c:234:        header->num_rows,
../map/map_asset_load.c:244:            R_PushArg(&header->num_materials, sizeof(header->num_materials)),
../map/map_asset_load.c:250:    size_t num_chunks = header->num_rows * header->num_cols;
../map/map_asset_load.c:256:        if(!m_al_read_pfchunk(stream, map->chunks + i))
../map/map_asset_load.c:262:        map->chunks[i].render_private = (void*)unused_base;
../map/map_asset_load.c:267:        if(!R_AL_InitPrivFromTiles(map, i / header->num_cols, i % header->num_cols,
../map/map_asset_load.c:268:                                   map->chunks[i].tiles, TILES_PER_CHUNK_WIDTH, TILES_PER_CHUNK_HEIGHT,
../map/map_asset_load.c:269:                                   map->chunks[i].render_private, basedir)) {
../map/map_asset_load.c:277:    const struct tile *chunk_tiles[map->width * map->height];
../map/map_asset_load.c:279:    for(int r = 0; r < map->height; r++) {
../map/map_asset_load.c:280:    for(int c = 0; c < map->width; c++) {
../map/map_asset_load.c:281:        chunk_tiles[r * map->width + c] = map->chunks[r * map->width + c].tiles;
../map/map_asset_load.c:284:    map->nav_private = N_BuildForMapData(map->width, map->height, 
../map/map_asset_load.c:286:    if(!map->nav_private)
../map/map_asset_load.c:294:    size_t num_chunks = header->num_rows * header->num_cols;
../map/map_asset_load.c:303:    if(desc->chunk_r >= map->height || desc->chunk_c >= map->width)
../map/map_asset_load.c:306:    struct pfchunk *chunk = &map->chunks[desc->chunk_r * map->width + desc->chunk_c];
../map/map_asset_load.c:307:    chunk->tiles[desc->tile_r * TILES_PER_CHUNK_WIDTH + desc->tile_c] = *tile;
../map/map_asset_load.c:312:    for(int dr = -1; dr <= 1; dr++) {
../map/map_asset_load.c:313:    for(int dc = -1; dc <= 1; dc++) {
../map/map_asset_load.c:319:            struct pfchunk *chunk = &map->chunks[curr.chunk_r * map->width + curr.chunk_c];
../map/map_asset_load.c:324:                    chunk->render_private,
../map/map_asset_load.c:338:    assert(map->nav_private);
../map/map_asset_load.c:339:    N_FreePrivate(map->nav_private);
../map/map_asset_load.c:350:    memcpy(dst, src, M_AL_ShallowCopySize(src->width, src->height));
../map/map_asset_load.c:360:    pf_snprintf(line, sizeof(line), "num_materials %d\n", map->num_mats);
../map/map_asset_load.c:363:    pf_snprintf(line, sizeof(line), "num_rows %d\n", map->height);
../map/map_asset_load.c:366:    pf_snprintf(line, sizeof(line), "num_cols %d\n", map->width);
../map/map_asset_load.c:369:    for(int i = 0; i < map->num_mats; i++) {
../map/map_asset_load.c:371:        pf_snprintf(line, sizeof(line), "material __anonymous__ %s\n", map->texnames[i]);
../map/map_asset_load.c:375:    for(int chunk_r = 0; chunk_r < map->height; chunk_r++) {
../map/map_asset_load.c:376:    for(int chunk_c = 0; chunk_c < map->width;  chunk_c++) {
../map/map_asset_load.c:378:        const struct pfchunk *curr_chunk = &map->chunks[chunk_r * map->width + chunk_c];
../map/map_asset_load.c:382:            const struct tile *curr_tile = &curr_chunk->tiles[tile_r * TILES_PER_CHUNK_WIDTH + tile_c];
../map/map_private.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/map_private.h:46:    /* ------------------------------------------------------------------------
../map/map_private.h:48:     * ------------------------------------------------------------------------
../map/map_private.h:51:    /* ------------------------------------------------------------------------
../map/map_private.h:52:     * World-space location of the top left corner of the map.
../map/map_private.h:53:     * ------------------------------------------------------------------------
../map/map_private.h:56:    /* ------------------------------------------------------------------------
../map/map_private.h:60:     * ------------------------------------------------------------------------
../map/map_private.h:63:    /* ------------------------------------------------------------------------
../map/map_private.h:65:     * ------------------------------------------------------------------------
../map/map_private.h:68:    /* ------------------------------------------------------------------------
../map/map_private.h:70:     * ------------------------------------------------------------------------
../map/map_private.h:73:    /* ------------------------------------------------------------------------
../map/map_private.h:75:     * ------------------------------------------------------------------------
../map/map_private.h:78:    /* ------------------------------------------------------------------------
../map/map_private.h:80:     * ------------------------------------------------------------------------
../map/map_private.h:83:    /* ------------------------------------------------------------------------
../map/map_private.h:86:     * ------------------------------------------------------------------------
../map/map_private.h:90:    /* ------------------------------------------------------------------------
../map/map_private.h:91:     * The map chunks stored in row-major order. In total, there must be 
../map/map_private.h:93:     * ------------------------------------------------------------------------
../map/minimap.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/minimap.c:78:       -sin(radians) * point_to_src.x + cos(radians) * point_to_src.y
../map/minimap.c:88:    float left  = center.x - width/2.0f;
../map/minimap.c:90:    float top   = center.y - height/2.0f;
../map/minimap.c:122:        map->minimap_center_pos.x, map->minimap_center_pos.y,
../map/minimap.c:123:        map->minimap_sz, map->minimap_sz
../map/minimap.c:125:    struct rect final_rect = UI_BoundsForAspectRatio(orig_rect, map->minimap_vres, 
../map/minimap.c:126:        UI_ArAdjustedVRes(map->minimap_vres), map->minimap_resize_mask);
../map/minimap.c:136:    if(map->width < map->height) {
../map/minimap.c:137:        width = map->minimap_sz * (((float)map->width)/map->height);
../map/minimap.c:139:        width = map->minimap_sz; 
../map/minimap.c:142:    if(map->height < map->width) {
../map/minimap.c:143:        height = map->minimap_sz * (((float)map->height)/map->width);
../map/minimap.c:145:        height = map->minimap_sz; 
../map/minimap.c:149:        map->minimap_center_pos.x, map->minimap_center_pos.y,
../map/minimap.c:152:    struct rect final_rect = UI_BoundsForAspectRatio(orig_terrain_rect, map->minimap_vres, 
../map/minimap.c:153:        UI_ArAdjustedVRes(map->minimap_vres), map->minimap_resize_mask);
../map/minimap.c:184:    x_frac -= 0.5f;
../map/minimap.c:188:    z_frac -= 0.5f;
../map/minimap.c:190:    float map_ws_width  = map->width  * TILES_PER_CHUNK_WIDTH  * X_COORDS_PER_TILE;
../map/minimap.c:191:    float map_ws_height = map->height * TILES_PER_CHUNK_HEIGHT * Z_COORDS_PER_TILE;
../map/minimap.c:196:        center_pos.x - x_frac * map_ws_len,
../map/minimap.c:210:        ((float)x) / w * UI_ArAdjustedVRes(map->minimap_vres).x,
../map/minimap.c:211:        ((float)y) / h * UI_ArAdjustedVRes(map->minimap_vres).y,
../map/minimap.c:220:    assert(mouse_event->type == SDL_MOUSEBUTTONDOWN);
../map/minimap.c:222:    if(map->minimap_sz == 0)
../map/minimap.c:232:    if(mouse_event->button.button != SDL_BUTTON_LEFT)
../map/minimap.c:241:        (float)mouse_event->button.x / w * UI_ArAdjustedVRes(map->minimap_vres).x,
../map/minimap.c:242:        (float)mouse_event->button.y / h * UI_ArAdjustedVRes(map->minimap_vres).y
../map/minimap.c:253:    assert(mouse_event->type == SDL_MOUSEMOTION);
../map/minimap.c:258:    if(!(mouse_event->motion.state & SDL_BUTTON_LMASK))
../map/minimap.c:264:        (float)mouse_event->motion.x / w * UI_ArAdjustedVRes(map->minimap_vres).x,
../map/minimap.c:265:        (float)mouse_event->motion.y / h * UI_ArAdjustedVRes(map->minimap_vres).y
../map/minimap.c:279:    map->minimap_center_pos = center_pos;
../map/minimap.c:281:    void *chunk_rprivates[map->width * map->height];
../map/minimap.c:282:    mat4x4_t chunk_model_mats[map->width * map->height];
../map/minimap.c:284:    for(int r = 0; r < map->height; r++) {
../map/minimap.c:285:    for(int c = 0; c < map->width;  c++) {
../map/minimap.c:287:        const struct pfchunk *curr = &map->chunks[r * map->width + c];
../map/minimap.c:288:        chunk_rprivates[r * map->width + c] = curr->render_private;
../map/minimap.c:289:        M_ModelMatrixForChunk(map, (struct chunkpos){r, c}, chunk_model_mats + (r * map->width + c));
../map/minimap.c:309:    if(chunk_r >= map->height || chunk_c >= map->width)
../map/minimap.c:320:            map->chunks[chunk_r * map->width + chunk_c].render_private,
../map/minimap.c:340:    *out_vres = UI_ArAdjustedVRes(map->minimap_vres);
../map/minimap.c:345:    map->minimap_vres = vres;
../map/minimap.c:350:    map->minimap_resize_mask = resize_mask;
../map/minimap.c:355:    *out_center_pos = map->minimap_center_pos;
../map/minimap.c:361:    map->minimap_center_pos = center_pos;
../map/minimap.c:366:    return map->minimap_sz;
../map/minimap.c:371:    map->minimap_sz = side_len;
../map/minimap.c:377:    if(map->minimap_sz == 0)
../map/minimap.c:408:    if(map->minimap_sz == 0)
../map/minimap.c:423:    void *pbuff = stalloc(&G_GetSimWS()->args, nunits * sizeof(vec2_t));
../map/minimap.c:424:    void *cbuff = stalloc(&G_GetSimWS()->args, nunits * sizeof(vec3_t));
../map/minimap.c:445:    if(map->minimap_sz == 0)
../map/minimap.c:463:        (float)x / w * UI_ArAdjustedVRes(map->minimap_vres).x,
../map/minimap.c:464:        (float)y / h * UI_ArAdjustedVRes(map->minimap_vres).y
../map/pfchunk.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/pfchunk.h:47:    /* ------------------------------------------------------------------------
../map/pfchunk.h:50:     * ------------------------------------------------------------------------
../map/pfchunk.h:53:    /* ------------------------------------------------------------------------
../map/pfchunk.h:55:     * ------------------------------------------------------------------------
../map/pfchunk.h:58:    /* ------------------------------------------------------------------------
../map/pfchunk.h:59:     * Each tiles' attributes, stored in row-major order.
../map/pfchunk.h:60:     * ------------------------------------------------------------------------
../map/public/map.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/public/map.h:65:/* ------------------------------------------------------------------------
../map/public/map.h:67: * ------------------------------------------------------------------------
../map/public/map.h:71:/* ------------------------------------------------------------------------
../map/public/map.h:73: * many off-screen chunks. Depending on the 'pass' type, this will perform 
../map/public/map.h:75: * ------------------------------------------------------------------------
../map/public/map.h:79:/* ------------------------------------------------------------------------
../map/public/map.h:81: * camera using a frustrum-chunk intersection test. Depending on the 'pass'
../map/public/map.h:83: * ------------------------------------------------------------------------
../map/public/map.h:88:/* ------------------------------------------------------------------------
../map/public/map.h:91: * ------------------------------------------------------------------------
../map/public/map.h:96:/* ------------------------------------------------------------------------
../map/public/map.h:99: * ------------------------------------------------------------------------
../map/public/map.h:103:/* ------------------------------------------------------------------------
../map/public/map.h:107: * ------------------------------------------------------------------------
../map/public/map.h:112:/* ------------------------------------------------------------------------
../map/public/map.h:114: * ------------------------------------------------------------------------
../map/public/map.h:119:/* ------------------------------------------------------------------------
../map/public/map.h:122: * ------------------------------------------------------------------------
../map/public/map.h:127:/* ------------------------------------------------------------------------
../map/public/map.h:130: * ------------------------------------------------------------------------
../map/public/map.h:135:/* ------------------------------------------------------------------------
../map/public/map.h:138: * ------------------------------------------------------------------------
../map/public/map.h:143:/* ------------------------------------------------------------------------
../map/public/map.h:145: * ------------------------------------------------------------------------
../map/public/map.h:150:/* ------------------------------------------------------------------------
../map/public/map.h:152: * ------------------------------------------------------------------------
../map/public/map.h:157:/* ------------------------------------------------------------------------
../map/public/map.h:159: * ------------------------------------------------------------------------
../map/public/map.h:163:/* ------------------------------------------------------------------------
../map/public/map.h:167: * ------------------------------------------------------------------------
../map/public/map.h:171:/* ------------------------------------------------------------------------
../map/public/map.h:172: * Install event handlers which will keep up-to-date state of the currently
../map/public/map.h:174: * ------------------------------------------------------------------------
../map/public/map.h:178:/* ------------------------------------------------------------------------
../map/public/map.h:180: * ------------------------------------------------------------------------
../map/public/map.h:184:/* ------------------------------------------------------------------------
../map/public/map.h:188: * ------------------------------------------------------------------------
../map/public/map.h:193:/* ------------------------------------------------------------------------
../map/public/map.h:196: * ------------------------------------------------------------------------
../map/public/map.h:200:/* ------------------------------------------------------------------------
../map/public/map.h:204: * ------------------------------------------------------------------------
../map/public/map.h:208:/* ------------------------------------------------------------------------
../map/public/map.h:210: * range (-1, -1) in the 'top left' corner to (1, 1) in the 'bottom right' 
../map/public/map.h:213: * for non-square maps, the proportion of the width to the height is kept 
../map/public/map.h:215: * range of [-1, 1]
../map/public/map.h:216: * ------------------------------------------------------------------------
../map/public/map.h:220:/* ------------------------------------------------------------------------
../map/public/map.h:222: * ------------------------------------------------------------------------
../map/public/map.h:226:/* ------------------------------------------------------------------------
../map/public/map.h:229: * ------------------------------------------------------------------------
../map/public/map.h:233:/* ------------------------------------------------------------------------
../map/public/map.h:235: * ------------------------------------------------------------------------
../map/public/map.h:239:/* ------------------------------------------------------------------------
../map/public/map.h:242: * ------------------------------------------------------------------------
../map/public/map.h:246:/* ------------------------------------------------------------------------
../map/public/map.h:249: * ------------------------------------------------------------------------
../map/public/map.h:253:/* ------------------------------------------------------------------------
../map/public/map.h:256: * ------------------------------------------------------------------------
../map/public/map.h:260:/* ------------------------------------------------------------------------
../map/public/map.h:263: * ------------------------------------------------------------------------
../map/public/map.h:267:/* ------------------------------------------------------------------------
../map/public/map.h:271: * ------------------------------------------------------------------------
../map/public/map.h:276:/* ------------------------------------------------------------------------
../map/public/map.h:280: * ------------------------------------------------------------------------
../map/public/map.h:284:/* ------------------------------------------------------------------------
../map/public/map.h:286: * color-coded based on the vision the specified faction has of it. 
../map/public/map.h:288: * ------------------------------------------------------------------------
../map/public/map.h:293:/* ------------------------------------------------------------------------
../map/public/map.h:296: * ------------------------------------------------------------------------
../map/public/map.h:301:/* ------------------------------------------------------------------------
../map/public/map.h:304: * ------------------------------------------------------------------------
../map/public/map.h:309:/* ------------------------------------------------------------------------
../map/public/map.h:311: * to a specific entity. This only works when we are within a chunk-sized
../map/public/map.h:313: * ------------------------------------------------------------------------
../map/public/map.h:318:/* ------------------------------------------------------------------------
../map/public/map.h:321: * ------------------------------------------------------------------------
../map/public/map.h:325:/* ------------------------------------------------------------------------
../map/public/map.h:328: * ------------------------------------------------------------------------
../map/public/map.h:333:/* ------------------------------------------------------------------------
../map/public/map.h:336: * ------------------------------------------------------------------------
../map/public/map.h:341:/* ------------------------------------------------------------------------
../map/public/map.h:343: * is currently occupying this tile, causing it to temporarily become non-traversable)
../map/public/map.h:344: * ------------------------------------------------------------------------
../map/public/map.h:349:/* ------------------------------------------------------------------------
../map/public/map.h:353: * ------------------------------------------------------------------------
../map/public/map.h:358:/* ------------------------------------------------------------------------
../map/public/map.h:363: * ------------------------------------------------------------------------
../map/public/map.h:369:/* ------------------------------------------------------------------------
../map/public/map.h:373: * ------------------------------------------------------------------------
../map/public/map.h:378:/* ------------------------------------------------------------------------
../map/public/map.h:381: * ------------------------------------------------------------------------
../map/public/map.h:386:/* ------------------------------------------------------------------------
../map/public/map.h:388: * ------------------------------------------------------------------------
../map/public/map.h:393:/* ------------------------------------------------------------------------
../map/public/map.h:397: * ------------------------------------------------------------------------
../map/public/map.h:405:/* ------------------------------------------------------------------------
../map/public/map.h:407: * ------------------------------------------------------------------------
../map/public/map.h:419:/* ------------------------------------------------------------------------
../map/public/map.h:423: * ------------------------------------------------------------------------
../map/public/map.h:428:/* ------------------------------------------------------------------------
../map/public/map.h:431: * ------------------------------------------------------------------------
../map/public/map.h:435:/* ------------------------------------------------------------------------
../map/public/map.h:437: * ------------------------------------------------------------------------
../map/public/map.h:441:/* ------------------------------------------------------------------------
../map/public/map.h:443: * ------------------------------------------------------------------------
../map/public/map.h:447:/* ------------------------------------------------------------------------
../map/public/map.h:449: * ------------------------------------------------------------------------
../map/public/map.h:453:/* ------------------------------------------------------------------------
../map/public/map.h:454: * Returns the position of the top-left corner of the amp, in world space.
../map/public/map.h:455: * ------------------------------------------------------------------------
../map/public/map.h:464:/* ------------------------------------------------------------------------
../map/public/map.h:466: * ------------------------------------------------------------------------
../map/public/map.h:470:/* ------------------------------------------------------------------------
../map/public/map.h:471: * Update a chunk-sized region of the minimap texture with the most 
../map/public/map.h:472: * up-to-date vertex data.
../map/public/map.h:473: * ------------------------------------------------------------------------
../map/public/map.h:477:/* ------------------------------------------------------------------------
../map/public/map.h:479: * ------------------------------------------------------------------------
../map/public/map.h:483:/* ------------------------------------------------------------------------
../map/public/map.h:486: * ------------------------------------------------------------------------
../map/public/map.h:489:/* ------------------------------------------------------------------------
../map/public/map.h:492: * ------------------------------------------------------------------------
../map/public/map.h:496:/* ------------------------------------------------------------------------
../map/public/map.h:498: * ------------------------------------------------------------------------
../map/public/map.h:503:/* ------------------------------------------------------------------------
../map/public/map.h:505: * ------------------------------------------------------------------------
../map/public/map.h:510:/* ------------------------------------------------------------------------
../map/public/map.h:512: * ------------------------------------------------------------------------
../map/public/map.h:516:/* ------------------------------------------------------------------------
../map/public/map.h:519: * ------------------------------------------------------------------------
../map/public/map.h:523:/* ------------------------------------------------------------------------
../map/public/map.h:525: * ------------------------------------------------------------------------
../map/public/map.h:530:/* ------------------------------------------------------------------------
../map/public/map.h:532: * ------------------------------------------------------------------------
../map/public/map.h:536:/* ------------------------------------------------------------------------
../map/public/map.h:540: * ------------------------------------------------------------------------
../map/public/map.h:544:/* ------------------------------------------------------------------------
../map/public/map.h:546: * ------------------------------------------------------------------------
../map/public/map.h:557:/* ------------------------------------------------------------------------
../map/public/map.h:560: * ------------------------------------------------------------------------
../map/public/map.h:565:/* ------------------------------------------------------------------------
../map/public/map.h:568: * ------------------------------------------------------------------------
../map/public/map.h:572:/* ------------------------------------------------------------------------
../map/public/map.h:574: * ------------------------------------------------------------------------
../map/public/map.h:578:/* ------------------------------------------------------------------------
../map/public/map.h:580: * ------------------------------------------------------------------------
../map/public/map.h:584:/* ------------------------------------------------------------------------
../map/public/map.h:587: * ------------------------------------------------------------------------
../map/public/map.h:595:/* ------------------------------------------------------------------------
../map/public/map.h:597: * ------------------------------------------------------------------------
../map/public/map.h:601:/* ------------------------------------------------------------------------
../map/public/map.h:605: * ------------------------------------------------------------------------
../map/public/map.h:609:/* ------------------------------------------------------------------------
../map/public/map.h:611: * ------------------------------------------------------------------------
../map/public/tile.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/public/tile.h:51:     *                     +----------+
../map/public/tile.h:53:     *                -  +----------+ +
../map/public/tile.h:54:     * base_height -> |  |          |/
../map/public/tile.h:55:     *                -  +----------+
../map/public/tile.h:83:    /* ------------------------------------------------------------------------
../map/public/tile.h:85:     * ------------------------------------------------------------------------
../map/public/tile.h:88:    /* ------------------------------------------------------------------------
../map/public/tile.h:89:     * Render-specific tile attributes. Only used for populating private render
../map/public/tile.h:91:     * ------------------------------------------------------------------------
../map/raycast.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/raycast.c:88:    assert(desc.chunk_r >= 0 && desc.chunk_r < map->height);
../map/raycast.c:89:    assert(desc.chunk_c >= 0 && desc.chunk_c < map->width);
../map/raycast.c:93:    const struct pfchunk *chunk = &map->chunks[desc.chunk_r * map->width + desc.chunk_c];
../map/raycast.c:94:    const struct tile *tile = &chunk->tiles[desc.tile_r * TILES_PER_CHUNK_WIDTH + desc.tile_c];
../map/raycast.c:97:        map->width, map->height,
../map/raycast.c:100:    struct box tile_bounds = M_Tile_Bounds(res, map->pos, desc);
../map/raycast.c:103:        .x_min = tile_bounds.x - tile_bounds.width,
../map/raycast.c:105:        .y_min = -TILE_DEPTH * Y_COORDS_PER_TILE,
../map/raycast.c:106:        .y_max = (tile->base_height + (tile->type == TILETYPE_FLAT ? 0 : tile->ramp_height)) * Y_COORDS_PER_TILE,
../map/raycast.c:120:    vec3_t ndc = (vec3_t){-1.0f + 2.0*((float)mouse_x/width),
../map/raycast.c:121:                           1.0f - 2.0*((float)mouse_y/height),
../map/raycast.c:122:                          -1.0f};
../map/raycast.c:142:        s_ctx.map->width, s_ctx.map->height,
../map/raycast.c:146:    /* Project the ray on the Y=(-TILE_DEPTH*Y_COORDS_PER_TILE) plane between the ray origin and where the 
../map/raycast.c:147:     * ray intersects the Y=(-TILE_DEPTH*Y_COORDS_PER_TILE) plane. */
../map/raycast.c:157:    int len = M_Tile_LineSupercoverTilesSorted(res, s_ctx.map->pos, y_eq_0_seg, cts, MAX_CANDIDATE_TILES);
../map/raycast.c:231:    int num_tiles = s_ctx.highlight_size * 2 - 1;
../map/raycast.c:233:    for(int r = -(num_tiles / 2); r < (num_tiles / 2) + 1; r++) {
../map/raycast.c:234:    for(int c = -(num_tiles / 2); c < (num_tiles / 2) + 1; c++) {
../map/raycast.c:237:            s_ctx.map->width, s_ctx.map->height,
../map/raycast.c:244:            const struct pfchunk *chunk = &s_ctx.map->chunks[curr.chunk_r * s_ctx.map->width + curr.chunk_c];
../map/raycast.c:257:                    chunk->render_private,
../map/tile.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../map/tile.c:109:    return sqrt( pow(bx - ax, 2) + pow(bz - az, 2) );
../map/tile.c:118:    bool top_nw_raised =  (tile->type == TILETYPE_RAMP_SN)
../map/tile.c:119:                       || (tile->type == TILETYPE_RAMP_EW)
../map/tile.c:120:                       || (tile->type == TILETYPE_CORNER_CONVEX_SW)
../map/tile.c:121:                       || (tile->type == TILETYPE_CORNER_CONVEX_SE)
../map/tile.c:122:                       || (tile->type == TILETYPE_CORNER_CONCAVE_SE)
../map/tile.c:123:                       || (tile->type == TILETYPE_CORNER_CONVEX_NE);
../map/tile.c:126:        return tile->base_height + tile->ramp_height;
../map/tile.c:128:        return tile->base_height;
../map/tile.c:133:    bool top_ne_raised =  (tile->type == TILETYPE_RAMP_SN)
../map/tile.c:134:                       || (tile->type == TILETYPE_RAMP_WE)
../map/tile.c:135:                       || (tile->type == TILETYPE_CORNER_CONVEX_SW)
../map/tile.c:136:                       || (tile->type == TILETYPE_CORNER_CONCAVE_SW)
../map/tile.c:137:                       || (tile->type == TILETYPE_CORNER_CONVEX_SE)
../map/tile.c:138:                       || (tile->type == TILETYPE_CORNER_CONVEX_NW);
../map/tile.c:141:        return tile->base_height + tile->ramp_height;
../map/tile.c:143:        return tile->base_height;
../map/tile.c:148:    bool top_sw_raised =  (tile->type == TILETYPE_RAMP_NS)
../map/tile.c:149:                       || (tile->type == TILETYPE_RAMP_EW)
../map/tile.c:150:                       || (tile->type == TILETYPE_CORNER_CONVEX_SE)
../map/tile.c:151:                       || (tile->type == TILETYPE_CORNER_CONVEX_NW)
../map/tile.c:152:                       || (tile->type == TILETYPE_CORNER_CONCAVE_NE)
../map/tile.c:153:                       || (tile->type == TILETYPE_CORNER_CONVEX_NE);
../map/tile.c:156:        return tile->base_height + tile->ramp_height;
../map/tile.c:158:        return tile->base_height;
../map/tile.c:163:    bool top_se_raised =  (tile->type == TILETYPE_RAMP_NS)
../map/tile.c:164:                       || (tile->type == TILETYPE_RAMP_WE)
../map/tile.c:165:                       || (tile->type == TILETYPE_CORNER_CONVEX_SW)
../map/tile.c:166:                       || (tile->type == TILETYPE_CORNER_CONVEX_NE)
../map/tile.c:167:                       || (tile->type == TILETYPE_CORNER_CONCAVE_NW)
../map/tile.c:168:                       || (tile->type == TILETYPE_CORNER_CONVEX_NW);
../map/tile.c:171:        return tile->base_height + tile->ramp_height;
../map/tile.c:173:        return tile->base_height;
../map/tile.c:178:    return tile->base_height;
../map/tile.c:186:    if(r == TILES_PER_CHUNK_HEIGHT-1)
../map/tile.c:205:    const struct tile *back = &tiles[(r-1) * TILES_PER_CHUNK_HEIGHT + c]; 
../map/tile.c:220:    const struct tile *left = &tiles[r * TILES_PER_CHUNK_HEIGHT + (c-1)]; 
../map/tile.c:231:    if(c == TILES_PER_CHUNK_WIDTH-1)
../map/tile.c:243:    if(tile->type == TILETYPE_FLAT) {
../map/tile.c:244:        return tile->base_height * Y_COORDS_PER_TILE;
../map/tile.c:246:    }else if(TILETYPE_IS_RAMP(tile->type)) {
../map/tile.c:270:        switch(tile->type){
../map/tile.c:333:        vec3_t ray_dir = (vec3_t){0.0f, -1.0f, 0.0f};
../map/tile.c:359:        map_box.x - desc.chunk_c * (TILES_PER_CHUNK_WIDTH * X_COORDS_PER_TILE)
../map/tile.c:360:                  - desc.tile_c  * TILE_X_DIM,
../map/tile.c:376:        map_box.x - chunk_c * CHUNK_WIDTH,
../map/tile.c:386:    int abs_r = inout->chunk_r * res.tile_h + inout->tile_r + tile_dr;
../map/tile.c:387:    int abs_c = inout->chunk_c * res.tile_w + inout->tile_c + tile_dc;
../map/tile.c:409:    int a_abs_r = a->chunk_r * res.tile_h + a->tile_r;
../map/tile.c:410:    int a_abs_c = a->chunk_c * res.tile_w + a->tile_c;
../map/tile.c:411:    int b_abs_r = b->chunk_r * res.tile_h + b->tile_r;
../map/tile.c:412:    int b_abs_c = b->chunk_c * res.tile_w + b->tile_c;
../map/tile.c:414:    *out_r = b_abs_r - a_abs_r;
../map/tile.c:415:    *out_c = b_abs_c - a_abs_c;
../map/tile.c:431:     * In the case of the line segmennt originating inside the map, this is simple - take the 
../map/tile.c:434:     * needs to be done - return an empty list. 
../map/tile.c:440:    vec2_t line_dir = (vec2_t){line.bx - line.ax, line.bz - line.az};
../map/tile.c:491:    const int step_c = line_dir.x <= 0.0f ? 1 : -1;
../map/tile.c:492:    const int step_r = line_dir.z >= 0.0f ? 1 : -1;
../map/tile.c:499:    t_max_x = (step_c > 0) ? fabs(start_x - (bounds.x - bounds.width)) / fabs(line_dir.x) 
../map/tile.c:500:                           : fabs(start_x - bounds.x) / fabs(line_dir.x);
../map/tile.c:502:    t_max_z = (step_r > 0) ? fabs(start_z - (bounds.z + bounds.height)) / fabs(line_dir.z)
../map/tile.c:503:                           : fabs(start_z - bounds.z) / fabs(line_dir.z);
../map/tile.c:550:    if(point.x > map_box.x || point.x < map_box.x - map_box.width)
../map/tile.c:557:    chunk_r = fabs(map_box.z - point.z) / CHUNK_HEIGHT;
../map/tile.c:558:    chunk_c = fabs(map_box.x - point.x) / CHUNK_WIDTH;
../map/tile.c:562:    chunk_r = CLAMP(chunk_r, 0, res.chunk_h-1);  
../map/tile.c:563:    chunk_c = CLAMP(chunk_c, 0, res.chunk_w-1);
../map/tile.c:566:    chunk_base_x = map_box.x - (chunk_c * CHUNK_WIDTH);
../map/tile.c:570:    tile_r = fabs(chunk_base_z - point.z) / TILE_Z_DIM;
../map/tile.c:571:    tile_c = fabs(chunk_base_x - point.x) / TILE_X_DIM;
../map/tile.c:573:    tile_r = CLAMP(tile_r, 0, res.tile_h-1);
../map/tile.c:574:    tile_c = CLAMP(tile_c, 0, res.tile_w-1);
../map/tile.c:579:    out->chunk_r = chunk_r;
../map/tile.c:580:    out->chunk_c = chunk_c;
../map/tile.c:581:    out->tile_r = tile_r;
../map/tile.c:582:    out->tile_c = tile_c;
../map/tile.c:591:    vec3_t bot_corners[4] = {obb->corners[0], obb->corners[1], obb->corners[5], obb->corners[4]};
../map/tile.c:609:     * tiles which intersect the line segment). Keep track of the top-most, bottom-most,
../map/tile.c:610:     * left-most and right-most tiles of the outline.
../map/tile.c:614:        min_rows[i] = (struct row_desc){res.chunk_h-1, res.tile_h-1};
../map/tile.c:616:        min_cols[i] = (struct col_desc){res.chunk_w-1, res.chunk_w-1};
../map/tile.c:619:        size_t num_tiles = M_Tile_LineSupercoverTilesSorted(res, map_pos, xz_line_segs[i], out + ret, maxout - ret);
../map/tile.c:661:                bounds.x - bounds.width/2.0f,
../map/tile.c:693:    for(int dr = -ntiles; dr <= ntiles; dr++) {
../map/tile.c:694:    for(int dc = -ntiles; dc <= ntiles; dc++) {
../map/tile.c:727:        xz_center.z - halfz,
../map/tile.c:732:    for(int dr = -ntiles_z; dr <= ntiles_z; dr++) {
../map/tile.c:733:    for(int dc = -ntiles_x; dc <= ntiles_x; dc++) {
../map/tile.c:764:        int absr = curr->chunk_r * res.tile_h + curr->tile_r;
../map/tile.c:765:        int absc = curr->chunk_c * res.tile_w + curr->tile_c;
../map/tile.c:773:    int dr = maxr - minr + 1;
../map/tile.c:774:    int dc = maxc - minc + 1;
../map/tile.c:782:        int absr = curr->chunk_r * res.tile_h + curr->tile_r;
../map/tile.c:783:        int absc = curr->chunk_c * res.tile_w + curr->tile_c;
../map/tile.c:785:        int relr = absr - minr + 1;
../map/tile.c:786:        int relc = absc - minc + 1;
../map/tile.c:791:    for(int r = minr - 1; r <= maxr + 1; r++) {
../map/tile.c:792:    for(int c = minc - 1; c <= maxc + 1; c++) {
../map/tile.c:794:        int relr = r - minr + 1;
../map/tile.c:795:        int relc = c - minc + 1;
../map/tile.c:809:        if((relr > (0)    && marked[relr - 1][relc])
../map/tile.c:810:        || (relr < (dr-1) && marked[relr + 1][relc])
../map/tile.c:811:        || (relc > (0)    && marked[relr][relc - 1])
../map/tile.c:812:        || (relc < (dc-1) && marked[relr][relc + 1])) {
../map/tile.c:816:        if((relr > 0      && relc > 0      && marked[relr - 1][relc - 1])
../map/tile.c:817:        || (relr > 0      && relc < (dc-1) && marked[relr - 1][relc + 1])
../map/tile.c:818:        || (relr < (dr-1) && relc > 0      && marked[relr + 1][relc - 1])
../map/tile.c:819:        || (relr < (dr-1) && relc < (dc-1) && marked[relr + 1][relc + 1])) {
../navigation/a_star.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/a_star.c:68:        assert(ret != -1);                              \
../navigation/a_star.c:83:    return (((uint64_t)ph->liid                   & 0xffff) << 48)
../navigation/a_star.c:84:         | (((uint64_t)ph->portal->chunk.r        & 0xff  ) << 40)
../navigation/a_star.c:85:         | (((uint64_t)ph->portal->chunk.c        & 0xff  ) << 32)
../navigation/a_star.c:86:         | (((uint64_t)ph->portal->endpoints[0].r & 0xff  ) << 24)
../navigation/a_star.c:87:         | (((uint64_t)ph->portal->endpoints[0].c & 0xff  ) << 16)
../navigation/a_star.c:88:         | (((uint64_t)ph->portal->endpoints[1].r & 0xff  ) <<  8)
../navigation/a_star.c:89:         | (((uint64_t)ph->portal->endpoints[1].c & 0xff  ) <<  0);
../navigation/a_star.c:97:    for(int r = -1; r <= 1; r++) {
../navigation/a_star.c:98:    for(int c = -1; c <= 1; c++) {
../navigation/a_star.c:112:        bool diag = (r == c) || (r == -c);
../navigation/a_star.c:129:    for(int r = port->endpoints[0].r; r <= port->endpoints[1].r; r++) {
../navigation/a_star.c:130:    for(int c = port->endpoints[0].c; c <= port->endpoints[1].c; c++) {
../navigation/a_star.c:132:        uint16_t curr_liid = chunk->local_islands[r][c];
../navigation/a_star.c:145:        priv->width, priv->height,
../navigation/a_star.c:149:    const struct portal *conn = port->connected;
../navigation/a_star.c:150:    const struct nav_chunk *pchunk = &priv->chunks[layer][port->chunk.r * priv->width + port->chunk.c];
../navigation/a_star.c:156:    for(int r1 = port->endpoints[0].r; r1 <= port->endpoints[1].r; r1++) {
../navigation/a_star.c:157:    for(int c1 = port->endpoints[0].c; c1 <= port->endpoints[1].c; c1++) {
../navigation/a_star.c:159:        uint16_t curr_liid = pchunk->local_islands[r1][c1];
../navigation/a_star.c:163:        for(int r2 = conn->endpoints[0].r; r2 <= conn->endpoints[1].r; r2++) {
../navigation/a_star.c:164:        for(int c2 = conn->endpoints[0].c; c2 <= conn->endpoints[1].c; c2++) {
../navigation/a_star.c:166:            const struct nav_chunk *cchunk = &priv->chunks[layer][conn->chunk.r * priv->width + conn->chunk.c];
../navigation/a_star.c:167:            struct tile_desc tda = (struct tile_desc){port->chunk.r, port->chunk.c, r1, c1};
../navigation/a_star.c:168:            struct tile_desc tdb = (struct tile_desc){conn->chunk.r, conn->chunk.c, r2, c2};
../navigation/a_star.c:176:                uint16_t neighb_liid = cchunk->local_islands[r2][c2];
../navigation/a_star.c:207:        &priv->chunks[layer][portal->chunk.r * priv->width + portal->chunk.c];
../navigation/a_star.c:209:    for(int i = 0; i < portal->num_neighbours; i++) {
../navigation/a_star.c:214:        const struct edge *edge = &portal->edges[i];
../navigation/a_star.c:215:        if(edge->es == EDGE_STATE_BLOCKED)
../navigation/a_star.c:221:        if(!portal_reachable_from_island(chunk, edge->neighbour, liid))
../navigation/a_star.c:224:        out_neighbours[ret] = edge->neighbour;
../navigation/a_star.c:225:        out_costs[ret] = edge->cost;
../navigation/a_star.c:238:        out_neighbours[ret] = portal->connected;
../navigation/a_star.c:253:        &priv->chunks[layer][finish->chunk.r * priv->width + finish->chunk.c];
../navigation/a_star.c:272:    int dx = abs(a.r - b.r);
../navigation/a_star.c:273:    int dy = abs(a.c - b.c);
../navigation/a_star.c:275:    return D * (dx + dy) + (D2 - 2 * D) * MIN(dx, dy);
../navigation/a_star.c:375:    for(int i = 0, j = vec_size(out_path) - 1; i < j; i++, j--) {
../navigation/a_star.c:424:    const struct nav_chunk *bchunk = &priv->chunks[layer][start_tile.chunk_r * priv->width + start_tile.chunk_c];
../navigation/a_star.c:429:    const struct nav_chunk *echunk = &priv->chunks[layer][end_tile.chunk_r * priv->width + end_tile.chunk_c];
../navigation/a_star.c:436:    for(int i = 0; i < bchunk->num_portals; i++) {
../navigation/a_star.c:438:        const struct portal *port = &bchunk->portals[i];
../navigation/a_star.c:443:            float cost = bchunk->portal_travel_costs[i][tile_coord.r][tile_coord.c];
../navigation/a_star.c:481:                /* No heuristic used - effectively Dijkstra's algorithm */
../navigation/a_star.c:508:    for(int i = 0, j = vec_size(out_path) - 1; i < j; i++, j--) {
../navigation/a_star.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/a_star.h:55: *   +----------+
../navigation/a_star.h:57: *   +----------+
../navigation/a_star.h:60: *   |0000000000| (chunk 1) - [1 local island]
../navigation/a_star.h:63: *   +----------+
../navigation/a_star.h:65: *   +----------+
../navigation/a_star.h:68: *   |1111^0000^| (chunk 2) - [2 local islands]
../navigation/a_star.h:71: *   +----------+
../navigation/a_star.h:73: *   +----------+
../navigation/a_star.h:76: *   |0000000000| (chunk 3) - [1 local island]
../navigation/a_star.h:79: *   +----------+
../navigation/a_star.h:81: *   +----------+
../navigation/a_star.h:85: * Obviously, this is the list of portals: A -> B -> C -> D
../navigation/a_star.h:88: * portal B into two portals - the left side and the right side. If 
../navigation/a_star.h:95: * (A, 0) -> (B, 1) -> (C, 0) -> (D, 0)
../navigation/a_star.h:109:/* ------------------------------------------------------------------------
../navigation/a_star.h:113: * ------------------------------------------------------------------------
../navigation/a_star.h:119:/* ------------------------------------------------------------------------
../navigation/a_star.h:123: * ------------------------------------------------------------------------
../navigation/field.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/field.c:70:#define sqrt(xMustBe2) 1.41421356237f // https://www.google.com/search?q=sqrt+2&oq=sqrt+2&aqs=chrome..69i57j0i67i131i433l4j0i67j69i60l2.936j0j7&sourceid=chrome&ie=UTF-8
../navigation/field.c:73:    [FD_NW]   = (vec2_t){  1.0f / sqrt(2.0f), -1.0f / sqrt(2.0f) },
../navigation/field.c:74:    [FD_N]    = (vec2_t){  0.0f,              -1.0f              },
../navigation/field.c:75:    [FD_NE]   = (vec2_t){ -1.0f / sqrt(2.0f), -1.0f / sqrt(2.0f) },
../navigation/field.c:77:    [FD_E]    = (vec2_t){ -1.0f,               0.0f              },
../navigation/field.c:80:    [FD_SE]   = (vec2_t){ -1.0f / sqrt(2.0f),  1.0f / sqrt(2.0f) },
../navigation/field.c:90:    int dr = abs(a.r - b.r);
../navigation/field.c:91:    int dc = abs(a.c - b.c);
../navigation/field.c:99:    return !((bc->r == ac->r) && (bc->c == ac->c));
../navigation/field.c:106:    return !((bc->chunk_r == ac->chunk_r) 
../navigation/field.c:107:          && (bc->chunk_c == ac->chunk_c)
../navigation/field.c:108:          && (bc->tile_r  == ac->tile_r)
../navigation/field.c:109:          && (bc->tile_c  == ac->tile_c));
../navigation/field.c:114:    if(chunk->cost_base[tile.r][tile.c] == COST_IMPASSABLE)
../navigation/field.c:116:    if(chunk->blockers[tile.r][tile.c] > 0)
../navigation/field.c:126:    if(chunk->cost_base[tile.r][tile.c] == COST_IMPASSABLE)
../navigation/field.c:131:        if(chunk->factions[i][tile.r][tile.c] && !(enemies & (0x1 << i))) {
../navigation/field.c:140:    if(chunk->blockers[tile.r][tile.c] > 0)
../navigation/field.c:159:    for(int r = -1; r <= 1; r++) {
../navigation/field.c:160:    for(int c = -1; c <= 1; c++) {
../navigation/field.c:171:        if((r == c) || (r == -c)) /* diag */
../navigation/field.c:186:        out_costs[ret] = chunk->cost_base[abs_r][abs_c];
../navigation/field.c:210:        priv->width, priv->height,
../navigation/field.c:214:    for(int r = -1; r <= 1; r++) {
../navigation/field.c:215:    for(int c = -1; c <= 1; c++) {
../navigation/field.c:219:        if((r == c) || (r == -c)) /* diag */
../navigation/field.c:226:        struct nav_chunk *chunk = &priv->chunks[layer][IDX(curr.chunk_r, priv->width, curr.chunk_c)];
../navigation/field.c:242:        out_costs[ret] = chunk->cost_base[curr.tile_r][curr.tile_c];
../navigation/field.c:264:    for(int r = -1; r <= 1; r++) {
../navigation/field.c:265:    for(int c = -1; c <= 1; c++) {
../navigation/field.c:276:        if((r == c) || (r == -c)) /* diag */
../navigation/field.c:278:        if(los->field[abs_r][abs_c].wavefront_blocked)
../navigation/field.c:282:        out_costs[ret] = chunk->cost_base[abs_r][abs_c];
../navigation/field.c:311:        min_cost = MIN(min_cost, integration_field[r-1][c]);
../navigation/field.c:313:    if(r < (rdim-1))
../navigation/field.c:317:        min_cost = MIN(min_cost, integration_field[r][c-1]);
../navigation/field.c:319:    if(c < (cdim-1))
../navigation/field.c:328:    && integration_field[r-1][c] < INFINITY
../navigation/field.c:329:    && integration_field[r][c-1] < INFINITY)
../navigation/field.c:330:        min_cost = MIN(min_cost, integration_field[r-1][c-1]);
../navigation/field.c:332:    if(r > 0 && c < (cdim-1)
../navigation/field.c:333:    && integration_field[r-1][c] < INFINITY
../navigation/field.c:335:        min_cost = MIN(min_cost, integration_field[r-1][c+1]);
../navigation/field.c:337:    if(r < (rdim-1) && c > 0
../navigation/field.c:339:    && integration_field[r][c-1] < INFINITY)
../navigation/field.c:340:        min_cost = MIN(min_cost, integration_field[r+1][c-1]);
../navigation/field.c:342:    if(r < (rdim-1) && c < (cdim-1)
../navigation/field.c:351:    && integration_field[r-1][c] == min_cost)
../navigation/field.c:353:    else if(r < (rdim-1) 
../navigation/field.c:356:    else if(c < (cdim-1) 
../navigation/field.c:360:    && integration_field[r][c-1] == min_cost)
../navigation/field.c:363:    && integration_field[r-1][c-1] == min_cost)
../navigation/field.c:365:    else if(r > 0 && c < (cdim-1) 
../navigation/field.c:366:    && integration_field[r-1][c+1] == min_cost)
../navigation/field.c:368:    else if(r < (rdim-1) && c > 0 
../navigation/field.c:369:    && integration_field[r+1][c-1] == min_cost)
../navigation/field.c:371:    else if(r < (rdim-1) && c < (rdim-1) 
../navigation/field.c:385:    if(cell.r > 0 && cell.r < FIELD_RES_R-1) {
../navigation/field.c:387:        bool left_blocked  = cost_field    [cell.r - 1][cell.c] == COST_IMPASSABLE
../navigation/field.c:388:                          || blockers_field[cell.r - 1][cell.c] > 0;
../navigation/field.c:395:    if(cell.c > 0 && cell.c < FIELD_RES_C-1) {
../navigation/field.c:397:        bool top_blocked = cost_field    [cell.r][cell.c - 1] == COST_IMPASSABLE
../navigation/field.c:398:                        || blockers_field[cell.r][cell.c - 1] > 0;
../navigation/field.c:416:        priv->width, priv->height,
../navigation/field.c:425:        target_bounds.x - target_bounds.width / 2.0f,
../navigation/field.c:429:        corner_bounds.x - corner_bounds.width / 2.0f,
../navigation/field.c:443:    int dy = -abs(slope.raw[1] * 1000);
../navigation/field.c:444:    int sx = slope.raw[0] > 0.0f ? 1 : -1;
../navigation/field.c:445:    int sy = slope.raw[1] < 0.0f ? 1 : -1;
../navigation/field.c:451:        out_los->field[curr.r][curr.c].wavefront_blocked = 1;
../navigation/field.c:471:        if(out_los->field[r][c].wavefront_blocked) {
../navigation/field.c:473:            for(int rr = r-1; rr <= r+1; rr++) {
../navigation/field.c:474:            for(int cc = c-1; cc <= c+1; cc++) {
../navigation/field.c:476:                if(rr < 0 || rr > FIELD_RES_R-1)
../navigation/field.c:478:                if(cc < 0 || cc > FIELD_RES_C-1)
../navigation/field.c:480:                out_los->field[rr][cc].visible = 0;
../navigation/field.c:529:        priv->width, priv->height,
../navigation/field.c:621:            inout_flow->field[r][c].dir_idx = FD_NONE;
../navigation/field.c:625:        inout_flow->field[r][c].dir_idx = field_flow_dir(FIELD_RES_R, FIELD_RES_C, 
../navigation/field.c:653:            inout_flow->field[r][c].dir_idx = FD_NONE;
../navigation/field.c:657:        inout_flow->field[r][c].dir_idx = field_flow_dir(rdim ,cdim, 
../navigation/field.c:667:    bool up    = port->connected->chunk.r < port->chunk.r;
../navigation/field.c:668:    bool down  = port->connected->chunk.r > port->chunk.r;
../navigation/field.c:669:    bool left  = port->connected->chunk.c < port->chunk.c;
../navigation/field.c:670:    bool right = port->connected->chunk.c > port->chunk.c;
../navigation/field.c:679:                inout_flow->field[r][c].dir_idx = FD_N;
../navigation/field.c:681:                inout_flow->field[r][c].dir_idx = FD_S;
../navigation/field.c:683:                inout_flow->field[r][c].dir_idx = FD_W;
../navigation/field.c:685:                inout_flow->field[r][c].dir_idx = FD_E;
../navigation/field.c:697:    int x_offset = -(chunk_coord.c * chunk_x_dim);
../navigation/field.c:700:    out->x_max = map_pos.x + x_offset;
../navigation/field.c:701:    out->x_min = out->x_max - chunk_x_dim;
../navigation/field.c:703:    out->z_min = map_pos.z + z_offset;
../navigation/field.c:704:    out->z_max = out->z_min + chunk_z_dim;
../navigation/field.c:709:    if(G_GetFactionID(ent->uid) == faction_id)
../navigation/field.c:711:    if(!(ent->flags & ENTITY_FLAG_COMBATABLE))
../navigation/field.c:715:    bool result = G_GetDiplomacyState(faction_id, G_GetFactionID(ent->uid), &ds);
../navigation/field.c:749:    --(*qsize);
../navigation/field.c:763:    int fhead = 0, ftail = -1;
../navigation/field.c:767:    int first_mh_dist = -1;
../navigation/field.c:776:            { 0, -1},
../navigation/field.c:778:            {-1,  0},
../navigation/field.c:801:        if(first_mh_dist > -1 && mh_dist > first_mh_dist) {
../navigation/field.c:805:        if(chunk->cost_base[curr.r][curr.c] == COST_IMPASSABLE)
../navigation/field.c:807:        if(chunk->blockers[curr.r][curr.c] > 0)
../navigation/field.c:810:        && chunk->islands[curr.r][curr.c] != global_iid)
../navigation/field.c:813:        && chunk->local_islands[curr.r][curr.c] != local_iid)
../navigation/field.c:816:        if(first_mh_dist == -1)
../navigation/field.c:870:        priv->width, priv->height,
../navigation/field.c:874:    const struct nav_chunk *next_chunk = &priv->chunks[layer][pd.next->chunk.r * priv->width + pd.next->chunk.c];
../navigation/field.c:875:    for(int r2 = pd.next->endpoints[0].r; r2 <= pd.next->endpoints[1].r; r2++) {
../navigation/field.c:876:    for(int c2 = pd.next->endpoints[0].c; c2 <= pd.next->endpoints[1].c; c2++) {
../navigation/field.c:878:        struct tile_desc curr_td = (struct tile_desc){pd.port->chunk.r, pd.port->chunk.c, r,  c };
../navigation/field.c:879:        struct tile_desc next_td = (struct tile_desc){pd.next->chunk.r, pd.next->chunk.c, r2, c2};
../navigation/field.c:884:            uint16_t neighb_liid = next_chunk->local_islands[r2][c2];
../navigation/field.c:911:    /* Set all non-blocked tiles of the portal as the frontier */
../navigation/field.c:913:    for(int r = pd.port->endpoints[0].r; r <= pd.port->endpoints[1].r; r++) {
../navigation/field.c:914:    for(int c = pd.port->endpoints[0].c; c <= pd.port->endpoints[1].c; c++) {
../navigation/field.c:916:        assert(chunk->cost_base[r][c] != COST_IMPASSABLE);
../navigation/field.c:927:        if(pd.port_iid != ISLAND_NONE && chunk->local_islands[r][c] != pd.port_iid)
../navigation/field.c:954:    field_chunk_bounds(enemies->map_pos, enemies->chunk, &bounds);
../navigation/field.c:955:    float xlen = bounds.x_max - bounds.x_min;
../navigation/field.c:956:    float zlen = bounds.z_max - bounds.z_min;
../navigation/field.c:960:        (vec2_t){bounds.x_min - xlen/2.0f - SEARCH_BUFFER, bounds.z_min - zlen/2.0f - SEARCH_BUFFER},
../navigation/field.c:966:        priv->width, priv->height,
../navigation/field.c:976:        if(!field_enemy_ent(enemies->faction_id, curr_enemy))
../navigation/field.c:978:        if(G_Combat_IsDying(curr_enemy->uid))
../navigation/field.c:983:        if(curr_enemy->flags & ENTITY_FLAG_BUILDING) {
../navigation/field.c:987:            ntds = M_Tile_AllUnderObj(enemies->map_pos, res, &obb, tds, ARR_SIZE(tds));
../navigation/field.c:989:            ntds = M_Tile_AllUnderCircle(res, G_Pos_GetXZ(curr_enemy->uid), 
../navigation/field.c:990:                G_GetSelectionRadius(curr_enemy->uid), enemies->map_pos, tds, ARR_SIZE(tds));
../navigation/field.c:994:            ntds += M_Tile_Contour(ntds, tds, res, tds + ntds, ARR_SIZE(tds) - ntds);
../navigation/field.c:997:            ntds += M_Tile_Contour(ntds, tds, res, tds + ntds, ARR_SIZE(tds) - ntds);
../navigation/field.c:1000:            ntds += M_Tile_Contour(ntds, tds, res, tds + ntds, ARR_SIZE(tds) - ntds);
../navigation/field.c:1045:        priv->width, priv->height,
../navigation/field.c:1051:    const struct entity *ent = target->target;
../navigation/field.c:1053:    if(ent->flags & ENTITY_FLAG_BUILDING) {
../navigation/field.c:1057:        ntds = M_Tile_AllUnderObj(target->map_pos, res, &obb, tds, ARR_SIZE(tds));
../navigation/field.c:1059:        ntds = M_Tile_AllUnderCircle(res, G_Pos_GetXZ(ent->uid), 
../navigation/field.c:1060:            G_GetSelectionRadius(ent->uid), target->map_pos, tds, ARR_SIZE(tds));
../navigation/field.c:1064:        ntds += M_Tile_Contour(ntds, tds, res, tds + ntds, ARR_SIZE(tds) - ntds);
../navigation/field.c:1067:        ntds += M_Tile_Contour(ntds, tds, res, tds + ntds, ARR_SIZE(tds) - ntds);
../navigation/field.c:1070:        ntds += M_Tile_Contour(ntds, tds, res, tds + ntds, ARR_SIZE(tds) - ntds);
../navigation/field.c:1137:        for(int i = 0; i < chunk->num_portals; i++) {
../navigation/field.c:1141:            field_fixup_portal_edges(integration_field, inout_flow, &chunk->portals[i]);
../navigation/field.c:1160:    int fhead = 0, ftail = -1;
../navigation/field.c:1170:            { 0, -1},
../navigation/field.c:1172:            {-1,  0},
../navigation/field.c:1215:        priv->width, priv->height,
../navigation/field.c:1229:    const int rdim = (priv->height > 1) ? FIELD_RES_R * 2 + (FIELD_RES_R % 2) : FIELD_RES_R;
../navigation/field.c:1230:    const int cdim = (priv->width  > 1) ? FIELD_RES_C * 2 + (FIELD_RES_C % 2) : FIELD_RES_C;
../navigation/field.c:1239:        .chunk_r = (chunk_coord.r > 0) ? chunk_coord.r - 1 : chunk_coord.r,
../navigation/field.c:1240:        .chunk_c = (chunk_coord.c > 0) ? chunk_coord.c - 1 : chunk_coord.c,
../navigation/field.c:1262:    inout_flow->target = (struct field_target){
../navigation/field.c:1288:        priv->width, priv->height,
../navigation/field.c:1295:    const int rdim = (priv->height > 1) ? FIELD_RES_R * 2 + (FIELD_RES_R % 2) : FIELD_RES_R;
../navigation/field.c:1296:    const int cdim = (priv->width  > 1) ? FIELD_RES_C * 2 + (FIELD_RES_C % 2) : FIELD_RES_C;
../navigation/field.c:1305:        .chunk_r = (chunk_coord.r > 0) ? chunk_coord.r - 1 : chunk_coord.r,
../navigation/field.c:1306:        .chunk_c = (chunk_coord.c > 0) ? chunk_coord.c - 1 : chunk_coord.c,
../navigation/field.c:1328:    inout_flow->target = (struct field_target){
../navigation/field.c:1355:             | (((uint64_t)target.pd.port->endpoints[0].r) << 34)
../navigation/field.c:1356:             | (((uint64_t)target.pd.port->endpoints[0].c) << 28)
../navigation/field.c:1357:             | (((uint64_t)target.pd.port->endpoints[1].r) << 22)
../navigation/field.c:1358:             | (((uint64_t)target.pd.port->endpoints[1].c) << 16)
../navigation/field.c:1383:             | (((uint64_t)target.ent.target->uid)         << 24)
../navigation/field.c:1408:        out->field[r][c].dir_idx = FD_NONE;
../navigation/field.c:1410:    out->chunk = chunk_coord;
../navigation/field.c:1431:    const struct nav_chunk *chunk = &priv->chunks[layer][IDX(chunk_coord.r, priv->width, chunk_coord.c)];
../navigation/field.c:1452:    inout_flow->target = target;
../navigation/field.c:1470:    out_los->chunk = chunk_coord;
../navigation/field.c:1471:    memset(out_los->field, 0x00, sizeof(out_los->field));
../navigation/field.c:1475:    const struct nav_chunk *chunk = &priv->chunks[N_DestLayer(id)]
../navigation/field.c:1476:                                                 [chunk_coord.r * priv->width + chunk_coord.c];
../navigation/field.c:1503:        if(prev_los->chunk.r < chunk_coord.r) {
../navigation/field.c:1507:            prev_edge_idx = FIELD_RES_R-1;
../navigation/field.c:1509:        }else if(prev_los->chunk.r > chunk_coord.r) {
../navigation/field.c:1512:            curr_edge_idx = FIELD_RES_R-1;
../navigation/field.c:1515:        }else if(prev_los->chunk.c < chunk_coord.c) {
../navigation/field.c:1519:            prev_edge_idx = FIELD_RES_C-1;
../navigation/field.c:1521:        }else if(prev_los->chunk.c > chunk_coord.c) {
../navigation/field.c:1524:            curr_edge_idx = FIELD_RES_C-1;
../navigation/field.c:1535:                out_los->field[r][curr_edge_idx] = prev_los->field[r][prev_edge_idx];
../navigation/field.c:1536:                if(out_los->field[r][curr_edge_idx].wavefront_blocked) {
../navigation/field.c:1544:                if(out_los->field[r][curr_edge_idx].visible) {
../navigation/field.c:1554:                out_los->field[curr_edge_idx][c] = prev_los->field[prev_edge_idx][c];
../navigation/field.c:1555:                if(out_los->field[curr_edge_idx][c].wavefront_blocked) {
../navigation/field.c:1563:                if(out_los->field[curr_edge_idx][c].visible) {
../navigation/field.c:1587:                if(!field_is_los_corner(neighbours[i], chunk->cost_base, chunk->blockers))
../navigation/field.c:1600:                out_los->field[nr][nc].visible = 1;
../navigation/field.c:1613:    /* Add a single tile-wide padding of invisible tiles around the wavefront. This is 
../navigation/field.c:1655:        inout_flow->field[r][c].dir_idx = field_flow_dir(FIELD_RES_R, FIELD_RES_C, 
../navigation/field.c:1669:    struct coord chunk_coord = inout_flow->chunk;
../navigation/field.c:1670:    const struct nav_chunk *chunk = &priv->chunks[layer][IDX(chunk_coord.r, priv->width, chunk_coord.c)];
../navigation/field.c:1685:    if(inout_flow->target.type == TARGET_ENEMIES) {
../navigation/field.c:1688:        size_t ntds = field_enemies_initial_frontier(&inout_flow->target.enemies, priv, base, 
../navigation/field.c:1698:    }else if(inout_flow->target.type == TARGET_ENTITY) {
../navigation/field.c:1701:        size_t ntds = field_entity_initial_frontier(&inout_flow->target.ent, priv, base, 
../navigation/field.c:1712:        ninit = field_initial_frontier(layer, inout_flow->target, chunk, priv, false, faction_id, 
../navigation/field.c:1717:            ninit = field_initial_frontier(layer, inout_flow->target, chunk, priv, true, faction_id, 
../navigation/field.c:1730:        uint16_t curr_giid = chunk->islands[curr.r][curr.c];
../navigation/field.c:1731:        uint16_t curr_liid = chunk->local_islands[curr.r][curr.c];
../navigation/field.c:1747:            tmp, ARR_SIZE(tmp) - new_ninit);
../navigation/field.c:1778:    field_fixup(inout_flow->target, integration_field, inout_flow, chunk);
../navigation/field.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/field.h:115:/* ------------------------------------------------------------------------
../navigation/field.h:117: * ------------------------------------------------------------------------
../navigation/field.h:123:/* ------------------------------------------------------------------------
../navigation/field.h:125: * ------------------------------------------------------------------------
../navigation/field.h:129:/* ------------------------------------------------------------------------
../navigation/field.h:131: * ------------------------------------------------------------------------
../navigation/field.h:135:/* ------------------------------------------------------------------------
../navigation/field.h:139: * ------------------------------------------------------------------------
../navigation/field.h:145:/* ------------------------------------------------------------------------
../navigation/field.h:149: * ------------------------------------------------------------------------
../navigation/field.h:158:/* ------------------------------------------------------------------------
../navigation/field.h:164: * ------------------------------------------------------------------------
../navigation/field.h:172:/* ------------------------------------------------------------------------
../navigation/field.h:178: * ------------------------------------------------------------------------
../navigation/field.h:185:/* ------------------------------------------------------------------------
../navigation/field.h:193: * ------------------------------------------------------------------------
../navigation/fieldcache.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/fieldcache.c:141:    vec_coord_destroy(&victim->path);
../navigation/fieldcache.c:169:        assert(ret != -1 && ret != 0);
../navigation/fieldcache.c:191:    for(int i = vec_size(keys)-1; i >= 0; i--) {
../navigation/fieldcache.c:214:    for(int i = vec_size(keys)-1; i >= 0; i--) {
../navigation/fieldcache.c:308:    out_stats->los_used = s_los_cache.used;
../navigation/fieldcache.c:309:    out_stats->los_max = s_los_cache.capacity;
../navigation/fieldcache.c:310:    out_stats->los_hit_rate = !s_perfstats.los_query ? 0
../navigation/fieldcache.c:312:    out_stats->los_invalidated = s_perfstats.los_invalidated;
../navigation/fieldcache.c:314:    out_stats->flow_used = s_flow_cache.used;
../navigation/fieldcache.c:315:    out_stats->flow_max = s_flow_cache.capacity;
../navigation/fieldcache.c:316:    out_stats->flow_hit_rate = !s_perfstats.flow_query ? 0
../navigation/fieldcache.c:318:    out_stats->flow_invalidated = s_perfstats.flow_invalidated;
../navigation/fieldcache.c:320:    out_stats->ffid_used = s_ffid_cache.used;
../navigation/fieldcache.c:321:    out_stats->ffid_max = s_ffid_cache.capacity;
../navigation/fieldcache.c:322:    out_stats->ffid_hit_rate = !s_perfstats.ffid_hit ? 0
../navigation/fieldcache.c:325:    out_stats->grid_path_used = s_grid_path_cache.used;
../navigation/fieldcache.c:326:    out_stats->grid_path_max = s_grid_path_cache.capacity;
../navigation/fieldcache.c:327:    out_stats->grid_path_hit_rate = !s_perfstats.grid_path_hit ? 0
../navigation/fieldcache.c:484:    for(int dr = -1; dr <= +1; dr++) {
../navigation/fieldcache.c:485:    for(int dc = -1; dc <= +1; dc++) {
../navigation/fieldcache.c:516:        if(!(ent->flags & ENTITY_FLAG_MOVABLE))
../navigation/fieldcache.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/nav.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/nav.c:65:#define CURSOR_OFF(cursor, base) ((ptrdiff_t)((cursor) - (base)))
../navigation/nav.c:76:        for(int chunk_r = 0; chunk_r < (_priv)->height; chunk_r++) {                            \
../navigation/nav.c:77:        for(int chunk_c = 0; chunk_c < (_priv)->width;  chunk_c++) {                            \
../navigation/nav.c:79:            struct nav_chunk *curr_chunk = &(_priv)->chunks[_layer]                             \
../navigation/nav.c:80:                                                           [IDX(chunk_r, (_priv)->width, chunk_c)]; \
../navigation/nav.c:81:            for((_local) = curr_chunk->portals;                                                 \
../navigation/nav.c:82:                (_local) < curr_chunk->portals + curr_chunk->num_portals; (_local)++) {         \
../navigation/nav.c:123:    return (((uint64_t)td->chunk_r << 48)
../navigation/nav.c:124:          | ((uint64_t)td->chunk_c << 32)
../navigation/nav.c:125:          | ((uint64_t)td->tile_r  << 16)
../navigation/nav.c:126:          | ((uint64_t)td->tile_c  <<  0));
../navigation/nav.c:131:    if(!tile->pathable)
../navigation/nav.c:133:    if(tile->type != TILETYPE_FLAT && tile->ramp_height > 1)
../navigation/nav.c:141:    struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:142:                                           [IDX(td.chunk_r, priv->width, td.chunk_c)];
../navigation/nav.c:143:    if(chunk->cost_base[td.tile_r][td.tile_c] == COST_IMPASSABLE)
../navigation/nav.c:145:    if(chunk->blockers[td.tile_r][td.tile_c] > 0)
../navigation/nav.c:154:        priv->width, priv->height,
../navigation/nav.c:189:    switch(tile->type) {
../navigation/nav.c:222:        chunk->cost_base[r_base + r][c_base + c] = n_tile_pathable(tile) ? 1 
../navigation/nav.c:241:        chunk->cost_base[r_base + r][c_base + c] = 0;
../navigation/nav.c:298:            chunk->cost_base[r_base + r][c_base + c] = COST_IMPASSABLE;
../navigation/nav.c:307:    if(a->type != TILETYPE_FLAT || b->type != TILETYPE_FLAT)
../navigation/nav.c:310:    return (a->base_height != b->base_height);
../navigation/nav.c:316:    for(int r = 0; r < priv->height; r++) {
../navigation/nav.c:317:    for(int c = 0; c < priv->width; c++) {
../navigation/nav.c:319:        struct nav_chunk *curr_chunk = &priv->chunks[layer]
../navigation/nav.c:320:                                                    [IDX(r, priv->width, c)];
../navigation/nav.c:322:        const struct tile *bot_tiles = (r < priv->height-1)  ? tiles[IDX(r+1, priv->width, c)] : NULL;
../navigation/nav.c:323:        const struct tile *top_tiles = (r > 0)               ? tiles[IDX(r-1, priv->width, c)] : NULL;
../navigation/nav.c:324:        const struct tile *right_tiles = (c < priv->width-1) ? tiles[IDX(r, priv->width, c+1)] : NULL;
../navigation/nav.c:325:        const struct tile *left_tiles = (c > 0)              ? tiles[IDX(r, priv->width, c-1)] : NULL;
../navigation/nav.c:330:            const struct tile *curr_tile = &tiles[IDX(r, priv->width, c)][IDX(chr, chunk_w, chc)];
../navigation/nav.c:331:            const struct tile *bot_tile   = (chr < chunk_h-1) ? curr_tile + chunk_w 
../navigation/nav.c:334:            const struct tile *top_tile   = (chr > 0)         ? curr_tile - chunk_w
../navigation/nav.c:335:                                          : top_tiles         ? &top_tiles[IDX(chunk_h-1, chunk_w, chc)]
../navigation/nav.c:337:            const struct tile *left_tile  = (chc > 0)         ? curr_tile - 1 
../navigation/nav.c:338:                                          : left_tiles        ? &left_tiles[IDX(chr, chunk_w, chunk_w-1)]
../navigation/nav.c:340:            const struct tile *right_tile = (chc < chunk_w-1) ? curr_tile + 1 
../navigation/nav.c:366:    uint8_t *a_cursor = &a->cost_base[a_type == EDGE_BOT   ? FIELD_RES_R-1 : 0]
../navigation/nav.c:367:                                     [a_type == EDGE_RIGHT ? FIELD_RES_C-1 : 0];
../navigation/nav.c:368:    uint8_t *b_cursor = &b->cost_base[b_type == EDGE_BOT   ? FIELD_RES_R-1 : 0]
../navigation/nav.c:369:                                     [b_type == EDGE_RIGHT ? FIELD_RES_C-1 : 0];
../navigation/nav.c:372:                    : a_type == EDGE_BOT   ? FIELD_RES_R-1
../navigation/nav.c:374:                    : a_type == EDGE_RIGHT ? FIELD_RES_C-1
../navigation/nav.c:377:                    : b_type == EDGE_BOT   ? FIELD_RES_R-1
../navigation/nav.c:379:                    : b_type == EDGE_RIGHT ? FIELD_RES_C-1
../navigation/nav.c:385:        assert(CURSOR_OFF(a_cursor, &a->cost_base[0][0]) >= 0 
../navigation/nav.c:386:            && CURSOR_OFF(a_cursor, &a->cost_base[0][0]) < (FIELD_RES_R*FIELD_RES_C));
../navigation/nav.c:387:        assert(CURSOR_OFF(b_cursor, &b->cost_base[0][0]) >= 0 
../navigation/nav.c:388:            && CURSOR_OFF(a_cursor, &b->cost_base[0][0]) < (FIELD_RES_R*FIELD_RES_C));
../navigation/nav.c:395:            a->portals[a->num_portals] = (struct portal) {
../navigation/nav.c:402:                .connected      = &b->portals[b->num_portals]
../navigation/nav.c:404:            b->portals[b->num_portals] = (struct portal) {
../navigation/nav.c:411:                .connected      = &a->portals[a->num_portals]
../navigation/nav.c:415:        }else if(in_portal && (!can_cross || i == line_len - 1)) {
../navigation/nav.c:417:            int idx = !can_cross ? i-1 : i;
../navigation/nav.c:419:            a->portals[a->num_portals].endpoints[1] 
../navigation/nav.c:423:            b->portals[b->num_portals].endpoints[1] 
../navigation/nav.c:428:            a->num_portals++;
../navigation/nav.c:429:            b->num_portals++;
../navigation/nav.c:431:            assert(a->num_portals <= MAX_PORTALS_PER_CHUNK);
../navigation/nav.c:432:            assert(b->num_portals <= MAX_PORTALS_PER_CHUNK);
../navigation/nav.c:444:    for(int r = 0; r < priv->height; r++) {
../navigation/nav.c:445:    for(int c = 0; c < priv->width;  c++) {
../navigation/nav.c:447:        struct nav_chunk *curr = &priv->chunks[layer][IDX(r, priv->width, c)];
../navigation/nav.c:448:        struct nav_chunk *bot = (r < priv->height-1) 
../navigation/nav.c:449:                              ? &priv->chunks[layer][IDX(r+1, priv->width, c)] 
../navigation/nav.c:451:        struct nav_chunk *right = (c < priv->width-1) 
../navigation/nav.c:452:                                ? &priv->chunks[layer][IDX(r, priv->width, c+1)] 
../navigation/nav.c:465:    assert(n_links == (priv->height)*(priv->width-1) + (priv->width)*(priv->height-1));
../navigation/nav.c:473:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:475:        struct portal *port = &chunk->portals[i];
../navigation/nav.c:476:        for(int j = 0; j < chunk->num_portals; j++) {
../navigation/nav.c:481:            struct portal *link_candidate = &chunk->portals[j];
../navigation/nav.c:483:                (port->endpoints[0].r + port->endpoints[1].r) / 2,
../navigation/nav.c:484:                (port->endpoints[0].c + port->endpoints[1].c) / 2,
../navigation/nav.c:487:                (link_candidate->endpoints[0].r + link_candidate->endpoints[1].r) / 2,
../navigation/nav.c:488:                (link_candidate->endpoints[0].c + link_candidate->endpoints[1].c) / 2,
../navigation/nav.c:492:            bool has_path = AStar_GridPath(a, b, chunk_coord, chunk->cost_base, layer, &path, &cost);
../navigation/nav.c:494:                port->edges[port->num_neighbours] = (struct edge){EDGE_STATE_ACTIVE, link_candidate, cost};
../navigation/nav.c:495:                port->num_neighbours++;    
../navigation/nav.c:505:    if(port->component_id != 0)
../navigation/nav.c:508:    port->component_id = comp_id;
../navigation/nav.c:509:    n_visit_portal(port->connected, comp_id); 
../navigation/nav.c:511:    for(int i = 0; i < port->num_neighbours; i++) {
../navigation/nav.c:513:        struct portal *curr = port->edges[i].neighbour;
../navigation/nav.c:514:        if(port->edges[i].es == EDGE_STATE_BLOCKED)
../navigation/nav.c:524:        port->component_id = 0;
../navigation/nav.c:535: * non-blocked tiles. */
../navigation/nav.c:539:    for(int r1 = a->endpoints[0].r; r1 <= a->endpoints[1].r; r1++) {
../navigation/nav.c:540:    for(int c1 = a->endpoints[0].c; c1 <= a->endpoints[1].c; c1++) {
../navigation/nav.c:542:        if(chunk->blockers[r1][c1] > 0)
../navigation/nav.c:545:        for(int r2 = b->endpoints[0].r; r2 <= b->endpoints[1].r; r2++) {
../navigation/nav.c:546:        for(int c2 = b->endpoints[0].c; c2 <= b->endpoints[1].c; c2++) {
../navigation/nav.c:548:            if(chunk->blockers[r2][c2] > 0)
../navigation/nav.c:551:            if(chunk->local_islands[r1][c1] == chunk->local_islands[r2][c2])
../navigation/nav.c:561:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:563:        struct portal *port = &chunk->portals[i];
../navigation/nav.c:565:        for(int j = 0; j < port->num_neighbours; j++) {
../navigation/nav.c:567:            struct portal *neighb = port->edges[j].neighbour;
../navigation/nav.c:571:            enum edge_state old_es = port->edges[j].es;
../navigation/nav.c:574:                port->edges[j].es = new_es;
../navigation/nav.c:601:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:602:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:606:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:607:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:642:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:644:        const struct portal *port = &chunk->portals[i];
../navigation/nav.c:645:        int r_start = MIN(port->endpoints[0].r, port->endpoints[1].r);
../navigation/nav.c:646:        int r_end = MAX(port->endpoints[0].r, port->endpoints[1].r);
../navigation/nav.c:650:            int c_start = MIN(port->endpoints[0].c, port->endpoints[1].c);
../navigation/nav.c:651:            int c_end = MAX(port->endpoints[0].c, port->endpoints[1].c);
../navigation/nav.c:656:                float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:657:                float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:661:                *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:662:                *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:703:        priv->width, priv->height,
../navigation/nav.c:707:    struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:708:                                           [IDX(start.chunk_r, priv->width, start.chunk_c)];
../navigation/nav.c:709:    chunk->islands[start.tile_r][start.tile_c] = id;
../navigation/nav.c:721:            { 0, -1},
../navigation/nav.c:723:            {-1,  0},
../navigation/nav.c:734:            chunk = &priv->chunks[layer]
../navigation/nav.c:735:                                 [IDX(neighb.chunk_r, priv->width, neighb.chunk_c)];
../navigation/nav.c:737:            if(chunk->islands[neighb.tile_r][neighb.tile_c] == ISLAND_NONE
../navigation/nav.c:738:            && chunk->cost_base[neighb.tile_r][neighb.tile_c] != COST_IMPASSABLE) {
../navigation/nav.c:740:                chunk->islands[neighb.tile_r][neighb.tile_c] = id;
../navigation/nav.c:761:    chunk->local_islands[start.r][start.c] = id;
../navigation/nav.c:770:            { 0, -1},
../navigation/nav.c:772:            {-1,  0},
../navigation/nav.c:782:            if(chunk->cost_base[neighb.tile_r][neighb.tile_c] == COST_IMPASSABLE)
../navigation/nav.c:785:            if(chunk->blockers[neighb.tile_r][neighb.tile_c] > 0)
../navigation/nav.c:788:            if(chunk->local_islands[neighb.tile_r][neighb.tile_c] != ISLAND_NONE)
../navigation/nav.c:791:            chunk->local_islands[neighb.tile_r][neighb.tile_c] = id;
../navigation/nav.c:804:    if(!(ent->flags & ENTITY_FLAG_COMBATABLE))
../navigation/nav.c:806:    if(G_GetFactionID(ent->uid) == faction_id)
../navigation/nav.c:809:    bool result = G_GetDiplomacyState(G_GetFactionID(ent->uid), faction_id, &ds);
../navigation/nav.c:817:    memset(chunk->local_islands, 0xff, sizeof(chunk->local_islands));
../navigation/nav.c:822:        if(chunk->local_islands[r][c] != ISLAND_NONE)
../navigation/nav.c:824:        if(chunk->cost_base[r][c] == COST_IMPASSABLE)
../navigation/nav.c:826:        if(chunk->blockers[r][c] > 0)
../navigation/nav.c:847:        struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:848:                                               [IDX(curr.r, priv->width, curr.c)];
../navigation/nav.c:860:        struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:861:                                               [IDX(curr.chunk_r, priv->width, curr.chunk_c)];
../navigation/nav.c:863:        assert(ref_delta < 0 ? chunk->blockers[curr.tile_r][curr.tile_c] >= -ref_delta : true);
../navigation/nav.c:864:        assert(ref_delta > 0 ? chunk->blockers[curr.tile_r][curr.tile_c] < (256 - ref_delta) : true);
../navigation/nav.c:866:        int prev_val = chunk->blockers[curr.tile_r][curr.tile_c];
../navigation/nav.c:867:        chunk->blockers[curr.tile_r][curr.tile_c] += ref_delta;
../navigation/nav.c:868:        chunk->factions[faction_id][curr.tile_r][curr.tile_c] += ref_delta;
../navigation/nav.c:869:        assert(chunk->blockers[curr.tile_r][curr.tile_c] < 255);
../navigation/nav.c:871:        int val = chunk->blockers[curr.tile_r][curr.tile_c];
../navigation/nav.c:872:        if(!!val != !!prev_val) { /* The tile changed states between occupied/non-occupied */
../navigation/nav.c:879:            assert(ret != -1);
../navigation/nav.c:942:      - (b.chunk_r * TILES_PER_CHUNK_HEIGHT + b.tile_r)
../navigation/nav.c:946:      - (b.chunk_c * TILES_PER_CHUNK_HEIGHT + b.tile_c)
../navigation/nav.c:957:        priv->width, priv->height,
../navigation/nav.c:970:    int first_mh_dist = -1;
../navigation/nav.c:978:            { 0, -1},
../navigation/nav.c:980:            {-1,  0},
../navigation/nav.c:991:            const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:992:                                                         [IDX(neighb.chunk_r, priv->width, neighb.chunk_c)];
../navigation/nav.c:997:            bool skip = (chunk->islands[neighb.tile_r][neighb.tile_c] != global_iid);
../navigation/nav.c:999:            && chunk->blockers[neighb.tile_r][neighb.tile_c] > 0)
../navigation/nav.c:1011:                if(first_mh_dist == -1)
../navigation/nav.c:1032:    for(int pi = 0; pi < chunk->num_portals; pi++) {
../navigation/nav.c:1040:            chunk->portal_travel_costs[pi][r][c] = FLT_MAX;
../navigation/nav.c:1043:        const struct portal *port = &chunk->portals[pi];
../navigation/nav.c:1044:        for(int r = port->endpoints[0].r; r <= port->endpoints[1].r; r++) {
../navigation/nav.c:1045:        for(int c = port->endpoints[0].c; c <= port->endpoints[1].c; c++) {
../navigation/nav.c:1057:            chunk->portal_travel_costs[pi][curr.coord.r][curr.coord.c] = curr.cost;
../navigation/nav.c:1061:            int num_neighbours = N_GridNeighbours(chunk->cost_base, curr.coord, neighbours, costs);
../navigation/nav.c:1084:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:1086:        const struct portal *curr = &chunk->portals[i];
../navigation/nav.c:1087:        float cost = chunk->portal_travel_costs[i][start.r][start.c];
../navigation/nav.c:1120:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:1124:        const struct portal *port = &chunk->portals[i];
../navigation/nav.c:1126:        for(int r = port->endpoints[0].r; r <= port->endpoints[1].r; r++) {
../navigation/nav.c:1127:        for(int c = port->endpoints[0].c; c <= port->endpoints[1].c; c++) {
../navigation/nav.c:1129:            struct tile_desc curr = (struct tile_desc){port->chunk.r, port->chunk.c, r, c};
../navigation/nav.c:1130:            uint16_t curr_liid = chunk->local_islands[r][c];
../navigation/nav.c:1156:    out_xz_min->x = map_pos.x - (chunk.c + 1) * X_COORDS_PER_TILE * TILES_PER_CHUNK_WIDTH;
../navigation/nav.c:1157:    out_xz_max->x = map_pos.x - (chunk.c + 0) * X_COORDS_PER_TILE * TILES_PER_CHUNK_WIDTH;
../navigation/nav.c:1159:    out_xz_min->z = map_pos.z + (chunk.r + 0) * Z_COORDS_PER_TILE * TILES_PER_CHUNK_HEIGHT;
../navigation/nav.c:1160:    out_xz_max->z = map_pos.z + (chunk.r + 1) * Z_COORDS_PER_TILE * TILES_PER_CHUNK_HEIGHT;
../navigation/nav.c:1177:        curr = (struct coord){chunk.r - 1, chunk.c};
../navigation/nav.c:1184:    if(chunk.r < FIELD_RES_R-1) {
../navigation/nav.c:1195:        curr = (struct coord){chunk.r, chunk.c - 1};
../navigation/nav.c:1202:    if(chunk.c < FIELD_RES_C-1) {
../navigation/nav.c:1212:    const struct nav_chunk *nchunk = &priv->chunks[layer]
../navigation/nav.c:1213:                                                  [IDX(chunk.r, priv->width, chunk.c)];
../navigation/nav.c:1215:    for(int i = 0; i < nchunk->num_portals; i++) {
../navigation/nav.c:1217:        const struct portal *curr = &nchunk->portals[i];
../navigation/nav.c:1219:        if(top && curr->endpoints[0].r == 0 
../navigation/nav.c:1220:               && curr->endpoints[1].r == 0)
../navigation/nav.c:1223:        if(bot && curr->endpoints[0].r == FIELD_RES_R-1 
../navigation/nav.c:1224:               && curr->endpoints[1].r == FIELD_RES_R-1)
../navigation/nav.c:1227:        if(left && curr->endpoints[0].c == 0 
../navigation/nav.c:1228:                && curr->endpoints[1].c == 0)
../navigation/nav.c:1231:        if(right && curr->endpoints[0].c == FIELD_RES_C-1 
../navigation/nav.c:1232:                 && curr->endpoints[1].c == FIELD_RES_C-1)
../navigation/nav.c:1242:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:1244:        bool areach = (chunk->portal_travel_costs[i][a.r][a.c] != FLT_MAX);
../navigation/nav.c:1245:        bool breach = (chunk->portal_travel_costs[i][b.r][b.c] != FLT_MAX);
../navigation/nav.c:1255:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:1256:        const struct portal *curr = &chunk->portals[i];
../navigation/nav.c:1273:        priv->width, priv->height,
../navigation/nav.c:1277:    vec2_t center_xz = (vec2_t){area->center.x, area->center.z};
../navigation/nav.c:1278:    float radius = MAX(area->half_lengths[0], area->half_lengths[2]);
../navigation/nav.c:1289:        vec2_t xz_pos = G_Pos_GetXZ(ents[i]->uid);
../navigation/nav.c:1307:        priv->width, priv->height,
../navigation/nav.c:1315:    const struct nav_chunk *src_chunk = &priv->chunks[layer]
../navigation/nav.c:1316:                                                     [src_desc.chunk_r * priv->width + src_desc.chunk_c];
../navigation/nav.c:1317:    const uint16_t src_iid = src_chunk->islands[src_desc.tile_r][src_desc.tile_c];
../navigation/nav.c:1331:            map_pos.x - (td.chunk_c * FIELD_RES_C + td.tile_c) * tile_dims.x,
../navigation/nav.c:1357:        priv->width, priv->height,
../navigation/nav.c:1362:    size_t ntiles_ent = M_Tile_AllUnderCircle(n_res(priv), G_Pos_GetXZ(ent->uid), G_GetSelectionRadius(ent->uid), 
../navigation/nav.c:1374:        if(abs(brow - arow) <= 1 && abs(bcol - acol) <= 1)
../navigation/nav.c:1382:    for(int chunk_r = 0; chunk_r < priv->height; chunk_r++){
../navigation/nav.c:1383:    for(int chunk_c = 0; chunk_c < priv->width; chunk_c++){
../navigation/nav.c:1385:        struct nav_chunk *curr_chunk = &priv->chunks[layer]
../navigation/nav.c:1386:                                                    [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:1387:        curr_chunk->num_portals = 0;
../navigation/nav.c:1392:    for(int chunk_r = 0; chunk_r < priv->height; chunk_r++){
../navigation/nav.c:1393:    for(int chunk_c = 0; chunk_c < priv->width; chunk_c++){
../navigation/nav.c:1395:        struct nav_chunk *curr_chunk = &priv->chunks[layer]
../navigation/nav.c:1396:                                                    [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:1414:    for(int chunk_r = 0; chunk_r < priv->height; chunk_r++) {
../navigation/nav.c:1415:    for(int chunk_c = 0; chunk_c < priv->width;  chunk_c++) {
../navigation/nav.c:1418:        struct nav_chunk *curr_chunk = &priv->chunks[layer]
../navigation/nav.c:1419:                                                    [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:1420:        memset(curr_chunk->islands, 0xff, sizeof(curr_chunk->islands));
../navigation/nav.c:1423:    for(int chunk_r = 0; chunk_r < priv->height; chunk_r++) {
../navigation/nav.c:1424:    for(int chunk_c = 0; chunk_c < priv->width;  chunk_c++) {
../navigation/nav.c:1426:        struct nav_chunk *curr_chunk = &priv->chunks[layer]
../navigation/nav.c:1427:                                                    [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:1432:            if(curr_chunk->islands[tile_r][tile_c] != ISLAND_NONE)
../navigation/nav.c:1435:            if(curr_chunk->cost_base[tile_r][tile_c] == COST_IMPASSABLE)
../navigation/nav.c:1466:    float screen_y = adj_vres.y - ((ndc.y + 1.0f) * adj_vres.y/2.0f);
../navigation/nav.c:1469:    struct rect bounds = (struct rect){screen_x - len/2.0f, screen_y, len, 25};
../navigation/nav.c:1480:        priv->width, priv->height,
../navigation/nav.c:1500:    const struct nav_chunk *src_chunk = &priv->chunks[layer]
../navigation/nav.c:1501:                                                     [src_desc.chunk_r * priv->width + src_desc.chunk_c];
../navigation/nav.c:1502:    const struct nav_chunk *dst_chunk = &priv->chunks[layer]
../navigation/nav.c:1503:                                                     [dst_desc.chunk_r * priv->width + dst_desc.chunk_c];
../navigation/nav.c:1505:    uint16_t src_iid = src_chunk->islands[src_desc.tile_r][src_desc.tile_c];
../navigation/nav.c:1506:    uint16_t dst_iid = dst_chunk->islands[dst_desc.tile_r][dst_desc.tile_c];
../navigation/nav.c:1631:    for(int i = vec_size(&path)-1; i > 0; i--) {
../navigation/nav.c:1638:        if(i == 1 && (vec_AT(&path, i).portal->chunk.r != src_desc.chunk_r 
../navigation/nav.c:1639:                   || vec_AT(&path, i).portal->chunk.c != src_desc.chunk_c)) {
../navigation/nav.c:1643:        struct portal_hop curr_hop = vec_AT(&path, MAX(next_hop_idx - 1, 0));
../navigation/nav.c:1646:        if(curr_hop.portal->connected == next_hop.portal)
../navigation/nav.c:1654:        if(curr_hop.portal->chunk.r == dst_desc.chunk_r 
../navigation/nav.c:1655:        && curr_hop.portal->chunk.c == dst_desc.chunk_c
../navigation/nav.c:1660:        struct coord chunk_coord = curr_hop.portal->chunk;
../navigation/nav.c:1666:                next_hop.portal->connected, 
../navigation/nav.c:1667:                (i < vec_size(&path)-1) ? vec_AT(&path, next_hop_idx + 1).liid : N_ClosestPathableLocalIsland(priv, dst_chunk, dst_desc),
../navigation/nav.c:1716:            assert((abs(prev_los_coord.r - chunk_coord.r) + abs(prev_los_coord.c - chunk_coord.c)) == 1);
../navigation/nav.c:1721:            assert(prev_los->chunk.r == prev_los_coord.r && prev_los->chunk.c == prev_los_coord.c);
../navigation/nav.c:1780:            N_FC_InvalidateNeighbourEnemySeekFields(priv->width, priv->height, curr, layer);
../navigation/nav.c:1782:            struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:1783:                                                   [IDX(curr.r, priv->width, curr.c)];
../navigation/nav.c:1828:    memset(ret->chunks, 0, sizeof(ret->chunks));
../navigation/nav.c:1830:        ret->chunks[i] = malloc(w * h * sizeof(struct nav_chunk));
../navigation/nav.c:1831:        if(!ret->chunks[i])
../navigation/nav.c:1835:    ret->width = w;
../navigation/nav.c:1836:    ret->height = h;
../navigation/nav.c:1844:        for(int chunk_r = 0; chunk_r < ret->height; chunk_r++){
../navigation/nav.c:1845:        for(int chunk_c = 0; chunk_c < ret->width;  chunk_c++){
../navigation/nav.c:1847:            struct nav_chunk *curr_chunk = &ret->chunks[layer]
../navigation/nav.c:1848:                                                       [IDX(chunk_r, ret->width, chunk_c)];
../navigation/nav.c:1850:            const struct tile *curr_tiles = chunk_tiles[IDX(chunk_r, ret->width, chunk_c)];
../navigation/nav.c:1851:            curr_chunk->num_portals = 0;
../navigation/nav.c:1863:            memset(curr_chunk->blockers, 0, sizeof(curr_chunk->blockers));
../navigation/nav.c:1864:            memset(curr_chunk->factions, 0, sizeof(curr_chunk->factions));
../navigation/nav.c:1886:        free(priv->chunks[i]);
../navigation/nav.c:1899:    assert(chunk_r < priv->height);
../navigation/nav.c:1900:    assert(chunk_c < priv->width);
../navigation/nav.c:1905:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:1906:                                                 [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:1918:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:1919:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:1923:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:1924:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:1926:        *colors_base++ = chunk->cost_base[r][c] == COST_IMPASSABLE ? (vec3_t){1.0f, 0.0f, 0.0f}
../navigation/nav.c:1955:    assert(chunk_r < priv->height);
../navigation/nav.c:1956:    assert(chunk_c < priv->width);
../navigation/nav.c:1973:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:1974:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:1977:            square_x - square_x_len / 2.0f,
../navigation/nav.c:1980:        dirs_buff[r * FIELD_RES_C + c] = g_flow_dir_lookup[ff->field[r][c].dir_idx];
../navigation/nav.c:2004:    assert(chunk_r < priv->height);
../navigation/nav.c:2005:    assert(chunk_c < priv->width);
../navigation/nav.c:2025:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2026:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2030:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:2031:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:2033:        *colors_base++ = lf->field[r][c].visible ? (vec3_t){1.0f, 1.0f, 0.0f}
../navigation/nav.c:2061:    assert(chunk_r < priv->height);
../navigation/nav.c:2062:    assert(chunk_c < priv->width);
../navigation/nav.c:2091:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2092:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2095:            square_x - square_x_len / 2.0f,
../navigation/nav.c:2098:        dirs_buff[r * FIELD_RES_C + c] = g_flow_dir_lookup[ff->field[r][c].dir_idx];
../navigation/nav.c:2102:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:2103:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:2105:        *colors_base++ = ff->field[r][c].dir_idx == FD_NONE ? (vec3_t){1.0f, 0.0f, 0.0f}
../navigation/nav.c:2144:    assert(chunk_r < priv->height);
../navigation/nav.c:2145:    assert(chunk_c < priv->width);
../navigation/nav.c:2165:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2166:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2169:            square_x - square_x_len / 2.0f,
../navigation/nav.c:2172:        dirs_buff[r * FIELD_RES_C + c] = g_flow_dir_lookup[ff->field[r][c].dir_idx];
../navigation/nav.c:2197:    assert(chunk_r < priv->height);
../navigation/nav.c:2198:    assert(chunk_c < priv->width);
../navigation/nav.c:2203:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2204:                                                 [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:2214:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2215:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2219:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:2220:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:2222:        *colors_base++ = chunk->blockers[r][c] ? (vec3_t){1.0f, 0.0f, 0.0f}
../navigation/nav.c:2250:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2251:                                                 [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:2257:        priv->width, priv->height,
../navigation/nav.c:2282:        float square_x = CLAMP(-(((float)tds[i].tile_c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2283:        float square_z = CLAMP( (((float)tds[i].tile_r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2287:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z + square_z_len};
../navigation/nav.c:2288:        *corners_base++ = (vec2_t){square_x - square_x_len, square_z};
../navigation/nav.c:2291:            square_x - square_x_len / 2.0,
../navigation/nav.c:2301:        if(chunk->blockers [tds[i].tile_r][tds[i].tile_c]
../navigation/nav.c:2302:        || chunk->cost_base[tds[i].tile_r][tds[i].tile_c] == COST_IMPASSABLE
../navigation/nav.c:2334:    assert(chunk_r < priv->height);
../navigation/nav.c:2335:    assert(chunk_c < priv->width);
../navigation/nav.c:2341:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2342:                                                 [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:2349:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2350:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2353:            square_x - square_x_len / 2.0,
../navigation/nav.c:2360:        pf_snprintf(text, sizeof(text), "%d", chunk->islands[r][c]);
../navigation/nav.c:2373:    assert(chunk_r < priv->height);
../navigation/nav.c:2374:    assert(chunk_c < priv->width);
../navigation/nav.c:2380:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2381:                                                 [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:2388:        float square_x = CLAMP(-(((float)c) / FIELD_RES_C) * chunk_x_dim, -chunk_x_dim, chunk_x_dim);
../navigation/nav.c:2389:        float square_z = CLAMP( (((float)r) / FIELD_RES_R) * chunk_z_dim, -chunk_z_dim, chunk_z_dim);
../navigation/nav.c:2392:            square_x - square_x_len / 2.0,
../navigation/nav.c:2399:        pf_snprintf(text, sizeof(text), "%d", chunk->local_islands[r][c]);
../navigation/nav.c:2409:    struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2410:                                           [IDX(chunk_r, priv->width, chunk_c)];
../navigation/nav.c:2417:    for(int i = 0; i < chunk->num_portals; i++) {
../navigation/nav.c:2419:        struct portal *port = &chunk->portals[i];
../navigation/nav.c:2421:        for(int j = 0; j < port->num_neighbours; j++) {
../navigation/nav.c:2423:            struct portal *neighb = port->edges[j].neighbour;
../navigation/nav.c:2425:                (port->endpoints[0].r + port->endpoints[1].r) / 2,
../navigation/nav.c:2426:                (port->endpoints[0].c + port->endpoints[1].c) / 2,
../navigation/nav.c:2429:                (neighb->endpoints[0].r + neighb->endpoints[1].r) / 2,
../navigation/nav.c:2430:                (neighb->endpoints[0].c + neighb->endpoints[1].c) / 2,
../navigation/nav.c:2433:            vec3_t link_color = port->edges[j].es == EDGE_STATE_ACTIVE  ? (vec3_t){0.0f, 1.0f, 0.0f} 
../navigation/nav.c:2434:                              : port->edges[j].es == EDGE_STATE_BLOCKED ? (vec3_t){1.0f, 0.0f, 0.0f}
../navigation/nav.c:2438:            bool has_path = AStar_GridPath(a, b, (struct coord){chunk_r, chunk_c}, chunk->cost_base, layer, &path, &cost);
../navigation/nav.c:2453:        priv->width, priv->height,
../navigation/nav.c:2465:            priv->chunks[layer][IDX(tds[i].chunk_r, priv->width, tds[i].chunk_c)]
../navigation/nav.c:2528:        priv->width, priv->height,
../navigation/nav.c:2548:    if(!ff || ff->field[tile.tile_r][tile.tile_c].dir_idx == FD_NONE) {
../navigation/nav.c:2567:    if(ff->field[tile.tile_r][tile.tile_c].dir_idx != FD_NONE)
../navigation/nav.c:2570:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2571:                                                 [IDX(tile.chunk_r, priv->width, tile.chunk_c)];
../navigation/nav.c:2572:    uint16_t local_iid = chunk->local_islands[tile.tile_r][tile.tile_c];
../navigation/nav.c:2607:    dir_idx = ff->field[tile.tile_r][tile.tile_c].dir_idx;
../navigation/nav.c:2616:        priv->width, priv->height,
../navigation/nav.c:2650:    const struct nav_chunk *nchunk = &priv->chunks[layer]
../navigation/nav.c:2651:                                                  [IDX(curr_tile.chunk_r, priv->width, curr_tile.chunk_c)];
../navigation/nav.c:2652:    uint16_t local_iid = nchunk->local_islands[curr_tile.tile_r][curr_tile.tile_c];
../navigation/nav.c:2653:    int dir_idx = pff->field[curr_tile.tile_r][curr_tile.tile_c].dir_idx;
../navigation/nav.c:2676:     * valid enemies - do our best to get as close to the 'action' as possible.
../navigation/nav.c:2678:    dir_idx = pff->field[curr_tile.tile_r][curr_tile.tile_c].dir_idx;
../navigation/nav.c:2690:    dir_idx = pff->field[curr_tile.tile_r][curr_tile.tile_c].dir_idx;
../navigation/nav.c:2699:        priv->width, priv->height,
../navigation/nav.c:2732:    const struct nav_chunk *nchunk = &priv->chunks[layer]
../navigation/nav.c:2733:                                                  [IDX(curr_tile.chunk_r, priv->width, curr_tile.chunk_c)];
../navigation/nav.c:2734:    uint16_t local_iid = nchunk->local_islands[curr_tile.tile_r][curr_tile.tile_c];
../navigation/nav.c:2735:    int dir_idx = pff->field[curr_tile.tile_r][curr_tile.tile_c].dir_idx;
../navigation/nav.c:2755:     * valid enemies - do our best to get as close to the 'action' as possible.
../navigation/nav.c:2757:    dir_idx = pff->field[curr_tile.tile_r][curr_tile.tile_c].dir_idx;
../navigation/nav.c:2769:    dir_idx = pff->field[curr_tile.tile_r][curr_tile.tile_c].dir_idx;
../navigation/nav.c:2776:    vec2_t ent_pos = G_Pos_GetXZ(ent->uid);
../navigation/nav.c:2781:        priv->width, priv->height,
../navigation/nav.c:2804:        priv->width, priv->height,
../navigation/nav.c:2817:    return lf->field[tile.tile_r][tile.tile_c].visible;
../navigation/nav.c:2824:        priv->width, priv->height,
../navigation/nav.c:2832:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2833:                                                 [IDX(tile.chunk_r, priv->width, tile.chunk_c)];
../navigation/nav.c:2834:    return chunk->cost_base[tile.tile_r][tile.tile_c] != COST_IMPASSABLE;
../navigation/nav.c:2841:        priv->width, priv->height,
../navigation/nav.c:2849:    const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:2850:                                                 [IDX(tile.chunk_r, priv->width, tile.chunk_c)];
../navigation/nav.c:2851:    return chunk->blockers[tile.tile_r][tile.tile_c] > 0;
../navigation/nav.c:2858:        priv->width, priv->height,
../navigation/nav.c:2871:    const struct nav_chunk *src_chunk = &priv->chunks[layer][src_desc.chunk_r * priv->width + src_desc.chunk_c];
../navigation/nav.c:2872:    const struct nav_chunk *dst_chunk = &priv->chunks[layer][dst_desc.chunk_r * priv->width + dst_desc.chunk_c];
../navigation/nav.c:2874:    uint16_t src_iid = src_chunk->islands[src_desc.tile_r][src_desc.tile_c];
../navigation/nav.c:2875:    uint16_t dst_iid = dst_chunk->islands[dst_desc.tile_r][dst_desc.tile_c];
../navigation/nav.c:2888:        map_pos.x - (closest_td.chunk_c * FIELD_RES_C + closest_td.tile_c + 0.5f) * tile_dims.x,
../navigation/nav.c:2899:        priv->width, priv->height,
../navigation/nav.c:2935:            { 0, -1},
../navigation/nav.c:2937:            {-1,  0},
../navigation/nav.c:2966:        priv->width, priv->height,
../navigation/nav.c:2978:    const struct nav_chunk *src_chunk = &priv->chunks[layer][src_desc.chunk_r * priv->width + src_desc.chunk_c];
../navigation/nav.c:2979:    const struct nav_chunk *dst_chunk = &priv->chunks[layer][dst_desc.chunk_r * priv->width + dst_desc.chunk_c];
../navigation/nav.c:2981:    uint16_t src_iid = src_chunk->islands[src_desc.tile_r][src_desc.tile_c];
../navigation/nav.c:2982:    uint16_t dst_iid = dst_chunk->islands[dst_desc.tile_r][dst_desc.tile_c];
../navigation/nav.c:2998:        priv->width, priv->height,
../navigation/nav.c:3016:        priv->width, priv->height,
../navigation/nav.c:3043:    n_update_blockers_circle(nav_private, xz_pos, range, faction_id, map_pos, -1);
../navigation/nav.c:3053:    n_update_blockers_obb(nav_private, obb, faction_id, map_pos, -1);
../navigation/nav.c:3063:        priv->width, priv->height,
../navigation/nav.c:3072:    struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:3073:                                           [IDX(dest_td.chunk_r, priv->width, dest_td.chunk_c)];
../navigation/nav.c:3075:    uint16_t giid = chunk->islands[dest_td.tile_r][dest_td.tile_c];
../navigation/nav.c:3083:            map_pos.x - (td->chunk_c * FIELD_RES_C + td->tile_c) * tile_dims.x,
../navigation/nav.c:3084:            map_pos.z + (td->chunk_r * FIELD_RES_R + td->tile_r) * tile_dims.z,
../navigation/nav.c:3102:        priv->width, priv->height,
../navigation/nav.c:3110:    for(int dr = -1; dr <= 1; dr++) {
../navigation/nav.c:3111:    for(int dc = -1; dc <= 1; dc++) {
../navigation/nav.c:3112:        if((dr == dc) || (dr == -dc)) /* diag */
../navigation/nav.c:3126:    for(int r = port->endpoints[0].r; r <= port->endpoints[1].r; r++) {
../navigation/nav.c:3127:    for(int c = port->endpoints[0].c; c <= port->endpoints[1].c; c++) {
../navigation/nav.c:3129:        if(chunk->local_islands[r][c] == ISLAND_NONE)
../navigation/nav.c:3138:        for(int r1 = tile.r - 1; r1 <= tile.r + 1; r1++) {
../navigation/nav.c:3139:        for(int c1 = tile.c - 1; c1 <= tile.c + 1; c1++) {
../navigation/nav.c:3145:            if(chunk->local_islands[r][c] == chunk->local_islands[r1][c1])
../navigation/nav.c:3157:    for(int r = -1; r <= 1; r++) {
../navigation/nav.c:3158:    for(int c = -1; c <= 1; c++) {
../navigation/nav.c:3172:        bool diag = (r == c) || (r == -c);
../navigation/nav.c:3192:        priv->width, priv->height,
../navigation/nav.c:3208:        priv->width, priv->height,
../navigation/nav.c:3222:    out->chunk_w = priv->width;
../navigation/nav.c:3223:    out->chunk_h = priv->height;
../navigation/nav.c:3224:    out->tile_w = FIELD_RES_C;
../navigation/nav.c:3225:    out->tile_h = FIELD_RES_R;
../navigation/nav.c:3235:        priv->width, priv->height,
../navigation/nav.c:3248:        const struct nav_chunk *chunk = &priv->chunks[layer]
../navigation/nav.c:3249:                                                     [IDX(tds[i].chunk_r, priv->width, tds[i].chunk_c)];
../navigation/nav.c:3252:            bounds.x - bounds.width / 2.0f,
../navigation/nav.c:3256:        if(chunk->blockers [tds[i].tile_r][tds[i].tile_c]
../navigation/nav.c:3257:        || chunk->cost_base[tds[i].tile_r][tds[i].tile_c] == COST_IMPASSABLE
../navigation/nav.c:3292:        priv->width, priv->height,
../navigation/nav.c:3303:    const struct nav_chunk *src_chunk = &priv->chunks[layer][src_desc.chunk_r * priv->width + src_desc.chunk_c];
../navigation/nav.c:3304:    uint16_t src_iid = src_chunk->islands[src_desc.tile_r][src_desc.tile_c];
../navigation/nav.c:3319:        const struct nav_chunk *curr_chunk = &priv->chunks[layer][curr->chunk_r * priv->width + curr->chunk_c];
../navigation/nav.c:3320:        uint16_t curr_iid = curr_chunk->islands[curr->tile_r][curr->tile_c];
../navigation/nav.c:3326:            map_pos.x - (curr->chunk_c * FIELD_RES_C + curr->tile_c) * tile_dims.x,
../navigation/nav.c:3327:            map_pos.z + (curr->chunk_r * FIELD_RES_R + curr->tile_r) * tile_dims.z,
../navigation/nav.c:3350:    if(chunk->local_islands[target.tile_r][target.tile_c] != ISLAND_NONE)
../navigation/nav.c:3351:        return chunk->local_islands[target.tile_r][target.tile_c];
../navigation/nav.c:3354:        priv->width, priv->height,
../navigation/nav.c:3373:            { 0, -1},
../navigation/nav.c:3375:            {-1,  0},
../navigation/nav.c:3391:            uint16_t curr = chunk->local_islands[neighb.tile_r][neighb.tile_c];
../navigation/nav_data.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/nav_data.h:76:    struct edge       edges[MAX_PORTALS_PER_CHUNK-1];
../navigation/nav_data.h:83:    /* The per-tile cost of traversal. Tiles with 'COST_IMPASSABLE'
../navigation/nav_data.h:111:    /* This field uses chunk-local island IDs and accounts for
../navigation/nav_private.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/public/nav.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../navigation/public/nav.h:69:/* Pathfinding happens on a per-layer basis. Each layer has 
../navigation/public/nav.h:89:/* ------------------------------------------------------------------------
../navigation/public/nav.h:91: * ------------------------------------------------------------------------
../navigation/public/nav.h:95:/* ------------------------------------------------------------------------
../navigation/public/nav.h:97: * ------------------------------------------------------------------------
../navigation/public/nav.h:101:/* ------------------------------------------------------------------------
../navigation/public/nav.h:103: * ------------------------------------------------------------------------
../navigation/public/nav.h:107:/* ------------------------------------------------------------------------
../navigation/public/nav.h:109: * ------------------------------------------------------------------------
../navigation/public/nav.h:113:/* ------------------------------------------------------------------------
../navigation/public/nav.h:117: * row-major order.
../navigation/public/nav.h:118: * ------------------------------------------------------------------------
../navigation/public/nav.h:123:/* ------------------------------------------------------------------------
../navigation/public/nav.h:125: * ------------------------------------------------------------------------
../navigation/public/nav.h:129:/* ------------------------------------------------------------------------
../navigation/public/nav.h:131: * non-pathable regions. 'chunk_x_dim' and 'chunk_z_dim' are the chunk
../navigation/public/nav.h:133: * ------------------------------------------------------------------------
../navigation/public/nav.h:139:/* ------------------------------------------------------------------------
../navigation/public/nav.h:143: * ------------------------------------------------------------------------
../navigation/public/nav.h:149:/* ------------------------------------------------------------------------
../navigation/public/nav.h:153: * ------------------------------------------------------------------------
../navigation/public/nav.h:158:/* ------------------------------------------------------------------------
../navigation/public/nav.h:161: * ------------------------------------------------------------------------
../navigation/public/nav.h:167:/* ------------------------------------------------------------------------
../navigation/public/nav.h:169: * ------------------------------------------------------------------------
../navigation/public/nav.h:175:/* ------------------------------------------------------------------------
../navigation/public/nav.h:178: * ------------------------------------------------------------------------
../navigation/public/nav.h:184:/* ------------------------------------------------------------------------
../navigation/public/nav.h:188: * ------------------------------------------------------------------------
../navigation/public/nav.h:194:/* ------------------------------------------------------------------------
../navigation/public/nav.h:197: * ------------------------------------------------------------------------
../navigation/public/nav.h:203:/* ------------------------------------------------------------------------
../navigation/public/nav.h:205: * ------------------------------------------------------------------------
../navigation/public/nav.h:211:/* ------------------------------------------------------------------------
../navigation/public/nav.h:213: * ------------------------------------------------------------------------
../navigation/public/nav.h:219:/* ------------------------------------------------------------------------
../navigation/public/nav.h:222: * ------------------------------------------------------------------------
../navigation/public/nav.h:227:/* ------------------------------------------------------------------------
../navigation/public/nav.h:231: * ------------------------------------------------------------------------
../navigation/public/nav.h:235:/* ------------------------------------------------------------------------
../navigation/public/nav.h:238: * ------------------------------------------------------------------------
../navigation/public/nav.h:242:/* ------------------------------------------------------------------------
../navigation/public/nav.h:245: * ------------------------------------------------------------------------
../navigation/public/nav.h:250:/* ------------------------------------------------------------------------
../navigation/public/nav.h:254: * ------------------------------------------------------------------------
../navigation/public/nav.h:259:/* ------------------------------------------------------------------------
../navigation/public/nav.h:261: * ------------------------------------------------------------------------
../navigation/public/nav.h:265:/* ------------------------------------------------------------------------
../navigation/public/nav.h:270: * ------------------------------------------------------------------------
../navigation/public/nav.h:276:/* ------------------------------------------------------------------------
../navigation/public/nav.h:280: * ------------------------------------------------------------------------
../navigation/public/nav.h:287:/* ------------------------------------------------------------------------
../navigation/public/nav.h:290: * ------------------------------------------------------------------------
../navigation/public/nav.h:295:/* ------------------------------------------------------------------------
../navigation/public/nav.h:298: * ------------------------------------------------------------------------
../navigation/public/nav.h:304:/* ------------------------------------------------------------------------
../navigation/public/nav.h:307: * outside a chunk-sized box centered at the enemy position. This is for
../navigation/public/nav.h:308: * fine-tuned movement when we are already close to the target.
../navigation/public/nav.h:309: * ------------------------------------------------------------------------
../navigation/public/nav.h:314:/* ------------------------------------------------------------------------
../navigation/public/nav.h:317: * ------------------------------------------------------------------------
../navigation/public/nav.h:323:/* ------------------------------------------------------------------------
../navigation/public/nav.h:326: * ------------------------------------------------------------------------
../navigation/public/nav.h:331:/* ------------------------------------------------------------------------
../navigation/public/nav.h:333: * ------------------------------------------------------------------------
../navigation/public/nav.h:338:/* ------------------------------------------------------------------------
../navigation/public/nav.h:340: * ------------------------------------------------------------------------
../navigation/public/nav.h:345:/* ------------------------------------------------------------------------
../navigation/public/nav.h:348: * ------------------------------------------------------------------------
../navigation/public/nav.h:352:/* ------------------------------------------------------------------------
../navigation/public/nav.h:356: * ------------------------------------------------------------------------
../navigation/public/nav.h:361:/* ------------------------------------------------------------------------
../navigation/public/nav.h:364: * ------------------------------------------------------------------------
../navigation/public/nav.h:374:/* ------------------------------------------------------------------------
../navigation/public/nav.h:377: * ------------------------------------------------------------------------
../navigation/public/nav.h:382:/* ------------------------------------------------------------------------
../navigation/public/nav.h:384: * ------------------------------------------------------------------------
../navigation/public/nav.h:389:/* ------------------------------------------------------------------------
../navigation/public/nav.h:394: * ------------------------------------------------------------------------
../navigation/public/nav.h:406:/* ------------------------------------------------------------------------
../navigation/public/nav.h:408: * range of the closest non-blocked tile that is reachable from the
../navigation/public/nav.h:410: * ------------------------------------------------------------------------
../navigation/public/nav.h:416:/* ------------------------------------------------------------------------
../navigation/public/nav.h:419: * ------------------------------------------------------------------------
../navigation/public/nav.h:424:/* ------------------------------------------------------------------------
../navigation/public/nav.h:427: * ------------------------------------------------------------------------
../navigation/public/nav.h:432:/* ------------------------------------------------------------------------
../navigation/public/nav.h:435: * ------------------------------------------------------------------------
../navigation/public/nav.h:441:/* ------------------------------------------------------------------------
../navigation/public/nav.h:443: * ------------------------------------------------------------------------
../navigation/public/nav.h:447:/* ------------------------------------------------------------------------
../navigation/public/nav.h:451: * ------------------------------------------------------------------------
../navigation/public/nav.h:456:/* ------------------------------------------------------------------------
../navigation/public/nav.h:460: * ------------------------------------------------------------------------
../navigation/public/nav.h:470:/* ------------------------------------------------------------------------
../navigation/public/nav.h:472: * ------------------------------------------------------------------------
../navigation/public/nav.h:476:/* ------------------------------------------------------------------------
../navigation/public/nav.h:477: * Get up-to-date performance counters for the field/path caches.
../navigation/public/nav.h:478: * ------------------------------------------------------------------------
../navigation/public/nav.h:482:/* ------------------------------------------------------------------------
../navigation/public/nav.h:484: * ------------------------------------------------------------------------
../perf.c:81:    /* Keep a mapping of function_name: unique_ID and a reverse-mapping. 
../perf.c:91:     * As such, the function calls are added in depth-first fashion.
../perf.c:131:    khiter_t k = kh_get(name_id, ps->name_id_table, name);
../perf.c:132:    if(k != kh_end(ps->name_id_table))
../perf.c:133:        return kh_val(ps->name_id_table, k);
../perf.c:136:    uint32_t new_id = ps->next_id++;
../perf.c:140:    kh_put(id_name, ps->id_name_table, new_id, &status);
../perf.c:141:    assert(status != -1);
../perf.c:142:    k = kh_get(id_name, ps->id_name_table, new_id);
../perf.c:143:    kh_val(ps->id_name_table, k) = copy;
../perf.c:145:    kh_put(name_id, ps->name_id_table, copy, &status);
../perf.c:146:    assert(status != -1);
../perf.c:147:    k = kh_get(name_id, ps->name_id_table, copy);
../perf.c:148:    kh_val(ps->name_id_table, k) = new_id;
../perf.c:155:    khiter_t k = kh_get(id_name, ps->id_name_table, id);
../perf.c:156:    if(k != kh_end(ps->id_name_table))
../perf.c:157:        return kh_val(ps->id_name_table, k);
../perf.c:163:    out->next_id = 0;
../perf.c:164:    out->name_id_table = kh_init(name_id);
../perf.c:165:    if(!out->name_id_table)
../perf.c:167:    out->id_name_table = kh_init(id_name);
../perf.c:168:    if(!out->id_name_table)
../perf.c:170:    vec_idx_init(&out->perf_stack);
../perf.c:171:    if(!vec_idx_resize(&out->perf_stack, 4096))
../perf.c:176:        vec_perf_init(&out->perf_trees[i]);
../perf.c:177:        if(!vec_perf_resize(&out->perf_trees[i], 32768))
../perf.c:181:    pf_strlcpy(out->name, name, sizeof(out->name));
../perf.c:182:    out->perf_tree_idx = 0;
../perf.c:188:        if(!out->perf_trees[i].array)
../perf.c:190:        vec_perf_destroy(&out->perf_trees[i]);
../perf.c:192:    vec_idx_destroy(&out->perf_stack);
../perf.c:194:    kh_destroy(id_name, out->id_name_table);
../perf.c:196:    kh_destroy(name_id, out->name_id_table);
../perf.c:204:        vec_perf_destroy(&in->perf_trees[i]);
../perf.c:206:    vec_idx_destroy(&in->perf_stack);
../perf.c:212:    kh_foreach(in->id_name_table, key, curr, {
../perf.c:216:    kh_destroy(id_name, in->id_name_table);
../perf.c:217:    kh_destroy(name_id, in->name_id_table);
../perf.c:227:    assert(status != -1 && status != 0);
../perf.c:273:    if(status == -1)
../perf.c:291:    const size_t ssize = vec_size(&ps->perf_stack);
../perf.c:292:    uint32_t parent_idx = ssize > 0 ? vec_AT(&ps->perf_stack, ssize-1) : PARENT_NONE;
../perf.c:294:    vec_perf_push(&ps->perf_trees[ps->perf_tree_idx], (struct perf_entry){
../perf.c:300:    uint32_t new_idx = vec_size(&ps->perf_trees[ps->perf_tree_idx])-1;
../perf.c:301:    vec_idx_push(&ps->perf_stack, new_idx);
../perf.c:312:    assert(vec_size(&ps->perf_stack) > 0);
../perf.c:314:    uint32_t idx = vec_idx_pop(&ps->perf_stack);
../perf.c:315:    assert(idx < vec_size(&ps->perf_trees[ps->perf_tree_idx]));
../perf.c:316:    struct perf_entry *pe = &vec_AT(&ps->perf_trees[ps->perf_tree_idx], idx);
../perf.c:317:    pe->pc_delta = abs(SDL_GetPerformanceCounter() - pe->pc_delta);
../perf.c:326:    const size_t ssize = vec_size(&ps->perf_stack);
../perf.c:327:    uint32_t parent_idx = ssize > 0 ? vec_AT(&ps->perf_stack, ssize-1) : PARENT_NONE;
../perf.c:329:    vec_perf_push(&ps->perf_trees[ps->perf_tree_idx], (struct perf_entry){
../perf.c:335:    uint32_t new_idx = vec_size(&ps->perf_trees[ps->perf_tree_idx])-1;
../perf.c:336:    vec_idx_push(&ps->perf_stack, new_idx);
../perf.c:345:    assert(vec_size(&ps->perf_stack) > 0);
../perf.c:347:    uint32_t idx = vec_idx_pop(&ps->perf_stack);
../perf.c:348:    assert(idx < vec_size(&ps->perf_trees[ps->perf_tree_idx]));
../perf.c:349:    struct perf_entry *pe = &vec_AT(&ps->perf_trees[ps->perf_tree_idx], idx);
../perf.c:350:    pe->end.gpu_cookie = cookie;
../perf.c:364:    int write_idx = (gpu_ps->perf_tree_idx + 3) % NFRAMES_LOGGED;
../perf.c:366:    for(int i = 0; i < vec_size(&gpu_ps->perf_trees[write_idx]); i++) {
../perf.c:368:        struct perf_entry *pe = &vec_AT(&gpu_ps->perf_trees[write_idx], i);
../perf.c:374:                &pe->begin.gpu_cookie,
../perf.c:375:                &pe->begin.gpu_ts,
../perf.c:382:                &pe->end.gpu_cookie,
../perf.c:383:                &pe->end.gpu_ts,
../perf.c:399:        assert(vec_size(&curr->perf_stack) == 0);
../perf.c:401:        curr->perf_tree_idx = (curr->perf_tree_idx + 1) % NFRAMES_LOGGED;
../perf.c:402:        vec_perf_reset(&curr->perf_trees[curr->perf_tree_idx]);
../perf.c:407:    s_last_frames_ms[s_last_idx] = curr_time - last_ts;
../perf.c:424:        int read_idx = (ps->perf_tree_idx + 1) % NFRAMES_LOGGED;
../perf.c:425:        struct perf_info *info = malloc(sizeof(struct perf_info) + vec_size(&ps->perf_trees[read_idx]) * sizeof(info->entries[0]));
../perf.c:429:        pf_strlcpy(info->threadname, ps->name, sizeof(info->threadname));
../perf.c:430:        info->nentries = vec_size(&ps->perf_trees[read_idx]);
../perf.c:432:        for(int i = 0; i < vec_size(&ps->perf_trees[read_idx]); i++) {
../perf.c:434:            const struct perf_entry *entry = &vec_AT(&ps->perf_trees[read_idx], i);
../perf.c:438:                uint64_t delta = abs(entry->end.gpu_ts - entry->begin.gpu_ts);
../perf.c:439:                info->entries[i].pc_delta = delta;
../perf.c:440:                info->entries[i].ms_delta = (delta * 1000.0 / hz);
../perf.c:443:                info->entries[i].pc_delta = entry->pc_delta;
../perf.c:444:                info->entries[i].ms_delta = (entry->pc_delta * 1000.0 / hz);
../perf.c:447:            info->entries[i].funcname = name_for_id(ps, entry->name_id);
../perf.c:448:            info->entries[i].parent_idx = entry->parent_idx;
../perf.c:466:    return curr_time - last_ts;
../perf.h:106: * cause a CPU<->GPU synch, which would negatively impact performance.
../pf_math.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../pf_math.c:46:    return op1->x * op2->x + 
../pf_math.c:47:           op1->y * op2->y;
../pf_math.c:52:    out->x = op1->x + op2->x; 
../pf_math.c:53:    out->y = op1->y + op2->y;
../pf_math.c:58:    out->x = op1->x - op2->x;
../pf_math.c:59:    out->y = op1->y - op2->y;
../pf_math.c:64:    out->x = op1->x * scale;
../pf_math.c:65:    out->y = op1->y * scale;
../pf_math.c:70:    return sqrt(op1->x * op1->x + 
../pf_math.c:71:                op1->y * op1->y);
../pf_math.c:78:    out->x = op1->x / len;
../pf_math.c:79:    out->y = op1->y / len;
../pf_math.c:84:    fprintf(dumpfile, "(%.4f, %.4f)\n", vec->x, vec->y);
../pf_math.c:89:    out->x =   a->y * b->z - a->z * b->y;
../pf_math.c:90:    out->y = -(a->x * b->z - a->z * b->x);
../pf_math.c:91:    out->z =   a->x * b->y - a->y * b->x;
../pf_math.c:96:    return op1->x * op2->x +
../pf_math.c:97:           op1->y * op2->y +
../pf_math.c:98:           op1->z * op2->z;
../pf_math.c:104:        out->raw[i] = op1->raw[i] + op2->raw[i];
../pf_math.c:110:        out->raw[i] = op1->raw[i] - op2->raw[i];
../pf_math.c:116:        out->raw[i] = op1->raw[i] * scale;
../pf_math.c:121:    return sqrt(op1->x * op1->x + 
../pf_math.c:122:                op1->y * op1->y +
../pf_math.c:123:                op1->z * op1->z);
../pf_math.c:131:        out->raw[i] = op1->raw[i] / len;
../pf_math.c:136:    fprintf(dumpfile, "(%.4f, %.4f, %.4f)\n", vec->x, vec->y, vec->z);
../pf_math.c:141:    return op1->x * op2->x +
../pf_math.c:142:           op1->y * op2->y +
../pf_math.c:143:           op1->z * op2->z +
../pf_math.c:144:           op1->w * op2->w;
../pf_math.c:150:        out->raw[i] = op1->raw[i] + op2->raw[i];
../pf_math.c:156:        out->raw[i] = op1->raw[i] - op2->raw[i];
../pf_math.c:162:        out->raw[i] = op1->raw[i] * scale;
../pf_math.c:167:    return sqrt(op1->x * op1->x + 
../pf_math.c:168:                op1->y * op1->y +
../pf_math.c:169:                op1->z * op1->z +
../pf_math.c:170:                op1->w * op1->w);
../pf_math.c:178:        out->raw[i] = op1->raw[i] / len;
../pf_math.c:183:    fprintf(dumpfile, "(%.4f, %.4f, %.4f, %.4f)\n", vec->x, vec->y, vec->z, vec->w);
../pf_math.c:189:        out->raw[i] = op1->raw[i] * scale;
../pf_math.c:197:            out->cols[c][r] = 0.0f;
../pf_math.c:199:                out->cols[c][r] += op1->cols[k][r] * op2->cols[c][k]; 
../pf_math.c:207:        out->raw[r] = 0.0f;
../pf_math.c:209:            out->raw[r] += op1->cols[c][r] * op2->raw[c];
../pf_math.c:218:        out->cols[i][i] = 1;
../pf_math.c:224:        out->raw[i] = op1->raw[i] * scale;
../pf_math.c:232:            out->cols[c][r] = 0.0f;
../pf_math.c:234:                out->cols[c][r] += op1->cols[k][r] * op2->cols[c][k]; 
../pf_math.c:242:        out->raw[r] = 0.0f;
../pf_math.c:244:            out->raw[r] += op1->cols[c][r] * op2->raw[c];
../pf_math.c:253:        out->cols[i][i] = 1;
../pf_math.c:260:    out->cols[0][0] = s1;
../pf_math.c:261:    out->cols[1][1] = s2;
../pf_math.c:262:    out->cols[2][2] = s3;
../pf_math.c:269:    out->cols[3][0] = tx;
../pf_math.c:270:    out->cols[3][1] = ty;
../pf_math.c:271:    out->cols[3][2] = tz;
../pf_math.c:278:    out->cols[1][1] =  cos(radians);
../pf_math.c:279:    out->cols[1][2] =  sin(radians);
../pf_math.c:281:    out->cols[2][1] = -sin(radians);
../pf_math.c:282:    out->cols[2][2] =  cos(radians);
../pf_math.c:289:    out->cols[0][0] =  cos(radians);
../pf_math.c:290:    out->cols[0][2] = -sin(radians);
../pf_math.c:292:    out->cols[2][0] =  sin(radians);
../pf_math.c:293:    out->cols[2][2] =  cos(radians);
../pf_math.c:300:    out->cols[0][0] =  cos(radians);
../pf_math.c:301:    out->cols[0][1] =  sin(radians);
../pf_math.c:303:    out->cols[1][0] = -sin(radians);
../pf_math.c:304:    out->cols[1][1] =  cos(radians);
../pf_math.c:314:    out->cols[0][0]  = 1 - 2*pow(quat->y, 2) - 2*pow(quat->z, 2);
../pf_math.c:315:    out->cols[1][0] = 2*quat->x*quat->y + 2*quat->w*quat->z;
../pf_math.c:316:    out->cols[2][0] = 2*quat->x*quat->z - 2*quat->w*quat->y;
../pf_math.c:318:    out->cols[0][1] = 2*quat->x*quat->y - 2*quat->w*quat->z;
../pf_math.c:319:    out->cols[1][1] = 1 - 2*pow(quat->x, 2) - 2*pow(quat->z, 2);
../pf_math.c:320:    out->cols[2][1] = 2*quat->y*quat->z + 2*quat->w*quat->x;
../pf_math.c:322:    out->cols[0][2] = 2*quat->x*quat->z + 2*quat->w*quat->y;
../pf_math.c:323:    out->cols[1][2] = 2*quat->y*quat->z - 2*quat->w*quat->x;
../pf_math.c:324:    out->cols[2][2] = 1 - 2*pow(quat->x, 2) - 2*pow(quat->y, 2);
../pf_math.c:339:/* - fov_radians is the vertical FOV angle
../pf_math.c:340: * - This is OpenGL specific, where the positive Z-axis is pointing out of 
../pf_math.c:342: * - Vectors multiplied by this matrix will already be in NDC
../pf_math.c:348:    /* This assumes symmetry (left = -right, top = -bottom) */ 
../pf_math.c:352:    memset(out->raw, 0, sizeof(out->raw));
../pf_math.c:353:    out->cols[0][0] = z_near / r;
../pf_math.c:354:    out->cols[1][1] = z_near / t;
../pf_math.c:355:    out->cols[2][2] = -(z_far + z_near) / (z_far - z_near);
../pf_math.c:356:    out->cols[2][3] = -1.0f;
../pf_math.c:357:    out->cols[3][2] = -(2.0f * z_far * z_near) / (z_far - z_near);
../pf_math.c:365:    out->cols[0][0] = 2.0f/(right - left);
../pf_math.c:366:    out->cols[1][1] = 2.0f/(top - bot);
../pf_math.c:367:    out->cols[2][2] = -2.0f/(far - near);
../pf_math.c:368:    out->cols[3][0] = -(right + left)/(right - left);
../pf_math.c:369:    out->cols[3][1] = -(top + bot)/(top - bot);
../pf_math.c:370:    out->cols[3][2] = -(far + near)/(far - near);
../pf_math.c:388:    axes.cols[0][1] = up->x;
../pf_math.c:389:    axes.cols[1][1] = up->y;
../pf_math.c:390:    axes.cols[2][1] = up->z;
../pf_math.c:396:    PFM_Mat4x4_MakeTrans(-camera_pos->x, -camera_pos->y, -camera_pos->z, &trans);
../pf_math.c:407:        in->raw[5]  * in->raw[10] * in->raw[15] - 
../pf_math.c:408:        in->raw[5]  * in->raw[11] * in->raw[14] - 
../pf_math.c:409:        in->raw[9]  * in->raw[6]  * in->raw[15] + 
../pf_math.c:410:        in->raw[9]  * in->raw[7]  * in->raw[14] +
../pf_math.c:411:        in->raw[13] * in->raw[6]  * in->raw[11] - 
../pf_math.c:412:        in->raw[13] * in->raw[7]  * in->raw[10];
../pf_math.c:415:       -in->raw[4]  * in->raw[10] * in->raw[15] + 
../pf_math.c:416:        in->raw[4]  * in->raw[11] * in->raw[14] + 
../pf_math.c:417:        in->raw[8]  * in->raw[6]  * in->raw[15] - 
../pf_math.c:418:        in->raw[8]  * in->raw[7]  * in->raw[14] - 
../pf_math.c:419:        in->raw[12] * in->raw[6]  * in->raw[11] + 
../pf_math.c:420:        in->raw[12] * in->raw[7]  * in->raw[10];
../pf_math.c:423:        in->raw[4]  * in->raw[9] * in->raw[15] - 
../pf_math.c:424:        in->raw[4]  * in->raw[11] * in->raw[13] - 
../pf_math.c:425:        in->raw[8]  * in->raw[5] * in->raw[15] + 
../pf_math.c:426:        in->raw[8]  * in->raw[7] * in->raw[13] + 
../pf_math.c:427:        in->raw[12] * in->raw[5] * in->raw[11] - 
../pf_math.c:428:        in->raw[12] * in->raw[7] * in->raw[9];
../pf_math.c:431:       -in->raw[4]  * in->raw[9] * in->raw[14] + 
../pf_math.c:432:        in->raw[4]  * in->raw[10] * in->raw[13] +
../pf_math.c:433:        in->raw[8]  * in->raw[5] * in->raw[14] - 
../pf_math.c:434:        in->raw[8]  * in->raw[6] * in->raw[13] - 
../pf_math.c:435:        in->raw[12] * in->raw[5] * in->raw[10] + 
../pf_math.c:436:        in->raw[12] * in->raw[6] * in->raw[9];
../pf_math.c:439:       -in->raw[1]  * in->raw[10] * in->raw[15] + 
../pf_math.c:440:        in->raw[1]  * in->raw[11] * in->raw[14] + 
../pf_math.c:441:        in->raw[9]  * in->raw[2] * in->raw[15] - 
../pf_math.c:442:        in->raw[9]  * in->raw[3] * in->raw[14] - 
../pf_math.c:443:        in->raw[13] * in->raw[2] * in->raw[11] + 
../pf_math.c:444:        in->raw[13] * in->raw[3] * in->raw[10];
../pf_math.c:447:        in->raw[0]  * in->raw[10] * in->raw[15] - 
../pf_math.c:448:        in->raw[0]  * in->raw[11] * in->raw[14] - 
../pf_math.c:449:        in->raw[8]  * in->raw[2] * in->raw[15] + 
../pf_math.c:450:        in->raw[8]  * in->raw[3] * in->raw[14] + 
../pf_math.c:451:        in->raw[12] * in->raw[2] * in->raw[11] - 
../pf_math.c:452:        in->raw[12] * in->raw[3] * in->raw[10];
../pf_math.c:455:       -in->raw[0]  * in->raw[9] * in->raw[15] + 
../pf_math.c:456:        in->raw[0]  * in->raw[11] * in->raw[13] + 
../pf_math.c:457:        in->raw[8]  * in->raw[1] * in->raw[15] - 
../pf_math.c:458:        in->raw[8]  * in->raw[3] * in->raw[13] - 
../pf_math.c:459:        in->raw[12] * in->raw[1] * in->raw[11] + 
../pf_math.c:460:        in->raw[12] * in->raw[3] * in->raw[9];
../pf_math.c:463:        in->raw[0]  * in->raw[9] * in->raw[14] - 
../pf_math.c:464:        in->raw[0]  * in->raw[10] * in->raw[13] - 
../pf_math.c:465:        in->raw[8]  * in->raw[1] * in->raw[14] + 
../pf_math.c:466:        in->raw[8]  * in->raw[2] * in->raw[13] + 
../pf_math.c:467:        in->raw[12] * in->raw[1] * in->raw[10] - 
../pf_math.c:468:        in->raw[12] * in->raw[2] * in->raw[9];
../pf_math.c:471:        in->raw[1]  * in->raw[6] * in->raw[15] - 
../pf_math.c:472:        in->raw[1]  * in->raw[7] * in->raw[14] - 
../pf_math.c:473:        in->raw[5]  * in->raw[2] * in->raw[15] + 
../pf_math.c:474:        in->raw[5]  * in->raw[3] * in->raw[14] + 
../pf_math.c:475:        in->raw[13] * in->raw[2] * in->raw[7] - 
../pf_math.c:476:        in->raw[13] * in->raw[3] * in->raw[6];
../pf_math.c:479:       -in->raw[0]  * in->raw[6] * in->raw[15] + 
../pf_math.c:480:        in->raw[0]  * in->raw[7] * in->raw[14] + 
../pf_math.c:481:        in->raw[4]  * in->raw[2] * in->raw[15] - 
../pf_math.c:482:        in->raw[4]  * in->raw[3] * in->raw[14] - 
../pf_math.c:483:        in->raw[12] * in->raw[2] * in->raw[7] + 
../pf_math.c:484:        in->raw[12] * in->raw[3] * in->raw[6];
../pf_math.c:487:        in->raw[0]  * in->raw[5] * in->raw[15] - 
../pf_math.c:488:        in->raw[0]  * in->raw[7] * in->raw[13] - 
../pf_math.c:489:        in->raw[4]  * in->raw[1] * in->raw[15] + 
../pf_math.c:490:        in->raw[4]  * in->raw[3] * in->raw[13] + 
../pf_math.c:491:        in->raw[12] * in->raw[1] * in->raw[7] - 
../pf_math.c:492:        in->raw[12] * in->raw[3] * in->raw[5];
../pf_math.c:495:       -in->raw[0]  * in->raw[5] * in->raw[14] + 
../pf_math.c:496:        in->raw[0]  * in->raw[6] * in->raw[13] + 
../pf_math.c:497:        in->raw[4]  * in->raw[1] * in->raw[14] - 
../pf_math.c:498:        in->raw[4]  * in->raw[2] * in->raw[13] - 
../pf_math.c:499:        in->raw[12] * in->raw[1] * in->raw[6] + 
../pf_math.c:500:        in->raw[12] * in->raw[2] * in->raw[5];
../pf_math.c:503:       -in->raw[1] * in->raw[6] * in->raw[11] + 
../pf_math.c:504:        in->raw[1] * in->raw[7] * in->raw[10] + 
../pf_math.c:505:        in->raw[5] * in->raw[2] * in->raw[11] - 
../pf_math.c:506:        in->raw[5] * in->raw[3] * in->raw[10] - 
../pf_math.c:507:        in->raw[9] * in->raw[2] * in->raw[7] + 
../pf_math.c:508:        in->raw[9] * in->raw[3] * in->raw[6];
../pf_math.c:511:        in->raw[0] * in->raw[6] * in->raw[11] - 
../pf_math.c:512:        in->raw[0] * in->raw[7] * in->raw[10] - 
../pf_math.c:513:        in->raw[4] * in->raw[2] * in->raw[11] + 
../pf_math.c:514:        in->raw[4] * in->raw[3] * in->raw[10] + 
../pf_math.c:515:        in->raw[8] * in->raw[2] * in->raw[7] - 
../pf_math.c:516:        in->raw[8] * in->raw[3] * in->raw[6];
../pf_math.c:519:       -in->raw[0] * in->raw[5] * in->raw[11] + 
../pf_math.c:520:        in->raw[0] * in->raw[7] * in->raw[9] + 
../pf_math.c:521:        in->raw[4] * in->raw[1] * in->raw[11] - 
../pf_math.c:522:        in->raw[4] * in->raw[3] * in->raw[9] - 
../pf_math.c:523:        in->raw[8] * in->raw[1] * in->raw[7] + 
../pf_math.c:524:        in->raw[8] * in->raw[3] * in->raw[5];
../pf_math.c:527:        in->raw[0] * in->raw[5] * in->raw[10] - 
../pf_math.c:528:        in->raw[0] * in->raw[6] * in->raw[9] - 
../pf_math.c:529:        in->raw[4] * in->raw[1] * in->raw[10] + 
../pf_math.c:530:        in->raw[4] * in->raw[2] * in->raw[9] + 
../pf_math.c:531:        in->raw[8] * in->raw[1] * in->raw[6] - 
../pf_math.c:532:        in->raw[8] * in->raw[2] * in->raw[5];
../pf_math.c:534:    det = in->raw[0] * inv[0] + in->raw[1] * inv[4] + in->raw[2] * inv[8] + in->raw[3] * inv[12];
../pf_math.c:540:        out->raw[i] = inv[i] * det;
../pf_math.c:548:            GLfloat tmp = out->cols[c][r];
../pf_math.c:549:            out->cols[c][r] = in->cols[r][c];
../pf_math.c:550:            in->cols[r][c] = tmp;
../pf_math.c:560:    GLfloat tr = mat->cols[0][0] + mat->cols[1][1] + mat->cols[2][2];
../pf_math.c:565:        out->w = 0.25 * S;
../pf_math.c:566:        out->x = (mat->cols[2][1] - mat->cols[1][2]) / S;
../pf_math.c:567:        out->y = (mat->cols[0][2] - mat->cols[2][0]) / S; 
../pf_math.c:568:        out->z = (mat->cols[1][0] - mat->cols[0][1]) / S; 
../pf_math.c:570:    } else if ((mat->cols[0][0] > mat->cols[1][1]) && (mat->cols[0][0] > mat->cols[2][2])) {
../pf_math.c:572:        GLfloat S = sqrt(1.0 + mat->cols[0][0] - mat->cols[1][1] - mat->cols[2][2]) * 2; // S=4*qx 
../pf_math.c:573:        out->w = (mat->cols[2][1] - mat->cols[1][2]) / S;
../pf_math.c:574:        out->x = 0.25 * S;
../pf_math.c:575:        out->y = (mat->cols[0][1] + mat->cols[1][0]) / S; 
../pf_math.c:576:        out->z = (mat->cols[0][2] + mat->cols[2][0]) / S; 
../pf_math.c:578:    } else if (mat->cols[1][1] > mat->cols[2][2]) {
../pf_math.c:580:        GLfloat S = sqrt(1.0 + mat->cols[1][1] - mat->cols[0][0] - mat->cols[2][2]) * 2; // S=4*qy
../pf_math.c:581:        out->w = (mat->cols[0][2] - mat->cols[2][0]) / S;
../pf_math.c:582:        out->x = (mat->cols[0][1] + mat->cols[1][0]) / S; 
../pf_math.c:583:        out->y = 0.25 * S;
../pf_math.c:584:        out->z = (mat->cols[1][2] + mat->cols[2][1]) / S; 
../pf_math.c:588:        float S = sqrt(1.0 + mat->cols[2][2] - mat->cols[0][0] - mat->cols[1][1]) * 2; // S=4*qz
../pf_math.c:589:        out->w = (mat->cols[1][0] - mat->cols[0][1]) / S;
../pf_math.c:590:        out->x = (mat->cols[0][2] + mat->cols[2][0]) / S;
../pf_math.c:591:        out->y = (mat->cols[1][2] + mat->cols[2][1]) / S;
../pf_math.c:592:        out->z = 0.25 * S;
../pf_math.c:601:    /* roll (x-axis rotation) */
../pf_math.c:603:        float sinr = 2.0f * (q->w * q->x + q->y * q->z);
../pf_math.c:604:        float cosr = 1.0f - 2.0f * (q->x * q->x + q->y * q->y);
../pf_math.c:608:    /* pitch (y-axis rotation) */
../pf_math.c:610:        float sinp = 2.0f * (q->w * q->y - q->z * q->x);
../pf_math.c:612:            *out_pitch = RAD_TO_DEG((sinp >= 0.0f) ? (M_PI / 2) : -(M_PI / 2)); // use 90 degrees if out of range
../pf_math.c:617:    /* yaw (z-axis rotation) */
../pf_math.c:619:        double siny = 2.0f * (q->w * q->z + q->x * q->y);
../pf_math.c:620:        double cosy = 1.0f - 2.0f * (q->y * q->y + q->z * q->z);
../pf_math.c:627:    out->x = ( op1->x * op2->w) + (op1->y * op2->z) - (op1->z * op2->y) + (op1->w * op2->x);
../pf_math.c:628:    out->y = (-op1->x * op2->z) + (op1->y * op2->w) + (op1->z * op2->x) + (op1->w * op2->y);
../pf_math.c:629:    out->z = ( op1->x * op2->y) - (op1->y * op2->x) + (op1->z * op2->w) + (op1->w * op2->z);
../pf_math.c:630:    out->w = (-op1->x * op2->x) - (op1->y * op2->y) - (op1->z * op2->z) + (op1->w * op2->w);
../pf_math.c:636:         op1->x * op1->x 
../pf_math.c:637:       + op1->y * op1->y
../pf_math.c:638:       + op1->z * op1->z 
../pf_math.c:639:       + op1->w * op1->w
../pf_math.c:641:    out->x = op1->x / len;
../pf_math.c:642:    out->y = op1->y / len;
../pf_math.c:643:    out->z = op1->z / len;
../pf_math.c:644:    out->w = op1->w / len;
../pf_math.c:649:    out->x = -op1->x;
../pf_math.c:650:    out->y = -op1->y;
../pf_math.c:651:    out->z = -op1->z;
../pf_math.c:652:    out->w =  op1->w;
../pf_math.c:680:    float det = dir1.x * dir2.z - dir1.z * dir2.x;
../pf_math.c:689:    x2x1 = x2 - x1;
../pf_math.c:690:    y2y1 = y2 - y1;
../pf_math.c:691:    x2x = x2 - x;
../pf_math.c:692:    y2y = y2 - y;
../pf_math.c:693:    yy1 = y - y1;
../pf_math.c:694:    xx1 = x - x1;
../pf_math.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../phys/collision.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../phys/collision.c:65: * https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution
../phys/collision.c:86:    float t = (d - PFM_Vec3_Dot(&n, &ray_origin)) / n_dot_ray_dir;
../phys/collision.c:101:    /* Lastly, perform the inside-outside test. */
../phys/collision.c:139:    PFM_Vec3_Sub(&point, (vec3_t*)&plane->point, &diff);
../phys/collision.c:140:    return PFM_Vec3_Dot(&diff, (vec3_t*)&plane->normal);
../phys/collision.c:173:    float imin = MAX(a->begin, b->begin);
../phys/collision.c:174:    float imax = MIN(a->end, b->end);
../phys/collision.c:184:    return (point >= r->begin && point <= r->end);
../phys/collision.c:194:    const vec3_t *frust_points[8] = {&frustum->ntl, &frustum->ntr, &frustum->nbl, &frustum->nbr,
../phys/collision.c:195:                                     &frustum->ftl, &frustum->ftr, &frustum->fbl, &frustum->fbr};
../phys/collision.c:214: * http://cgvr.informatik.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html
../phys/collision.c:215: * Note that our engine's coordinate system is left-handed.
../phys/collision.c:256:    PFM_Vec3_Sub(&tmp, &right_half_wfar, &out->ftl);
../phys/collision.c:260:    PFM_Vec3_Add(&tmp, &right_half_wfar, &out->ftr);
../phys/collision.c:264:    PFM_Vec3_Sub(&tmp, &right_half_wfar, &out->fbl);
../phys/collision.c:268:    PFM_Vec3_Add(&tmp, &right_half_wfar, &out->fbr);
../phys/collision.c:272:    PFM_Vec3_Sub(&tmp, &right_half_wnear, &out->ntl);
../phys/collision.c:276:    PFM_Vec3_Add(&tmp, &right_half_wnear, &out->ntr);
../phys/collision.c:280:    PFM_Vec3_Sub(&tmp, &right_half_wnear, &out->nbl);
../phys/collision.c:284:    PFM_Vec3_Add(&tmp, &right_half_wnear, &out->nbr);
../phys/collision.c:288:    out->near.point = nc;
../phys/collision.c:289:    out->near.normal = front;
../phys/collision.c:293:    PFM_Vec3_Scale(&front, -1.0f, &negative_dir);
../phys/collision.c:295:    out->far.point = fc;
../phys/collision.c:296:    out->far.normal = negative_dir;
../phys/collision.c:305:    out->right.point = pos;
../phys/collision.c:306:    PFM_Vec3_Cross(&p_to_near_right_edge, &up, &out->right.normal);
../phys/collision.c:315:    out->left.point = pos;
../phys/collision.c:316:    PFM_Vec3_Cross(&up, &p_to_near_left_edge, &out->left.normal);
../phys/collision.c:325:    out->top.point = pos;
../phys/collision.c:326:    PFM_Vec3_Cross(&cam_right, &p_to_near_top_edge, &out->top.normal);
../phys/collision.c:335:    out->bot.point = pos;
../phys/collision.c:336:    PFM_Vec3_Cross(&p_to_near_bot_edge, &cam_right, &out->bot.normal);
../phys/collision.c:341:     float t1 = (aabb.x_min - ray_origin.x) / ray_dir.x;
../phys/collision.c:342:     float t2 = (aabb.x_max - ray_origin.x) / ray_dir.x;
../phys/collision.c:343:     float t3 = (aabb.y_min - ray_origin.y) / ray_dir.y;
../phys/collision.c:344:     float t4 = (aabb.y_max - ray_origin.y) / ray_dir.y;
../phys/collision.c:345:     float t5 = (aabb.z_min - ray_origin.z) / ray_dir.z;
../phys/collision.c:346:     float t6 = (aabb.z_max - ray_origin.z) / ray_dir.z;
../phys/collision.c:380:            /* Ray is parallel to the slabs - check that the ray origin is inside the slab. */
../phys/collision.c:381:            if(fabs(dA - tmin * DA) > obb.half_lengths[i] || fabs(dA - tmax * DA) > obb.half_lengths[i])
../phys/collision.c:387:            GLfloat es = (DA > 0.0) ? obb.half_lengths[i] : -obb.half_lengths[i];
../phys/collision.c:390:            GLfloat t1 = (dA - es) * invDA;
../phys/collision.c:481:    const struct plane *planes[] = {&frustum->top, &frustum->bot, &frustum->left, 
../phys/collision.c:482:                                    &frustum->right, &frustum->near, &frustum->far};
../phys/collision.c:494: * http://cgvr.informatik.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html
../phys/collision.c:498:    const struct plane *planes[] = {&frustum->top, &frustum->bot, &frustum->left, 
../phys/collision.c:499:                                    &frustum->right, &frustum->near, &frustum->far};
../phys/collision.c:502:        (vec3_t){aabb->x_min, aabb->y_min, aabb->z_min},
../phys/collision.c:503:        (vec3_t){aabb->x_min, aabb->y_min, aabb->z_max},
../phys/collision.c:504:        (vec3_t){aabb->x_min, aabb->y_max, aabb->z_min},
../phys/collision.c:505:        (vec3_t){aabb->x_min, aabb->y_max, aabb->z_max},
../phys/collision.c:506:        (vec3_t){aabb->x_max, aabb->y_min, aabb->z_min},
../phys/collision.c:507:        (vec3_t){aabb->x_max, aabb->y_min, aabb->z_max},
../phys/collision.c:508:        (vec3_t){aabb->x_max, aabb->y_max, aabb->z_min},
../phys/collision.c:509:        (vec3_t){aabb->x_max, aabb->y_max, aabb->z_max},
../phys/collision.c:538:    const struct plane *planes[] = {&frustum->top, &frustum->bot, &frustum->left, 
../phys/collision.c:539:                                    &frustum->right, &frustum->near, &frustum->far};
../phys/collision.c:549:            if(plane_point_signed_distance(planes[i], obb->corners[k]) < 0.0f)
../phys/collision.c:574:        (vec3_t){aabb->x_min, aabb->y_min, aabb->z_min},
../phys/collision.c:575:        (vec3_t){aabb->x_min, aabb->y_min, aabb->z_max},
../phys/collision.c:576:        (vec3_t){aabb->x_min, aabb->y_max, aabb->z_min},
../phys/collision.c:577:        (vec3_t){aabb->x_min, aabb->y_max, aabb->z_max},
../phys/collision.c:578:        (vec3_t){aabb->x_max, aabb->y_min, aabb->z_min},
../phys/collision.c:579:        (vec3_t){aabb->x_max, aabb->y_min, aabb->z_max},
../phys/collision.c:580:        (vec3_t){aabb->x_max, aabb->y_max, aabb->z_min},
../phys/collision.c:581:        (vec3_t){aabb->x_max, aabb->y_max, aabb->z_max},
../phys/collision.c:591:        frustum->near.normal,
../phys/collision.c:592:        frustum->far.normal,
../phys/collision.c:593:        frustum->top.normal,
../phys/collision.c:594:        frustum->bot.normal,
../phys/collision.c:595:        frustum->left.normal,
../phys/collision.c:596:        frustum->right.normal
../phys/collision.c:606:    PFM_Vec3_Sub((vec3_t*)&frustum->ntr, (vec3_t*)&frustum->ntl, &frust_edges[0]);
../phys/collision.c:607:    PFM_Vec3_Sub((vec3_t*)&frustum->ntl, (vec3_t*)&frustum->nbl, &frust_edges[1]);
../phys/collision.c:608:    PFM_Vec3_Sub((vec3_t*)&frustum->ftl, (vec3_t*)&frustum->ntl, &frust_edges[2]);
../phys/collision.c:609:    PFM_Vec3_Sub((vec3_t*)&frustum->ftr, (vec3_t*)&frustum->ntr, &frust_edges[3]);
../phys/collision.c:610:    PFM_Vec3_Sub((vec3_t*)&frustum->fbr, (vec3_t*)&frustum->nbr, &frust_edges[4]);
../phys/collision.c:611:    PFM_Vec3_Sub((vec3_t*)&frustum->fbl, (vec3_t*)&frustum->nbl, &frust_edges[5]);
../phys/collision.c:640:    for(int i = 0; i < ARR_SIZE(obb->axes); i++) {
../phys/collision.c:642:        if(separating_axis_exists(obb->axes[i], frustum, obb->corners))
../phys/collision.c:648:        frustum->far.normal,
../phys/collision.c:649:        frustum->top.normal,
../phys/collision.c:650:        frustum->bot.normal,
../phys/collision.c:651:        frustum->left.normal,
../phys/collision.c:652:        frustum->right.normal
../phys/collision.c:657:        if(separating_axis_exists(frust_normals[i], frustum, obb->corners))
../phys/collision.c:662:    PFM_Vec3_Sub((vec3_t*)&frustum->ntr, (vec3_t*)&frustum->ntl, &frust_edges[0]);
../phys/collision.c:663:    PFM_Vec3_Sub((vec3_t*)&frustum->ntl, (vec3_t*)&frustum->nbl, &frust_edges[1]);
../phys/collision.c:664:    PFM_Vec3_Sub((vec3_t*)&frustum->ftl, (vec3_t*)&frustum->ntl, &frust_edges[2]);
../phys/collision.c:665:    PFM_Vec3_Sub((vec3_t*)&frustum->ftr, (vec3_t*)&frustum->ntr, &frust_edges[3]);
../phys/collision.c:666:    PFM_Vec3_Sub((vec3_t*)&frustum->fbr, (vec3_t*)&frustum->nbr, &frust_edges[4]);
../phys/collision.c:667:    PFM_Vec3_Sub((vec3_t*)&frustum->fbl, (vec3_t*)&frustum->nbl, &frust_edges[5]);
../phys/collision.c:671:    vec3_t edge_cross_products[ARR_SIZE(obb->axes) * ARR_SIZE(frust_edges)];
../phys/collision.c:673:    for(int i = 0; i < ARR_SIZE(obb->axes); i++) {
../phys/collision.c:676:            PFM_Vec3_Cross((vec3_t*)&obb->axes[i], &frust_edges[j], &edge_cross_products[ncrosses]);
../phys/collision.c:686:        if(separating_axis_exists(edge_cross_products[i], frustum, obb->corners))
../phys/collision.c:721:    GLfloat inv_denom = 1.0f / (dot00 * dot11 - dot01 * dot01);
../phys/collision.c:722:    GLfloat u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
../phys/collision.c:723:    GLfloat v = (dot00 * dot12 - dot01 * dot02) * inv_denom;
../phys/collision.c:738:    s1_x = l1.bx - l1.ax;     s1_z = l1.bz - l1.az;
../phys/collision.c:739:    s2_x = l2.bx - l2.ax;     s2_z = l2.bz - l2.az;
../phys/collision.c:742:    s = (-s1_z * (l1.ax - l2.ax) + s1_x * (l1.az - l2.az)) / (-s2_x * s1_z + s1_x * s2_z);
../phys/collision.c:743:    t = ( s2_x * (l1.az - l2.az) - s2_z * (l1.ax - l2.ax)) / (-s2_x * s1_z + s1_x * s2_z);
../phys/collision.c:748:            out_xz->raw[0] = l1.ax + (t * s1_x);
../phys/collision.c:749:            out_xz->raw[1] = l1.az + (t * s1_z);
../phys/collision.c:763:    if(fabs(l1_slope - l2_slope) < EPSILON)
../phys/collision.c:768:        out_xz->raw[0] = l1.point.raw[0];
../phys/collision.c:769:        out_xz->raw[1] = (l1.point.raw[0] - l2.point.raw[0]) * l2_slope + l2.point.raw[1];
../phys/collision.c:773:        out_xz->raw[0] = l2.point.raw[0];
../phys/collision.c:774:        out_xz->raw[1] = (l2.point.raw[0] - l1.point.raw[0]) * l1_slope + l2.point.raw[1];
../phys/collision.c:778:        out_xz->raw[0] = (l1_slope * l1.point.raw[0] - l2_slope * l2.point.raw[0] 
../phys/collision.c:779:            + l2.point.raw[1] - l1.point.raw[1]) / (l1_slope - l2_slope);
../phys/collision.c:780:        out_xz->raw[1] = l2_slope * (out_xz->raw[0] - l2.point.raw[0]) + l2.point.raw[1];
../phys/collision.c:793:    if((intersec_point.raw[0] - l1.point.raw[0]) / l1.dir.raw[0] < 0.0f)
../phys/collision.c:796:    if((intersec_point.raw[1] - l1.point.raw[1]) / l1.dir.raw[1] < 0.0f)
../phys/collision.c:799:    if((intersec_point.raw[0] - l2.point.raw[0]) / l2.dir.raw[0] < 0.0f)
../phys/collision.c:802:    if((intersec_point.raw[1] - l2.point.raw[1]) / l2.dir.raw[1] < 0.0f)
../phys/collision.c:816:        bounds.x - bounds.width,
../phys/collision.c:823:        bounds.x - bounds.width,
../phys/collision.c:835:        bounds.x - bounds.width, 
../phys/collision.c:837:        bounds.x - bounds.width,
../phys/collision.c:859:    return (px <= bounds.x && px >= bounds.x - bounds.width)
../phys/collision.c:865:    float len_sqrt = pow(seg.bz - seg.az, 2) + pow(seg.bx - seg.ax, 2);
../phys/collision.c:867:        return sqrt(pow(seg.az - point.z, 2) + pow(seg.ax - point.x, 2));
../phys/collision.c:870:    /* Consider the line extending the segment, parameterized as a + t * (b - a). 
../phys/collision.c:889:    return sqrt(pow(proj.z - point.z, 2) + pow(proj.x - point.x, 2));
../phys/collision.c:897:    float dx = line.bx - line.ax;
../phys/collision.c:898:    float dz = line.bz - line.az;
../phys/collision.c:901:    float B = 2 * (dx * (line.ax - cx) + dz * (line.az - cz));
../phys/collision.c:902:    float C = pow(line.ax - cx, 2) + pow(line.az - cz, 2) - pow(radius, 2);
../phys/collision.c:903:    float det = pow(B, 2) - (4 * A * C);
../phys/collision.c:913:        t = -B / (2 * A);
../phys/collision.c:917:        float t1 = (-B + sqrt(det)) / (2 * A);
../phys/collision.c:918:        float t2 = (-B - sqrt(det)) / (2 * A);
../phys/collision.c:932:        rect.x - rect.width, rect.z,
../phys/collision.c:935:        rect.x - rect.width, rect.z + rect.height,
../phys/collision.c:962:    struct range ax = (struct range){a.x - a.width, a.x};
../phys/collision.c:964:    struct range bx = (struct range){b.x - b.width, b.x};
../phys/projectile.c:143:    return (a->uid == b->uid);
../phys/projectile.c:150:    assert(idx == -1);
../phys/projectile.c:155:    vec3_t accel = (vec3_t){0.0f, -GRAVITY, 0.0f};
../phys/projectile.c:156:    PFM_Vec3_Add(&proj->vel, &accel, &proj->vel);
../phys/projectile.c:157:    PFM_Vec3_Add(&proj->pos, &proj->vel, &proj->pos);
../phys/projectile.c:160:    quat_t qrot = phys_velocity_dir(proj->vel);
../phys/projectile.c:162:    PFM_Mat4x4_MakeTrans(proj->pos.x, proj->pos.y, proj->pos.z, &trans);
../phys/projectile.c:163:    PFM_Mat4x4_MakeScale(proj->scale.x, proj->scale.y, proj->scale.z, &scale);
../phys/projectile.c:167:    PFM_Mat4x4_Mult4x4(&trans, &tmp, &proj->model);
../phys/projectile.c:175:    for(int i = proj_arg->begin_idx; i <= proj_arg->end_idx; i++) {
../phys/projectile.c:188:    for(int i = vec_size(&s_front)-1; i >= 0; i--) {
../phys/projectile.c:191:        if(curr->pos.y < -Z_COORDS_PER_TILE) {
../phys/projectile.c:192:            E_Global_Notify(EVENT_PROJECTILE_DISAPPEAR, (void*)((uintptr_t)curr->uid), ES_ENGINE);
../phys/projectile.c:221:    if(faction_id == G_GetFactionID(ent->uid))
../phys/projectile.c:225:    bool result = G_GetDiplomacyState(faction_id, G_GetFactionID(ent->uid), &ds);
../phys/projectile.c:235:    size_t nents = G_Pos_EntsInCircle((vec2_t){proj->pos.x, proj->pos.z}, NEAR_TOLERANCE, near, ARR_SIZE(near));
../phys/projectile.c:240:     * the motion since the last update - this is 's_simticks' worth of fixed
../phys/projectile.c:249:    vec3_t begin = proj->pos;
../phys/projectile.c:250:    vec3_t end, delta = proj->vel;
../phys/projectile.c:251:    PFM_Vec3_Scale(&delta, -1.0f * s_simticks, &delta);
../phys/projectile.c:261:        if(proj->ent_parent == ent->uid)
../phys/projectile.c:263:        if(ent->flags & ENTITY_FLAG_ZOMBIE)
../phys/projectile.c:265:        if((proj->flags & PROJ_ONLY_HIT_COMBATABLE) && !(ent->flags & ENTITY_FLAG_COMBATABLE))
../phys/projectile.c:267:        if((proj->flags & PROJ_ONLY_HIT_ENEMIES) && !phys_enemies(proj->faction_id, ent))
../phys/projectile.c:276:            vec3_t ent_pos = G_Pos_Get(ent->uid);
../phys/projectile.c:277:            PFM_Vec3_Sub((vec3_t*)&proj->pos, &ent_pos, &diff);
../phys/projectile.c:289:        hit->ent_uid = hit_ent->uid;
../phys/projectile.c:290:        hit->proj_uid = proj->uid;
../phys/projectile.c:291:        hit->parent_uid = proj->ent_parent;
../phys/projectile.c:292:        hit->cookie = proj->cookie;
../phys/projectile.c:324:        arg->begin_idx = nitems * i;
../phys/projectile.c:325:        arg->end_idx = MIN(nitems * (i + 1) - 1, nwork-1);
../phys/projectile.c:332:            for(int j = arg->begin_idx; j <= arg->end_idx; j++) {
../phys/projectile.c:348:    out->cam = G_GetActiveCamera();
../phys/projectile.c:349:    out->map = G_GetPrevTickMap();
../phys/projectile.c:350:    out->shadows = false;
../phys/projectile.c:351:    out->light_pos = G_GetLightPos();
../phys/projectile.c:353:    vec_rstat_init(&out->cam_vis_stat);
../phys/projectile.c:354:    vec_ranim_init(&out->cam_vis_anim);
../phys/projectile.c:356:    vec_rstat_init(&out->light_vis_stat);
../phys/projectile.c:357:    vec_ranim_init(&out->light_vis_anim);
../phys/projectile.c:362:        if(!curr->render_private)
../phys/projectile.c:365:            .render_private = curr->render_private,
../phys/projectile.c:366:            .model = curr->model,
../phys/projectile.c:370:        vec_rstat_push(&out->cam_vis_stat, rstate);
../phys/projectile.c:376:    vec_rstat_destroy(&in->cam_vis_stat);
../phys/projectile.c:377:    vec_ranim_destroy(&in->cam_vis_anim);
../phys/projectile.c:379:    vec_rstat_destroy(&in->light_vis_stat);
../phys/projectile.c:380:    vec_ranim_destroy(&in->light_vis_anim);
../phys/projectile.c:386:    if(in->cam_vis_stat.size) {
../phys/projectile.c:387:        ret->cam_vis_stat.array = R_PushArg(
../phys/projectile.c:388:            in->cam_vis_stat.array, 
../phys/projectile.c:389:            in->cam_vis_stat.size * sizeof(struct ent_stat_rstate)
../phys/projectile.c:392:    if(in->cam_vis_anim.size) {
../phys/projectile.c:393:        ret->cam_vis_anim.array = R_PushArg(
../phys/projectile.c:394:            in->cam_vis_anim.array, 
../phys/projectile.c:395:            in->cam_vis_anim.size * sizeof(struct ent_stat_rstate)
../phys/projectile.c:398:    if(in->light_vis_stat.size) {
../phys/projectile.c:399:        ret->light_vis_stat.array = R_PushArg(
../phys/projectile.c:400:            in->light_vis_stat.array, 
../phys/projectile.c:401:            in->light_vis_stat.size * sizeof(struct ent_stat_rstate)
../phys/projectile.c:404:    if(in->light_vis_anim.size) {
../phys/projectile.c:405:        ret->light_vis_anim.array = R_PushArg(
../phys/projectile.c:406:            in->light_vis_anim.array, 
../phys/projectile.c:407:            in->light_vis_anim.size * sizeof(struct ent_stat_rstate)
../phys/projectile.c:459:    for(int i = vec_size(&s_front)-1; i >= 0; i--) {
../phys/projectile.c:522:    /* Use a coordinate system such that the y-axis is up and 
../phys/projectile.c:523:     * the x-axis is along the direction of motion (src -> dst). 
../phys/projectile.c:533:     *              (v^2 +/- sqrt(v^4 - g(gx^2 + 2yv^2))
../phys/projectile.c:534:     * tan(THETA) = (----------------------------------)
../phys/projectile.c:543:    float descriminant = pow(v, 4) - g * (g * pow(x, 2) + 2 * y * pow(v, 2));
../phys/projectile.c:544:    if(descriminant < -EPSILON) {
../phys/projectile.c:557:        t2 = pow(v, 2) - sqrt(descriminant);
../phys/projectile.c:586:    /* 's_front' now has the most up-to-date projectile state */
../phys/projectile.c:600:            .val.as_int = curr->uid,
../phys/projectile.c:606:            .val.as_int = curr->ent_parent,
../phys/projectile.c:612:            .val.as_int = curr->cookie,
../phys/projectile.c:618:            .val.as_int = curr->flags,
../phys/projectile.c:624:            .val.as_int = curr->faction_id,
../phys/projectile.c:629:        AL_NameForRenderPrivate(curr->render_private, dir, name);
../phys/projectile.c:645:            .val.as_vec3 = curr->pos,
../phys/projectile.c:651:            .val.as_vec3 = curr->vel,
../phys/projectile.c:657:            .val.as_vec3 = curr->scale,
../phys/projectile.c:661:        /* No need to save the matrix - it is fully derived */
../phys/projectile.c:729:        /* Lastly, derive the most up-to-date model matrix */
../phys/public/collision.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_assert.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_assert.h:45:    // https://stackoverflow.com/questions/7159348/disable-single-warning-error
../render/gl_assert.h:47:    #pragma GCC diagnostic ignored "-Wformat"
../render/gl_assert.h:60:#define GL_ASSERT_OK() /* no-op */
../render/gl_batch.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../render/gl_batch.c:144:    /* Ringbuffer for for per-instance attributes associated
../render/gl_batch.c:204:    return -1;
../render/gl_batch.c:209:    if(batch->ntexarrs == MAX_TEX_ARRS)
../render/gl_batch.c:212:    R_GL_Texture_ArrayAlloc(TEX_ARR_SZ, &batch->textures[batch->ntexarrs].arr, GL_TEXTURE0 + batch->ntexarrs);
../render/gl_batch.c:213:    batch->textures[batch->ntexarrs].free = ~((uint32_t)0);
../render/gl_batch.c:214:    batch->ntexarrs++;
../render/gl_batch.c:234:    /* Attribute 0 - position */
../render/gl_batch.c:238:    /* Attribute 1 - texture coordinates */
../render/gl_batch.c:243:    /* Attribute 2 - normal */
../render/gl_batch.c:248:    /* Attribute 3 - material index */
../render/gl_batch.c:255:        /* Attribute 4 - draw ID 
../render/gl_batch.c:256:         * This is a per-instance attribute that is sourced from the draw ID buffer */
../render/gl_batch.c:265:        /* Attribute 4/5 - joint indices */
../render/gl_batch.c:273:        /* Attribute 6/7 - joint weights */
../render/gl_batch.c:281:        /* Attribute 8 - draw ID 
../render/gl_batch.c:282:         * This is a per-instance attribute that is sourced from the draw ID buffer */
../render/gl_batch.c:295:    if(batch->nvbos == MAX_MESH_BUFFS)
../render/gl_batch.c:308:    batch_init_vao(batch->type, &VAO, VBO);
../render/gl_batch.c:310:    batch->vbos[batch->nvbos] = (struct vbo_desc){heap_meta, VBO, VAO};
../render/gl_batch.c:311:    batch->nvbos++;
../render/gl_batch.c:317:    khiter_t k = kh_get(mdesc, batch->vbo_desc_map, VBO);
../render/gl_batch.c:318:    if(k != kh_end(batch->vbo_desc_map))
../render/gl_batch.c:321:    size_t alignment = batch_vert_alignment(batch->type);
../render/gl_batch.c:331:    int vbo_offset = -1;
../render/gl_batch.c:333:        vbo_offset = pf_metamemalign(batch->vbos[curr_vbo_idx].heap_meta, alignment, size);
../render/gl_batch.c:336:    }while(++curr_vbo_idx < batch->nvbos);
../render/gl_batch.c:339:        if(batch->nvbos == MAX_MESH_BUFFS)
../render/gl_batch.c:343:        curr_vbo_idx = batch->nvbos-1;
../render/gl_batch.c:344:        vbo_offset = pf_metamemalign(batch->vbos[curr_vbo_idx].heap_meta, alignment, size);
../render/gl_batch.c:346:    assert(curr_vbo_idx >= 0 && curr_vbo_idx < batch->nvbos);
../render/gl_batch.c:349:    /* Perform VBO-to-VBO copy. The data should be copied without having 
../render/gl_batch.c:350:     * to do a round-trip to the CPU.
../render/gl_batch.c:352:    glBindBuffer(GL_COPY_WRITE_BUFFER, batch->vbos[curr_vbo_idx].VBO);
../render/gl_batch.c:356:    k = kh_put(mdesc, batch->vbo_desc_map, VBO, &status);
../render/gl_batch.c:357:    if(status == -1) {
../render/gl_batch.c:358:        pf_metafree(batch->vbos[curr_vbo_idx].heap_meta, vbo_offset);
../render/gl_batch.c:362:    kh_value(batch->vbo_desc_map, k) = (struct mesh_desc){curr_vbo_idx, vbo_offset};
../render/gl_batch.c:368:    khiter_t k = kh_get(mdesc, batch->vbo_desc_map, VBO);
../render/gl_batch.c:369:    assert(k != kh_end(batch->vbo_desc_map));
../render/gl_batch.c:371:    struct mesh_desc md = kh_value(batch->vbo_desc_map, k);
../render/gl_batch.c:372:    pf_metafree(batch->vbos[md.vbo_idx].heap_meta, md.offset);
../render/gl_batch.c:374:    kh_del(mdesc, batch->vbo_desc_map, k);
../render/gl_batch.c:379:    khiter_t k = kh_get(tdesc, batch->tid_desc_map, tid);
../render/gl_batch.c:380:    if(k != kh_end(batch->tid_desc_map))
../render/gl_batch.c:384:    int slice_idx = -1;
../render/gl_batch.c:386:        if(batch->textures[curr_arr_idx].free == 0)
../render/gl_batch.c:388:        slice_idx = batch_first_free_idx(batch->textures[curr_arr_idx].free);
../render/gl_batch.c:390:    }while(++curr_arr_idx < batch->ntexarrs);
../render/gl_batch.c:392:    if(slice_idx == -1) {
../render/gl_batch.c:397:        curr_arr_idx = batch->ntexarrs-1;
../render/gl_batch.c:398:        slice_idx = batch_first_free_idx(batch->textures[curr_arr_idx].free);
../render/gl_batch.c:400:    assert(curr_arr_idx >= 0 && curr_arr_idx < batch->ntexarrs);
../render/gl_batch.c:403:    R_GL_Texture_BindArray(&batch->textures[curr_arr_idx].arr, R_GL_Shader_GetCurrActive());
../render/gl_batch.c:404:    R_GL_Texture_ArrayCopyElem(&batch->textures[curr_arr_idx].arr, slice_idx, arr, idx);
../render/gl_batch.c:407:    k = kh_put(tdesc, batch->tid_desc_map, tid, &status);
../render/gl_batch.c:408:    if(status == -1) {
../render/gl_batch.c:412:    kh_value(batch->tid_desc_map, k) = (struct tex_desc){curr_arr_idx, slice_idx};
../render/gl_batch.c:413:    batch->textures[curr_arr_idx].free &= ~(((uint32_t)0x1) << slice_idx);
../render/gl_batch.c:419:    khiter_t k = kh_get(tdesc, batch->tid_desc_map, id);
../render/gl_batch.c:420:    assert(k != kh_end(batch->tid_desc_map));
../render/gl_batch.c:422:    struct tex_desc td = kh_value(batch->tid_desc_map, k);
../render/gl_batch.c:423:    batch->textures[td.arr_idx].free |= (0x1 << td.tex_idx);
../render/gl_batch.c:425:    kh_del(tdesc, batch->tid_desc_map, k);
../render/gl_batch.c:430:    if(!batch_append_mesh(batch, priv->mesh.VBO))
../render/gl_batch.c:434:    for(; tex_idx < priv->num_materials; tex_idx++) {
../render/gl_batch.c:435:        if(!batch_append_tex(batch, priv->materials[tex_idx].texture.id, tex_idx, &priv->material_arr))
../render/gl_batch.c:443:        --tex_idx;
../render/gl_batch.c:444:        batch_free_tex(batch, priv->materials[tex_idx].texture.id);
../render/gl_batch.c:446:    batch_free_mesh(batch, priv->mesh.VBO);
../render/gl_batch.c:457:    batch->type = type;
../render/gl_batch.c:458:    batch->cmd_ring = R_GL_RingbufferInit(CMD_RING_SZ, RING_UBYTE);
../render/gl_batch.c:459:	if(!batch->cmd_ring)
../render/gl_batch.c:464:        batch->attr_ring = R_GL_RingbufferInit(STAT_ATTR_RING_SZ, RING_FLOAT);
../render/gl_batch.c:467:        batch->attr_ring = R_GL_RingbufferInit(ANIM_ATTR_RING_SZ, RING_FLOAT);
../render/gl_batch.c:472:    if(!batch->attr_ring)
../render/gl_batch.c:475:    batch->vbo_desc_map = kh_init(mdesc);
../render/gl_batch.c:476:    if(!batch->vbo_desc_map)
../render/gl_batch.c:479:    batch->tid_desc_map = kh_init(tdesc);
../render/gl_batch.c:480:    if(!batch->tid_desc_map)
../render/gl_batch.c:483:    batch->ntexarrs = 0;
../render/gl_batch.c:487:    batch->nvbos = 0;
../render/gl_batch.c:495:    R_GL_Texture_ArrayFree(batch->textures[0].arr);
../render/gl_batch.c:497:    kh_destroy(tdesc, batch->tid_desc_map);
../render/gl_batch.c:499:    kh_destroy(mdesc, batch->vbo_desc_map);
../render/gl_batch.c:501:    R_GL_RingbufferDestroy(batch->attr_ring);
../render/gl_batch.c:503:    R_GL_RingbufferDestroy(batch->cmd_ring);
../render/gl_batch.c:512:    for(int i = 0; i < batch->ntexarrs; i++) {
../render/gl_batch.c:513:        R_GL_Texture_ArrayFree(batch->textures[i].arr);
../render/gl_batch.c:515:    for(int i = 0; i < batch->nvbos; i++) {
../render/gl_batch.c:516:        glDeleteBuffers(1, &batch->vbos[i].VBO);
../render/gl_batch.c:519:    kh_destroy(tdesc, batch->tid_desc_map);
../render/gl_batch.c:520:    kh_destroy(mdesc, batch->vbo_desc_map);
../render/gl_batch.c:522:    R_GL_RingbufferDestroy(batch->attr_ring);
../render/gl_batch.c:523:    R_GL_RingbufferDestroy(batch->cmd_ring);
../render/gl_batch.c:530:    khiter_t k = kh_get(mdesc, batch->vbo_desc_map, VBO);
../render/gl_batch.c:531:    assert(k != kh_end(batch->vbo_desc_map));
../render/gl_batch.c:532:    return kh_value(batch->vbo_desc_map, k);
../render/gl_batch.c:537:    khiter_t k = kh_get(tdesc, batch->tid_desc_map, tid);
../render/gl_batch.c:538:    assert(k != kh_end(batch->tid_desc_map));
../render/gl_batch.c:539:    return kh_value(batch->tid_desc_map, k);
../render/gl_batch.c:549:/* Sort the 'ents' array in-place by the chunk coordinate of the entities. Fill
../render/gl_batch.c:560:        while(j > 0 && batch_chunk_compare(vec_AT(ents, j - 1).td, vec_AT(ents, j).td)) {
../render/gl_batch.c:562:            struct ent_stat_rstate tmp = vec_AT(ents, j - 1);
../render/gl_batch.c:563:            vec_AT(ents, j - 1) = vec_AT(ents, j);
../render/gl_batch.c:565:            j--;
../render/gl_batch.c:579:        if(batch_td_key(vec_AT(ents, i - 1).td) != batch_td_key(vec_AT(ents, i).td)) {
../render/gl_batch.c:580:            curr.end_idx = i - 1;
../render/gl_batch.c:592:    curr.end_idx = i - 1;
../render/gl_batch.c:604:        while(j > 0 && ((uintptr_t)ents[j - 1].render_private) > ((uintptr_t)ents[j].render_private)) {
../render/gl_batch.c:606:            struct ent_stat_rstate tmp = ents[j - 1];
../render/gl_batch.c:607:            ents[j - 1] = ents[j];
../render/gl_batch.c:609:            j--;
../render/gl_batch.c:622:        if(((uintptr_t)ents[i - 1].render_private) != ((uintptr_t)ents[i].render_private)) {
../render/gl_batch.c:624:            curr.end_idx = i - 1;
../render/gl_batch.c:635:    curr.end_idx = i - 1;
../render/gl_batch.c:647:        while(j > 0 && ((uintptr_t)ents[j - 1].render_private) > ((uintptr_t)ents[j].render_private)) {
../render/gl_batch.c:649:            struct ent_anim_rstate tmp = ents[j - 1];
../render/gl_batch.c:650:            ents[j - 1] = ents[j];
../render/gl_batch.c:652:            j--;
../render/gl_batch.c:665:        if(((uintptr_t)ents[i - 1].render_private) != ((uintptr_t)ents[i].render_private)) {
../render/gl_batch.c:667:            curr.end_idx = i - 1;
../render/gl_batch.c:678:    curr.end_idx = i - 1;
../render/gl_batch.c:691:        GLuint VBO1 = ((struct render_private*)descs[j - 1].render_private)->mesh.VBO;
../render/gl_batch.c:692:        GLuint VBO2 = ((struct render_private*)descs[j].render_private)->mesh.VBO;
../render/gl_batch.c:698:            struct inst_group_desc tmp = descs[j - 1];
../render/gl_batch.c:699:            descs[j - 1] = descs[j];
../render/gl_batch.c:701:            j--;
../render/gl_batch.c:708:    GLuint VBO = ((struct render_private*)descs[0].render_private)->mesh.VBO;
../render/gl_batch.c:717:        GLuint VBO1 = ((struct render_private*)descs[i - 1].render_private)->mesh.VBO;
../render/gl_batch.c:718:        GLuint VBO2 = ((struct render_private*)descs[i].render_private)->mesh.VBO;
../render/gl_batch.c:724:            curr.end_idx = i - 1;
../render/gl_batch.c:735:    curr.end_idx = i - 1;
../render/gl_batch.c:743:    /* Push a lookup table mapping the per-vertex material index to 
../render/gl_batch.c:746:        if(k < priv->num_materials) {
../render/gl_batch.c:747:            struct tex_desc td = batch_tdesc_for_tid(batch, priv->materials[k].texture.id);
../render/gl_batch.c:749:            R_GL_RingbufferAppendLast(batch->attr_ring, &tex_arr_coord, sizeof(vec2_t));
../render/gl_batch.c:752:            R_GL_RingbufferAppendLast(batch->attr_ring, &tex_arr_coord, sizeof(vec2_t));
../render/gl_batch.c:758:        if(k < priv->num_materials) {
../render/gl_batch.c:759:            struct material *mat = &priv->materials[k];
../render/gl_batch.c:761:            R_GL_RingbufferAppendLast(batch->attr_ring, &mat->ambient_intensity, sizeof(float));
../render/gl_batch.c:762:            R_GL_RingbufferAppendLast(batch->attr_ring, &zero, sizeof(float));
../render/gl_batch.c:763:            R_GL_RingbufferAppendLast(batch->attr_ring, &mat->diffuse_clr, sizeof(vec3_t));
../render/gl_batch.c:764:            R_GL_RingbufferAppendLast(batch->attr_ring, &mat->specular_clr, sizeof(vec3_t));
../render/gl_batch.c:767:            R_GL_RingbufferAppendLast(batch->attr_ring, &zero, sizeof(zero));
../render/gl_batch.c:775:    /* The per-instance static attributes have the follwing layout in the buffer:
../render/gl_batch.c:777:     *  +--------------------------------------------------+ <-- base
../render/gl_batch.c:779:     *  +--------------------------------------------------+
../render/gl_batch.c:781:     *  +--------------------------------------------------+
../render/gl_batch.c:783:     *  +--------------------------------------------------+
../render/gl_batch.c:791:        struct render_private *priv = curr->render_private;
../render/gl_batch.c:793:        for(int j = curr->start_idx; j <= curr->end_idx; j++) {
../render/gl_batch.c:795:            if(i == dcall.start_idx && j == curr->start_idx) {
../render/gl_batch.c:796:                R_GL_RingbufferPush(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:798:                R_GL_RingbufferAppendLast(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:802:        ninsts += curr->end_idx - curr->start_idx + 1;
../render/gl_batch.c:805:    R_GL_RingbufferGetLastRange(batch->attr_ring, &begin, &end);
../render/gl_batch.c:806:    assert(end > begin ? (end - begin == 704 * ninsts)
../render/gl_batch.c:807:                       : ((STAT_ATTR_RING_SZ - begin) + end == 704 * ninsts));
../render/gl_batch.c:819:    /* The per-instance static attributes have the follwing layout in the buffer:
../render/gl_batch.c:821:     *  +--------------------------------------------------+ <-- base
../render/gl_batch.c:823:     *  +--------------------------------------------------+
../render/gl_batch.c:831:        struct render_private *priv = curr->render_private;
../render/gl_batch.c:833:        for(int j = curr->start_idx; j <= curr->end_idx; j++) {
../render/gl_batch.c:835:            if(i == dcall.start_idx && j == curr->start_idx) {
../render/gl_batch.c:836:                R_GL_RingbufferPush(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:838:                R_GL_RingbufferAppendLast(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:841:        ninsts += curr->end_idx - curr->start_idx + 1;
../render/gl_batch.c:844:    R_GL_RingbufferGetLastRange(batch->attr_ring, &begin, &end);
../render/gl_batch.c:845:    assert(end > begin ? (end - begin == 64 * ninsts)
../render/gl_batch.c:846:                       : ((STAT_ATTR_RING_SZ - begin) + end == 64 * ninsts));
../render/gl_batch.c:858:    /* The per-instance static attributes have the follwing layout in the buffer:
../render/gl_batch.c:860:     *  +--------------------------------------------------+ <-- base
../render/gl_batch.c:862:     *  +--------------------------------------------------+
../render/gl_batch.c:864:     *  +--------------------------------------------------+
../render/gl_batch.c:866:     *  +--------------------------------------------------+
../render/gl_batch.c:868:     *  +--------------------------------------------------+
../render/gl_batch.c:870:     *  +--------------------------------------------------+
../render/gl_batch.c:872:     *  +--------------------------------------------------+
../render/gl_batch.c:880:        struct render_private *priv = curr->render_private;
../render/gl_batch.c:882:        for(int j = curr->start_idx; j <= curr->end_idx; j++) {
../render/gl_batch.c:884:            if(i == dcall.start_idx && j == curr->start_idx) {
../render/gl_batch.c:885:                R_GL_RingbufferPush(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:887:                R_GL_RingbufferAppendLast(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:895:            R_GL_RingbufferAppendLast(batch->attr_ring, &ents[j].model, sizeof(mat4x4_t));
../render/gl_batch.c:899:            const size_t pad = (MAX_JOINTS - njoints) * sizeof(mat4x4_t);
../render/gl_batch.c:901:            R_GL_RingbufferAppendLast(batch->attr_ring, ents[j].curr_pose, matsize);
../render/gl_batch.c:902:            R_GL_RingbufferExtendLast(batch->attr_ring, pad);
../render/gl_batch.c:904:            R_GL_RingbufferAppendLast(batch->attr_ring, ents[j].inv_bind_pose, matsize);
../render/gl_batch.c:905:            R_GL_RingbufferExtendLast(batch->attr_ring, pad);
../render/gl_batch.c:907:        ninsts += curr->end_idx - curr->start_idx + 1;
../render/gl_batch.c:910:    R_GL_RingbufferGetLastRange(batch->attr_ring, &begin, &end);
../render/gl_batch.c:911:    assert(end > begin ? (end - begin == 13056 * ninsts)
../render/gl_batch.c:912:                       : ((ANIM_ATTR_RING_SZ - begin) + end == 13056 * ninsts));
../render/gl_batch.c:928:        struct mesh_desc mdesc = batch_mdesc_for_vbo(batch, priv->mesh.VBO);
../render/gl_batch.c:929:        assert(mdesc.offset % batch_vert_alignment(batch->type) == 0);
../render/gl_batch.c:932:            .count = priv->mesh.num_verts,
../render/gl_batch.c:933:            .instance_count = descs[i].end_idx - descs[i].start_idx + 1,
../render/gl_batch.c:934:            .first_index = mdesc.offset / batch_vert_alignment(batch->type),
../render/gl_batch.c:939:            R_GL_RingbufferPush(batch->cmd_ring, &cmd, sizeof(struct GL_DAI_Cmd));
../render/gl_batch.c:941:            R_GL_RingbufferAppendLast(batch->cmd_ring, &cmd, sizeof(struct GL_DAI_Cmd));
../render/gl_batch.c:946:    size_t ncmds = dcall.end_idx - dcall.start_idx + 1;
../render/gl_batch.c:948:    R_GL_RingbufferGetLastRange(batch->cmd_ring, &begin, &end);
../render/gl_batch.c:949:    assert(end > begin ? (end - begin == sizeof(struct GL_DAI_Cmd) * ncmds)
../render/gl_batch.c:950:                       : ((CMD_RING_SZ - begin) + end  == sizeof(struct GL_DAI_Cmd) * ncmds));
../render/gl_batch.c:960:        struct render_private *priv = curr->render_private;
../render/gl_batch.c:961:        struct mesh_desc mdesc = batch_mdesc_for_vbo(batch, priv->mesh.VBO);
../render/gl_batch.c:969:        GLint first = mdesc.offset / batch_vert_alignment(batch->type);
../render/gl_batch.c:970:        GLint count = priv->mesh.num_verts;
../render/gl_batch.c:971:        size_t instcount = curr->end_idx - curr->start_idx + 1;
../render/gl_batch.c:989:    GLuint cmd_vbo = R_GL_RingbufferGetVBO(batch->cmd_ring);
../render/gl_batch.c:993:    R_GL_RingbufferGetLastRange(batch->cmd_ring, &cmd_begin, &cmd_end);
../render/gl_batch.c:997:        assert((CMD_RING_SZ - cmd_begin) % sizeof(struct GL_DAI_Cmd) == 0);
../render/gl_batch.c:998:        size_t ncmds_end = (CMD_RING_SZ - cmd_begin) / sizeof(struct GL_DAI_Cmd);
../render/gl_batch.c:1005:        size_t ncmds = dcall.end_idx - dcall.start_idx + 1;
../render/gl_batch.c:1009:    R_GL_RingbufferSyncLast(batch->cmd_ring);
../render/gl_batch.c:1025:    R_GL_RingbufferBindLast(batch->attr_ring, ATTR_RING_TUNIT, R_GL_Shader_GetCurrActive(), "attrbuff");
../render/gl_batch.c:1027:    GLuint VAO = batch->vbos[dcall.vbo_idx].VAO;
../render/gl_batch.c:1036:    R_GL_RingbufferSyncLast(batch->attr_ring);
../render/gl_batch.c:1043:    R_GL_RingbufferBindLast(batch->attr_ring, ATTR_RING_TUNIT, R_GL_Shader_GetCurrActive(), "attrbuff");
../render/gl_batch.c:1045:    GLuint VAO = batch->vbos[dcall.vbo_idx].VAO;
../render/gl_batch.c:1054:    R_GL_RingbufferSyncLast(batch->attr_ring);
../render/gl_batch.c:1068:    for(int i = 0; i < batch->ntexarrs; i++) {
../render/gl_batch.c:1069:        R_GL_Texture_BindArray(&batch->textures[i].arr, R_GL_Shader_GetCurrActive());
../render/gl_batch.c:1089:    for(int i = 0; i < batch->ntexarrs; i++) {
../render/gl_batch.c:1090:        R_GL_Texture_BindArray(&batch->textures[i].arr, R_GL_Shader_GetCurrActive());
../render/gl_batch.c:1111:        R_GL_Shader_Install("batched.mesh.animated.textured-phong-shadowed");
../render/gl_batch.c:1136:        R_GL_Shader_Install("batched.mesh.static.textured-phong-shadowed");
../render/gl_batch.c:1148:            uint32_t key = batch_chunk_key(curr->chunk_r, curr->chunk_c);
../render/gl_batch.c:1154:                assert(status != -1 && status != 0);
../render/gl_batch.c:1166:                assert(status != -1 && status != 0);
../render/gl_batch.c:1173:        size_t ndraw = curr->end_idx - curr->start_idx + 1;
../render/gl_batch.c:1176:            batch_append(batch, vec_AT(ents, curr->start_idx + i).render_private);
../render/gl_batch.c:1178:        batch_render_stat(batch, &vec_AT(ents, curr->start_idx), ndraw, pass);
../render/gl_batch.c:1241:    batch_render_anim_all(&in->cam_vis_anim, true, RENDER_PASS_REGULAR);
../render/gl_batch.c:1242:    batch_render_stat_all(&in->cam_vis_stat, true, RENDER_PASS_REGULAR, BATCH_ID_NULL);
../render/gl_batch.c:1251:    batch_render_anim_all(&in->cam_vis_anim, true, RENDER_PASS_REGULAR);
../render/gl_batch.c:1252:    batch_render_stat_all(&in->cam_vis_stat, true, RENDER_PASS_REGULAR, *id);
../render/gl_batch.c:1261:    batch_render_anim_all(&in->cam_vis_anim, true, RENDER_PASS_DEPTH);
../render/gl_batch.c:1262:    batch_render_stat_all(&in->cam_vis_stat, true, RENDER_PASS_DEPTH, BATCH_ID_NULL);
../render/gl_batch.c:1286:    for(int r = 0; r < res->chunk_h; r++) {
../render/gl_batch.c:1287:    for(int c = 0; c < res->chunk_w; c++) {
../render/gl_batch.c:1295:            assert(status != -1 && status != 0);
../render/gl_batch.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../render/gl_material.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_mesh.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_minimap.c:150:     * components in the range [-1, 1] */
../render/gl_minimap.c:173:    /* Attribute 0 - position */
../render/gl_minimap.c:198:    PFM_Mat4x4_MakeTrans(-1.0f, -1.0f, 0.0f, &one_px_trans);
../render/gl_minimap.c:236:    GLuint old_shader_prog = priv->shader_prog;
../render/gl_minimap.c:237:    priv->shader_prog = R_GL_Shader_GetProgForName("terrain");
../render/gl_minimap.c:239:    priv->shader_prog = old_shader_prog;
../render/gl_minimap.c:247:/* for the minimap, we just blit a pre-rendered water texture. It is too expensive 
../render/gl_minimap.c:248: * to actually render the water and still have real-time updates of the minimap. 
../render/gl_minimap.c:260:    float center_rel_r = cc.r - res.chunk_h / 2.0f;
../render/gl_minimap.c:261:    float center_rel_c = cc.c - res.chunk_w / 2.0f;
../render/gl_minimap.c:352:    Camera_SetPitchAndYaw((struct camera*)map_cam, -90.0f, 90.0f);
../render/gl_minimap.c:400:    Camera_SetPitchAndYaw((struct camera*)map_cam, -90.0f, 90.0f);
../render/gl_minimap.c:403:    vec2_t bot_left  = (vec2_t){ -(map_dim/2),  (map_dim/2) };
../render/gl_minimap.c:404:    vec2_t top_right = (vec2_t){  (map_dim/2), -(map_dim/2) };
../render/gl_minimap.c:416:            .pos = (vec3_t) {-1.0f, -1.0f, 0.0f}, 
../render/gl_minimap.c:420:            .pos = (vec3_t) {-1.0f, 1.0f, 0.0f}, 
../render/gl_minimap.c:428:            .pos = (vec3_t) {1.0f, -1.0f, 0.0f}, 
../render/gl_minimap.c:440:    /* Attribute 0 - position */
../render/gl_minimap.c:444:    /* Attribute 1 - texture coordinates */
../render/gl_minimap.c:456:        (vec3_t) {-1.0f / side_len_px * 4, -1.0f / side_len_px * 4, 0.0f}, 
../render/gl_minimap.c:457:        (vec3_t) {-1.0f / side_len_px * 4,  1.0f / side_len_px * 4, 0.0f}, 
../render/gl_minimap.c:459:        (vec3_t) { 1.0f / side_len_px * 4, -1.0f / side_len_px * 4, 0.0f}, 
../render/gl_minimap.c:462:    glGenVertexArrays(1, &in->vao);
../render/gl_minimap.c:463:    glBindVertexArray(in->vao);
../render/gl_minimap.c:465:    glGenBuffers(1, &in->vert_vbo);
../render/gl_minimap.c:466:    glBindBuffer(GL_ARRAY_BUFFER, in->vert_vbo);
../render/gl_minimap.c:469:    /* Attribute 0 - position */
../render/gl_minimap.c:473:    /* Attribute 1 - color */
../render/gl_minimap.c:474:    glGenBuffers(1, &in->clr_vbo);
../render/gl_minimap.c:475:    glBindBuffer(GL_ARRAY_BUFFER, in->clr_vbo);
../render/gl_minimap.c:482:    /* Attribute 2 - offset */
../render/gl_minimap.c:483:    glGenBuffers(1, &in->off_vbo);
../render/gl_minimap.c:484:    glBindBuffer(GL_ARRAY_BUFFER, in->off_vbo);
../render/gl_minimap.c:494:    glDeleteBuffers(1, &in->vert_vbo);
../render/gl_minimap.c:495:    glDeleteBuffers(1, &in->clr_vbo);
../render/gl_minimap.c:496:    glDeleteBuffers(1, &in->off_vbo);
../render/gl_minimap.c:497:    glDeleteVertexArrays(1, &in->vao);
../render/gl_minimap.c:513:    /* Render the map top-down view to the texture. */
../render/gl_minimap.c:521:    /* Re-bind the default framebuffer when we're done rendering */
../render/gl_minimap.c:564:    /* Re-bind the default framebuffer when we're done rendering */
../render/gl_minimap.c:580:    PFM_Mat4x4_MakeRotZ(DEG_TO_RAD(-45.0f), &tilt);
../render/gl_minimap.c:582:    PFM_Mat4x4_MakeTrans(center_pos->x, center_pos->y, 0.0f, &trans);
../render/gl_minimap.c:665:    PFM_Mat4x4_MakeRotZ(DEG_TO_RAD(-45.0f), &tilt);
../render/gl_minimap.c:667:    PFM_Mat4x4_MakeTrans(center_pos->x, center_pos->y, 0.0f, &trans);
../render/gl_minimap.c:678:    R_GL_Shader_Install("minimap-units");
../render/gl_render.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_render.c:77:    struct mesh *mesh = &priv->mesh;
../render/gl_render.c:79:    glGenVertexArrays(1, &mesh->VAO);
../render/gl_render.c:81:    glBindVertexArray(mesh->VAO);
../render/gl_render.c:84:    glGenBuffers(1, &mesh->VBO);
../render/gl_render.c:86:    glBindBuffer(GL_ARRAY_BUFFER, mesh->VBO);
../render/gl_render.c:88:    glBufferData(GL_ARRAY_BUFFER, mesh->num_verts * priv->vertex_stride, vbuff, GL_STATIC_DRAW);
../render/gl_render.c:91:    /* Attribute 0 - position */
../render/gl_render.c:92:    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, priv->vertex_stride, (void*)0);
../render/gl_render.c:97:    /* Attribute 1 - texture coordinates */
../render/gl_render.c:98:    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, priv->vertex_stride, 
../render/gl_render.c:104:    /* Attribute 2 - normal */
../render/gl_render.c:105:    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, priv->vertex_stride, 
../render/gl_render.c:111:    /* Attribute 3 - material index */
../render/gl_render.c:112:    glVertexAttribIPointer(3, 1, GL_INT, priv->vertex_stride, 
../render/gl_render.c:123:        /* Attribute 4/5 - joint indices */
../render/gl_render.c:124:        glVertexAttribIPointer(4, 3, GL_UNSIGNED_BYTE, priv->vertex_stride,
../render/gl_render.c:129:        glVertexAttribIPointer(5, 3, GL_UNSIGNED_BYTE, priv->vertex_stride,
../render/gl_render.c:135:        /* Attribute 6/7 - joint weights */
../render/gl_render.c:136:        glVertexAttribPointer(6, 3, GL_FLOAT, GL_FALSE, priv->vertex_stride,
../render/gl_render.c:141:        glVertexAttribPointer(7, 3, GL_FLOAT, GL_FALSE, priv->vertex_stride,
../render/gl_render.c:149:        /* Attribute 4 - blend mode */
../render/gl_render.c:150:        glVertexAttribIPointer(4, 1, GL_SHORT, priv->vertex_stride, 
../render/gl_render.c:156:        /* Attribute 5 - middle material indices packed together */
../render/gl_render.c:157:        glVertexAttribIPointer(5, 1, GL_SHORT, priv->vertex_stride, 
../render/gl_render.c:163:        /* Attribute 6 - corner 1 material indices packed together */
../render/gl_render.c:164:        glVertexAttribIPointer(6, 2, GL_INT, priv->vertex_stride, 
../render/gl_render.c:170:        /* Attribute 7 - corner 2 material indices packed together */
../render/gl_render.c:171:        glVertexAttribIPointer(7, 2, GL_INT, priv->vertex_stride, 
../render/gl_render.c:177:        /* Attribute 8 - tile top and bottom material indices packed together */
../render/gl_render.c:178:        glVertexAttribIPointer(8, 1, GL_INT, priv->vertex_stride, 
../render/gl_render.c:184:        /* Attribute 9 - tile left and right material indices packed together */
../render/gl_render.c:185:        glVertexAttribIPointer(9, 1, GL_INT, priv->vertex_stride, 
../render/gl_render.c:192:    priv->shader_prog = R_GL_Shader_GetProgForName(shader);
../render/gl_render.c:195:        priv->shader_prog_dp = R_GL_Shader_GetProgForName("mesh.animated.depth");
../render/gl_render.c:197:        priv->shader_prog_dp = R_GL_Shader_GetProgForName("mesh.static.depth");
../render/gl_render.c:199:    assert(priv->shader_prog != -1 && priv->shader_prog_dp != -1);
../render/gl_render.c:201:    if(priv->num_materials > 0) {
../render/gl_render.c:202:        R_GL_Texture_ArrayMake(priv->materials, priv->num_materials, &priv->material_arr, GL_TEXTURE0); // Segfaults... stack corruption beforehand is likely! (Maybe by the OpenGL calls before it?)
../render/gl_render.c:230:    }, sizeof(struct material), priv->num_materials, priv->materials);
../render/gl_render.c:232:    R_GL_Shader_InstallProg(priv->shader_prog);
../render/gl_render.c:234:    if(priv->num_materials > 0) {
../render/gl_render.c:235:        R_GL_Texture_BindArray(&priv->material_arr, priv->shader_prog);
../render/gl_render.c:239:    glBindVertexArray(priv->mesh.VAO);
../render/gl_render.c:240:    glDrawArrays(GL_TRIANGLES, 0, priv->mesh.num_verts);
../render/gl_render.c:360:    PFM_Mat4x4_MakeOrthographic(0.0f, width, height, 0.0f, -1.0f, 1.0f, &ortho);
../render/gl_render.c:390:     * +----------------+-------------+--------------+-----
../render/gl_render.c:392:     * +----------------+-------------+--------------+-----
../render/gl_render.c:394:    vbuff = calloc(skel->num_joints * 2, sizeof(vec3_t));
../render/gl_render.c:396:    for(int i = 0, vbuff_idx = 0; i < skel->num_joints; i++, vbuff_idx +=2) {
../render/gl_render.c:398:        struct joint *curr = &skel->joints[i];
../render/gl_render.c:404:        PFM_Mat4x4_Inverse(&skel->inv_bind_poses[i], &bind_pose);
../render/gl_render.c:411:        homo = (vec4_t){curr->tip.x, curr->tip.y, curr->tip.z, 1.0f}; 
../render/gl_render.c:431:        float screen_y = height - ((ndc.y + 1.0f) * height/2.0f);
../render/gl_render.c:432:        UI_DrawText(curr->name, (struct rect){screen_x, screen_y, 100, 25}, (struct rgba){0, 255, 0, 255});
../render/gl_render.c:440:    glBufferData(GL_ARRAY_BUFFER, skel->num_joints * sizeof(vec3_t) * 2, vbuff, GL_STATIC_DRAW);
../render/gl_render.c:461:    glDrawArrays(GL_POINTS, 0, skel->num_joints * 2);
../render/gl_render.c:462:    glDrawArrays(GL_LINES, 0, skel->num_joints * 2);
../render/gl_render.c:582:    vec4_t color4 = (vec4_t){color->x, color->y, color->z, 1.0f};
../render/gl_render.c:616:        [0] = {aabb->x_min, aabb->y_min, aabb->z_min},
../render/gl_render.c:617:        [1] = {aabb->x_min, aabb->y_min, aabb->z_max},
../render/gl_render.c:618:        [2] = {aabb->x_min, aabb->y_max, aabb->z_min},
../render/gl_render.c:619:        [3] = {aabb->x_min, aabb->y_max, aabb->z_max},
../render/gl_render.c:620:        [4] = {aabb->x_max, aabb->y_min, aabb->z_min},
../render/gl_render.c:621:        [5] = {aabb->x_max, aabb->y_min, aabb->z_max},
../render/gl_render.c:622:        [6] = {aabb->x_max, aabb->y_max, aabb->z_min},
../render/gl_render.c:623:        [7] = {aabb->x_max, aabb->y_max, aabb->z_max},
../render/gl_render.c:686:        (vec3_t){screen_pos->x,                  screen_pos->y,                  0.0f},
../render/gl_render.c:687:        (vec3_t){screen_pos->x + signed_size->x, screen_pos->y,                  0.0f},
../render/gl_render.c:688:        (vec3_t){screen_pos->x + signed_size->x, screen_pos->y + signed_size->y, 0.0f},
../render/gl_render.c:689:        (vec3_t){screen_pos->x,                  screen_pos->y + signed_size->y, 0.0f},
../render/gl_render.c:697:    PFM_Mat4x4_MakeOrthographic(0.0f, win_width, win_height, 0.0f, -1.0f, 1.0f, &ortho);
../render/gl_render.c:721:    vec4_t color4 = (vec4_t){color->x, color->y, color->z, 1.0f};
../render/gl_render.c:768:    glBindVertexArray(priv->mesh.VAO);
../render/gl_render.c:769:    glDrawArrays(GL_TRIANGLES, 0, priv->mesh.num_verts);
../render/gl_render.c:839:                z = (2 * (*near)) / ((*far) + (*near) - norm_depth * ((*far) - (*near)));
../render/gl_render.c:873:        float x_near = xz->x + (*radius) * cos(theta);
../render/gl_render.c:874:        float z_near = xz->z - (*radius) * sin(theta);
../render/gl_render.c:876:        float x_far = xz->x + (*radius + *width) * cos(theta);
../render/gl_render.c:877:        float z_far = xz->z - (*radius + *width) * sin(theta);
../render/gl_render.c:907:    vec4_t color4 = (vec4_t){color->x, color->y, color->z, 1.0f};
../render/gl_render.c:937:        {box->corners[0].x, box->corners[0].z},
../render/gl_render.c:938:        {box->corners[1].x, box->corners[1].z},
../render/gl_render.c:939:        {box->corners[5].x, box->corners[5].z},
../render/gl_render.c:940:        {box->corners[4].x, box->corners[4].z},
../render/gl_render.c:969:        vec3_t pdir = (vec3_t){-deltas[i].z, 0.0f, deltas[i].x};
../render/gl_render.c:986:            vec3_t nudge = (vec3_t){-deltas[i].z, 0.0f, deltas[i].x}, nudged;
../render/gl_render.c:1018:    vec4_t color4 = (vec4_t){color->x, color->y, color->z, 1.0f};
../render/gl_render.c:1047:    vec2_t perp = (vec2_t){ delta.z, -delta.x };
../render/gl_render.c:1100:    vec4_t color4 = (vec4_t){color->x, color->y, color->z, 1.0f};
../render/gl_render.c:1185:        vec4_t surf_color = (vec4_t){colors->x, colors->y, colors->z, 0.25};
../render/gl_render.c:1186:        vec4_t line_color = (vec4_t){colors->x, colors->y, colors->z, 0.75};
../render/gl_render.c:1253:    R_GL_Shader_Install("mesh.static.colored-per-vert");
../render/gl_render.c:1381:    vec3_t ray_vbuff[*num_vos * (NUM_SAMPLES - 1) * 4];
../render/gl_render.c:1385:        for(int s = 0; s < NUM_SAMPLES-1; s++) {
../render/gl_render.c:1388:            assert(fabs(PFM_Vec2_Len(&left_rays[i]) - 1.0) < EPSILON);
../render/gl_render.c:1403:            assert(fabs(PFM_Vec2_Len(&right_rays[i]) - 1.0) < EPSILON);
../render/gl_render.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_ringbuffer.c:78:    /* The texture buffer object associated with the VBO - 
../render/gl_ringbuffer.c:97:    assert(ring->fences[ring->imark_tail] > 0);
../render/gl_ringbuffer.c:99:    if(ring->nmarkers == 0)
../render/gl_ringbuffer.c:102:    GLenum result = glClientWaitSync(ring->fences[ring->imark_tail], 0, TIMEOUT_NSEC);
../render/gl_ringbuffer.c:103:    glDeleteSync(ring->fences[ring->imark_tail]);
../render/gl_ringbuffer.c:104:    ring->fences[ring->imark_tail] = 0;
../render/gl_ringbuffer.c:105:    ring->imark_tail = (ring->imark_tail + 1) % NMAXMARKERS;
../render/gl_ringbuffer.c:106:    ring->nmarkers--;
../render/gl_ringbuffer.c:116:    if(ring->nmarkers == NMAXMARKERS)
../render/gl_ringbuffer.c:118:    if(ring->nmarkers == 0)
../render/gl_ringbuffer.c:121:    assert((ring->imark_head - ring->imark_tail + 1) % NMAXMARKERS == ring->nmarkers);
../render/gl_ringbuffer.c:122:    size_t begin = ring->markers[ring->imark_tail].begin;
../render/gl_ringbuffer.c:123:    size_t end = ring->markers[ring->imark_head].end;
../render/gl_ringbuffer.c:129:        return begin - end >= size;
../render/gl_ringbuffer.c:131:        size_t end_size = ring->size - end;
../render/gl_ringbuffer.c:140:    glBindBuffer(GL_TEXTURE_BUFFER, ring->VBO);
../render/gl_ringbuffer.c:141:    glBufferStorage(GL_TEXTURE_BUFFER, ring->size, NULL, flags);
../render/gl_ringbuffer.c:142:    ring->user = glMapBufferRange(GL_TEXTURE_BUFFER, 0, ring->size, flags);
../render/gl_ringbuffer.c:147:    return ((unsigned char*)ring->user) + offset;
../render/gl_ringbuffer.c:152:    /* no-op */
../render/gl_ringbuffer.c:157:    glBindBuffer(GL_TEXTURE_BUFFER, ring->VBO);
../render/gl_ringbuffer.c:158:    glBufferData(GL_TEXTURE_BUFFER, ring->size, NULL, GL_STREAM_DRAW);
../render/gl_ringbuffer.c:163:    glBindBuffer(GL_TEXTURE_BUFFER, ring->VBO);
../render/gl_ringbuffer.c:183:    glGenBuffers(1, &ret->VBO);
../render/gl_ringbuffer.c:184:    glGenTextures(1, &ret->tex_buff);
../render/gl_ringbuffer.c:186:    ret->pos = 0;
../render/gl_ringbuffer.c:187:    ret->size = size;
../render/gl_ringbuffer.c:188:    ret->imark_head = 0;
../render/gl_ringbuffer.c:189:    ret->imark_tail = 0;
../render/gl_ringbuffer.c:190:    ret->nmarkers = 0;
../render/gl_ringbuffer.c:191:    memset(&ret->fences, 0, sizeof(ret->fences));
../render/gl_ringbuffer.c:192:    memset(&ret->markers, 0, sizeof(ret->fences));
../render/gl_ringbuffer.c:195:        ret->mode = MODE_PERSISTENT_MAPPED_BUFFER;
../render/gl_ringbuffer.c:196:        ret->ops = (struct buffer_ops){
../render/gl_ringbuffer.c:202:        ret->mode = MODE_UNSYNCHRONIZED_VBO;
../render/gl_ringbuffer.c:203:        ret->ops = (struct buffer_ops){
../render/gl_ringbuffer.c:209:    ret->ops.init(ret);
../render/gl_ringbuffer.c:211:    glBindTexture(GL_TEXTURE_BUFFER, ret->tex_buff);
../render/gl_ringbuffer.c:213:        glTexBuffer(GL_TEXTURE_BUFFER, GL_R8UI, ret->VBO);
../render/gl_ringbuffer.c:215:        glTexBuffer(GL_TEXTURE_BUFFER, GL_R32F, ret->VBO);
../render/gl_ringbuffer.c:224:    while(ring->nmarkers) {
../render/gl_ringbuffer.c:227:    glDeleteBuffers(1, &ring->VBO);
../render/gl_ringbuffer.c:228:    glDeleteTextures(1, &ring->tex_buff);
../render/gl_ringbuffer.c:234:    if(size > ring->size) {
../render/gl_ringbuffer.c:243:    size_t left = ring->size - ring->pos;
../render/gl_ringbuffer.c:244:    size_t old_pos = ring->pos;
../render/gl_ringbuffer.c:247:        void *ptr = ring->ops.map(ring, ring->pos, size);
../render/gl_ringbuffer.c:249:        ring->pos = (ring->pos + size) % ring->size;
../render/gl_ringbuffer.c:251:        size_t start = size - left;
../render/gl_ringbuffer.c:253:            void *ptr = ring->ops.map(ring, ring->pos, left);
../render/gl_ringbuffer.c:255:            ring->ops.unmap(ring);
../render/gl_ringbuffer.c:259:        void *ptr = ring->ops.map(ring, 0, start);
../render/gl_ringbuffer.c:261:        ring->pos = start;
../render/gl_ringbuffer.c:264:    ring->ops.unmap(ring);
../render/gl_ringbuffer.c:265:    ring->imark_head = (ring->imark_head + 1) % NMAXMARKERS;
../render/gl_ringbuffer.c:266:    ring->markers[ring->imark_head] = (struct marker){old_pos, ring->pos};
../render/gl_ringbuffer.c:268:    if(!ring->nmarkers)
../render/gl_ringbuffer.c:269:        ring->imark_tail = ring->imark_head;
../render/gl_ringbuffer.c:271:    ring->nmarkers++;
../render/gl_ringbuffer.c:279:    assert(ring->nmarkers);
../render/gl_ringbuffer.c:280:    assert(ring->fences[ring->imark_head] == 0);
../render/gl_ringbuffer.c:282:    if(size > ring->size) {
../render/gl_ringbuffer.c:291:    size_t left = ring->size - ring->pos;
../render/gl_ringbuffer.c:292:    size_t old_pos = ring->pos;
../render/gl_ringbuffer.c:295:        void *ptr = ring->ops.map(ring, ring->pos, size);
../render/gl_ringbuffer.c:297:        ring->pos = (ring->pos + size) % ring->size;
../render/gl_ringbuffer.c:299:        size_t start = size - left;
../render/gl_ringbuffer.c:301:            void *ptr = ring->ops.map(ring, ring->pos, left);
../render/gl_ringbuffer.c:303:            ring->ops.unmap(ring);
../render/gl_ringbuffer.c:307:        void *ptr = ring->ops.map(ring, 0, start);
../render/gl_ringbuffer.c:309:        ring->pos = start;
../render/gl_ringbuffer.c:312:    ring->ops.unmap(ring);
../render/gl_ringbuffer.c:313:    ring->markers[ring->imark_head].end = ring->pos;
../render/gl_ringbuffer.c:321:    assert(ring->nmarkers);
../render/gl_ringbuffer.c:322:    assert(ring->fences[ring->imark_head] == 0);
../render/gl_ringbuffer.c:324:    if(size > ring->size) {
../render/gl_ringbuffer.c:333:    size_t left = ring->size - ring->pos;
../render/gl_ringbuffer.c:334:    size_t old_pos = ring->pos;
../render/gl_ringbuffer.c:337:        ring->pos = (ring->pos + size) % ring->size;
../render/gl_ringbuffer.c:339:        size_t start = size - left;
../render/gl_ringbuffer.c:340:        ring->pos = start;
../render/gl_ringbuffer.c:343:    ring->markers[ring->imark_head].end = ring->pos;
../render/gl_ringbuffer.c:349:    if(ring->nmarkers == 0)
../render/gl_ringbuffer.c:352:    *out_begin = ring->markers[ring->imark_head].begin;
../render/gl_ringbuffer.c:353:    *out_end = ring->markers[ring->imark_head].end;
../render/gl_ringbuffer.c:359:    assert(ring->nmarkers);
../render/gl_ringbuffer.c:360:    assert(ring->fences[ring->imark_head] == 0);
../render/gl_ringbuffer.c:361:    size_t bpos = ring->markers[ring->imark_head].begin;
../render/gl_ringbuffer.c:367:    glBindTexture(GL_TEXTURE_BUFFER, ring->tex_buff);
../render/gl_ringbuffer.c:372:        .val.as_int = tunit - GL_TEXTURE0
../render/gl_ringbuffer.c:385:    assert(ring->nmarkers);
../render/gl_ringbuffer.c:386:    assert(ring->fences[ring->imark_head] == 0);
../render/gl_ringbuffer.c:387:    ring->fences[ring->imark_head] = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
../render/gl_ringbuffer.c:392:    return ring->VBO;
../render/gl_shader.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_shader.c:107:        .name        = "mesh.static.textured-phong",
../render/gl_shader.c:110:        .frag_path   = "shaders/fragment/textured-phong.glsl",
../render/gl_shader.c:127:        .name        = "mesh.static.tile-outline",
../render/gl_shader.c:130:        .frag_path   = "shaders/fragment/tile-outline.glsl",
../render/gl_shader.c:141:        .name        = "mesh.animated.textured-phong",
../render/gl_shader.c:144:        .frag_path   = "shaders/fragment/textured-phong.glsl",
../render/gl_shader.c:197:        .name        = "mesh.static.colored-per-vert",
../render/gl_shader.c:200:        .frag_path   = "shaders/fragment/colored-per-vert.glsl",
../render/gl_shader.c:233:        .name        = "terrain-shadowed",
../render/gl_shader.c:234:        .vertex_path = "shaders/vertex/terrain-shadowed.glsl",
../render/gl_shader.c:236:        .frag_path   = "shaders/fragment/terrain-shadowed.glsl",
../render/gl_shader.c:272:        .vertex_path = "shaders/vertex/depth-batched.glsl",
../render/gl_shader.c:289:        .vertex_path = "shaders/vertex/skinned-depth.glsl",
../render/gl_shader.c:304:        .vertex_path = "shaders/vertex/skinned-depth-batched.glsl",
../render/gl_shader.c:319:        .name        = "mesh.static.textured-phong-shadowed",
../render/gl_shader.c:320:        .vertex_path = "shaders/vertex/static-shadowed.glsl",
../render/gl_shader.c:322:        .frag_path   = "shaders/fragment/textured-phong-shadowed.glsl",
../render/gl_shader.c:340:        .name        = "batched.mesh.static.textured-phong-shadowed",
../render/gl_shader.c:341:        .vertex_path = "shaders/vertex/static-shadowed-batched.glsl",
../render/gl_shader.c:343:        .frag_path   = "shaders/fragment/textured-phong-shadowed-batched.glsl",
../render/gl_shader.c:367:        .name        = "mesh.animated.textured-phong-shadowed",
../render/gl_shader.c:368:        .vertex_path = "shaders/vertex/skinned-shadowed.glsl",
../render/gl_shader.c:370:        .frag_path   = "shaders/fragment/textured-phong-shadowed.glsl",
../render/gl_shader.c:392:        .name        = "batched.mesh.animated.textured-phong-shadowed",
../render/gl_shader.c:393:        .vertex_path = "shaders/vertex/skinned-shadowed-batched.glsl",
../render/gl_shader.c:395:        .frag_path   = "shaders/fragment/textured-phong-shadowed-batched.glsl",
../render/gl_shader.c:495:        .name        = "minimap-units",
../render/gl_shader.c:496:        .vertex_path = "shaders/vertex/colored-instanced.glsl",
../render/gl_shader.c:498:        .frag_path   = "shaders/fragment/colored-per-vert.glsl",
../render/gl_shader.c:531:        read = SDL_RWread(stream, out, 1, fsize - read_total); 
../render/gl_shader.c:629:        if(!strcmp(curr->name, name))
../render/gl_shader.c:642:        if(curr->prog_id == prog)
../render/gl_shader.c:650:    const struct uniform *curr = shader->uniforms;
../render/gl_shader.c:652:    if(s_curr_prog != shader->prog_id) {
../render/gl_shader.c:653:        glUseProgram(shader->prog_id);
../render/gl_shader.c:655:        s_curr_prog = shader->prog_id;
../render/gl_shader.c:658:    while(curr->name) {
../render/gl_shader.c:660:        R_GL_StateInstall(curr->name, shader->prog_id);
../render/gl_shader.c:680:        pf_snprintf(path, sizeof(path), "%s/%s", base_path, res->vertex_path);
../render/gl_shader.c:687:        if(res->geo_path)
../render/gl_shader.c:688:            pf_snprintf(path, sizeof(path), "%s/%s", base_path, res->geo_path);
../render/gl_shader.c:689:        if(res->geo_path && !shader_load_and_init(path, &geometry, GL_GEOMETRY_SHADER)) {
../render/gl_shader.c:693:        assert(!res->geo_path || geometry > 0);
../render/gl_shader.c:695:        pf_snprintf(path, sizeof(path), "%s/%s", base_path, res->frag_path);
../render/gl_shader.c:701:        if(!shader_make_prog(vertex, geometry, fragment, &res->prog_id)) {
../render/gl_shader.c:708:                    i + 1, (int)ARR_SIZE(s_shaders), res->vertex_path, res->frag_path, res->geo_path, res->name);
../render/gl_shader.c:729:        if(!strcmp(curr->name, name))
../render/gl_shader.c:730:            return curr->prog_id;
../render/gl_shader.c:733:    return -1;
../render/gl_shader.c:743:        if(curr->prog_id == prog)
../render/gl_shader.c:744:            return curr->name;
../render/gl_shader.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_shadows.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../render/gl_shadows.c:78:    vec3_t cam_ray_ground_isec = (vec3_t){cam_pos.x - t * cam_dir.x, 0.0f, cam_pos.z - t * cam_dir.z};
../render/gl_shadows.c:82:    PFM_Vec3_Scale(&light_dir, -1.0f, &light_dir);
../render/gl_shadows.c:84:    vec3_t right = (vec3_t){-1.0f, 0.0f, 0.0f}, up;
../render/gl_shadows.c:89:    PFM_Vec3_Scale(&light_dir, -t, &delta);
../render/gl_shadows.c:157:    PFM_Mat4x4_MakeOrthographic(-CONFIG_SHADOW_FOV, CONFIG_SHADOW_FOV, 
../render/gl_shadows.c:158:        CONFIG_SHADOW_FOV, -CONFIG_SHADOW_FOV, 0.1f, CONFIG_SHADOW_DRAWDIST, &light_proj);
../render/gl_shadows.c:186:        .val.as_int = SHADOW_MAP_TUNIT - GL_TEXTURE0
../render/gl_shadows.c:209:    R_GL_Shader_InstallProg(priv->shader_prog_dp);
../render/gl_shadows.c:211:    glBindVertexArray(priv->mesh.VAO);
../render/gl_shadows.c:212:    glDrawArrays(GL_TRIANGLES, 0, priv->mesh.num_verts);
../render/gl_shadows.c:224:        {"terrain",                      "terrain-shadowed"},
../render/gl_shadows.c:225:        {"mesh.static.textured-phong",   "mesh.static.textured-phong-shadowed"},
../render/gl_shadows.c:226:        {"mesh.animated.textured-phong", "mesh.animated.textured-phong-shadowed"}
../render/gl_shadows.c:238:        if(priv->shader_prog == from)
../render/gl_shadows.c:239:            priv->shader_prog = to;
../render/gl_state.c:127:    if(a->type != b->type)
../render/gl_state.c:129:    return (0 == memcmp(&a->val, &b->val, uval_size(a->type)));
../render/gl_state.c:137:    switch(uv->type) {
../render/gl_state.c:139:        glUniform1fv(loc, 1, &uv->val.as_float);
../render/gl_state.c:142:        glUniform2fv(loc, 1, uv->val.as_vec2.raw);
../render/gl_state.c:145:        glUniform3fv(loc, 1, uv->val.as_vec3.raw);
../render/gl_state.c:148:        glUniform4fv(loc, 1, uv->val.as_vec4.raw);
../render/gl_state.c:151:        glUniform1iv(loc, 1, &uv->val.as_int);
../render/gl_state.c:154:        glUniform2iv(loc, 1, uv->val.as_ivec2);
../render/gl_state.c:157:        glUniform3iv(loc, 1, uv->val.as_ivec3);
../render/gl_state.c:160:        glUniform4iv(loc, 1, uv->val.as_ivec4);
../render/gl_state.c:163:        glUniformMatrix3fv(loc, 1, GL_FALSE, uv->val.as_mat3.raw);
../render/gl_state.c:166:        glUniformMatrix4fv(loc, 1, GL_FALSE, uv->val.as_mat4.raw);
../render/gl_state.c:178:    void *data = mp_buff_entry(&s_buff_pool, av->data)->raw;
../render/gl_state.c:180:    switch(av->itemtype) {
../render/gl_state.c:182:        glUniform1fv(loc, av->nitems, data);
../render/gl_state.c:185:        glUniform2fv(loc, av->nitems, data);
../render/gl_state.c:188:        glUniform3fv(loc, av->nitems, data);
../render/gl_state.c:191:        glUniform4fv(loc, av->nitems, data);
../render/gl_state.c:194:        glUniform1iv(loc, av->nitems, data);
../render/gl_state.c:197:        glUniform2iv(loc, av->nitems, data);
../render/gl_state.c:200:        glUniform3iv(loc, av->nitems, data);
../render/gl_state.c:203:        glUniform4iv(loc, av->nitems, data);
../render/gl_state.c:206:        glUniformMatrix3fv(loc, av->nitems, GL_FALSE, data);
../render/gl_state.c:209:        glUniformMatrix4fv(loc, av->nitems, GL_FALSE, data);
../render/gl_state.c:219:    unsigned char *data = (unsigned char*)mp_buff_entry(&s_buff_pool, cv->data)->raw;
../render/gl_state.c:220:    const struct mdesc *descs = (const struct mdesc*)mp_buff_entry(&s_buff_pool, cv->descs)->raw;
../render/gl_state.c:222:    for(int i = 0; i < cv->nitems; i++) {
../render/gl_state.c:225:        while(curr->name) {
../render/gl_state.c:228:            pf_snprintf(uname_full, sizeof(uname_full), "%s[%d].%s", uname, i, curr->name);
../render/gl_state.c:232:            switch(curr->type) {
../render/gl_state.c:234:                glUniform1fv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:237:                glUniform2fv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:240:                glUniform3fv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:243:                glUniform4fv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:246:                glUniform1iv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:249:                glUniform2iv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:252:                glUniform3iv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:255:                glUniform4iv(loc, 1, (void*)(data + curr->offset));
../render/gl_state.c:258:                glUniformMatrix3fv(loc, 1, GL_FALSE, (void*)(data + curr->offset));
../render/gl_state.c:261:                glUniformMatrix4fv(loc, 1, GL_FALSE, (void*)(data + curr->offset));
../render/gl_state.c:269:        data += cv->itemsize;
../render/gl_state.c:289:    for(int i = 0; i < p->ninstalled; i++) {
../render/gl_state.c:290:        if(p->installed_progs[i] == prog)
../render/gl_state.c:298:    if(p->ninstalled == NINSTALLED_CACHE)
../render/gl_state.c:300:    p->installed_progs[p->ninstalled++] = prog;
../render/gl_state.c:344:        if(uval_equal(&p->v, &val))
../render/gl_state.c:350:        assert(status != -1 && status != 0);
../render/gl_state.c:370:    if(p->v.type == UTYPE_COMPOSITE || p->v.type == UTYPE_ARRAY)
../render/gl_state.c:373:    *out = p->v;
../render/gl_state.c:387:    if(p->v.type == UTYPE_ARRAY) {
../render/gl_state.c:388:        uval_array_install(shader_prog, uname, &p->av);
../render/gl_state.c:389:    }else if(p->v.type == UTYPE_COMPOSITE) {
../render/gl_state.c:390:        uval_composite_install(shader_prog, uname, &p->cv);
../render/gl_state.c:392:        uval_install(shader_prog, uname, &p->v);
../render/gl_state.c:408:        if(p->av.hash == hash)
../render/gl_state.c:410:        mp_buff_free(&s_buff_pool, p->av.data);
../render/gl_state.c:415:        assert(status != -1 && status != 0);
../render/gl_state.c:421:    assert(len <= sizeof(((struct buff*)NULL)->raw));
../render/gl_state.c:423:    memcpy(mp_buff_entry(&s_buff_pool, data_ref)->raw, data, len);
../render/gl_state.c:447:        if(p->cv.hash == hash)
../render/gl_state.c:449:        mp_buff_free(&s_buff_pool, p->cv.descs);
../render/gl_state.c:450:        mp_buff_free(&s_buff_pool, p->cv.data);
../render/gl_state.c:455:        assert(status != -1 && status != 0);
../render/gl_state.c:463:    assert(len <= sizeof(((struct buff*)NULL)->raw));
../render/gl_state.c:466:    struct mdesc *base = (struct mdesc*)mp_buff_entry(&s_buff_pool, desc_ref)->raw;
../render/gl_state.c:467:    while(curr->name) {
../render/gl_state.c:471:    memcpy(mp_buff_entry(&s_buff_pool, data_ref)->raw, data, len);
../render/gl_statusbar.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../render/gl_statusbar.c:69:    vec2_t ent_top_pos_ss[*num_ents]; /* Screen-space XY positions of the entity tops. */
../render/gl_statusbar.c:85:        float screen_y = height - ((ndc.y + 1.0f) * height/2.0f);
../render/gl_statusbar.c:91:     * Set uv attribute for each vertex - used in fragment shader to determine relative 
../render/gl_statusbar.c:96:            .pos = (vec3_t) {-1.0f, -1.0f, 0.0f}, 
../render/gl_statusbar.c:100:            .pos = (vec3_t) {-1.0f, 1.0f, 0.0f}, 
../render/gl_statusbar.c:108:            .pos = (vec3_t) {1.0f, -1.0f, 0.0f}, 
../render/gl_terrain.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../render/gl_terrain.c:71:    size_t nchunks = res->chunk_w * res->chunk_h;
../render/gl_terrain.c:79:        .val.as_ivec4[0] = res->chunk_w, 
../render/gl_terrain.c:80:        .val.as_ivec4[1] = res->chunk_h,
../render/gl_terrain.c:81:        .val.as_ivec4[2] = res->tile_w,
../render/gl_terrain.c:82:        .val.as_ivec4[3] = res->tile_h
../render/gl_terrain.c:123:        shader_prog = R_GL_Shader_GetProgForName("terrain-shadowed");
../render/gl_terrain.c:127:    assert(shader_prog != -1);
../render/gl_texture.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_texture.c:52:#define LOD_BIAS (-0.5f)
../render/gl_texture.c:227:    assert(put_ret != -1 && put_ret != 0);
../render/gl_texture.c:248:    assert(put_ret != -1 && put_ret != 0);
../render/gl_texture.c:280:    glActiveTexture(text->tunit);
../render/gl_texture.c:282:    //glActiveTexture(text->tunit); // Works the second time only!?
../render/gl_texture.c:285:    glBindTexture(GL_TEXTURE_2D, text->id);
../render/gl_texture.c:287:    GLint sampler = text->tunit - GL_TEXTURE0;
../render/gl_texture.c:325:    out->tunit = tunit;
../render/gl_texture.c:326:    glGenTextures(1, &out->id);
../render/gl_texture.c:327:    glBindTexture(GL_TEXTURE_2D_ARRAY, out->id);
../render/gl_texture.c:350:    for(int i = 0; i < texture_arr_num_mip_levels(dst->id); i++) {
../render/gl_texture.c:355:            glCopyImageSubData(src->id, GL_TEXTURE_2D_ARRAY, i, 0, 0, src_idx,
../render/gl_texture.c:356:                               dst->id, GL_TEXTURE_2D_ARRAY, i, 0, 0, dst_idx,
../render/gl_texture.c:361:            glFramebufferTextureLayer(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, src->id, i, src_idx);
../render/gl_texture.c:362:            glFramebufferTextureLayer(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, dst->id, i, dst_idx);
../render/gl_texture.c:383:    out->tunit = tunit;
../render/gl_texture.c:384:    glGenTextures(1, &out->id);
../render/gl_texture.c:386:    glBindTexture(GL_TEXTURE_2D_ARRAY, out->id);
../render/gl_texture.c:454:    out->tunit = tunit;
../render/gl_texture.c:455:    glGenTextures(1, &out->id);
../render/gl_texture.c:456:    glBindTexture(GL_TEXTURE_2D_ARRAY, out->id);
../render/gl_texture.c:508:    int idx = (arr->tunit - GL_TEXTURE0);
../render/gl_texture.c:516:    glActiveTexture(arr->tunit);
../render/gl_texture.c:517:    glBindTexture(GL_TEXTURE_2D_ARRAY, arr->id);
../render/gl_texture.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_tile.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../render/gl_tile.c:106: *   +------+------+
../render/gl_tile.c:110: *   +------+------+
../render/gl_tile.c:114: *   +------+------+
../render/gl_tile.c:119: *   +------+------+
../render/gl_tile.c:127: *   +------+------+
../render/gl_tile.c:181:    switch(tile->type) {
../render/gl_tile.c:190:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, Z_COORDS_PER_TILE);
../render/gl_tile.c:199:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, Z_COORDS_PER_TILE);
../render/gl_tile.c:201:        out_tri_normals[0] = (vec3_t) {0.0f, sin(normal_angle), -cos(normal_angle)};
../render/gl_tile.c:202:        out_tri_normals[1] = (vec3_t) {0.0f, sin(normal_angle), -cos(normal_angle)};
../render/gl_tile.c:208:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, X_COORDS_PER_TILE);
../render/gl_tile.c:210:        out_tri_normals[0] = (vec3_t) {-cos(normal_angle), sin(normal_angle), 0.0f};
../render/gl_tile.c:211:        out_tri_normals[1] = (vec3_t) {-cos(normal_angle), sin(normal_angle), 0.0f};
../render/gl_tile.c:217:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, X_COORDS_PER_TILE);
../render/gl_tile.c:226:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:237:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:248:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:252:        out_tri_normals[1] = (vec3_t) {-cos(normal_angle) * cos(M_PI/4.0f), sin(normal_angle), 
../render/gl_tile.c:259:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:262:        out_tri_normals[0] = (vec3_t) {-cos(normal_angle) * cos(M_PI/4.0f), sin(normal_angle), 
../render/gl_tile.c:270:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:274:                                       -cos(normal_angle) * sin(M_PI/4.0f)};
../render/gl_tile.c:281:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:286:                                       -cos(normal_angle) * sin(M_PI/4.0f)};
../render/gl_tile.c:292:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:295:        out_tri_normals[0] = (vec3_t) {-cos(normal_angle) * cos(M_PI/4.0f), sin(normal_angle), 
../render/gl_tile.c:296:                                       -cos(normal_angle) * sin(M_PI/4.0f)};
../render/gl_tile.c:303:        float normal_angle = M_PI/2.0f - atan2(tile->ramp_height * Y_COORDS_PER_TILE, 
../render/gl_tile.c:307:        out_tri_normals[1] = (vec3_t) {-cos(normal_angle) * cos(M_PI/4.0f), sin(normal_angle), 
../render/gl_tile.c:308:                                       -cos(normal_angle) * sin(M_PI/4.0f)};
../render/gl_tile.c:361:    inout->normal = norm_total;
../render/gl_tile.c:384:    inout->normal = norm_total;
../render/gl_tile.c:389:    assert(inout->tile);
../render/gl_tile.c:393:    tile_top_normals(inout->tile, top_tri_normals, out_top_tri_left_aligned);
../render/gl_tile.c:396:        fabs(top_tri_normals[0].y) < 1.0 && (inout->tile->ramp_height > 1) ? inout->tile->sides_mat_idx : inout->tile->top_mat_idx,
../render/gl_tile.c:397:        fabs(top_tri_normals[1].y) < 1.0 && (inout->tile->ramp_height > 1) ? inout->tile->sides_mat_idx : inout->tile->top_mat_idx,
../render/gl_tile.c:401:     * CONFIG 1 (left-aligned)   CONFIG 2
../render/gl_tile.c:403:     * +---------+               +---------+
../render/gl_tile.c:408:     * +---------+               +---------+
../render/gl_tile.c:411:    inout->middle_mask = INDICES_MASK_16(tri_mats[0], tri_mats[1]);
../render/gl_tile.c:412:    inout->bot_center_idx = tri_mats[0];
../render/gl_tile.c:413:    inout->top_center_idx = tri_mats[1];
../render/gl_tile.c:416:        inout->top_left_mask     = INDICES_MASK_16(tri_mats[1], tri_mats[0]);
../render/gl_tile.c:417:        inout->top_right_mask    = INDICES_MASK_16(tri_mats[1], tri_mats[1]);
../render/gl_tile.c:418:        inout->bot_left_mask     = INDICES_MASK_16(tri_mats[0], tri_mats[0]);
../render/gl_tile.c:419:        inout->bot_right_mask    = INDICES_MASK_16(tri_mats[0], tri_mats[1]);
../render/gl_tile.c:421:        inout->left_center_idx  = tri_mats[0];
../render/gl_tile.c:422:        inout->right_center_idx = tri_mats[1];
../render/gl_tile.c:424:        inout->top_left_mask     = INDICES_MASK_16(tri_mats[1], tri_mats[1]);
../render/gl_tile.c:425:        inout->top_right_mask    = INDICES_MASK_16(tri_mats[0], tri_mats[1]);
../render/gl_tile.c:426:        inout->bot_left_mask     = INDICES_MASK_16(tri_mats[1], tri_mats[0]);
../render/gl_tile.c:427:        inout->bot_right_mask    = INDICES_MASK_16(tri_mats[0], tri_mats[0]);
../render/gl_tile.c:429:        inout->left_center_idx  = tri_mats[1];
../render/gl_tile.c:430:        inout->right_center_idx = tri_mats[0];
../render/gl_tile.c:438:    if(SAME_INDICES_32(vert->c1_indices[0])
../render/gl_tile.c:439:    && vert->c1_indices[0] == vert->c2_indices[0]
../render/gl_tile.c:440:    && vert->c1_indices[0] == vert->c2_indices[1]
../render/gl_tile.c:441:    && vert->c1_indices[0] == vert->tb_indices
../render/gl_tile.c:442:    && vert->c1_indices[0] == vert->lr_indices) {
../render/gl_tile.c:446:        return vert->blend_mode; 
../render/gl_tile.c:465:    return -1;
../render/gl_tile.c:493:    ret = M_Tile_RelativeDesc(res, &ref, 0, -1);
../render/gl_tile.c:507:    ret = M_Tile_RelativeDesc(res, &ref, -1, 0);
../render/gl_tile.c:527:        left_tile ? M_Tile_NEHeight(left_tile) : -1,
../render/gl_tile.c:528:        left_tile ? M_Tile_SEHeight(left_tile) : -1,
../render/gl_tile.c:530:        top_tile ? M_Tile_SWHeight(top_tile) : -1,
../render/gl_tile.c:531:        top_tile ? M_Tile_SEHeight(top_tile) : -1,
../render/gl_tile.c:533:        right_tile ? M_Tile_NWHeight(right_tile) : -1,
../render/gl_tile.c:534:        right_tile ? M_Tile_SWHeight(right_tile) : -1,
../render/gl_tile.c:536:        bot_tile  ? M_Tile_NWHeight(bot_tile) : -1,
../render/gl_tile.c:537:        bot_tile  ? M_Tile_NEHeight(bot_tile) : -1,
../render/gl_tile.c:558:    size_t offset = (in->tile_r * (*tiles_per_chunk_x) + in->tile_c) * VERTS_PER_TILE * sizeof(struct terrain_vert);
../render/gl_tile.c:561:    glBindBuffer(GL_ARRAY_BUFFER, priv->mesh.VBO);
../render/gl_tile.c:575:        ( 0.0f - (in->tile_c* X_COORDS_PER_TILE) - X_COORDS_PER_TILE/2.0f ), 
../render/gl_tile.c:576:        (-TILE_DEPTH * Y_COORDS_PER_TILE - Y_COORDS_PER_TILE/2.0f), 
../render/gl_tile.c:577:        ( 0.0f + (in->tile_r* Z_COORDS_PER_TILE) + Z_COORDS_PER_TILE/2.0f),
../render/gl_tile.c:579:    PFM_Mat4x4_MakeTrans(-center.x, -center.y, -center.z, &trans);
../render/gl_tile.c:593:    /* Attribute 0 - position */
../render/gl_tile.c:597:    /* Attribute 1 - texture coordinates */
../render/gl_tile.c:602:    /* Attribute 2 - normal */
../render/gl_tile.c:618:    R_GL_Shader_Install("mesh.static.tile-outline");
../render/gl_tile.c:638:    GLuint VBO = priv->mesh.VBO;
../render/gl_tile.c:657:    ret = M_Tile_RelativeDesc(res, &ref, 0, -1);
../render/gl_tile.c:671:    ret = M_Tile_RelativeDesc(res, &ref, -1, 0);
../render/gl_tile.c:685:    ret = M_Tile_RelativeDesc(res, &ref, 1, -1);
../render/gl_tile.c:699:    ret = M_Tile_RelativeDesc(res, &ref, -1, -1);
../render/gl_tile.c:706:    ret = M_Tile_RelativeDesc(res, &ref, -1, 1);
../render/gl_tile.c:754:        if(adjacent[i]->tile) {
../render/gl_tile.c:785:     * two non-central vertices. If the vertex is surrounded by only 2 different materials, 
../render/gl_tile.c:793:    size_t offset = VERTS_PER_TILE * (tile->tile_r * TILES_PER_CHUNK_WIDTH + tile->tile_c) * sizeof(struct terrain_vert);
../render/gl_tile.c:812:        south_provoking[i]->c1_indices[0] = INDICES_MASK_32(bot.top_left_mask, bot_left.top_right_mask);
../render/gl_tile.c:813:        south_provoking[i]->c1_indices[1] = INDICES_MASK_32(left.bot_right_mask, curr.bot_left_mask);
../render/gl_tile.c:815:        south_provoking[i]->c2_indices[0] = INDICES_MASK_32(bot_right.top_left_mask, bot.top_right_mask);
../render/gl_tile.c:816:        south_provoking[i]->c2_indices[1] = INDICES_MASK_32(curr.bot_right_mask, right.bot_left_mask);
../render/gl_tile.c:818:        north_provoking[i]->c1_indices[0] = INDICES_MASK_32(curr.top_left_mask, left.top_right_mask);
../render/gl_tile.c:819:        north_provoking[i]->c1_indices[1] = INDICES_MASK_32(top_left.bot_right_mask, top.bot_left_mask);
../render/gl_tile.c:821:        north_provoking[i]->c2_indices[0] = INDICES_MASK_32(right.top_left_mask, curr.top_right_mask);
../render/gl_tile.c:822:        north_provoking[i]->c2_indices[1] = INDICES_MASK_32(top.bot_right_mask, top_right.bot_left_mask);
../render/gl_tile.c:824:        CPY2(west_provoking[i]->c1_indices, south_provoking[0]->c1_indices);
../render/gl_tile.c:825:        CPY2(west_provoking[i]->c2_indices, north_provoking[0]->c1_indices);
../render/gl_tile.c:827:        CPY2(east_provoking[i]->c1_indices, south_provoking[0]->c2_indices);
../render/gl_tile.c:828:        CPY2(east_provoking[i]->c2_indices, north_provoking[0]->c2_indices);
../render/gl_tile.c:849:        provoking[i]->tb_indices = tb_mask;
../render/gl_tile.c:850:        provoking[i]->lr_indices = lr_mask;
../render/gl_tile.c:851:        provoking[i]->middle_indices = curr.middle_mask;
../render/gl_tile.c:852:        provoking[i]->blend_mode = optimal_blendmode(provoking[i]);
../render/gl_tile.c:864:    GLuint VBO = priv->mesh.VBO;
../render/gl_tile.c:866:    size_t offset = VERTS_PER_TILE * (tile->tile_r * TILES_PER_CHUNK_WIDTH + tile->tile_c) * sizeof(struct terrain_vert);
../render/gl_tile.c:889:    /* NW (top-left) corner */
../render/gl_tile.c:891:    td = *tile; if(M_Tile_RelativeDesc(res, &td, -1, -1)) M_TileForDesc(map, td, &tiles[0]);
../render/gl_tile.c:892:    td = *tile; if(M_Tile_RelativeDesc(res, &td,  0, -1)) M_TileForDesc(map, td, &tiles[1]);
../render/gl_tile.c:894:    td = *tile; if(M_Tile_RelativeDesc(res, &td, -1,  0)) M_TileForDesc(map, td, &tiles[3]);
../render/gl_tile.c:895:    tile_smooth_normals_corner(tiles, &tfvb->nw0);
../render/gl_tile.c:896:    tile_smooth_normals_corner(tiles, &tfvb->nw1);
../render/gl_tile.c:898:    /* NE (top-right) corner */
../render/gl_tile.c:900:    td = *tile; if(M_Tile_RelativeDesc(res, &td,  0, -1)) M_TileForDesc(map, td, &tiles[0]);
../render/gl_tile.c:901:    td = *tile; if(M_Tile_RelativeDesc(res, &td,  1, -1)) M_TileForDesc(map, td, &tiles[1]);
../render/gl_tile.c:904:    tile_smooth_normals_corner(tiles, &tfvb->ne0);
../render/gl_tile.c:905:    tile_smooth_normals_corner(tiles, &tfvb->ne1);
../render/gl_tile.c:907:    /* SE (bot-right) corner */
../render/gl_tile.c:913:    tile_smooth_normals_corner(tiles, &tfvb->se0);
../render/gl_tile.c:914:    tile_smooth_normals_corner(tiles, &tfvb->se1);
../render/gl_tile.c:916:    /* SW (bot-left) corner */
../render/gl_tile.c:918:    td = *tile; if(M_Tile_RelativeDesc(res, &td, -1,  0)) M_TileForDesc(map, td, &tiles[0]);
../render/gl_tile.c:921:    td = *tile; if(M_Tile_RelativeDesc(res, &td, -1,  1)) M_TileForDesc(map, td, &tiles[3]);
../render/gl_tile.c:922:    tile_smooth_normals_corner(tiles, &tfvb->sw0);
../render/gl_tile.c:923:    tile_smooth_normals_corner(tiles, &tfvb->sw1);
../render/gl_tile.c:927:    td = *tile; if(M_Tile_RelativeDesc(res, &td,  0, -1)) M_TileForDesc(map, td, &tiles[2]);
../render/gl_tile.c:929:    tile_smooth_normals_edge(tiles, &tfvb->n0);
../render/gl_tile.c:930:    tile_smooth_normals_edge(tiles, &tfvb->n1);
../render/gl_tile.c:936:    tile_smooth_normals_edge(tiles, &tfvb->s0);
../render/gl_tile.c:937:    tile_smooth_normals_edge(tiles, &tfvb->s1);
../render/gl_tile.c:941:    td = *tile; if(M_Tile_RelativeDesc(res, &td, -1,  0)) M_TileForDesc(map, td, &tiles[0]);
../render/gl_tile.c:943:    tile_smooth_normals_edge(tiles, &tfvb->w0);
../render/gl_tile.c:944:    tile_smooth_normals_edge(tiles, &tfvb->w1);
../render/gl_tile.c:950:    tile_smooth_normals_edge(tiles, &tfvb->e0);
../render/gl_tile.c:951:    tile_smooth_normals_edge(tiles, &tfvb->e1);
../render/gl_tile.c:959:    tfvb->center0.normal = center_norm;
../render/gl_tile.c:960:    tfvb->center1.normal = center_norm;
../render/gl_tile.c:961:    tfvb->center2.normal = center_norm;
../render/gl_tile.c:962:    tfvb->center3.normal = center_norm;
../render/gl_tile.c:963:    tfvb->center4.normal = center_norm;
../render/gl_tile.c:964:    tfvb->center5.normal = center_norm;
../render/gl_tile.c:965:    tfvb->center6.normal = center_norm;
../render/gl_tile.c:966:    tfvb->center7.normal = center_norm;
../render/gl_tile.c:983:    size_t offset = (desc->tile_r * TILES_PER_CHUNK_WIDTH + desc->tile_c) * VERTS_PER_TILE * sizeof(struct terrain_vert);
../render/gl_tile.c:985:    glBindBuffer(GL_ARRAY_BUFFER, priv->mesh.VBO);
../render/gl_tile.c:993:    if(tile->blend_normals) {
../render/gl_tile.c:1020:            .pos    = (vec3_t) { 0.0f - ((td.tile_c+1) * X_COORDS_PER_TILE), 
../render/gl_tile.c:1024:            .normal = (vec3_t) { 0.0f, -1.0f, 0.0f },
../render/gl_tile.c:1025:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1028:            .pos    = (vec3_t) { 0.0f - (td.tile_c * X_COORDS_PER_TILE), 
../render/gl_tile.c:1032:            .normal = (vec3_t) { 0.0f, -1.0f, 0.0f },
../render/gl_tile.c:1033:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1036:            .pos    = (vec3_t) { 0.0f - (td.tile_c * X_COORDS_PER_TILE), 
../render/gl_tile.c:1040:            .normal = (vec3_t) { 0.0f, -1.0f, 0.0f },
../render/gl_tile.c:1041:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1044:            .pos    = (vec3_t) { 0.0f - ((td.tile_c+1) * X_COORDS_PER_TILE),
../render/gl_tile.c:1048:            .normal = (vec3_t) { 0.0f, -1.0f, 0.0f },
../render/gl_tile.c:1049:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1056:            .pos    = (vec3_t) { 0.0f - (td.tile_c * X_COORDS_PER_TILE),
../render/gl_tile.c:1060:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1063:            .pos    = (vec3_t) { 0.0f - ((td.tile_c+1) * X_COORDS_PER_TILE), 
../render/gl_tile.c:1067:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1070:            .pos    = (vec3_t) { 0.0f - ((td.tile_c+1) * X_COORDS_PER_TILE), 
../render/gl_tile.c:1074:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1077:            .pos    = (vec3_t) { 0.0f - (td.tile_c * X_COORDS_PER_TILE), 
../render/gl_tile.c:1081:            .material_idx  = tile->top_mat_idx,
../render/gl_tile.c:1091:            .normal = (vec3_t) { 0.0f, 0.0f, -1.0f },
../render/gl_tile.c:1092:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1097:            .normal = (vec3_t) { 0.0f, 0.0f, -1.0f },
../render/gl_tile.c:1098:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1103:            .normal = (vec3_t) { 0.0f, 0.0f, -1.0f },
../render/gl_tile.c:1104:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1109:            .normal = (vec3_t) { 0.0f, 0.0f, -1.0f },
../render/gl_tile.c:1110:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1119:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1125:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1131:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1137:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1146:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1152:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1158:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1164:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1172:            .normal = (vec3_t) { -1.0f, 0.0f, 0.0f },
../render/gl_tile.c:1173:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1178:            .normal = (vec3_t) { -1.0f, 0.0f, 0.0f },
../render/gl_tile.c:1179:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1184:            .normal = (vec3_t) { -1.0f, 0.0f, 0.0f },
../render/gl_tile.c:1185:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1190:            .normal = (vec3_t) { -1.0f, 0.0f, 0.0f },
../render/gl_tile.c:1191:            .material_idx  = tile->sides_mat_idx,
../render/gl_tile.c:1206:        memcpy(out + (i * VERTS_PER_SIDE_FACE) + 0, &curr->nw, sizeof(struct terrain_vert));
../render/gl_tile.c:1207:        memcpy(out + (i * VERTS_PER_SIDE_FACE) + 1, &curr->ne, sizeof(struct terrain_vert));
../render/gl_tile.c:1208:        memcpy(out + (i * VERTS_PER_SIDE_FACE) + 2, &curr->sw, sizeof(struct terrain_vert));
../render/gl_tile.c:1211:        memcpy(out + (i * VERTS_PER_SIDE_FACE) + 3, &curr->se, sizeof(struct terrain_vert));
../render/gl_tile.c:1212:        memcpy(out + (i * VERTS_PER_SIDE_FACE) + 4, &curr->sw, sizeof(struct terrain_vert));
../render/gl_tile.c:1213:        memcpy(out + (i * VERTS_PER_SIDE_FACE) + 5, &curr->ne, sizeof(struct terrain_vert));
../render/gl_tile.c:1226:     * CONFIG 1 (left-aligned)   CONFIG 2
../render/gl_tile.c:1228:     * +---------+               +---------+
../render/gl_tile.c:1233:     * +---------+               +---------+
../render/gl_tile.c:1238:          TILETYPE_IS_RAMP(tile->type)          ? (tile->base_height + tile->ramp_height / 2.0f) 
../render/gl_tile.c:1239:        : TILETYPE_IS_CORNER_CONVEX(tile->type) ? (tile->base_height + tile->ramp_height) 
../render/gl_tile.c:1240:        : (tile->base_height);
../render/gl_tile.c:1243:        top.nw.pos.x - X_COORDS_PER_TILE / 2.0f, 
../render/gl_tile.c:1248:    bool tri0_side_mat = fabs(top_tri_normals[0].y) < 1.0 && (tile->ramp_height > 1);
../render/gl_tile.c:1249:    bool tri1_side_mat = fabs(top_tri_normals[1].y) < 1.0 && (tile->ramp_height > 1);
../render/gl_tile.c:1250:	int tri0_idx = tri0_side_mat ? tile->sides_mat_idx : tile->top_mat_idx;
../render/gl_tile.c:1251:	int tri1_idx = tri1_side_mat ? tile->sides_mat_idx : tile->top_mat_idx;
../render/gl_tile.c:1305:    tfvb->se0 = top.se;
../render/gl_tile.c:1306:    tfvb->s0 = south_vert;
../render/gl_tile.c:1307:    tfvb->center0 = center_vert_tri0;
../render/gl_tile.c:1308:    tfvb->center1 = center_vert_tri0;
../render/gl_tile.c:1309:    tfvb->s1 = south_vert;
../render/gl_tile.c:1310:    tfvb->sw0 = top.sw;
../render/gl_tile.c:1311:    tfvb->sw1 = top.sw;
../render/gl_tile.c:1312:    tfvb->w0 = west_vert;
../render/gl_tile.c:1313:    tfvb->center2 = top_tri_left_aligned ? center_vert_tri1 : center_vert_tri0;
../render/gl_tile.c:1314:    tfvb->center3 = top_tri_left_aligned ? center_vert_tri1 : center_vert_tri0;
../render/gl_tile.c:1315:    tfvb->w1 = west_vert;
../render/gl_tile.c:1316:    tfvb->nw0 = top.nw;
../render/gl_tile.c:1317:    tfvb->nw1 = top.nw;
../render/gl_tile.c:1318:    tfvb->n0 = north_vert;
../render/gl_tile.c:1319:    tfvb->center4 = center_vert_tri1;
../render/gl_tile.c:1320:    tfvb->center5 = center_vert_tri1;
../render/gl_tile.c:1321:    tfvb->n1 = north_vert;
../render/gl_tile.c:1322:    tfvb->ne0 = top.ne;
../render/gl_tile.c:1323:    tfvb->ne1 = top.ne;
../render/gl_tile.c:1324:    tfvb->e0 = east_vert;
../render/gl_tile.c:1325:    tfvb->center6 = top_tri_left_aligned ? center_vert_tri0 : center_vert_tri1;
../render/gl_tile.c:1326:    tfvb->center7 = top_tri_left_aligned ? center_vert_tri0 : center_vert_tri1;
../render/gl_tile.c:1327:    tfvb->e1 = east_vert;
../render/gl_tile.c:1328:    tfvb->se1 = top.se;
../render/gl_tile.c:1332:    tfvb->center0.pos.z -= 0.005;
../render/gl_tile.c:1333:    tfvb->center1.pos.z -= 0.005;
../render/gl_tile.c:1334:    tfvb->center2.pos.x -= 0.005;
../render/gl_tile.c:1335:    tfvb->center3.pos.x -= 0.005;
../render/gl_tile.c:1336:    tfvb->center4.pos.z += 0.005;
../render/gl_tile.c:1337:    tfvb->center5.pos.z += 0.005;
../render/gl_tile.c:1338:    tfvb->center6.pos.x += 0.005;
../render/gl_tile.c:1339:    tfvb->center7.pos.x += 0.005;
../render/gl_tile.c:1342:        tfvb->se0.material_idx = tri0_idx;
../render/gl_tile.c:1343:        tfvb->sw0.material_idx = tri0_idx;
../render/gl_tile.c:1344:        tfvb->sw1.material_idx = tri1_idx;
../render/gl_tile.c:1345:        tfvb->nw0.material_idx = tri1_idx;
../render/gl_tile.c:1346:        tfvb->nw1.material_idx = tri1_idx;
../render/gl_tile.c:1347:        tfvb->ne0.material_idx = tri1_idx;
../render/gl_tile.c:1348:        tfvb->ne1.material_idx = tri0_idx;
../render/gl_tile.c:1349:        tfvb->se1.material_idx = tri0_idx;
../render/gl_tile.c:1351:        tfvb->se0.normal = top_tri_normals[0];
../render/gl_tile.c:1352:        tfvb->sw0.normal = top_tri_normals[0];
../render/gl_tile.c:1353:        tfvb->sw1.normal = top_tri_normals[1];
../render/gl_tile.c:1354:        tfvb->nw0.normal = top_tri_normals[1];
../render/gl_tile.c:1355:        tfvb->nw1.normal = top_tri_normals[1];
../render/gl_tile.c:1356:        tfvb->ne0.normal = top_tri_normals[1];
../render/gl_tile.c:1357:        tfvb->ne1.normal = top_tri_normals[0];
../render/gl_tile.c:1358:        tfvb->se1.normal = top_tri_normals[0];
../render/gl_tile.c:1360:        tfvb->se0.material_idx = tri0_idx;
../render/gl_tile.c:1361:        tfvb->sw0.material_idx = tri0_idx;
../render/gl_tile.c:1362:        tfvb->sw1.material_idx = tri0_idx;
../render/gl_tile.c:1363:        tfvb->nw0.material_idx = tri0_idx;
../render/gl_tile.c:1364:        tfvb->nw1.material_idx = tri1_idx;
../render/gl_tile.c:1365:        tfvb->ne0.material_idx = tri1_idx;
../render/gl_tile.c:1366:        tfvb->ne1.material_idx = tri1_idx;
../render/gl_tile.c:1367:        tfvb->se1.material_idx = tri1_idx;
../render/gl_tile.c:1369:        tfvb->se0.normal = top_tri_normals[0];
../render/gl_tile.c:1370:        tfvb->sw0.normal = top_tri_normals[0];
../render/gl_tile.c:1371:        tfvb->sw1.normal = top_tri_normals[0];
../render/gl_tile.c:1372:        tfvb->nw0.normal = top_tri_normals[0];
../render/gl_tile.c:1373:        tfvb->nw1.normal = top_tri_normals[1];
../render/gl_tile.c:1374:        tfvb->ne0.normal = top_tri_normals[1];
../render/gl_tile.c:1375:        tfvb->ne1.normal = top_tri_normals[1];
../render/gl_tile.c:1376:        tfvb->se1.normal = top_tri_normals[1];
../render/gl_tile.c:1383:        curr_provoking->blend_mode = BLEND_MODE_NOBLEND;
../render/gl_tile.c:1389:        curr_provoking->blend_mode = tile->blend_mode;
../render/gl_ui.c:79:    PFM_Mat4x4_MakeOrthographic(0.0f, curr_vres.x, curr_vres.y, 0.0f, -1.0f, 1.0f, &ortho);
../render/gl_ui.c:87:    for(cmd = nk__draw_list_begin(dl, dl->buffer); cmd; 
../render/gl_ui.c:88:        cmd = nk__draw_list_next(cmd, dl->buffer, dl)) {
../render/gl_ui.c:90:        if(cmd->userdata.ptr) {
../render/gl_ui.c:92:            struct nk_command_userdata *ud = cmd->userdata.ptr;
../render/gl_ui.c:93:            switch(ud->type) {
../render/gl_ui.c:97:                curr_vres = ud->vec2i;
../render/gl_ui.c:99:                PFM_Mat4x4_MakeOrthographic(0.0f, ud->vec2i.x, ud->vec2i.y, 0.0f, -1.0f, 1.0f, &ortho);
../render/gl_ui.c:112:                R_GL_Texture_GetOrLoad(g_basepath, ud->texpath, (GLuint*)&cmd->texture.id);
../render/gl_ui.c:122:        if(!cmd->elem_count) 
../render/gl_ui.c:125:        struct texture tex = (struct texture){cmd->texture.id, GL_TEXTURE0};
../render/gl_ui.c:128:        glScissor((GLint)(cmd->clip_rect.x / (float)curr_vres.x * w),
../render/gl_ui.c:129:            h - (GLint)((cmd->clip_rect.y + cmd->clip_rect.h) / (float)curr_vres.y * h),
../render/gl_ui.c:130:            (GLint)(cmd->clip_rect.w / (float)curr_vres.x * w),
../render/gl_ui.c:131:            (GLint)(cmd->clip_rect.h / (float)curr_vres.y * h));
../render/gl_ui.c:133:        glDrawElements(GL_TRIANGLES, (GLsizei)cmd->elem_count, GL_UNSIGNED_SHORT, offset);
../render/gl_ui.c:136:        offset += cmd->elem_count;
../render/gl_ui.c:238:    glBufferData(GL_ARRAY_BUFFER, dl->vertices->memory.size, dl->vertices->memory.ptr, GL_STREAM_DRAW);
../render/gl_ui.c:240:    glBufferData(GL_ELEMENT_ARRAY_BUFFER, dl->elements->memory.size, dl->elements->memory.ptr, GL_STREAM_DRAW);
../render/gl_vertex.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/gl_vertex.h:73:    /* Each uint32_t holds 4 8-bit indices */
../render/gl_water.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../render/gl_water.c:79:#define WATER_LVL       (-1.0f * Y_COORDS_PER_TILE + 2.0f)
../render/gl_water.c:105:    glGetIntegerv(GL_VIEWPORT, out->viewport);
../render/gl_water.c:106:    glGetIntegerv(GL_FRAMEBUFFER_BINDING, &out->fb);
../render/gl_water.c:107:    glGetFloatv(GL_COLOR_CLEAR_VALUE, out->clear_clr);
../render/gl_water.c:113:    out->u_cam_pos = pval.val.as_vec3;
../render/gl_water.c:114:    out->u_view = tval.val.as_mat4;
../render/gl_water.c:124:    glBindFramebuffer(GL_FRAMEBUFFER, in->fb);
../render/gl_water.c:125:    glViewport(in->viewport[0], in->viewport[1], in->viewport[2], in->viewport[3]);
../render/gl_water.c:126:    glClearColor(in->clear_clr[0], in->clear_clr[1], in->clear_clr[2], in->clear_clr[3]);
../render/gl_water.c:127:    R_GL_SetViewMatAndPos(&in->u_view, &in->u_cam_pos);
../render/gl_water.c:214:    vec4_t plane_eq = (vec4_t){0.0f, -1.0f, 0.0f, WATER_LVL};
../render/gl_water.c:277:    cam_pos.y -= (cam_pos.y - WATER_LVL) * 2.0f;
../render/gl_water.c:278:    cam_dir.y *= -1.0f;
../render/gl_water.c:283:    /* Face culling is problematic when we're looking from below - changing 
../render/gl_water.c:317:        .val.as_int = REFRACT_TUNIT - GL_TEXTURE0
../render/gl_water.c:327:        .val.as_int = REFRACT_DEPTH_TUNIT - GL_TEXTURE0
../render/gl_water.c:337:        .val.as_int = REFLECT_TUNIT - GL_TEXTURE0
../render/gl_water.c:380:        .val.as_int = s_ctx.dudv.tunit - GL_TEXTURE0
../render/gl_water.c:390:        .val.as_int = s_ctx.normal.tunit - GL_TEXTURE0
../render/gl_water.c:471:    uint32_t delta = curr - s_ctx.prev_frame_tick;
../render/gl_water.c:508:    const vec3_t tr = (vec3_t){-1.0f, WATER_LVL, +1.0f};
../render/gl_water.c:509:    const vec3_t bl = (vec3_t){+1.0f, WATER_LVL, -1.0f};
../render/gl_water.c:510:    const vec3_t br = (vec3_t){-1.0f, WATER_LVL, -1.0f};
../render/gl_water.c:525:    /* Attribute 0 - position */
../render/gl_water.c:595:    setup_fog_uniforms(shader_prog, in->map);
../render/gl_water.c:596:    setup_model_mat(shader_prog, in->map);
../render/gl_water.c:598:    setup_tiling_uniforms(shader_prog, in->map);
../render/public/render.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/public/render.h:83:/* ---------------------------------------------------------------------------
../render/public/render.h:86: * ---------------------------------------------------------------------------
../render/public/render.h:90:/* ---------------------------------------------------------------------------
../render/public/render.h:93: * ---------------------------------------------------------------------------
../render/public/render.h:97:/* ---------------------------------------------------------------------------
../render/public/render.h:99: * ---------------------------------------------------------------------------
../render/public/render.h:103:/* ---------------------------------------------------------------------------
../render/public/render.h:105: * ---------------------------------------------------------------------------
../render/public/render.h:109:/* ---------------------------------------------------------------------------
../render/public/render.h:110: * Set OpenGL uniforms for animation-related shader programs.
../render/public/render.h:111: * ---------------------------------------------------------------------------
../render/public/render.h:116:/* ---------------------------------------------------------------------------
../render/public/render.h:118: * materials. The color is an RGB floating-point multiplier. 
../render/public/render.h:119: * ---------------------------------------------------------------------------
../render/public/render.h:123:/* ---------------------------------------------------------------------------
../render/public/render.h:125: * The color is an RGB floating-point multiplier. 
../render/public/render.h:126: * ---------------------------------------------------------------------------
../render/public/render.h:130:/* ---------------------------------------------------------------------------
../render/public/render.h:134: * ---------------------------------------------------------------------------
../render/public/render.h:138:/* ---------------------------------------------------------------------------
../render/public/render.h:143: * ---------------------------------------------------------------------------
../render/public/render.h:148:/* ---------------------------------------------------------------------------
../render/public/render.h:150: * ---------------------------------------------------------------------------
../render/public/render.h:154:/* ---------------------------------------------------------------------------
../render/public/render.h:156: * ---------------------------------------------------------------------------
../render/public/render.h:160:/* ---------------------------------------------------------------------------
../render/public/render.h:162: * ---------------------------------------------------------------------------
../render/public/render.h:167:/* ---------------------------------------------------------------------------
../render/public/render.h:169: * ---------------------------------------------------------------------------
../render/public/render.h:173:/* ---------------------------------------------------------------------------
../render/public/render.h:176: * ---------------------------------------------------------------------------
../render/public/render.h:181:/* ---------------------------------------------------------------------------
../render/public/render.h:183: * ---------------------------------------------------------------------------
../render/public/render.h:188:/* ---------------------------------------------------------------------------
../render/public/render.h:193: * ---------------------------------------------------------------------------
../render/public/render.h:198:/* ---------------------------------------------------------------------------
../render/public/render.h:200: * ---------------------------------------------------------------------------
../render/public/render.h:205:/* ---------------------------------------------------------------------------
../render/public/render.h:207: * ---------------------------------------------------------------------------
../render/public/render.h:212:/* ---------------------------------------------------------------------------
../render/public/render.h:214: * ---------------------------------------------------------------------------
../render/public/render.h:219:/* ---------------------------------------------------------------------------
../render/public/render.h:221: * ---------------------------------------------------------------------------
../render/public/render.h:226:/* ---------------------------------------------------------------------------
../render/public/render.h:230: * ---------------------------------------------------------------------------
../render/public/render.h:235:/* ---------------------------------------------------------------------------
../render/public/render.h:238: * ---------------------------------------------------------------------------
../render/public/render.h:243:/* ---------------------------------------------------------------------------
../render/public/render.h:247: * 0 z-dimention. The x and y dimentions correspond to screenspace coordinates.
../render/public/render.h:248: * ---------------------------------------------------------------------------
../render/public/render.h:252:/* ---------------------------------------------------------------------------
../render/public/render.h:257: * ---------------------------------------------------------------------------
../render/public/render.h:262:/* ---------------------------------------------------------------------------
../render/public/render.h:267: * ---------------------------------------------------------------------------
../render/public/render.h:272:/* ---------------------------------------------------------------------------
../render/public/render.h:273: * Get a nanosecond-resolution GPU timestamp for a previously created
../render/public/render.h:275: * ---------------------------------------------------------------------------
../render/public/render.h:283:/* ---------------------------------------------------------------------------
../render/public/render.h:285: * ---------------------------------------------------------------------------
../render/public/render.h:291:/* ---------------------------------------------------------------------------
../render/public/render.h:294: * ---------------------------------------------------------------------------
../render/public/render.h:302:/* ---------------------------------------------------------------------------
../render/public/render.h:305: * ---------------------------------------------------------------------------
../render/public/render.h:310:/* ---------------------------------------------------------------------------
../render/public/render.h:311: * Update a chunk-sized region of the minimap texture with up-to-date mesh 
../render/public/render.h:313: * ---------------------------------------------------------------------------
../render/public/render.h:318:/* ---------------------------------------------------------------------------
../render/public/render.h:323: * ---------------------------------------------------------------------------
../render/public/render.h:328:/* ---------------------------------------------------------------------------
../render/public/render.h:330: * ---------------------------------------------------------------------------
../render/public/render.h:336:/* ---------------------------------------------------------------------------
../render/public/render.h:338: * ---------------------------------------------------------------------------
../render/public/render.h:342:/* ---------------------------------------------------------------------------
../render/public/render.h:347: * ---------------------------------------------------------------------------
../render/public/render.h:351:/* ---------------------------------------------------------------------------
../render/public/render.h:354: * ---------------------------------------------------------------------------
../render/public/render.h:362:/* ---------------------------------------------------------------------------
../render/public/render.h:364: * ---------------------------------------------------------------------------
../render/public/render.h:369:/* ---------------------------------------------------------------------------
../render/public/render.h:371: * ---------------------------------------------------------------------------
../render/public/render.h:375:/* ---------------------------------------------------------------------------
../render/public/render.h:378: * ---------------------------------------------------------------------------
../render/public/render.h:382:/* ---------------------------------------------------------------------------
../render/public/render.h:384: * ---------------------------------------------------------------------------
../render/public/render.h:388:/* ---------------------------------------------------------------------------
../render/public/render.h:389: * Send the current-frame fog-of-war information to the rendering susbsystem.
../render/public/render.h:390: * ---------------------------------------------------------------------------
../render/public/render.h:394:/* ---------------------------------------------------------------------------
../render/public/render.h:397: * ---------------------------------------------------------------------------
../render/public/render.h:405:/* ---------------------------------------------------------------------------
../render/public/render.h:409: * ---------------------------------------------------------------------------
../render/public/render.h:413:/* ---------------------------------------------------------------------------
../render/public/render.h:416: * ---------------------------------------------------------------------------
../render/public/render.h:420:/* ---------------------------------------------------------------------------
../render/public/render.h:423: * ---------------------------------------------------------------------------
../render/public/render.h:427:/* ---------------------------------------------------------------------------
../render/public/render.h:429: * An up-to-date frustum is generated during 'R_GL_DepthPassBegin'
../render/public/render.h:430: * ---------------------------------------------------------------------------
../render/public/render.h:434:/* ---------------------------------------------------------------------------
../render/public/render.h:436: * ---------------------------------------------------------------------------
../render/public/render.h:444:/* ---------------------------------------------------------------------------
../render/public/render.h:446: * ---------------------------------------------------------------------------
../render/public/render.h:450:/* ---------------------------------------------------------------------------
../render/public/render.h:452: * ---------------------------------------------------------------------------
../render/public/render.h:456:/* ---------------------------------------------------------------------------
../render/public/render.h:458: * ---------------------------------------------------------------------------
../render/public/render.h:467:/* ---------------------------------------------------------------------------
../render/public/render.h:469: * ---------------------------------------------------------------------------
../render/public/render.h:473:/* ---------------------------------------------------------------------------
../render/public/render.h:475: * ---------------------------------------------------------------------------
../render/public/render.h:479:/* ---------------------------------------------------------------------------
../render/public/render.h:482: * ---------------------------------------------------------------------------
../render/public/render.h:486:/* ---------------------------------------------------------------------------
../render/public/render.h:488: * ---------------------------------------------------------------------------
../render/public/render.h:502:/* ---------------------------------------------------------------------------
../render/public/render.h:503: * Draw all the camera-visible entities in the render input, making use of 
../render/public/render.h:505: * R_GL_Draw(...) for every camera-visible entitiy. Meshes and textures that are 
../render/public/render.h:507: * ---------------------------------------------------------------------------
../render/public/render.h:511:/* ---------------------------------------------------------------------------
../render/public/render.h:512: * Like 'R_GL_Batch_Draw' but using the specified batch instead of per-chunk batches.
../render/public/render.h:513: * ---------------------------------------------------------------------------
../render/public/render.h:517:/* ---------------------------------------------------------------------------
../render/public/render.h:518: * Update the depth map for every light-visible entity in the render input.
../render/public/render.h:520: * light-visible entity.
../render/public/render.h:521: * ---------------------------------------------------------------------------
../render/public/render.h:525:/* ---------------------------------------------------------------------------
../render/public/render.h:526: * Free all the resources used by live batches. Free all the per-chunk batches,
../render/public/render.h:528: * ---------------------------------------------------------------------------
../render/public/render.h:532:/* ---------------------------------------------------------------------------
../render/public/render.h:535: * ---------------------------------------------------------------------------
../render/public/render_al.h:46:/* ---------------------------------------------------------------------------
../render/public/render_al.h:49: * ---------------------------------------------------------------------------
../render/public/render_al.h:53:/* ---------------------------------------------------------------------------
../render/public/render_al.h:55: * ---------------------------------------------------------------------------
../render/public/render_al.h:59:/* ---------------------------------------------------------------------------
../render/public/render_al.h:62: * ---------------------------------------------------------------------------
../render/public/render_al.h:66:/* ---------------------------------------------------------------------------
../render/public/render_al.h:71: * ---------------------------------------------------------------------------
../render/public/render_ctrl.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../render/render.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/render.c:72:/* write-once strings. Set by render thread at initialization */
../render/render.c:84:    if(new_val->type != ST_TYPE_VEC2)
../render/render.c:88:    return (new_val->as_vec2.x / new_val->as_vec2.y >= AR_MIN)
../render/render.c:89:        && (new_val->as_vec2.x / new_val->as_vec2.y <= AR_MAX);
../render/render.c:101:    float new_ratio = new_val->as_vec2.x/new_val->as_vec2.y;
../render/render.c:102:    if(fabs(new_ratio - curr_ratio) < EPSILON)
../render/render.c:128:    if(new_val->type != ST_TYPE_VEC2)
../render/render.c:137:        if(fabs(new_val->as_vec2.x / new_val->as_vec2.y - set_ar) > EPSILON)
../render/render.c:143:    return (new_val->as_vec2.x >= DIM_MIN && new_val->as_vec2.x <= DIM_MAX)
../render/render.c:144:        && (new_val->as_vec2.y >= DIM_MIN && new_val->as_vec2.y <= DIM_MAX);
../render/render.c:149:    int rval = Engine_SetRes(new_val->as_vec2.x, new_val->as_vec2.y);
../render/render.c:170:    assert(new_val->type == ST_TYPE_INT);
../render/render.c:171:    if(new_val->type != ST_TYPE_INT)
../render/render.c:174:    return new_val->as_int == PF_WF_FULLSCREEN
../render/render.c:175:        || new_val->as_int == PF_WF_BORDERLESS_WIN
../render/render.c:176:        || new_val->as_int == PF_WF_WINDOW;
../render/render.c:181:    Engine_SetDispMode(new_val->as_int);
../render/render.c:186:    return (new_val->type == ST_TYPE_BOOL);
../render/render.c:199:        .args = { R_PushArg(&new_val->as_bool, sizeof(bool)) }
../render/render.c:205:    return (new_val->type == ST_TYPE_INT);
../render/render.c:228:        .args = { R_PushArg(&new_val->as_int, sizeof(int)) },
../render/render.c:242:        .args = { R_PushArg(&new_val->as_bool, sizeof(bool)) }
../render/render.c:248:    SDL_LockMutex(rstate->sq_lock);
../render/render.c:249:    while(!rstate->start && !rstate->quit)
../render/render.c:250:        SDL_CondWait(rstate->sq_cond, rstate->sq_lock);
../render/render.c:252:    if(rstate->quit) {
../render/render.c:254:        rstate->quit = false;
../render/render.c:255:        SDL_UnlockMutex(rstate->sq_lock);
../render/render.c:259:    assert(rstate->start == true);
../render/render.c:260:    rstate->start = false;
../render/render.c:261:    SDL_UnlockMutex(rstate->sq_lock);
../render/render.c:267:    SDL_LockMutex(rstate->done_lock);
../render/render.c:268:    rstate->done = true;
../render/render.c:269:    SDL_CondSignal(rstate->done_cond);
../render/render.c:270:    SDL_UnlockMutex(rstate->done_lock);
../render/render.c:323:    SDL_GL_MakeCurrent(arg->in_window, s_context);
../render/render.c:328:        arg->out_success = false;
../render/render.c:334:        arg->out_success = false;
../render/render.c:344:    int vp[4] = {0 ,0, arg->in_width, arg->in_height};
../render/render.c:353:        arg->out_success = false;
../render/render.c:359:    strncpy(s_info_vendor,     (const char*)glGetString(GL_VENDOR),   ARR_SIZE(s_info_vendor)-1);
../render/render.c:360:    strncpy(s_info_renderer,   (const char*)glGetString(GL_RENDERER), ARR_SIZE(s_info_renderer)-1);
../render/render.c:361:    strncpy(s_info_version,    (const char*)glGetString(GL_VERSION),  ARR_SIZE(s_info_version)-1);
../render/render.c:362:    strncpy(s_info_sl_version, (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION), ARR_SIZE(s_info_sl_version)-1);
../render/render.c:364:    arg->out_success = true;
../render/render.c:510:    SDL_Window *window = rstate->arg->in_window; /* cache window ptr */
../render/render.c:516:    render_init_ctx(rstate->arg);
../render/render.c:517:    bool initialized = rstate->arg->out_success;
../render/render.c:519:    rstate->arg = NULL; /* arg is stale after signalling main thread */
../render/render.c:528:        render_process_cmds(&G_GetRenderWS()->commands);
../render/render.c:529:        if(rstate->swap_buffers) {
../render/render.c:531:            SDL_mutex* swaplock = (((struct SDL_WindowData_impl*)((struct SDL_Window_impl*)window)->driverdata)->videodata)->swaplock;
../render/render.c:538:            else if (ret == -1) {
../render/render.c:552:            ((void(*)(void*, SEL))objc_msgSend)(nscontext, NSSelectorFromString(aCFString)); // Call the `flushBuffer` method on the current SDLOpenGLContext object (which inherits from NSOpenGLContext : https://developer.apple.com/documentation/appkit/nsopenglcontext/1436211-flushbuffer?language=objc )
../render/render.c:710:    s_context = SDL_GL_CreateContext(rstate->arg->in_window);
../render/render.c:715:    SDL_GL_MakeCurrent(rstate->arg->in_window, NULL);
../render/render.c:724:    void *ret = stalloc(&ws->args, size);
../render/render.c:743:    queue_rcmd_push(&ws->commands, &cmd);
../render/render.c:748:    if(!stalloc_init(&ws->args)) 
../render/render.c:751:    if(!queue_rcmd_init(&ws->commands, 2048))
../render/render.c:757:    stalloc_destroy(&ws->args);
../render/render.c:764:    queue_rcmd_destroy(&ws->commands);
../render/render.c:765:    stalloc_destroy(&ws->args);
../render/render.c:770:    queue_rcmd_clear(&ws->commands);
../render/render.c:771:    stalloc_clear(&ws->args);
../render/render_asset_load.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../render/render_asset_load.c:72:    if(!sscanf(line, "v %f %f %f", &out->pos.x, &out->pos.y, &out->pos.z))
../render/render_asset_load.c:76:    if(!sscanf(line, "vt %f %f", &out->uv.x, &out->uv.y))
../render/render_asset_load.c:80:    if(!sscanf(line, "vn %f %f %f", &out->normal.x, &out->normal.y, &out->normal.z))
../render/render_asset_load.c:88:    if(!sscanf(line, "vm %d", &out->material_idx))
../render/render_asset_load.c:110:    memset(out->weights, 0, sizeof(out->weights));
../render/render_asset_load.c:111:    memset(out->joint_indices, 0, sizeof(out->joint_indices));
../render/render_asset_load.c:122:        if(!sscanf(string, "%d/%f", &idx, &out->weights[i]))
../render/render_asset_load.c:124:        out->joint_indices[i] = idx;
../render/render_asset_load.c:139:    /* Consume the first line with the name - we don't use it currently */
../render/render_asset_load.c:151:    if(!sscanf(line, " ambient %f", &out->ambient_intensity))
../render/render_asset_load.c:155:    if(!sscanf(line, " diffuse %f %f %f", &out->diffuse_clr.x, &out->diffuse_clr.y, &out->diffuse_clr.z))
../render/render_asset_load.c:159:    if(!sscanf(line, " specular %f %f %f", &out->specular_clr.x, &out->specular_clr.y, &out->specular_clr.z))
../render/render_asset_load.c:163:    if(!sscanf(line, " texture %" STREVAL(sizeof(out->texname)) "s",  out->texname))
../render/render_asset_load.c:165:    out->texname[sizeof(out->texname)-1] = '\0';
../render/render_asset_load.c:172:            R_PushArg(out->texname, strlen(out->texname) + 1),
../render/render_asset_load.c:173:            &out->texture.id,
../render/render_asset_load.c:189:    ret += header->num_materials * sizeof(struct material);
../render/render_asset_load.c:201: *  +---------------------------------+ <-- base
../render/render_asset_load.c:203: *  +---------------------------------+
../render/render_asset_load.c:205: *  +---------------------------------+
../render/render_asset_load.c:216:    bool anim = (header->num_as > 0);
../render/render_asset_load.c:217:    priv->vertex_stride = anim ? sizeof(struct anim_vert) : sizeof(struct vertex);
../render/render_asset_load.c:219:    size_t vbuff_sz = header->num_verts * priv->vertex_stride;
../render/render_asset_load.c:224:    priv->mesh.num_verts = header->num_verts;
../render/render_asset_load.c:225:    priv->num_materials = header->num_materials;
../render/render_asset_load.c:226:    priv->materials = (void*)(priv + 1);
../render/render_asset_load.c:228:    for(int i = 0; i < header->num_verts; i++) {
../render/render_asset_load.c:242:    for(int i = 0; i < header->num_materials; i++) {
../render/render_asset_load.c:245:        priv->materials[i].texture.tunit = GL_TEXTURE0 + i;
../render/render_asset_load.c:246:        priv->materials[i].texture.id = -1;
../render/render_asset_load.c:247:        if(!al_read_material(stream, base_path, &priv->materials[i], &null)) 
../render/render_asset_load.c:258:        shader = anim ? "mesh.animated.textured-phong-shadowed" 
../render/render_asset_load.c:259:                      : "mesh.static.textured-phong-shadowed";
../render/render_asset_load.c:261:        shader = anim ? "mesh.animated.textured-phong" 
../render/render_asset_load.c:262:                      : "mesh.static.textured-phong";
../render/render_asset_load.c:289:    glBindBuffer(GL_ARRAY_BUFFER, priv->mesh.VBO);
../render/render_asset_load.c:294:    for(int i = 0; i < priv->mesh.num_verts; i++) {
../render/render_asset_load.c:296:        struct vertex *v = (struct vertex*)(((char*)vbuff) + priv->vertex_stride * i);
../render/render_asset_load.c:298:        fprintf(stream, "v %.6f %.6f %.6f\n", v->pos.x, v->pos.y, v->pos.z); 
../render/render_asset_load.c:299:        fprintf(stream, "vt %.6f %.6f \n", v->uv.x, v->uv.y); 
../render/render_asset_load.c:300:        fprintf(stream, "vn %.6f %.6f %.6f\n", v->normal.x, v->normal.y, v->normal.z);
../render/render_asset_load.c:303:        if(strstr("animated", R_GL_Shader_GetName(priv->shader_prog))) {
../render/render_asset_load.c:307:                if(av->weights[j]) {
../render/render_asset_load.c:308:                    fprintf(stream, "%d/%.6f ", av->joint_indices[j], av->weights[j]);
../render/render_asset_load.c:314:        fprintf(stream, "vm %d\n", v->material_idx); 
../render/render_asset_load.c:320:    for(int i = 0; i < priv->num_materials; i++) {
../render/render_asset_load.c:322:        struct material *m = &priv->materials[i];
../render/render_asset_load.c:329:        fprintf(stream, "\tambient %.6f\n", m->ambient_intensity);
../render/render_asset_load.c:331:            m->diffuse_clr.x, m->diffuse_clr.y, m->diffuse_clr.z);
../render/render_asset_load.c:333:            m->specular_clr.x, m->specular_clr.y, m->specular_clr.z);
../render/render_asset_load.c:334:        fprintf(stream, "\ttexture %s\n", m->texname);
../render/render_asset_load.c:365:    priv->vertex_stride = sizeof(struct terrain_vert);
../render/render_asset_load.c:366:    priv->mesh.num_verts = num_verts;
../render/render_asset_load.c:367:    priv->materials = (void*)unused_base;
../render/render_asset_load.c:368:    priv->num_materials = 0;
../render/render_asset_load.c:382:    const char *shader = sh_setting.as_bool ? "terrain-shadowed" : "terrain";
../render/render_private.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../scene.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../scene.c:87:        assert(ret != -1 && ret != 0);
../scene.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../sched.c:144:#define ALIGNED(val, align)     (((val) + ((align) - 1)) & ~((align) - 1))
../sched.c:184: * notified when the ready queue(s) becomes non-empty, so that
../sched.c:190: * We have 2 diff. queues to allow only de-queuing tasks based
../sched.c:231:"# parameter 0 (%rcx) - save ctx ptr            \n"
../sched.c:232:"# parameter 1 (%rdx) - load ctx ptr            \n"
../sched.c:233:"# parameter 2 (%r8)  - return value            \n"
../sched.c:234:"# parameter 3 (%r9)  - arg passed to           \n"
../sched.c:295:"# (%rax) - pointer to 128 bits of task result  \n"
../sched.c:307:#ifndef __APPLE__ // https://stackoverflow.com/questions/19720084/what-is-the-difference-between-assembly-on-mac-and-assembly-on-linux/19725269#19725269 <- https://stackoverflow.com/questions/20907946/error-unknown-directive-type-func-function
../sched.c:311:"# parameter 0 (%rdi) - save ctx ptr            \n"
../sched.c:312:"# parameter 1 (%rsi) - load ctx ptr            \n"
../sched.c:313:"# parameter 2 (%rdx) - return value            \n"
../sched.c:314:"# parameter 3 (%rcx) - arg passed to           \n"
../sched.c:358:"# (%rax) - low 64 bits of task result          \n"
../sched.c:359:"# (%rdx) - high 64 bits of task result         \n"
../sched.c:379:    const size_t stack_size = (task->flags & TASK_BIG_STACK) ? BIG_STACK_SZ : STACK_SZ;
../sched.c:380:    char *stack_end = task->stackmem;
../sched.c:384:        stack_base -= 32;
../sched.c:388:     * is responsible for context-switching out of the 
../sched.c:390:    stack_base -= 8;
../sched.c:395:    stack_base -= 8;
../sched.c:398:    memset(&task->ctx, 0, sizeof(task->ctx));
../sched.c:399:    task->ctx.rsp = (uintptr_t)stack_base;
../sched.c:401:    /* +-------------------------------------------------------------------+
../sched.c:403:     * + ---------------+--------------------------------------------------+
../sched.c:405:     * | FPCSR[7]       | Reserved - 0                                     |
../sched.c:406:     * | FPCSR[8:9]     | Precision Control - 10B (double precision)       |
../sched.c:407:     * | FPCSR[10:11]   | Rounding control - 0 (round to nearest)          |
../sched.c:408:     * | FPCSR[12]      | Infinity control - 0 (not used)                  |
../sched.c:409:     * +----------------+--------------------------------------------------+
../sched.c:411:    task->ctx.fpucw = (((uint16_t)(0x0  & 0x1 )) << 12)
../sched.c:418:     * They are caller-saved, so their initial state doesn't matter.
../sched.c:420:     * +-------------------------------------------------------------------+
../sched.c:422:     * + ---------------+--------------------------------------------------+
../sched.c:423:     * | MXCSR[6]       | Denormals are zeros - 0                          |
../sched.c:425:     * | MXCSR[13:14]   | Rounding control - 0 (round to nearest)          |
../sched.c:426:     * | MXCSR[15]      | Flush to zero for masked underflow - 0 (off)     |
../sched.c:427:     * +----------------+--------------------------------------------------+
../sched.c:429:    task->ctx.mxcsr = (((uint32_t)(0x0  & 0x1 )) << 15)
../sched.c:444:    return task->ctx.rsp;
../sched.c:448: * code is compiled with -fno-omit-framepointer.
../sched.c:459:    return *(((uint64_t*)(task->ctx.rbp)) + 1);
../sched.c:475:        printf("#%-2d 0x%016" PRIx64 "\n", i++, retaddr);
../sched.c:487:    uintptr_t sp = task->ctx.rsp;
../sched.c:491:    size_t size = (task->flags & TASK_BIG_STACK) ? BIG_STACK_SZ : STACK_SZ;
../sched.c:492:    if(sp < (uintptr_t)task->stackmem)
../sched.c:495:    if(sp >= ((uintptr_t)task->stackmem) + size)
../sched.c:549:    if(ret->prev)
../sched.c:550:        ret->prev->next = ret->next;
../sched.c:551:    if(ret->next)
../sched.c:552:        ret->next->prev = ret->prev;
../sched.c:554:    s_freehead = s_freehead->next;
../sched.c:555:    s_nfree--;
../sched.c:561:    task->next = s_freehead;
../sched.c:562:    task->prev = NULL;
../sched.c:564:        s_freehead->prev = task;
../sched.c:572:    task->state = TASK_STATE_READY;
../sched.c:574:    if(task->flags & TASK_MAIN_THREAD_PINNED) {
../sched.c:575:        pq_task_push(&s_ready_queue_main, task->prio, task);
../sched.c:577:        pq_task_push(&s_ready_queue, task->prio, task);
../sched.c:587:    struct task *task = &s_tasks[tid - 1];
../sched.c:589:    if(task->future) {
../sched.c:590:        task->future->res = ret;
../sched.c:591:        SDL_AtomicSet(&task->future->status, FUTURE_COMPLETE);
../sched.c:594:    if(task->destructor) {
../sched.c:595:        task->destructor(task->darg);
../sched.c:598:    if(task->erelease) {
../sched.c:599:        task->erelease(task->earg);
../sched.c:600:        task->erelease = NULL;
../sched.c:601:        task->earg = NULL;
../sched.c:604:    task->req.type = _SCHED_REQ_FREE;
../sched.c:607:        sched_switch_ctx(&task->ctx, &s_main_ctx, 0, NULL);
../sched.c:610:        sched_switch_ctx(&task->ctx, &s_worker_contexts[id], 0, NULL);
../sched.c:619:    task->prio = prio;
../sched.c:620:    task->parent_tid = parent;
../sched.c:621:    task->flags = flags;
../sched.c:622:    task->retval = 0;
../sched.c:623:    task->arg = arg;
../sched.c:624:    task->destructor = NULL;
../sched.c:625:    task->darg = NULL;
../sched.c:626:    task->future = future;
../sched.c:627:    task->earg = NULL;
../sched.c:628:    task->erelease = NULL;
../sched.c:630:    if(task->future) {
../sched.c:631:        SDL_AtomicSet(&task->future->status, FUTURE_INCOMPLETE);    
../sched.c:635:        task->stackmem = malloc(BIG_STACK_SZ);
../sched.c:637:        task->stackmem = s_stacks[task->tid - 1];
../sched.c:646:    struct task *recv_task = &s_tasks[tid - 1];
../sched.c:648:    /* write data to blocked send-blocked task to unblock it */
../sched.c:649:    if(recv_task->state == TASK_STATE_SEND_BLOCKED) {
../sched.c:651:        uint32_t *out_send = (uint32_t*)recv_task->req.argv[0];
../sched.c:652:        void *dst = (void*)recv_task->req.argv[1];
../sched.c:653:        size_t dstlen = (size_t)recv_task->req.argv[2];
../sched.c:657:        *out_send = task->tid;
../sched.c:659:        task->state = TASK_STATE_REPLY_BLOCKED;
../sched.c:660:        assert(recv_task->state != TASK_STATE_EVENT_BLOCKED);
../sched.c:665:        task->state = TASK_STATE_RECV_BLOCKED;
../sched.c:666:        queue_tid_push(&s_msg_queues[tid - 1], &task->tid);
../sched.c:672:    if(queue_size(s_msg_queues[task->tid - 1]) > 0) {
../sched.c:675:        assert(task->state != TASK_STATE_SEND_BLOCKED);
../sched.c:676:        queue_tid_pop(&s_msg_queues[task->tid - 1], &send_tid);
../sched.c:679:        struct task *send_task = &s_tasks[send_tid - 1];
../sched.c:680:        void *src = (void*)send_task->req.argv[1];
../sched.c:681:        size_t srclen = (size_t)send_task->req.argv[2];
../sched.c:687:        assert(send_task->state == TASK_STATE_RECV_BLOCKED);
../sched.c:688:        send_task->state = TASK_STATE_REPLY_BLOCKED;
../sched.c:689:        assert(task->state != TASK_STATE_EVENT_BLOCKED);
../sched.c:694:        task->state = TASK_STATE_SEND_BLOCKED;
../sched.c:700:    struct task *send_task = &s_tasks[tid - 1];
../sched.c:701:    assert(send_task->state == TASK_STATE_REPLY_BLOCKED);
../sched.c:703:    void *dst = (void*)send_task->req.argv[3];
../sched.c:704:    size_t dstlen = (size_t)send_task->req.argv[4];
../sched.c:709:    assert(send_task->state != TASK_STATE_EVENT_BLOCKED);
../sched.c:711:    assert(task->state != TASK_STATE_EVENT_BLOCKED);
../sched.c:728:            task->erelease = free;
../sched.c:731:            task->erelease = free;
../sched.c:737:            task->erelease = free;
../sched.c:742:            task->erelease = NULL;
../sched.c:745:    task->earg = (void*)(uintptr_t)ret;
../sched.c:751:    if(task->destructor) {
../sched.c:752:        task->destructor(task->darg);
../sched.c:754:    if(task->erelease) {
../sched.c:755:        task->erelease(task->earg);
../sched.c:761:    task->state = TASK_STATE_EVENT_BLOCKED;
../sched.c:769:        assert(status != -1 && status != 0);
../sched.c:772:    queue_tid_push(&kh_val(s_event_queues, k), &task->tid);
../sched.c:783:    return task->tid;
../sched.c:791:    struct task *child = &s_tasks[child_tid - 1];
../sched.c:792:    if(child->parent_tid != task->tid
../sched.c:793:    || (child->flags & TASK_DETACHED))
../sched.c:796:    if(child->state == TASK_STATE_ZOMBIE) {
../sched.c:798:        assert(task->state != TASK_STATE_EVENT_BLOCKED);
../sched.c:803:    s_parent_waiting[child_tid - 1] = true;
../sched.c:810:    sched_set_thread_tid(thisThreadID(), task->tid);
../sched.c:811:    task->state = TASK_STATE_ACTIVE;
../sched.c:815:    pf_snprintf(name, sizeof(name), "Task %03u", task->tid);
../sched.c:819:        sched_switch_ctx(&s_main_ctx, &task->ctx, task->retval, task->arg);
../sched.c:822:        sched_switch_ctx(&s_worker_contexts[id], &task->ctx, task->retval, task->arg);
../sched.c:835:    switch((int)task->req.type) {
../sched.c:837:        task->retval = sched_create(
../sched.c:838:            (int)           task->req.argv[0],
../sched.c:839:            (task_func_t)   task->req.argv[1],
../sched.c:840:            (void*)         task->req.argv[2],
../sched.c:841:            (struct future*)task->req.argv[3],
../sched.c:842:            (int)           task->req.argv[4],
../sched.c:843:            task->tid
../sched.c:848:        task->retval = task->tid;
../sched.c:852:        task->retval = task->parent_tid;
../sched.c:861:            (uint32_t)  task->req.argv[0], 
../sched.c:862:            (void*)     task->req.argv[1], 
../sched.c:863:            (size_t)    task->req.argv[2]
../sched.c:869:            (uint32_t*) task->req.argv[0], 
../sched.c:870:            (void*)     task->req.argv[1], 
../sched.c:871:            (size_t)    task->req.argv[2]
../sched.c:877:            (uint32_t)  task->req.argv[0], 
../sched.c:878:            (void*)     task->req.argv[1], 
../sched.c:879:            (size_t)    task->req.argv[2]
../sched.c:885:            (int)       task->req.argv[0]
../sched.c:890:        task->destructor = (void (*)(void*))task->req.argv[0];
../sched.c:891:        task->darg = (void*)task->req.argv[1];
../sched.c:895:        task->retval = sched_wait(task, task->req.argv[0]);
../sched.c:899:        if(task->flags & TASK_BIG_STACK) {
../sched.c:900:            PF_FREE(task->stackmem);
../sched.c:902:        if(task->flags & TASK_DETACHED) {
../sched.c:904:        }else if(s_parent_waiting[task->tid - 1]) {
../sched.c:906:            struct task *parent = &s_tasks[task->parent_tid - 1];
../sched.c:907:            s_parent_waiting[task->tid - 1] = false;
../sched.c:908:            assert(parent->state != TASK_STATE_EVENT_BLOCKED);
../sched.c:912:            task->state = TASK_STATE_ZOMBIE;
../sched.c:917:        struct task *requested = &s_tasks[((uint32_t)task->req.argv[0]) - 1];
../sched.c:926:    if(task->erelease) {
../sched.c:927:        task->erelease(task->earg);
../sched.c:928:        task->erelease = NULL;
../sched.c:929:        task->earg = NULL;
../sched.c:951:    assert(status != -1 && status != 0);
../sched.c:957:        //uint64_t key = thread_id_to_key(s_worker_thread_id[&s_worker_threads[i] - s_worker_threads]);
../sched.c:961:        assert(status != -1 && status != 0);
../sched.c:972:        //uint64_t key = thread_id_to_key(s_worker_thread_id[&s_worker_threads[i] - s_worker_threads]);
../sched.c:977:        assert(status != -1 && status != 0);
../sched.c:1041:    s_nwaiters--;
../sched.c:1080:    return ((uintptr_t)(ta) - (uintptr_t)(tb));
../sched.c:1126:    s_tasks[MAX_TASKS-1].prev = &s_tasks[MAX_TASKS - 2];
../sched.c:1127:    s_tasks[MAX_TASKS-1].next = NULL;
../sched.c:1129:    for(int i = 1; i < MAX_TASKS-1; i++) {
../sched.c:1131:        s_tasks[i].prev = &s_tasks[i - 1];
../sched.c:1143:    /* On a single-core system, all the tasks will just be run on the main thread */
../sched.c:1144:    s_nworkers = SDL_GetCPUCount() - 1;
../sched.c:1163:        pf_snprintf(threadname, sizeof(threadname), "worker-%d", i);
../sched.c:1265:        struct task *task = &s_tasks[tid - 1];
../sched.c:1266:        assert(task->state == TASK_STATE_EVENT_BLOCKED);
../sched.c:1268:        int *source = (void*)task->req.argv[1];
../sched.c:1276:        task->retval = sched_retain_arg(task, event, event_source, arg);
../sched.c:1290:        struct task *task = &s_tasks[tid - 1];
../sched.c:1329:    /* Use a do-while to ensure we're always making at least _some_ forward progress */
../sched.c:1341:                        ? SCHED_TICK_MS - Perf_CurrFrameMS() 
../sched.c:1352:            float prio_main = -1.0, prio_gen = -1.0;
../sched.c:1398:    struct task *task = &s_tasks[tid - 1];
../sched.c:1399:    if(!(task->flags & TASK_DETACHED)) {
../sched.c:1402:    if(task->state != TASK_STATE_READY) {
../sched.c:1464:            struct task *curr = &s_tasks[queue->mem[i] - 1];
../sched.c:1474:            struct task *curr = &s_tasks[queue->mem[i] - 1];
../sched.c:1490:    s_tasks[MAX_TASKS-1].prev = &s_tasks[MAX_TASKS - 2];
../sched.c:1491:    s_tasks[MAX_TASKS-1].next = NULL;
../sched.c:1493:    for(int i = 1; i < MAX_TASKS-1; i++) {
../sched.c:1495:        s_tasks[i].prev = &s_tasks[i - 1];
../sched.c:1506:    struct task *task = &s_tasks[tid - 1];
../sched.c:1508:    task->req = req;
../sched.c:1511:        return sched_switch_ctx(&task->ctx, &s_main_ctx, 0, NULL);
../sched.c:1514:        return sched_switch_ctx(&task->ctx, &s_worker_contexts[id], 0, NULL);
../sched.c:1525:    return (SDL_AtomicGet((SDL_atomic_t*)&future->status) == FUTURE_COMPLETE);
../sched.c:1566:    struct task *task = &s_tasks[tid - 1];
../sched.c:1567:    return (task->flags & TASK_BIG_STACK);
../sched.c:1604:    ret = s_tasks[tid - 1].state == TASK_STATE_READY;
../sched.h:59:/* Careful changing the size of this. It is assumed to be (64-128] bits 
../script/private_types.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../script/public/script.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../script/public/script.h:68: * No-op in the case of a NULL-pointer passed in */
../script/public/script.h:76:/* This value is not persistent accross sessions - careful */
../script/py_camera.c:159:    "  - mode {pf.CAM_MODE_RTS, pf.CAM_MODE_FPS, pf.CAM_MODE_FREE}  \n"
../script/py_camera.c:160:    "  - position (tuple of 3 floats)                               \n"
../script/py_camera.c:161:    "  - pitch (float)                                              \n"
../script/py_camera.c:162:    "  - yaw (float)                                                \n"
../script/py_camera.c:163:    "  - speed (float)                                              \n"
../script/py_camera.c:164:    "  - sensitivity (float)                                        \n"
../script/py_camera.c:197:    PyCameraObject *self = (PyCameraObject*)type->tp_alloc(type, 0);
../script/py_camera.c:213:    self->mode = mode;
../script/py_camera.c:214:    self->cam = cam;
../script/py_camera.c:221:    if(self->cam != G_GetActiveCamera()) {
../script/py_camera.c:222:        Camera_Free(self->cam);
../script/py_camera.c:224:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_camera.c:232:    vec3_t pos = Camera_GetPos(self->cam);
../script/py_camera.c:235:    float pitch = Camera_GetPitch(self->cam);
../script/py_camera.c:236:    float yaw = Camera_GetYaw(self->cam);
../script/py_camera.c:243:        return -1;
../script/py_camera.c:253:        return -1;
../script/py_camera.c:264:    Camera_SetPos(self->cam, pos);
../script/py_camera.c:265:    Camera_SetPitchAndYaw(self->cam, pitch, yaw);
../script/py_camera.c:266:    Camera_SetSpeed(self->cam, speed);
../script/py_camera.c:267:    Camera_SetSens(self->cam, sens);
../script/py_camera.c:280:    vec3_t dir = Camera_GetDir(self->cam);
../script/py_camera.c:281:    vec3_t pos = Camera_GetPos(self->cam);
../script/py_camera.c:284:    bool hit = M_Raycast_CameraIntersecCoord(self->cam, &map_intersect);
../script/py_camera.c:308:    Camera_SetPos(self->cam, newpos);
../script/py_camera.c:326:    PyObject *mode = PyInt_FromLong(self->mode);
../script/py_camera.c:332:    vec3_t cam_pos = Camera_GetPos(self->cam);
../script/py_camera.c:339:    PyObject *pitch = PyFloat_FromDouble(Camera_GetPitch(self->cam));
../script/py_camera.c:345:    PyObject *yaw = PyFloat_FromDouble(Camera_GetYaw(self->cam));
../script/py_camera.c:351:    PyObject *speed = PyFloat_FromDouble(Camera_GetSpeed(self->cam));
../script/py_camera.c:357:    PyObject *sens = PyFloat_FromDouble(Camera_GetSens(self->cam));
../script/py_camera.c:470:    if(self->mode != CAM_MODE_FREE) {
../script/py_camera.c:479:    return PyInt_FromLong(self->mode);
../script/py_camera.c:484:    vec3_t pos = Camera_GetPos(self->cam);
../script/py_camera.c:491:        return -1;
../script/py_camera.c:501:        return -1;
../script/py_camera.c:504:    Camera_SetPos(self->cam, newpos);
../script/py_camera.c:510:    vec3_t dir = Camera_GetDir(self->cam);
../script/py_camera.c:516:    return PyFloat_FromDouble(Camera_GetPitch(self->cam));
../script/py_camera.c:522:        return -1;
../script/py_camera.c:526:        return -1;
../script/py_camera.c:529:    Camera_SetPitchAndYaw(self->cam, PyFloat_AS_DOUBLE(value), Camera_GetYaw(self->cam));
../script/py_camera.c:535:    return PyFloat_FromDouble(Camera_GetYaw(self->cam));
../script/py_camera.c:541:        return -1;
../script/py_camera.c:545:        return -1;
../script/py_camera.c:548:    Camera_SetPitchAndYaw(self->cam, Camera_GetPitch(self->cam), PyFloat_AS_DOUBLE(value));
../script/py_camera.c:554:    return PyFloat_FromDouble(Camera_GetSpeed(self->cam));
../script/py_camera.c:561:        return -1;
../script/py_camera.c:564:    Camera_SetSpeed(self->cam, PyFloat_AS_DOUBLE(value));
../script/py_camera.c:570:    return PyFloat_FromDouble(Camera_GetSens(self->cam));
../script/py_camera.c:577:        return -1;
../script/py_camera.c:580:    Camera_SetSens(self->cam, PyFloat_AS_DOUBLE(value));
../script/py_camera.c:604:    ((PyCameraObject*)s_active_cam)->cam = G_GetActiveCamera();
../script/py_camera.c:605:    ((PyCameraObject*)s_active_cam)->mode = CAM_MODE_RTS; /* default */
../script/py_camera.c:612:    /* No-op for now */
../script/py_camera.c:631:    if(!PyType_IsSubtype(cam->ob_type, &PyCamera_type)) {
../script/py_camera.c:641:    G_SetActiveCamera(pycam->cam, pycam->mode);
../script/py_constants.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_constants.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_entity.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_entity.c:1024:    self = (PyEntityObject*)type->tp_alloc(type, 0);
../script/py_entity.c:1030:        self->ent = ent; 
../script/py_entity.c:1073:    self->ent->flags |= extra_flags;
../script/py_entity.c:1074:    G_AddEntity(self->ent, pos);
../script/py_entity.c:1077:    khiter_t k = kh_put(PyObject, s_uid_pyobj_table, ent->uid, &ret);
../script/py_entity.c:1078:    assert(ret != -1 && ret != 0);
../script/py_entity.c:1086:    assert(self->ent);
../script/py_entity.c:1088:    khiter_t k = kh_get(PyObject, s_uid_pyobj_table, self->ent->uid);
../script/py_entity.c:1098:    G_DeferredRemove(self->ent);
../script/py_entity.c:1099:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_entity.c:1104:    return PyInt_FromLong(self->ent->uid);
../script/py_entity.c:1109:    return Py_BuildValue("s", self->ent->name);
../script/py_entity.c:1114:    if(self->ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:1123:    Entity_CurrentOBB(self->ent, &obb, true);
../script/py_entity.c:1132:        return -1;
../script/py_entity.c:1138:        return -1;
../script/py_entity.c:1141:    PF_FREE(self->ent->name);
../script/py_entity.c:1142:    self->ent->name = s;
../script/py_entity.c:1148:    vec3_t pos = G_Pos_Get(self->ent->uid);
../script/py_entity.c:1156:        return -1;
../script/py_entity.c:1162:        return -1;
../script/py_entity.c:1165:    G_Pos_Set(self->ent, newpos);
../script/py_entity.c:1171:    vec3_t scale = Entity_GetScale(self->ent->uid);
../script/py_entity.c:1179:        return -1;
../script/py_entity.c:1184:        return -1;
../script/py_entity.c:1186:    Entity_SetScale(self->ent->uid, scale);
../script/py_entity.c:1192:    quat_t rot = Entity_GetRot(self->ent->uid);
../script/py_entity.c:1200:        return -1;
../script/py_entity.c:1205:        return -1;
../script/py_entity.c:1207:    Entity_SetRot(self->ent->uid, rot);
../script/py_entity.c:1213:    if(self->ent->flags & ENTITY_FLAG_SELECTABLE)
../script/py_entity.c:1223:    if(-1 == result) {
../script/py_entity.c:1225:        return -1;
../script/py_entity.c:1227:        self->ent->flags |= ENTITY_FLAG_SELECTABLE;
../script/py_entity.c:1229:        self->ent->flags &= ~ENTITY_FLAG_SELECTABLE;
../script/py_entity.c:1237:    return Py_BuildValue("f", G_GetSelectionRadius(self->ent->uid));
../script/py_entity.c:1244:        return -1;
../script/py_entity.c:1247:    G_SetSelectionRadius(self->ent->uid, PyFloat_AsDouble(value));
../script/py_entity.c:1253:    char buff[strlen(self->ent->basedir) + strlen(self->ent->filename) + 2];
../script/py_entity.c:1254:    strcpy(buff, self->ent->basedir);
../script/py_entity.c:1256:    strcat(buff, self->ent->filename);
../script/py_entity.c:1264:    vec2_t coord = Entity_TopScreenPos(self->ent, width, height);
../script/py_entity.c:1270:    return Py_BuildValue("i", G_GetFactionID(self->ent->uid));
../script/py_entity.c:1277:        return -1;
../script/py_entity.c:1284:        return -1;
../script/py_entity.c:1287:    G_SetFactionID(self->ent->uid, faction_id);
../script/py_entity.c:1293:    if(self->ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:1297:    return Py_BuildValue("f", G_GetVisionRange(self->ent->uid));
../script/py_entity.c:1302:    if(self->ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:1304:        return -1;
../script/py_entity.c:1309:        return -1;
../script/py_entity.c:1312:    G_SetVisionRange(self->ent->uid, PyFloat_AS_DOUBLE(value));
../script/py_entity.c:1319:    size_t ntags = Entity_TagsForEnt(self->ent->uid, ARR_SIZE(tags), tags);
../script/py_entity.c:1340:    Entity_CurrentOBB(self->ent, &obb, true);
../script/py_entity.c:1365:    bool ret = E_Entity_ScriptRegister(event, self->ent->uid, callable, user_arg, G_RUNNING);
../script/py_entity.c:1385:    E_Entity_ScriptUnregister(event, self->ent->uid, callable);
../script/py_entity.c:1401:    E_Entity_Notify(event, self->ent->uid, arg, ES_SCRIPT);
../script/py_entity.c:1407:    assert(self->ent);
../script/py_entity.c:1408:    G_Sel_Add(self->ent);
../script/py_entity.c:1414:    assert(self->ent);
../script/py_entity.c:1415:    G_Sel_Remove(self->ent);
../script/py_entity.c:1421:    assert(self->ent);
../script/py_entity.c:1422:    G_StopEntity(self->ent, true);
../script/py_entity.c:1434:    Entity_FaceTowards(self->ent, (vec2_t){pos.x, pos.z});
../script/py_entity.c:1446:    if(!strcmp(self->ent->basedir, dirpath)
../script/py_entity.c:1447:    && !strcmp(self->ent->filename, filename)) {
../script/py_entity.c:1451:    if(!AL_EntitySetPFObj(self->ent, dirpath, filename)) {
../script/py_entity.c:1460:    Entity_Ping(self->ent);
../script/py_entity.c:1466:    G_Zombiefy(self->ent, true);
../script/py_entity.c:1478:    if(!Entity_AddTag(self->ent->uid, tag)) {
../script/py_entity.c:1494:    Entity_RemoveTag(self->ent->uid, tag);
../script/py_entity.c:1506:    PyObject *basedir = PyString_FromString(self->ent->basedir);
../script/py_entity.c:1512:    PyObject *filename = PyString_FromString(self->ent->filename);
../script/py_entity.c:1518:    PyObject *name = PyString_FromString(self->ent->name);
../script/py_entity.c:1524:    PyObject *uid = PyInt_FromLong(self->ent->uid);
../script/py_entity.c:1530:    vec3_t rawpos = G_Pos_Get(self->ent->uid);
../script/py_entity.c:1537:    vec3_t vscale = Entity_GetScale(self->ent->uid);
../script/py_entity.c:1544:    quat_t qrot = Entity_GetRot(self->ent->uid);
../script/py_entity.c:1551:    PyObject *flags = Py_BuildValue("i", self->ent->flags);
../script/py_entity.c:1557:    PyObject *sel_radius = Py_BuildValue("f", G_GetSelectionRadius(self->ent->uid));
../script/py_entity.c:1563:    PyObject *faction_id = Py_BuildValue("i", G_GetFactionID(self->ent->uid));
../script/py_entity.c:1569:    PyObject *vision_range = Py_BuildValue("f", G_GetVisionRange(self->ent->uid));
../script/py_entity.c:1659:     * to avoid calling any magic that might be risiding in the user-implemented __new__ 
../script/py_entity.c:1662:    assert(heap_subtype->tp_new);
../script/py_entity.c:1664:    PyObject *entobj = heap_subtype->tp_new((struct _typeobject*)cls, ent_args, ent_kwargs);
../script/py_entity.c:1671:    struct entity *ent = ((PyEntityObject*)entobj)->ent;
../script/py_entity.c:1678:    Entity_SetScale(ent->uid, vscale);
../script/py_entity.c:1682:    Entity_SetRot(ent->uid, qrot);
../script/py_entity.c:1690:    if(!(ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:1698:            Entity_AddTag(ent->uid, PyString_AS_STRING(tag));
../script/py_entity.c:1727:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:1732:    G_StopEntity(self->super.ent, true);
../script/py_entity.c:1734:    assert(self->super.ent->flags & ENTITY_FLAG_COMBATABLE);
../script/py_entity.c:1735:    G_Combat_SetStance(self->super.ent, COMBAT_STANCE_HOLD_POSITION);
../script/py_entity.c:1741:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:1757:    assert(self->super.ent->flags & ENTITY_FLAG_COMBATABLE);
../script/py_entity.c:1758:    G_Combat_SetStance(self->super.ent, COMBAT_STANCE_AGGRESSIVE);
../script/py_entity.c:1760:    if(self->super.ent->flags & ENTITY_FLAG_MOVABLE) {
../script/py_entity.c:1761:        G_Move_SetDest(self->super.ent, xz_pos, true);
../script/py_entity.c:1783:    if(!(self->super.ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:1785:        max_hp = PyInt_FromLong(G_Combat_GetMaxHP(self->super.ent));
../script/py_entity.c:1786:        base_dmg = PyInt_FromLong(G_Combat_GetBaseDamage(self->super.ent));
../script/py_entity.c:1787:        base_armour = PyFloat_FromDouble(G_Combat_GetBaseArmour(self->super.ent));
../script/py_entity.c:1788:        curr_hp = PyInt_FromLong(G_Combat_GetCurrentHP(self->super.ent));
../script/py_entity.c:1789:        attack_range = PyFloat_FromDouble(G_Combat_GetRange(self->super.ent));
../script/py_entity.c:1855:    if(!(((PyCombatableEntityObject*)ent)->super.ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:1879:        G_Combat_SetCurrentHP(((PyEntityObject*)ent)->ent, PyInt_AS_LONG(curr_hp));
../script/py_entity.c:1909:        return -1;
../script/py_entity.c:1914:        return -1; 
../script/py_entity.c:1917:    if(!A_HasClip(self->super.ent->uid, PyString_AS_STRING(idle_clip))) {
../script/py_entity.c:1920:            self->super.ent->filename, PyString_AS_STRING(idle_clip));
../script/py_entity.c:1922:        return -1;
../script/py_entity.c:1925:    A_SetIdleClip(self->super.ent->uid, PyString_AS_STRING(idle_clip), 24);
../script/py_entity.c:1929:     * This allows this type to be used as one of many mix-in bases. */
../script/py_entity.c:1932:        return -1; /* Exception already set */
../script/py_entity.c:1963:    if(!A_HasClip(self->super.ent->uid, clipname)) {
../script/py_entity.c:1966:            self->super.ent->filename, clipname);
../script/py_entity.c:1971:    A_SetActiveClip(self->super.ent->uid, clipname, mode, 24);
../script/py_entity.c:1977:    return PyString_FromString(A_GetCurrClip(self->super.ent->uid));
../script/py_entity.c:1990:    PyObject *idle_clip = PyString_FromString(A_GetIdleClip(self->super.ent->uid));
../script/py_entity.c:2039:    A_SetIdleClip(((PyAnimEntityObject*)ent)->super.ent->uid, PyString_AS_STRING(idle_clip), 24);
../script/py_entity.c:2055:    assert(self->super.ent->flags & ENTITY_FLAG_COMBATABLE);
../script/py_entity.c:2063:        return -1;
../script/py_entity.c:2068:        return -1; /* Exception already set */ 
../script/py_entity.c:2081:            return -1;
../script/py_entity.c:2089:        G_Combat_SetProjDesc(self->super.ent, &pd);
../script/py_entity.c:2095:        return -1; /* Exception already set */ 
../script/py_entity.c:2097:    G_Combat_SetCurrentHP(self->super.ent, PyInt_AS_LONG(max_hp));
../script/py_entity.c:2101:     * This allows this type to be used as one of many mix-in bases. */
../script/py_entity.c:2104:        return -1; /* Exception already set */
../script/py_entity.c:2116:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2120:    return PyInt_FromLong(G_Combat_GetCurrentHP(self->super.ent));
../script/py_entity.c:2125:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2127:        return -1;
../script/py_entity.c:2132:        return -1;
../script/py_entity.c:2138:        return -1;
../script/py_entity.c:2141:    G_Combat_SetCurrentHP(self->super.ent, hp);
../script/py_entity.c:2147:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2152:    int max_hp = G_Combat_GetMaxHP(self->super.ent);
../script/py_entity.c:2158:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2160:        return -1;
../script/py_entity.c:2165:        return -1;
../script/py_entity.c:2171:        return -1;
../script/py_entity.c:2174:    G_Combat_SetMaxHP(self->super.ent, max_hp);
../script/py_entity.c:2180:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2184:    return PyInt_FromLong(G_Combat_GetBaseDamage(self->super.ent));
../script/py_entity.c:2189:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2191:        return -1;
../script/py_entity.c:2196:        return -1;
../script/py_entity.c:2202:        return -1;
../script/py_entity.c:2205:    G_Combat_SetBaseDamage(self->super.ent, base_dmg);
../script/py_entity.c:2211:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2216:    return PyFloat_FromDouble(G_Combat_GetBaseArmour(self->super.ent));
../script/py_entity.c:2221:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2223:        return -1;
../script/py_entity.c:2228:        return -1;
../script/py_entity.c:2234:        return -1;
../script/py_entity.c:2237:    G_Combat_SetBaseArmour(self->super.ent, base_armour);
../script/py_entity.c:2243:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2248:    return PyFloat_FromDouble(G_Combat_GetRange(self->super.ent));
../script/py_entity.c:2253:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2255:        return -1;
../script/py_entity.c:2260:        return -1;
../script/py_entity.c:2266:        return -1;
../script/py_entity.c:2269:    G_Combat_SetRange(self->super.ent, range);
../script/py_entity.c:2280:        return -1;
../script/py_entity.c:2298:        G_Building_SetRequired(self->super.ent->uid, rname, ramount);
../script/py_entity.c:2303:     * This allows this type to be used as one of many mix-in bases. */
../script/py_entity.c:2307:        return -1; /* Exception already set */
../script/py_entity.c:2314:    return -1;
../script/py_entity.c:2324:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2329:    if(!G_Building_Mark(self->super.ent)) {
../script/py_entity.c:2338:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2352:    if(!force && !G_Building_Unobstructed(self->super.ent)) {
../script/py_entity.c:2357:    if(!G_Building_Found(self->super.ent, blocking)) {
../script/py_entity.c:2366:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2371:    if(!G_Building_Supply(self->super.ent)) {
../script/py_entity.c:2380:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2385:    if(!G_Building_Complete(self->super.ent)) {
../script/py_entity.c:2394:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2399:    if(G_Building_Unobstructed(self->super.ent)) {
../script/py_entity.c:2408:    vec3_t pos = G_Pos_Get(self->super.ent->uid);
../script/py_entity.c:2416:        return -1;
../script/py_entity.c:2422:        return -1;
../script/py_entity.c:2425:    newpos.x -= fmod(newpos.x, X_COORDS_PER_TILE / 2.0);
../script/py_entity.c:2426:    newpos.z -= fmod(newpos.z, Z_COORDS_PER_TILE / 2.0);
../script/py_entity.c:2428:    G_Pos_Set(self->super.ent, newpos);
../script/py_entity.c:2434:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2438:    if(G_Building_IsFounded(self->super.ent)) {
../script/py_entity.c:2446:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2450:    if(G_Building_IsSupplied(self->super.ent)) {
../script/py_entity.c:2458:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2462:    if(G_Building_IsCompleted(self->super.ent)) {
../script/py_entity.c:2470:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2474:    return Py_BuildValue("f", G_Building_GetVisionRange(self->super.ent));
../script/py_entity.c:2479:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2481:        return -1;
../script/py_entity.c:2486:        return -1;
../script/py_entity.c:2489:    G_Building_SetVisionRange(self->super.ent, PyFloat_AS_DOUBLE(value));
../script/py_entity.c:2495:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2504:    size_t nreq = G_Building_GetAllRequired(self->super.ent->uid, max, names, amounts);
../script/py_entity.c:2547:        return -1;
../script/py_entity.c:2552:        return -1; 
../script/py_entity.c:2555:    G_Builder_SetBuildSpeed(self->super.ent, PyInt_AS_LONG(build_speed));
../script/py_entity.c:2559:     * This allows this type to be used as one of many mix-in bases. */
../script/py_entity.c:2562:        return -1; /* Exception already set */
../script/py_entity.c:2569:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2581:    G_Builder_Build(self->super.ent, ((PyBuildableEntityObject*)building)->super.ent);
../script/py_entity.c:2595:    if(!(self->super.ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:2597:        PyObject *build_speed = PyInt_FromLong(G_Builder_GetBuildSpeed(self->super.ent));
../script/py_entity.c:2642:    if(!(((PyBuilderEntityObject*)ent)->super.ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:2651:        G_Builder_SetBuildSpeed(((PyBuilderEntityObject*)ent)->super.ent, PyInt_AS_LONG(build_speed));
../script/py_entity.c:2682:        return -1;
../script/py_entity.c:2687:        return -1;
../script/py_entity.c:2692:        return -1;
../script/py_entity.c:2695:    G_Resource_SetName(self->super.ent->uid, PyString_AS_STRING(name));
../script/py_entity.c:2696:    G_Resource_SetAmount(self->super.ent->uid, PyInt_AS_LONG(amount));
../script/py_entity.c:2700:     * This allows this type to be used as one of many mix-in bases. */
../script/py_entity.c:2703:        return -1; /* Exception already set */
../script/py_entity.c:2718:    if(!(self->super.ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:2720:        PyObject *name = PyString_FromString(G_Resource_GetName(self->super.ent->uid));
../script/py_entity.c:2726:        PyObject *amount = PyInt_FromLong(G_Resource_GetAmount(self->super.ent->uid));
../script/py_entity.c:2774:    if(!(((PyResourceEntityObject*)ent)->super.ent->flags & ENTITY_FLAG_ZOMBIE)) {
../script/py_entity.c:2780:        G_Resource_SetName(((PyResourceEntityObject*)ent)->super.ent->uid, PyString_AS_STRING(name));
../script/py_entity.c:2786:        G_Resource_SetAmount(((PyResourceEntityObject*)ent)->super.ent->uid, PyInt_AS_LONG(amount));
../script/py_entity.c:2805:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2810:    return Py_BuildValue("s", G_Resource_GetCursor(self->super.ent->uid));
../script/py_entity.c:2815:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2817:        return -1;
../script/py_entity.c:2822:        return -1;
../script/py_entity.c:2827:        return -1;
../script/py_entity.c:2831:    G_Resource_SetCursor(self->super.ent->uid, s);
../script/py_entity.c:2837:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2842:    return PyString_FromString(G_Resource_GetName(self->super.ent->uid));
../script/py_entity.c:2847:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2852:    return PyInt_FromLong(G_Resource_GetAmount(self->super.ent->uid));
../script/py_entity.c:2857:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2859:        return -1;
../script/py_entity.c:2864:        return -1;
../script/py_entity.c:2867:    G_Resource_SetAmount(self->super.ent->uid, PyInt_AS_LONG(value));
../script/py_entity.c:2878:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2890:    G_StopEntity(self->super.ent, true);
../script/py_entity.c:2891:    if(!G_Harvester_Gather(self->super.ent, resource->super.ent)) {
../script/py_entity.c:2900:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2912:    G_StopEntity(self->super.ent, true);
../script/py_entity.c:2913:    if(!G_Harvester_DropOff(self->super.ent, storage->super.ent)) {
../script/py_entity.c:2922:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2934:    G_StopEntity(self->super.ent, true);
../script/py_entity.c:2935:    if(!G_Harvester_Transport(self->super.ent, storage->super.ent)) {
../script/py_entity.c:2944:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2955:    int ret = G_Harvester_GetCurrCarry(self->super.ent->uid, rname);
../script/py_entity.c:2961:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2966:    G_Harvester_ClearCurrCarry(self->super.ent->uid);
../script/py_entity.c:2972:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:2983:    int ret = G_Harvester_GetMaxCarry(self->super.ent->uid, rname);
../script/py_entity.c:2989:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3002:    if(!G_Harvester_SetMaxCarry(self->super.ent->uid, name, amount)) {
../script/py_entity.c:3011:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3022:    float ret = G_Harvester_GetGatherSpeed(self->super.ent->uid, rname);
../script/py_entity.c:3028:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3041:    if(!G_Harvester_SetGatherSpeed(self->super.ent->uid, name, amount)) {
../script/py_entity.c:3050:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3061:    if(G_Harvester_IncreaseTransportPrio(self->super.ent->uid, name)) {
../script/py_entity.c:3070:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3081:    if(G_Harvester_DecreaseTransportPrio(self->super.ent->uid, name)) {
../script/py_entity.c:3101:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3106:    int total = G_Harvester_GetCurrTotalCarry(self->super.ent->uid);
../script/py_entity.c:3112:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3118:    int nres = G_Harvester_GetTransportPrio(self->super.ent->uid, ARR_SIZE(names), names);
../script/py_entity.c:3137:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3142:    enum tstrategy strat = G_Harvester_GetStrategy(self->super.ent->uid);
../script/py_entity.c:3148:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3150:        return -1;
../script/py_entity.c:3156:        return -1;
../script/py_entity.c:3159:    G_Harvester_SetStrategy(self->super.ent->uid, PyInt_AS_LONG(value));
../script/py_entity.c:3170:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3181:    int curr = G_StorageSite_GetCurr(self->super.ent->uid, name);
../script/py_entity.c:3187:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3199:    if(!G_StorageSite_SetCurr(self->super.ent, name, amount)) {
../script/py_entity.c:3211:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3222:    int cap = G_StorageSite_GetCapacity(self->super.ent->uid, name);
../script/py_entity.c:3228:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3241:    if(!G_StorageSite_SetCapacity(self->super.ent, name, amount)) {
../script/py_entity.c:3250:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3261:    int cap = G_StorageSite_GetDesired(self->super.ent->uid, name);
../script/py_entity.c:3267:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3280:    if(!G_StorageSite_SetDesired(self->super.ent->uid, name, amount)) {
../script/py_entity.c:3289:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3294:    bool do_not_take = G_StorageSite_GetDoNotTake(self->super.ent->uid);
../script/py_entity.c:3304:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3306:        return -1;
../script/py_entity.c:3310:    G_StorageSite_SetDoNotTake(self->super.ent->uid, do_not_take);
../script/py_entity.c:3316:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3322:    int nres = G_StorageSite_GetStorableResources(self->super.ent->uid, ARR_SIZE(names), names);
../script/py_entity.c:3352:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3358:    G_Move_GetMaxSpeed(self->super.ent->uid, &speed);
../script/py_entity.c:3364:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3366:        return -1;
../script/py_entity.c:3371:        return -1;
../script/py_entity.c:3374:    G_Move_SetMaxSpeed(self->super.ent->uid, PyFloat_AS_DOUBLE(value));
../script/py_entity.c:3380:    if(self->super.ent->flags & ENTITY_FLAG_ZOMBIE) {
../script/py_entity.c:3396:    G_Move_SetDest(self->super.ent, xz_pos, false);
../script/py_entity.c:3419:    switch(attr->type){
../script/py_entity.c:3420:    case TYPE_STRING:   return Py_BuildValue("s", attr->val.as_string);
../script/py_entity.c:3421:    case TYPE_FLOAT:    return Py_BuildValue("f", attr->val.as_float);
../script/py_entity.c:3422:    case TYPE_INT:      return Py_BuildValue("i", attr->val.as_int);
../script/py_entity.c:3423:    case TYPE_VEC3:     return Py_BuildValue("(f,f,f)", attr->val.as_vec3.x, attr->val.as_vec3.y, attr->val.as_vec3.z);
../script/py_entity.c:3425:                               attr->val.as_quat.x, attr->val.as_quat.y, attr->val.as_quat.z, attr->val.as_quat.w);
../script/py_entity.c:3426:    case TYPE_BOOL:     return Py_BuildValue("i", attr->val.as_bool);
../script/py_entity.c:3456:        end--;
../script/py_entity.c:3561:    ret = tp_class->tp_new(tp_class, args, kwargs);
../script/py_entity.c:3563:        int status = tp_class->tp_init(ret, args, NULL);
../script/py_entity.c:3665:    *out = ((PyEntityObject*)obj)->ent->uid;
../script/py_entity.c:3700:            PyObject *repr = PyObject_Repr(tstate->curexc_value);
../script/py_entity.c:3715:    struct entity *ent = ((PyEntityObject*)ret)->ent;
../script/py_entity.c:3719:        ((PyEntityObject*)ret)->ent->flags |= ENTITY_FLAG_COLLISION;
../script/py_entity.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_error.c:94:        *offset = -1;
../script/py_error.c:132:        if (offset > 0 && offset == strlen(text) && text[offset - 1] == '\n')
../script/py_error.c:133:            offset--;
../script/py_error.c:136:            if (nl == NULL || nl-text >= offset)
../script/py_error.c:138:            offset -= (int)(nl+1-text);
../script/py_error.c:143:            offset--;
../script/py_error.c:148:    if (*text == '\0' || text[strlen(text)-1] != '\n')
../script/py_error.c:150:    if (offset == -1)
../script/py_error.c:153:    offset--;
../script/py_error.c:156:        offset--;
../script/py_error.c:203:                    if (len > 0 && namebuf[len-1] != SEP)
../script/py_error.c:219:        char* pLastChar = &linebuf[sizeof(linebuf)-2];
../script/py_error.c:244:            indent -= 10;
../script/py_error.c:262:    if(!err_ctx->occurred)
../script/py_error.c:272:        vres.x / 2.0f - 400,
../script/py_error.c:273:        vres.y / 2.0f - 200,
../script/py_error.c:294:        assert(err_ctx->type);
../script/py_error.c:295:        if(PyExceptionClass_Check(err_ctx->type) && PyExceptionClass_Name(err_ctx->type)) {
../script/py_error.c:296:            const char *clsname = PyExceptionClass_Name(err_ctx->type);
../script/py_error.c:302:            repr = PyObject_Str(err_ctx->type);
../script/py_error.c:313:        if(err_ctx->value) {
../script/py_error.c:315:            if(s_parse_syntax_error(err_ctx->value, &message, &filename, &lineno, &offset, &text)) {
../script/py_error.c:320:                repr = PyObject_Str(err_ctx->value);
../script/py_error.c:364:        if(err_ctx->traceback) {
../script/py_error.c:371:            PyTracebackObject *tb = (PyTracebackObject*)err_ctx->traceback;
../script/py_error.c:375:                tb = tb->tb_next;
../script/py_error.c:377:            tb = (PyTracebackObject*)err_ctx->traceback;
../script/py_error.c:384:                        PyString_AsString(tb->tb_frame->f_code->co_filename), tb->tb_lineno);
../script/py_error.c:390:                    s_print_source_line(PyString_AsString(tb->tb_frame->f_code->co_filename), tb->tb_lineno, 4, 
../script/py_error.c:393:                    linebuff[len > 0 ? len-1 : 0] = '\0'; /* trim newline */
../script/py_error.c:399:                depth--;
../script/py_error.c:400:                tb = tb->tb_next;
../script/py_error.c:413:            err_ctx->occurred = false;
../script/py_error.c:414:            Py_CLEAR(err_ctx->type);
../script/py_error.c:415:            Py_CLEAR(err_ctx->value);
../script/py_error.c:416:            Py_CLEAR(err_ctx->traceback);
../script/py_error.c:417:            G_SetSimState(err_ctx->prev_state);
../script/py_pickle.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../script/py_pickle.c:57:#define TOP(_stk)   (vec_AT(_stk, vec_size(_stk)-1))
../script/py_pickle.c:67:        written += snprintf(errbuff + written, sizeof(errbuff) - written,       \
../script/py_pickle.c:69:        errbuff[sizeof(errbuff)-1] = '\0';                                      \
../script/py_pickle.c:90:        printf("[U] %-14s: [stack size: %4u] [mark stack size: %4u] (%s:%d)\n", \
../script/py_pickle.c:91:            #op, (unsigned)vec_size(&ctx->stack),                               \
../script/py_pickle.c:92:            (unsigned)vec_size(&ctx->mark_stack),                               \
../script/py_pickle.c:107:        printf("[P] %-24s: (%-36s:%4d) [0x%p] %s\n", obj->ob_type->tp_name,     \
../script/py_pickle.c:117: * type argument to support pickling/unpickling of instances of user-defined 
../script/py_pickle.c:129:#define STRING          'S' /* push string; NL-terminated string argument           */
../script/py_pickle.c:130:#define UNICODE         'V' /* push Unicode string; raw-unicode-escaped'd argument  */
../script/py_pickle.c:153:#define PF_BUILTIN      'i' /* Push new reference to built-in that is identified by its' fully-qualified name */
../script/py_pickle.c:172:#define PF_NEWINST      'B' /* Create new-style instance with type on TOS, args on TOS1 and the outer-most builtin base on TOS2 */
../script/py_pickle.c:176:#define PF_METHWRAP     'F' /* Push a 'method-wrapper' instance from top 2 stack items */
../script/py_pickle.c:200:#define PF_CALLITER     '4' /* Push a callable-iterator instance from top 2 TOS items */
../script/py_pickle.c:205:#define PF_DICTKEYITER  '9' /* Push a dictionary-keyiterator instance from top 5 TOS items */
../script/py_pickle.c:206:#define PF_DICTVALITER  '!' /* Push a dictionary-valueiterator instance from top 5 TOS items */
../script/py_pickle.c:207:#define PF_DICTITEMITER '@' /* Push a dictionary-itemiterator instance from top 5 TOS items */
../script/py_pickle.c:213:#define PF_BI_METHOD    '*' /* Push a 'built-in method' (variant of PyCFunctionObject) type from top 3 TOS items */
../script/py_pickle.c:216:#define PF_OP_METHODCALL '-' /* Push an operator.methodcaller instance from top 3 TOS items */
../script/py_pickle.c:246:     * all newly-created objects until pickling is done. */
../script/py_pickle.c:463:    /* The Python 2.7 public built-in types. Some of these types may be 
../script/py_pickle.c:499:    {.type = NULL, /*&PyClass_Type*/        .picklefunc = class_pickle                  }, /* indirectly: Old-style class */
../script/py_pickle.c:508:    /* These are from accessing the attributes of built-in types; created via PyDescr_ API*/
../script/py_pickle.c:514:     * in C. Sublcasses of these types will re-use the same descriptor objects. Thus 
../script/py_pickle.c:529:    /* Built-in singletons. These may not be instantiated directly  */
../script/py_pickle.c:548:    /* Built-in struct sequences (i.e. 'named tuples') */
../script/py_pickle.c:552:    /* The following are non-instantiatable named tuple singletons in 'sys' */
../script/py_pickle.c:556:    /* Derived with dict built-in methods */
../script/py_pickle.c:588:    /* The following built-in types can never be instantiated. 
../script/py_pickle.c:592:    /* The built-in exception types. All of them can be instantiated directly.  */
../script/py_pickle.c:653:/* An 'empty' user-defined type that acts as a placeholder */
../script/py_pickle.c:656:/* The permafrost engine built-in types */
../script/py_pickle.c:785:/* Statically-linked builtin modules not imported on initialization which also contain C builtins */
../script/py_pickle.c:801:/* Create a 'dummy' subclass of every user-subclassable builtin and maintain a 
../script/py_pickle.c:803: * of user-defined subclasses of builtins. This is the same as using the actual
../script/py_pickle.c:804: * user-created type object for construction, except we avoid any side-effects that 
../script/py_pickle.c:853:        if(obj->ob_type == s_type_dispatch_table[i].type)
../script/py_pickle.c:857:    /* It's not one of the Python builtins - it may be an engine builtin */
../script/py_pickle.c:860:        if(obj->ob_type == s_pf_dispatch_table[i].type)
../script/py_pickle.c:913:        /* Every user-defiened type is considered to be a subtype of 
../script/py_pickle.c:930:        assert(!strcmp(((PyTypeObject*)ret)->tp_name, "__object_subclass__"));
../script/py_pickle.c:943:    return -1;
../script/py_pickle.c:946:/* Some of the built-in types are declared 'static' but can still be referenced
../script/py_pickle.c:959:    assert(!strcmp(tmp->ob_type->tp_name, "method_descriptor"));
../script/py_pickle.c:960:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:967:    assert(!strcmp(tmp->ob_type->tp_name, "classmethod_descriptor"));
../script/py_pickle.c:968:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:976:    assert(!strcmp(mw->ob_type->tp_name, "method-wrapper"));
../script/py_pickle.c:977:    s_type_dispatch_table[idx].type = mw->ob_type;
../script/py_pickle.c:984:    assert(!strcmp(tmp->ob_type->tp_name, "NoneType"));
../script/py_pickle.c:985:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:990:    assert(!strcmp(tmp->ob_type->tp_name, "NotImplementedType"));
../script/py_pickle.c:991:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:996:    assert(!strcmp(tmp->ob_type->tp_name, "sys.long_info"));
../script/py_pickle.c:997:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:1003:    assert(!strcmp(tmp->ob_type->tp_name, "sys.float_info"));
../script/py_pickle.c:1004:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:1010:    assert(!strcmp(tmp->ob_type->tp_name, "sys.flags"));
../script/py_pickle.c:1011:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:1016:    assert(!strcmp(tmp->ob_type->tp_name, "sys.version_info"));
../script/py_pickle.c:1017:    s_type_dispatch_table[idx].type = tmp->ob_type;
../script/py_pickle.c:1026:    s_type_dispatch_table[idx].type = iter->ob_type;
../script/py_pickle.c:1027:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "setiterator"));
../script/py_pickle.c:1036:    s_type_dispatch_table[idx].type = PyTuple_GET_ITEM(tuple, 1)->ob_type;
../script/py_pickle.c:1037:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "fieldnameiterator"));
../script/py_pickle.c:1047:    s_type_dispatch_table[idx].type = iter->ob_type;
../script/py_pickle.c:1048:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "formatteriterator"));
../script/py_pickle.c:1057:    s_type_dispatch_table[idx].type = iter->ob_type;
../script/py_pickle.c:1058:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "listiterator"));
../script/py_pickle.c:1072:    s_type_dispatch_table[idx].type = iter->ob_type;
../script/py_pickle.c:1073:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "listreverseiterator"));
../script/py_pickle.c:1082:    s_type_dispatch_table[idx].type = iter->ob_type;
../script/py_pickle.c:1083:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "tupleiterator"));
../script/py_pickle.c:1091:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "operator.itemgetter"));
../script/py_pickle.c:1096:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "operator.attrgetter"));
../script/py_pickle.c:1101:    assert(!strcmp(s_type_dispatch_table[idx].type->tp_name, "operator.methodcaller"));
../script/py_pickle.c:1241:    int base_idx = -1;
../script/py_pickle.c:1358:            // https://stackoverflow.com/questions/27469454/pyimport-import-fails-returns-null/27469748
../script/py_pickle.c:1363:        //printf("%jd\n", mod->ob_refcnt); // https://stackoverflow.com/questions/24844970/how-to-print-types-of-unknown-size-like-ino-t : "The j length modifier" :        "Specifies that a following d, i, o, u, x, or X conversion specifier applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a pointer to an intmax_t argument."
../script/py_pickle.c:1364:        assert(mod && mod->ob_refcnt == 2);
../script/py_pickle.c:1374:     * garbage-collected) 
../script/py_pickle.c:1380:        assert(PyDict_GetItemString(sysmods, s_extra_indexed_mods[i])->ob_refcnt == 1);
../script/py_pickle.c:1399:        pf_strlcpy(name, ((PyTypeObject*)type)->tp_name, sizeof(name));
../script/py_pickle.c:1402:                *curr = '-';
../script/py_pickle.c:1419:    return -1;
../script/py_pickle.c:1434:    PyInterpreterState *interp = PyThreadState_Get()->interp; 
../script/py_pickle.c:1436:    PyObject *err_registry = interp->codec_error_registry;
../script/py_pickle.c:1457:    return -1;
../script/py_pickle.c:1472:        pf_snprintf(name, sizeof(name), "__%s_subclass__", bi->tp_name);
../script/py_pickle.c:1551:        return -1;
../script/py_pickle.c:1562:        ret = -1;
../script/py_pickle.c:1570: * a user-defined __get__ method, begin careful not to actually
../script/py_pickle.c:1571: * invoke the method, which may have arbitrary side-effects. */
../script/py_pickle.c:1580:        descr =_PyType_Lookup(obj->ob_type, name);
../script/py_pickle.c:1586:    if(PyType_HasFeature(descr->ob_type, Py_TPFLAGS_HAVE_CLASS)
../script/py_pickle.c:1587:    && descr->ob_type->tp_descr_get) {
../script/py_pickle.c:1604:/* Non-derived attributes are those that don't return a new 
../script/py_pickle.c:1629:        /* Don't touch the frame's locals - getting this causes modification of 
../script/py_pickle.c:1641:        if(attr->ob_refcnt == 1) {
../script/py_pickle.c:1650:            if(obj->ob_type != &PyFrame_Type) {
../script/py_pickle.c:1681:        SET_RUNTIME_EXC("Could not find built-in qualified name in index: %s", 
../script/py_pickle.c:1684:        return -1;
../script/py_pickle.c:1691:    CHK_TRUE(rw->write(rw, &xtend, 1, 1), fail);
../script/py_pickle.c:1692:    CHK_TRUE(rw->write(rw, &builtin, 1, 1), fail);
../script/py_pickle.c:1693:    CHK_TRUE(rw->write(rw, qname, strlen(qname), 1), fail);
../script/py_pickle.c:1694:    CHK_TRUE(rw->write(rw, "\n", 1, 1), fail);
../script/py_pickle.c:1700:    return -1;
../script/py_pickle.c:1708:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:1711:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:1716:    return -1;
../script/py_pickle.c:1731:    PyObject *umeth = PyObject_GetAttrString((PyObject*)obj->ob_type, "__unpickle__");
../script/py_pickle.c:1739:    CHK_TRUE(rw->write(rw, &mark, 1, 1), fail);
../script/py_pickle.c:1766:        SET_RUNTIME_EXC("Error pickling %s instance (%p)", obj->ob_type->tp_name, obj);
../script/py_pickle.c:1771:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:1773:    vec_pobj_push(&ctx->to_free, ret);
../script/py_pickle.c:1785:        CHK_TRUE(rw->write(rw, &pmark, 1, 1), fail);
../script/py_pickle.c:1793:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:1798:    return -1;
../script/py_pickle.c:1818:            assert(Py_TYPE(desc)->tp_descr_get);
../script/py_pickle.c:1830:            assert(Py_TYPE(desc)->tp_descr_get);
../script/py_pickle.c:1853:        if(meth->im_self
../script/py_pickle.c:1854:        && meth->im_self->ob_type != (PyTypeObject*)obj) {
../script/py_pickle.c:1855:            PyObject *clsmeth = PyClassMethod_New(meth->im_func);
../script/py_pickle.c:1859:            PyDict_SetItem(ret, name, meth->im_func);
../script/py_pickle.c:1879:    PyObject *name = PyString_FromString(type->tp_name);
../script/py_pickle.c:1880:    vec_pobj_push(&ctx->to_free, name);
../script/py_pickle.c:1884:    PyObject *bases = type->tp_bases;
../script/py_pickle.c:1891:    vec_pobj_push(&ctx->to_free, dict);
../script/py_pickle.c:1894:    vec_pobj_push(&ctx->to_free, str);
../script/py_pickle.c:1906:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:1916:        CHK_TRUE(rw->write(rw, pops, ARR_SIZE(pops), 1), fail);
../script/py_pickle.c:1923:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:1928:    return -1;
../script/py_pickle.c:1939:        CHK_TRUE(rw->write(rw, true_ops, ARR_SIZE(true_ops), 1), fail);
../script/py_pickle.c:1941:        CHK_TRUE(rw->write(rw, false_ops, ARR_SIZE(false_ops), 1), fail);
../script/py_pickle.c:1947:    return -1;
../script/py_pickle.c:1957:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:1961:        return -1;
../script/py_pickle.c:1965:    CHK_TRUE(rw->write(rw, &op, 1, 1), fail);
../script/py_pickle.c:1966:    CHK_TRUE(rw->write(rw, repr_str, strlen(repr_str), 1), fail);
../script/py_pickle.c:1967:    CHK_TRUE(rw->write(rw, "\n", 1, 1), fail);
../script/py_pickle.c:1975:    return -1;
../script/py_pickle.c:1981:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:1993:    vec_pobj_push(&ctx->to_free, str);
../script/py_pickle.c:2000:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2005:    return -1;
../script/py_pickle.c:2017:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2018:    CHK_TRUE(rw->write(rw, &empty_list, 1, 1), fail);
../script/py_pickle.c:2029:    CHK_TRUE(rw->write(rw, &mark, 1, 1), fail);
../script/py_pickle.c:2037:            return -1;
../script/py_pickle.c:2041:    CHK_TRUE(rw->write(rw, &appends, 1, 1), fail);
../script/py_pickle.c:2046:    return -1;
../script/py_pickle.c:2054:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2055:    CHK_TRUE(pickle_obj(ctx, (PyObject*)su->type, rw), fail);
../script/py_pickle.c:2056:    if(su->obj) {
../script/py_pickle.c:2057:        CHK_TRUE(pickle_obj(ctx, su->obj, rw), fail);
../script/py_pickle.c:2063:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2068:    return -1;
../script/py_pickle.c:2075:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2078:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2083:    return -1;
../script/py_pickle.c:2092:    PyObject *ilow = PyLong_FromLong(range->start);
../script/py_pickle.c:2093:    PyObject *ihigh = PyLong_FromLong(range->start + (range->len * range->step));
../script/py_pickle.c:2094:    PyObject *step = PyLong_FromLong(range->step);
../script/py_pickle.c:2095:    vec_pobj_push(&ctx->to_free, ilow);
../script/py_pickle.c:2096:    vec_pobj_push(&ctx->to_free, ihigh);
../script/py_pickle.c:2097:    vec_pobj_push(&ctx->to_free, step);
../script/py_pickle.c:2104:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2109:    return -1;
../script/py_pickle.c:2121:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2122:    CHK_TRUE(rw->write(rw, &empty_dict, 1, 1), fail);
../script/py_pickle.c:2132:    CHK_TRUE(rw->write(rw, &mark, 1, 1), fail);
../script/py_pickle.c:2141:            return -1;
../script/py_pickle.c:2146:            return -1;
../script/py_pickle.c:2150:    CHK_TRUE(rw->write(rw, &setitems, 1, 1), fail);
../script/py_pickle.c:2155:    return -1;
../script/py_pickle.c:2163:    vec_pobj_push(&ctx->to_free, ret);
../script/py_pickle.c:2179:    return -1;
../script/py_pickle.c:2188:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2191:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2196:    return -1;
../script/py_pickle.c:2204:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2207:    CHK_TRUE(rw->write(rw, &unicode, 1, 1), fail);
../script/py_pickle.c:2212:    int nwritten = rw->write(rw, PyString_AS_STRING(str), 1, PyString_GET_SIZE(str));
../script/py_pickle.c:2214:    vec_pobj_push(&ctx->to_free, str);
../script/py_pickle.c:2216:    CHK_TRUE(rw->write(rw, "\0\n", 2, 1), fail);
../script/py_pickle.c:2221:    return -1;
../script/py_pickle.c:2231:    CHK_TRUE(pickle_obj(ctx, slice->start, rw), fail);
../script/py_pickle.c:2232:    CHK_TRUE(pickle_obj(ctx, slice->stop, rw), fail);
../script/py_pickle.c:2233:    CHK_TRUE(pickle_obj(ctx, slice->step, rw), fail);
../script/py_pickle.c:2236:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2241:    return -1;
../script/py_pickle.c:2247:    assert(PyType_IsSubtype(obj->ob_type, &PyStaticMethod_Type));
../script/py_pickle.c:2250:    assert(method->sm_callable);
../script/py_pickle.c:2251:    CHK_TRUE(pickle_obj(ctx, method->sm_callable, rw), fail);
../script/py_pickle.c:2252:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2255:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2260:    return -1;
../script/py_pickle.c:2270:    PyObject *real = PyFloat_FromDouble(cmplx->cval.real);
../script/py_pickle.c:2271:    PyObject *imag = PyFloat_FromDouble(cmplx->cval.imag);
../script/py_pickle.c:2272:    vec_pobj_push(&ctx->to_free, real);
../script/py_pickle.c:2273:    vec_pobj_push(&ctx->to_free, imag);
../script/py_pickle.c:2277:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2280:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2285:    return -1;
../script/py_pickle.c:2293:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2298:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2306:    if(!rw->write(rw, buff, strlen(buff), 1)) {
../script/py_pickle.c:2313:    CHK_TRUE(rw->write(rw, "\n", 1, 1), fail);
../script/py_pickle.c:2318:    return -1;
../script/py_pickle.c:2333:    if(buff->b_ptr) {
../script/py_pickle.c:2334:        assert(!buff->b_base);
../script/py_pickle.c:2337:        return -1;
../script/py_pickle.c:2339:    assert(buff->b_base);
../script/py_pickle.c:2341:    PyObject *size = PyLong_FromLong(buff->b_size);
../script/py_pickle.c:2342:    PyObject *offset = PyLong_FromLong(buff->b_offset);
../script/py_pickle.c:2343:    PyObject *readonly = PyLong_FromLong(buff->b_readonly);
../script/py_pickle.c:2344:    vec_pobj_push(&ctx->to_free, size);
../script/py_pickle.c:2345:    vec_pobj_push(&ctx->to_free, offset);
../script/py_pickle.c:2346:    vec_pobj_push(&ctx->to_free, readonly);
../script/py_pickle.c:2348:    CHK_TRUE(pickle_obj(ctx, buff->b_base, rw), fail);
../script/py_pickle.c:2354:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2359:    return -1;
../script/py_pickle.c:2368:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2372:    size_t repr_len = strlen(PyString_AS_STRING(repr)) - 1; /* strip L suffix */
../script/py_pickle.c:2376:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2377:    CHK_TRUE(rw->write(rw, PyString_AS_STRING(repr), repr_len, 1), fail);
../script/py_pickle.c:2378:    CHK_TRUE(rw->write(rw, "\n", 1, 1), fail);
../script/py_pickle.c:2385:    return -1;
../script/py_pickle.c:2393:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2399:    PyOS_snprintf(str + 1, sizeof(str) - 1, "%ld\n", l);
../script/py_pickle.c:2400:    CHK_TRUE(rw->write(rw, str, 1, strlen(str)), fail);
../script/py_pickle.c:2405:    return -1;
../script/py_pickle.c:2414:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2417:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2422:    return -1;
../script/py_pickle.c:2428:    assert(PyType_IsSubtype(obj->ob_type, &PyProperty_Type));
../script/py_pickle.c:2431:    if(prop->prop_get) {
../script/py_pickle.c:2432:        CHK_TRUE(pickle_obj(ctx, prop->prop_get, rw), fail);
../script/py_pickle.c:2437:    if(prop->prop_set) {
../script/py_pickle.c:2438:        CHK_TRUE(pickle_obj(ctx, prop->prop_set, rw), fail);
../script/py_pickle.c:2443:    if(prop->prop_del) {
../script/py_pickle.c:2444:        CHK_TRUE(pickle_obj(ctx, prop->prop_del, rw), fail);
../script/py_pickle.c:2449:    if(prop->prop_doc) {
../script/py_pickle.c:2450:        CHK_TRUE(pickle_obj(ctx, prop->prop_doc, rw), fail);
../script/py_pickle.c:2454:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2457:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2462:    return -1;
../script/py_pickle.c:2471:    /* Similar to legacy 'buffer' objects, raw-byte based memory views (created 
../script/py_pickle.c:2476:    if(NULL == mview->base) {
../script/py_pickle.c:2477:        SET_RUNTIME_EXC("raw-byte memoryview objects are not supported");
../script/py_pickle.c:2481:    CHK_TRUE(pickle_obj(ctx, mview->base, rw), fail);
../script/py_pickle.c:2484:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2489:    return -1;
../script/py_pickle.c:2506:        CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2508:        CHK_TRUE(rw->write(rw, str, 1, ARR_SIZE(str)), fail);
../script/py_pickle.c:2521:    CHK_TRUE(rw->write(rw, &mark, 1, 1), fail);
../script/py_pickle.c:2529:            return -1;
../script/py_pickle.c:2536:        CHK_TRUE(rw->write(rw, &pmark, 1, 1), fail);
../script/py_pickle.c:2542:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2544:    CHK_TRUE(rw->write(rw, &tuple, 1, 1), fail);
../script/py_pickle.c:2549:    return -1;
../script/py_pickle.c:2555:    assert(PyType_IsSubtype(obj->ob_type, &PyEnum_Type));
../script/py_pickle.c:2558:    PyObject *index = PyLong_FromLong(en->en_index);
../script/py_pickle.c:2559:    vec_pobj_push(&ctx->to_free, index);
../script/py_pickle.c:2562:    CHK_TRUE(pickle_obj(ctx, en->en_sit, rw), fail);
../script/py_pickle.c:2564:    if(en->en_result) {
../script/py_pickle.c:2565:        CHK_TRUE(pickle_obj(ctx, en->en_result, rw), fail);
../script/py_pickle.c:2570:    if(en->en_longindex) {
../script/py_pickle.c:2571:        CHK_TRUE(pickle_obj(ctx, en->en_longindex, rw), fail);
../script/py_pickle.c:2576:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2579:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2584:    return -1;
../script/py_pickle.c:2590:    assert(PyType_IsSubtype(obj->ob_type, &PyReversed_Type));
../script/py_pickle.c:2593:    PyObject *index = PyLong_FromSsize_t(rev->index);
../script/py_pickle.c:2594:    vec_pobj_push(&ctx->to_free, index);
../script/py_pickle.c:2597:    if(rev->seq) {
../script/py_pickle.c:2598:        CHK_TRUE(pickle_obj(ctx, rev->seq, rw), fail);
../script/py_pickle.c:2602:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:2605:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2610:    return -1;
../script/py_pickle.c:2619:    CHK_TRUE(pickle_obj(ctx, meth->im_func, rw), fail);
../script/py_pickle.c:2620:    if(!meth->im_self) {
../script/py_pickle.c:2623:        CHK_TRUE(pickle_obj(ctx, meth->im_self, rw), fail);
../script/py_pickle.c:2625:    CHK_TRUE(pickle_obj(ctx, meth->im_class, rw), fail);
../script/py_pickle.c:2628:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2633:    return -1;
../script/py_pickle.c:2644:    CHK_TRUE(rw->write(rw, emptyfunc, ARR_SIZE(emptyfunc), 1), fail);
../script/py_pickle.c:2647:     * as the function may be self-referencing. This is why we need to 
../script/py_pickle.c:2654:    CHK_TRUE(pickle_obj(ctx, func->func_code, rw), fail);
../script/py_pickle.c:2655:    CHK_TRUE(pickle_obj(ctx, func->func_globals, rw), fail);
../script/py_pickle.c:2657:    if(func->func_closure) {
../script/py_pickle.c:2658:        CHK_TRUE(pickle_obj(ctx, func->func_closure, rw), fail);
../script/py_pickle.c:2663:    if(func->func_module) {
../script/py_pickle.c:2664:        CHK_TRUE(pickle_obj(ctx, func->func_module, rw), fail);
../script/py_pickle.c:2669:    if(func->func_defaults) {
../script/py_pickle.c:2670:        CHK_TRUE(pickle_obj(ctx, func->func_defaults, rw), fail);
../script/py_pickle.c:2676:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2681:    return -1;
../script/py_pickle.c:2691:    if(!pickle_obj(ctx, cls->cl_name, rw))
../script/py_pickle.c:2695:    PyObject *bases = cls->cl_bases;
../script/py_pickle.c:2702:    if(!pickle_obj(ctx, cls->cl_dict, rw))
../script/py_pickle.c:2706:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2711:    return -1;
../script/py_pickle.c:2724:    assert(gen->gi_code);
../script/py_pickle.c:2725:    if(gen->gi_frame) {
../script/py_pickle.c:2726:        CHK_TRUE(pickle_obj(ctx, (PyObject*)gen->gi_frame, rw), fail);
../script/py_pickle.c:2728:        CHK_TRUE(pickle_obj(ctx, gen->gi_code, rw), fail);
../script/py_pickle.c:2732:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2737:    return -1;
../script/py_pickle.c:2746:    CHK_TRUE(pickle_obj(ctx, (PyObject*)inst->in_class, rw), fail);
../script/py_pickle.c:2747:    CHK_TRUE(pickle_obj(ctx, inst->in_dict, rw), fail);
../script/py_pickle.c:2750:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2755:    return -1;
../script/py_pickle.c:2762:    assert(PyString_Check(file->f_name));
../script/py_pickle.c:2764:    if(file->f_fp == stdin  || !strcmp(PyString_AS_STRING(file->f_name), "<stdin>")
../script/py_pickle.c:2765:    || file->f_fp == stdout || !strcmp(PyString_AS_STRING(file->f_name), "<stdout>")
../script/py_pickle.c:2766:    || file->f_fp == stderr || !strcmp(PyString_AS_STRING(file->f_name), "<stderr>")) {
../script/py_pickle.c:2772:        PyString_AS_STRING(file->f_name));
../script/py_pickle.c:2773:    return -1;
../script/py_pickle.c:2785:    if(cell->ob_ref == NULL) {
../script/py_pickle.c:2786:        CHK_TRUE(rw->write(rw, ec_ops, ARR_SIZE(ec_ops), 1), fail);
../script/py_pickle.c:2788:        CHK_TRUE(pickle_obj(ctx, cell->ob_ref, rw), fail);
../script/py_pickle.c:2789:        CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ec_ops), 1), fail);
../script/py_pickle.c:2795:    return -1;
../script/py_pickle.c:2803:    /* The module can be self-referencing. Push an empty instance and 
../script/py_pickle.c:2806:    CHK_TRUE(rw->write(rw, emptymod, ARR_SIZE(emptymod), 1), fail);
../script/py_pickle.c:2813:    CHK_TRUE(pickle_obj(ctx, mod->md_dict, rw), fail);
../script/py_pickle.c:2817:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2822:    return -1;
../script/py_pickle.c:2827:    assert(obj->ob_type == &PyGetSetDescr_Type);
../script/py_pickle.c:2833:    CHK_TRUE(pickle_obj(ctx, (PyObject*)desc->d_type, rw), fail);
../script/py_pickle.c:2834:    CHK_TRUE(pickle_obj(ctx, desc->d_name, rw), fail);
../script/py_pickle.c:2837:    CHK_TRUE(rw->write(rw, getattr, ARR_SIZE(getattr), 1), fail);
../script/py_pickle.c:2842:    return -1;
../script/py_pickle.c:2852:    assert(obj->ob_type == &PyMemberDescr_Type);
../script/py_pickle.c:2858:    CHK_TRUE(pickle_obj(ctx, (PyObject*)desc->d_type, rw), fail);
../script/py_pickle.c:2860:    assert(desc->d_member->name);
../script/py_pickle.c:2861:    PyObject *str = PyString_FromString(desc->d_member->name);
../script/py_pickle.c:2862:    vec_pobj_push(&ctx->to_free, str);
../script/py_pickle.c:2866:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2871:    return -1;
../script/py_pickle.c:2877:    assert(obj->ob_type == &PyDictProxy_Type);
../script/py_pickle.c:2880:    CHK_TRUE(pickle_obj(ctx, proxy->dict, rw), fail);
../script/py_pickle.c:2883:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2888:    return -1;
../script/py_pickle.c:2895:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2900:    return -1;
../script/py_pickle.c:2907:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:2912:    return -1;
../script/py_pickle.c:2927:    assert(obj->ob_type == &PyCFunction_Type);
../script/py_pickle.c:2930:    /* Instances of unbounded built-in functions are never re-created. It is sufficient 
../script/py_pickle.c:2932:    if(!func->m_self || !strcmp(func->m_ml->ml_name, "__new__")) {
../script/py_pickle.c:2938:    CHK_TRUE(pickle_obj(ctx, func->m_self, rw), fail);
../script/py_pickle.c:2939:    CHK_TRUE(pickle_obj(ctx, (PyObject*)func->m_self->ob_type, rw), fail);
../script/py_pickle.c:2941:    PyObject *name = PyString_FromString(func->m_ml->ml_name);
../script/py_pickle.c:2942:    vec_pobj_push(&ctx->to_free, name);
../script/py_pickle.c:2946:    CHK_TRUE(rw->write(rw, ops, 2, 1), fail);
../script/py_pickle.c:2951:    return -1;
../script/py_pickle.c:2960:    PyObject *co_argcount = PyInt_FromLong(co->co_argcount);
../script/py_pickle.c:2961:    vec_pobj_push(&ctx->to_free, co_argcount);
../script/py_pickle.c:2964:    PyObject *co_nlocals = PyInt_FromLong(co->co_nlocals);
../script/py_pickle.c:2965:    vec_pobj_push(&ctx->to_free, co_nlocals);
../script/py_pickle.c:2968:    PyObject *co_stacksize = PyInt_FromLong(co->co_stacksize);
../script/py_pickle.c:2969:    vec_pobj_push(&ctx->to_free, co_stacksize);
../script/py_pickle.c:2972:    PyObject *co_flags = PyInt_FromLong(co->co_flags);
../script/py_pickle.c:2973:    vec_pobj_push(&ctx->to_free, co_flags);
../script/py_pickle.c:2976:    CHK_TRUE(pickle_obj(ctx, co->co_code, rw), fail);
../script/py_pickle.c:2977:    CHK_TRUE(pickle_obj(ctx, co->co_consts, rw), fail);
../script/py_pickle.c:2978:    CHK_TRUE(pickle_obj(ctx, co->co_names, rw), fail);
../script/py_pickle.c:2979:    CHK_TRUE(pickle_obj(ctx, co->co_varnames, rw), fail);
../script/py_pickle.c:2980:    CHK_TRUE(pickle_obj(ctx, co->co_freevars, rw), fail);
../script/py_pickle.c:2981:    CHK_TRUE(pickle_obj(ctx, co->co_cellvars, rw), fail);
../script/py_pickle.c:2982:    CHK_TRUE(pickle_obj(ctx, co->co_filename, rw), fail);
../script/py_pickle.c:2983:    CHK_TRUE(pickle_obj(ctx, co->co_name, rw), fail);
../script/py_pickle.c:2985:    PyObject *co_firstlineno = PyInt_FromLong(co->co_firstlineno);
../script/py_pickle.c:2986:    vec_pobj_push(&ctx->to_free, co_firstlineno);
../script/py_pickle.c:2988:    CHK_TRUE(pickle_obj(ctx, co->co_lnotab, rw), fail);
../script/py_pickle.c:2991:    CHK_TRUE(rw->write(rw, ops, 2, 1), fail);
../script/py_pickle.c:2996:    return -1;
../script/py_pickle.c:3005:    if(tb->tb_next) {
../script/py_pickle.c:3006:        CHK_TRUE(pickle_obj(ctx, (PyObject*)tb->tb_next, rw), fail);
../script/py_pickle.c:3011:    CHK_TRUE(pickle_obj(ctx, (PyObject*)tb->tb_frame, rw), fail);
../script/py_pickle.c:3013:    PyObject *lineno = PyInt_FromLong(tb->tb_lineno);
../script/py_pickle.c:3014:    PyObject *lasti = PyInt_FromLong(tb->tb_lasti);
../script/py_pickle.c:3015:    vec_pobj_push(&ctx->to_free, lineno);
../script/py_pickle.c:3016:    vec_pobj_push(&ctx->to_free, lasti);
../script/py_pickle.c:3022:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3027:    return -1;
../script/py_pickle.c:3033:    ncells = PyTuple_GET_SIZE(frame->f_code->co_cellvars);
../script/py_pickle.c:3034:    nfrees = PyTuple_GET_SIZE(frame->f_code->co_freevars);
../script/py_pickle.c:3035:    extras = frame->f_code->co_stacksize + frame->f_code->co_nlocals 
../script/py_pickle.c:3047:    vec_pobj_push(&ctx->to_free, valsize);
../script/py_pickle.c:3051:     * attributes after. This is to handle self-referencing cases. 
../script/py_pickle.c:3054:    CHK_TRUE(rw->write(rw, emptyframe, ARR_SIZE(emptyframe), 1), fail);
../script/py_pickle.c:3061:    CHK_TRUE(rw->write(rw, pop, ARR_SIZE(pop), 1), fail);
../script/py_pickle.c:3070:    size_t nvals = (f->f_stacktop == NULL) ? 0 : (f->f_stacktop - f->f_valuestack);
../script/py_pickle.c:3073:    PyObject *nv = f->f_stacktop == NULL ? (Py_INCREF(Py_None), Py_None) 
../script/py_pickle.c:3075:    vec_pobj_push(&ctx->to_free, nv);
../script/py_pickle.c:3079:    CHK_TRUE(rw->write(rw, mark, ARR_SIZE(mark), 1), fail);
../script/py_pickle.c:3085:    for(int i = nvals-1; i >= 0; i--) {
../script/py_pickle.c:3086:        CHK_TRUE(pickle_obj(ctx, f->f_valuestack[i], rw), fail);
../script/py_pickle.c:3089:    CHK_TRUE(rw->write(rw, mark, ARR_SIZE(mark), 1), fail);
../script/py_pickle.c:3090:    for(int i = f->f_iblock-1; i >= 0; i--) {
../script/py_pickle.c:3092:        const PyTryBlock *b = &f->f_blockstack[i];
../script/py_pickle.c:3093:        PyObject *type = PyInt_FromLong(b->b_type);
../script/py_pickle.c:3094:        PyObject *handler = PyInt_FromLong(b->b_handler);
../script/py_pickle.c:3095:        PyObject *level = PyInt_FromLong(b->b_level);
../script/py_pickle.c:3097:        vec_pobj_push(&ctx->to_free, type);
../script/py_pickle.c:3098:        vec_pobj_push(&ctx->to_free, handler);
../script/py_pickle.c:3099:        vec_pobj_push(&ctx->to_free, level);
../script/py_pickle.c:3107:    CHK_TRUE(rw->write(rw, mark, ARR_SIZE(mark), 1), fail);
../script/py_pickle.c:3109:    size_t nextra = f->f_valuestack - f->f_localsplus;
../script/py_pickle.c:3110:    for(int i = nextra-1; i >= 0; i--) {
../script/py_pickle.c:3111:        PyObject *curr = f->f_localsplus[i];
../script/py_pickle.c:3114:            CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3120:    PyObject *lasti = PyInt_FromLong(f->f_lasti);
../script/py_pickle.c:3121:    vec_pobj_push(&ctx->to_free, lasti);
../script/py_pickle.c:3124:    PyObject *lineno = PyInt_FromLong(f->f_lineno);
../script/py_pickle.c:3125:    vec_pobj_push(&ctx->to_free, lineno);
../script/py_pickle.c:3128:    if(f->f_back) {
../script/py_pickle.c:3129:        CHK_TRUE(pickle_obj(ctx, (PyObject*)f->f_back, rw), fail);
../script/py_pickle.c:3136:    CHK_TRUE(pickle_obj(ctx, (PyObject*)f->f_code, rw), fail);
../script/py_pickle.c:3137:    CHK_TRUE(pickle_obj(ctx, f->f_globals, rw), fail);
../script/py_pickle.c:3139:    if(f->f_locals) {
../script/py_pickle.c:3140:        CHK_TRUE(pickle_obj(ctx, f->f_locals, rw), fail);
../script/py_pickle.c:3150:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3155:    return -1;
../script/py_pickle.c:3162:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3166:    return -1;
../script/py_pickle.c:3174:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3178:    return -1;
../script/py_pickle.c:3186:    CHK_TRUE(rw->write(rw, &none, 1, 1), fail);
../script/py_pickle.c:3190:    return -1;
../script/py_pickle.c:3198:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3202:    return -1;
../script/py_pickle.c:3211:    assert(ref->wr_object == Py_None || PyType_SUPPORTS_WEAKREFS(Py_TYPE(ref->wr_object)));
../script/py_pickle.c:3212:    CHK_TRUE(pickle_obj(ctx, ref->wr_object, rw), fail);
../script/py_pickle.c:3214:    if(ref->wr_callback) {
../script/py_pickle.c:3215:        CHK_TRUE(pickle_obj(ctx, ref->wr_callback, rw), fail);
../script/py_pickle.c:3221:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3226:    return -1;
../script/py_pickle.c:3239:    CHK_TRUE(pickle_obj(ctx, ref->wr_object, rw), fail);
../script/py_pickle.c:3241:    if(ref->wr_callback) {
../script/py_pickle.c:3242:        CHK_TRUE(pickle_obj(ctx, ref->wr_callback, rw), fail);
../script/py_pickle.c:3248:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3253:    return -1;
../script/py_pickle.c:3262:    CHK_TRUE(pickle_obj(ctx, entry->ste_id, rw), fail);
../script/py_pickle.c:3263:    CHK_TRUE(pickle_obj(ctx, entry->ste_symbols, rw), fail);
../script/py_pickle.c:3264:    CHK_TRUE(pickle_obj(ctx, entry->ste_name, rw), fail);
../script/py_pickle.c:3265:    CHK_TRUE(pickle_obj(ctx, entry->ste_varnames, rw), fail);
../script/py_pickle.c:3266:    CHK_TRUE(pickle_obj(ctx, entry->ste_children, rw), fail);
../script/py_pickle.c:3268:    PyObject *ste_type = PyInt_FromLong(entry->ste_type);
../script/py_pickle.c:3269:    PyObject *ste_unoptimized = PyInt_FromLong(entry->ste_unoptimized);
../script/py_pickle.c:3270:    PyObject *ste_nested = PyInt_FromLong(entry->ste_nested);
../script/py_pickle.c:3271:    PyObject *ste_free = PyInt_FromLong(entry->ste_free);
../script/py_pickle.c:3272:    PyObject *ste_child_free = PyInt_FromLong(entry->ste_child_free);
../script/py_pickle.c:3273:    PyObject *ste_generator = PyInt_FromLong(entry->ste_generator);
../script/py_pickle.c:3274:    PyObject *ste_varargs = PyInt_FromLong(entry->ste_varargs);
../script/py_pickle.c:3275:    PyObject *ste_varkeywords = PyInt_FromLong(entry->ste_varkeywords);
../script/py_pickle.c:3276:    PyObject *ste_returns_value = PyInt_FromLong(entry->ste_returns_value);
../script/py_pickle.c:3277:    PyObject *ste_lineno = PyInt_FromLong(entry->ste_lineno);
../script/py_pickle.c:3278:    PyObject *ste_tmpname = PyInt_FromLong(entry->ste_tmpname);
../script/py_pickle.c:3280:    vec_pobj_push(&ctx->to_free, ste_type);
../script/py_pickle.c:3281:    vec_pobj_push(&ctx->to_free, ste_unoptimized);
../script/py_pickle.c:3282:    vec_pobj_push(&ctx->to_free, ste_nested);
../script/py_pickle.c:3283:    vec_pobj_push(&ctx->to_free, ste_free);
../script/py_pickle.c:3284:    vec_pobj_push(&ctx->to_free, ste_child_free);
../script/py_pickle.c:3285:    vec_pobj_push(&ctx->to_free, ste_generator);
../script/py_pickle.c:3286:    vec_pobj_push(&ctx->to_free, ste_varargs);
../script/py_pickle.c:3287:    vec_pobj_push(&ctx->to_free, ste_varkeywords);
../script/py_pickle.c:3288:    vec_pobj_push(&ctx->to_free, ste_returns_value);
../script/py_pickle.c:3289:    vec_pobj_push(&ctx->to_free, ste_lineno);
../script/py_pickle.c:3290:    vec_pobj_push(&ctx->to_free, ste_tmpname);
../script/py_pickle.c:3305:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3310:    return -1;
../script/py_pickle.c:3321:    assert(obj->ob_type == &PyClassMethod_Type);
../script/py_pickle.c:3325:    vec_pobj_push(&ctx->to_free, func);
../script/py_pickle.c:3329:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3334:    return -1;
../script/py_pickle.c:3343:    CHK_TRUE(pickle_obj(ctx, (PyObject*)dv->dv_dict, rw), fail);
../script/py_pickle.c:3346:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3351:    return -1;
../script/py_pickle.c:3360:    CHK_TRUE(pickle_obj(ctx, (PyObject*)dv->dv_dict, rw), fail);
../script/py_pickle.c:3363:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3368:    return -1;
../script/py_pickle.c:3377:    CHK_TRUE(pickle_obj(ctx, (PyObject*)dv->dv_dict, rw), fail);
../script/py_pickle.c:3380:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3385:    return -1;
../script/py_pickle.c:3391:    assert(obj->ob_type == s_type_dispatch_table[idx].type);
../script/py_pickle.c:3396:    CHK_TRUE(pickle_obj(ctx, (PyObject*)desc->d_type, rw), fail);
../script/py_pickle.c:3397:    CHK_TRUE(pickle_obj(ctx, desc->d_name, rw), fail);
../script/py_pickle.c:3400:    CHK_TRUE(rw->write(rw, getattr, ARR_SIZE(getattr), 1), fail);
../script/py_pickle.c:3405:    return -1;
../script/py_pickle.c:3413:    CHK_TRUE(pickle_obj(ctx, (PyObject*)wrapper->descr, rw), fail);
../script/py_pickle.c:3414:    CHK_TRUE(pickle_obj(ctx, wrapper->self, rw), fail);
../script/py_pickle.c:3417:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3422:    return -1;
../script/py_pickle.c:3431:    if(ci->it_callable)
../script/py_pickle.c:3432:        CHK_TRUE(pickle_obj(ctx, ci->it_callable, rw), fail);
../script/py_pickle.c:3436:    if(ci->it_sentinel)
../script/py_pickle.c:3437:        CHK_TRUE(pickle_obj(ctx, ci->it_sentinel, rw), fail);
../script/py_pickle.c:3442:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3447:    return -1;
../script/py_pickle.c:3455:    PyObject *index = PyLong_FromLong(seq->it_index);
../script/py_pickle.c:3457:    vec_pobj_push(&ctx->to_free, index);
../script/py_pickle.c:3460:    if(seq->it_seq) {
../script/py_pickle.c:3461:        CHK_TRUE(pickle_obj(ctx, seq->it_seq, rw), fail);
../script/py_pickle.c:3467:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3472:    return -1;
../script/py_pickle.c:3480:    if(iter->di_dict)
../script/py_pickle.c:3481:        CHK_TRUE(pickle_obj(ctx, (PyObject*)iter->di_dict, rw), fail);
../script/py_pickle.c:3485:    PyObject *di_used = PyLong_FromSsize_t(iter->di_used);
../script/py_pickle.c:3487:    vec_pobj_push(&ctx->to_free, di_used);
../script/py_pickle.c:3489:    PyObject *di_pos = PyLong_FromSsize_t(iter->di_pos);
../script/py_pickle.c:3491:    vec_pobj_push(&ctx->to_free, di_pos);
../script/py_pickle.c:3495:    if(iter->di_result)
../script/py_pickle.c:3496:        CHK_TRUE(pickle_obj(ctx, iter->di_result, rw), fail);
../script/py_pickle.c:3500:    PyObject *len = PyLong_FromSsize_t(iter->len);
../script/py_pickle.c:3502:    vec_pobj_push(&ctx->to_free, len);
../script/py_pickle.c:3507:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3512:    return -1;
../script/py_pickle.c:3550:    CHK_TRUE(pickle_obj(ctx, (PyObject*)iter->str, rw), fail);
../script/py_pickle.c:3552:    const char *raw = PyString_AS_STRING(iter->str);
../script/py_pickle.c:3555:    assert(iter->it_field.ptr >= raw && iter->it_field.ptr < raw + rawlen);
../script/py_pickle.c:3556:    assert(iter->it_field.str.ptr >= raw && iter->it_field.str.ptr < raw + rawlen);
../script/py_pickle.c:3557:    assert(iter->it_field.str.end >= raw && iter->it_field.str.end <= raw + rawlen);
../script/py_pickle.c:3559:    size_t swiz_ptr = iter->it_field.ptr - raw;
../script/py_pickle.c:3560:    size_t swiz_str_ptr = iter->it_field.str.ptr - raw;
../script/py_pickle.c:3561:    size_t swiz_str_end = iter->it_field.str.end - raw;
../script/py_pickle.c:3569:    vec_pobj_push(&ctx->to_free, ptr);
../script/py_pickle.c:3573:    vec_pobj_push(&ctx->to_free, str_ptr);
../script/py_pickle.c:3577:    vec_pobj_push(&ctx->to_free, str_end);
../script/py_pickle.c:3584:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3589:    return -1;
../script/py_pickle.c:3597:    CHK_TRUE(pickle_obj(ctx, (PyObject*)iter->str, rw), fail);
../script/py_pickle.c:3599:    const char *raw = PyString_AS_STRING(iter->str);
../script/py_pickle.c:3602:    assert(iter->it_markup.str.ptr >= raw && iter->it_markup.str.ptr < raw + rawlen);
../script/py_pickle.c:3603:    assert(iter->it_markup.str.end >= raw && iter->it_markup.str.end <= raw + rawlen);
../script/py_pickle.c:3605:    size_t swiz_str_ptr = iter->it_markup.str.ptr - raw;
../script/py_pickle.c:3606:    size_t swiz_str_end = iter->it_markup.str.end - raw;
../script/py_pickle.c:3613:    vec_pobj_push(&ctx->to_free, str_ptr);
../script/py_pickle.c:3617:    vec_pobj_push(&ctx->to_free, str_end);
../script/py_pickle.c:3623:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3628:    return -1;
../script/py_pickle.c:3648:    if(si->si_set)
../script/py_pickle.c:3649:        CHK_TRUE(pickle_obj(ctx, (PyObject*)si->si_set, rw), fail);
../script/py_pickle.c:3653:    PyObject *si_used = PyLong_FromSsize_t(si->si_used);
../script/py_pickle.c:3655:    vec_pobj_push(&ctx->to_free, si_used);
../script/py_pickle.c:3657:    PyObject *si_pos = PyLong_FromSsize_t(si->si_pos);
../script/py_pickle.c:3659:    vec_pobj_push(&ctx->to_free, si_pos);
../script/py_pickle.c:3661:    PyObject *len = PyLong_FromSsize_t(si->len);
../script/py_pickle.c:3663:    vec_pobj_push(&ctx->to_free, len);
../script/py_pickle.c:3670:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3675:    return -1;
../script/py_pickle.c:3688:    PyTypeObject *type = obj->ob_type, *basetype = NULL;
../script/py_pickle.c:3689:    assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
../script/py_pickle.c:3690:    assert(type->tp_mro);
../script/py_pickle.c:3691:    assert(PyTuple_Check(type->tp_mro));
../script/py_pickle.c:3692:    assert(PyTuple_GET_SIZE(type->tp_mro) >= 1);
../script/py_pickle.c:3694:    for(int i = 0; i < PyTuple_GET_SIZE(type->tp_mro); i++) {
../script/py_pickle.c:3696:        PyObject *base = PyTuple_GET_ITEM(type->tp_mro, i);
../script/py_pickle.c:3716:    CHK_TRUE(pickle_obj(ctx, (PyObject*)obj->ob_type, rw), fail);
../script/py_pickle.c:3719:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3724:    return -1;
../script/py_pickle.c:3732:    PyObject *nitems = PyInt_FromSsize_t(ig->nitems);
../script/py_pickle.c:3733:    vec_pobj_push(&ctx->to_free, nitems);
../script/py_pickle.c:3736:    assert(ig->item);
../script/py_pickle.c:3737:    CHK_TRUE(pickle_obj(ctx, ig->item, rw), fail);
../script/py_pickle.c:3740:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3745:    return -1;
../script/py_pickle.c:3753:    PyObject *nattrs = PyInt_FromSsize_t(ag->nattrs);
../script/py_pickle.c:3754:    vec_pobj_push(&ctx->to_free, nattrs);
../script/py_pickle.c:3757:    assert(ag->attr);
../script/py_pickle.c:3758:    CHK_TRUE(pickle_obj(ctx, ag->attr, rw), fail);
../script/py_pickle.c:3761:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3766:    return -1;
../script/py_pickle.c:3774:    CHK_TRUE(pickle_obj(ctx, mc->name, rw), fail);
../script/py_pickle.c:3775:    CHK_TRUE(pickle_obj(ctx, mc->args, rw), fail);
../script/py_pickle.c:3777:    if(mc->kwds) {
../script/py_pickle.c:3778:        CHK_TRUE(pickle_obj(ctx, mc->kwds, rw), fail);
../script/py_pickle.c:3784:    CHK_TRUE(rw->write(rw, ops, ARR_SIZE(ops), 1), fail);
../script/py_pickle.c:3789:    return -1;
../script/py_pickle.c:3799:        return -1;
../script/py_pickle.c:3801:    vec_pobj_push(&ctx->to_free, ph);
../script/py_pickle.c:3809:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:3813:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:3830:        SET_RUNTIME_EXC("Bad int in pickle stream [offset: %ld]", (long)rw->seek(rw, RW_SEEK_CUR, 0));
../script/py_pickle.c:3836:    vec_pobj_push(&ctx->stack, val);
../script/py_pickle.c:3844:    return -1;
../script/py_pickle.c:3851:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:3855:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:3872:        SET_RUNTIME_EXC("Bad long in pickle stream [offset: %ld]", (long)rw->seek(rw, RW_SEEK_CUR, 0));
../script/py_pickle.c:3878:    vec_pobj_push(&ctx->stack, val);
../script/py_pickle.c:3886:    return -1;
../script/py_pickle.c:3892:    ctx->stop = true;
../script/py_pickle.c:3900:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:3904:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:3923:    vec_AT(&str, vec_size(&str)-1) = '\0';
../script/py_pickle.c:3926:    len = vec_size(&str)-1;
../script/py_pickle.c:3929:    while (len > 0 && p[len-1] <= ' ')
../script/py_pickle.c:3930:        len--;
../script/py_pickle.c:3933:    if (len > 1 && p[0] == '"' && p[len-1] == '"') {
../script/py_pickle.c:3934:        p[len-1] = '\0';
../script/py_pickle.c:3936:        len -= 2;
../script/py_pickle.c:3937:    } else if (len > 1 && p[0] == '\'' && p[len-1] == '\'') {
../script/py_pickle.c:3938:        p[len-1] = '\0';
../script/py_pickle.c:3940:        len -= 2;
../script/py_pickle.c:3963:    vec_pobj_push(&ctx->stack, strobj);
../script/py_pickle.c:3972:    return -1;
../script/py_pickle.c:3982:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:3984:        return -1;
../script/py_pickle.c:3990:        SET_RUNTIME_EXC("Bad index in pickle stream: [offset: %ld]", (long)rw->seek(rw, RW_SEEK_CUR, 0));
../script/py_pickle.c:3991:        return -1;
../script/py_pickle.c:3994:    if(idx != ctx->memo.size) {
../script/py_pickle.c:3995:        SET_RUNTIME_EXC("Bad index %d (expected %d)", idx, (int)ctx->memo.size);
../script/py_pickle.c:3996:        return -1;
../script/py_pickle.c:3999:    vec_pobj_resize(&ctx->memo, idx + 1);
../script/py_pickle.c:4000:    ctx->memo.size = idx + 1;    
../script/py_pickle.c:4001:    vec_AT(&ctx->memo, idx) = TOP(&ctx->stack);
../script/py_pickle.c:4002:    Py_INCREF(vec_AT(&ctx->memo, idx)); /* The memo references everything in it */
../script/py_pickle.c:4007:    return -1;
../script/py_pickle.c:4020:        SET_RUNTIME_EXC("Bad index in pickle stream: [offset: %ld]", (long)rw->seek(rw, RW_SEEK_CUR, 0));
../script/py_pickle.c:4021:        return -1;
../script/py_pickle.c:4024:    if(vec_size(&ctx->memo) <= idx) {
../script/py_pickle.c:4026:        return -1;
../script/py_pickle.c:4029:    vec_pobj_push(&ctx->stack, vec_AT(&ctx->memo, idx));
../script/py_pickle.c:4030:    Py_INCREF(TOP(&ctx->stack));
../script/py_pickle.c:4035:    return -1;
../script/py_pickle.c:4041:    return vec_int_push(&ctx->mark_stack, vec_size(&ctx->stack)) ? 0 : -1;
../script/py_pickle.c:4047:    if(vec_size(&ctx->stack) == 0) {
../script/py_pickle.c:4049:        return -1;
../script/py_pickle.c:4052:    Py_DECREF(TOP(&ctx->stack));
../script/py_pickle.c:4053:    vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4060:    if(vec_size(&ctx->mark_stack) == 0) {
../script/py_pickle.c:4062:        return -1;
../script/py_pickle.c:4065:    int mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:4066:    if(vec_size(&ctx->stack) < mark) {
../script/py_pickle.c:4068:        return -1;
../script/py_pickle.c:4071:    while(vec_size(&ctx->stack) > mark) {
../script/py_pickle.c:4073:        PyObject *obj = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4082:    int ret = -1;
../script/py_pickle.c:4084:    if(vec_size(&ctx->mark_stack) == 0) {
../script/py_pickle.c:4089:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4093:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4103:    int mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:4104:    if(vec_size(&ctx->stack) < mark) {
../script/py_pickle.c:4106:        return -1;
../script/py_pickle.c:4109:    size_t tup_len = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:4114:        PyObject *elem = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4115:        PyTuple_SET_ITEM(tmp, tup_len - i - 1, elem);
../script/py_pickle.c:4122:    vec_pobj_push(&ctx->stack, tuple);
../script/py_pickle.c:4135:    int ret = -1;
../script/py_pickle.c:4137:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4141:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4154:        return -1;
../script/py_pickle.c:4156:    vec_pobj_push(&ctx->stack, tuple);
../script/py_pickle.c:4168:    int ret = -1;
../script/py_pickle.c:4170:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4174:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4192:    vec_pobj_push(&ctx->stack, list);
../script/py_pickle.c:4206:    if(vec_size(&ctx->mark_stack) == 0) {
../script/py_pickle.c:4208:        return -1;
../script/py_pickle.c:4211:    int mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:4212:    if(vec_size(&ctx->stack) < mark-1) {
../script/py_pickle.c:4214:        return -1;
../script/py_pickle.c:4217:    size_t extra_len = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:4218:    PyObject *list = vec_AT(&ctx->stack, mark-1);
../script/py_pickle.c:4221:        return -1;
../script/py_pickle.c:4227:        return -1;
../script/py_pickle.c:4232:        PyObject *elem = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4233:        PyList_SetItem(append, extra_len - i - 1, elem);
../script/py_pickle.c:4245:    int ret = -1;
../script/py_pickle.c:4247:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4251:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4264:    vec_pobj_push(&ctx->stack, dict);
../script/py_pickle.c:4277:    if(vec_size(&ctx->mark_stack) == 0) {
../script/py_pickle.c:4279:        return -1;
../script/py_pickle.c:4282:    int mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:4283:    if(vec_size(&ctx->stack) < mark-1) {
../script/py_pickle.c:4285:        return -1;
../script/py_pickle.c:4288:    size_t nitems = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:4290:        SET_RUNTIME_EXC("Non-even number of key-value pair objects");
../script/py_pickle.c:4291:        return -1;
../script/py_pickle.c:4295:    PyObject *dict = vec_AT(&ctx->stack, mark-1);
../script/py_pickle.c:4298:        return -1;
../script/py_pickle.c:4303:        PyObject *val = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4304:        PyObject *key = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4316:    vec_pobj_push(&ctx->stack, Py_None);
../script/py_pickle.c:4325:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4329:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4349:    assert(strlen(str.array) == vec_size(&str) - 1);
../script/py_pickle.c:4350:    PyObject *tmp = PyUnicode_DecodeUTF7(str.array, vec_size(&str)-1, "strict");
../script/py_pickle.c:4360:    vec_pobj_push(&ctx->stack, unicode);
../script/py_pickle.c:4369:    return -1;
../script/py_pickle.c:4377:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4381:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4404:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:4414:    return -1;
../script/py_pickle.c:4432:        return -1;
../script/py_pickle.c:4435:    vec_pobj_push(&ctx->stack, ret);
../script/py_pickle.c:4440:    return -1;
../script/py_pickle.c:4447:    int ret = -1;
../script/py_pickle.c:4448:    if(vec_size(&ctx->stack) < 4) {
../script/py_pickle.c:4453:    PyObject *meta = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4454:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4455:    PyObject *bases = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4456:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4482:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:4500:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:4502:        return -1;
../script/py_pickle.c:4504:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4505:    PyObject *obj = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4507:    int ret = -1;
../script/py_pickle.c:4516:    vec_pobj_push(&ctx->stack, attr);
../script/py_pickle.c:4529:    if(vec_size(&ctx->stack) < 14) {
../script/py_pickle.c:4531:        return -1;
../script/py_pickle.c:4534:    int rval = -1;
../script/py_pickle.c:4535:    PyObject *lnotab = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4536:    PyObject *firstlineno = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4537:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4538:    PyObject *filename = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4539:    PyObject *cellvars = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4540:    PyObject *freevars = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4541:    PyObject *varnames = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4542:    PyObject *names = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4543:    PyObject *consts = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4544:    PyObject *code = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4545:    PyObject *flags = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4546:    PyObject *stacksize = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4547:    PyObject *nlocals = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4548:    PyObject *argcount = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4581:    vec_pobj_push(&ctx->stack, ret);
../script/py_pickle.c:4605:    if(vec_size(&ctx->stack) < 6) {
../script/py_pickle.c:4607:        return -1;
../script/py_pickle.c:4610:    PyObject *defaults = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4611:    PyObject *module = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4612:    PyObject *closure = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4613:    PyObject *globals = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4614:    PyObject *code = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4615:    PyFunctionObject *op = (PyFunctionObject*)vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4617:    /* Make sure we don't traverse the function object's fields mid-surgery */
../script/py_pickle.c:4621:    Py_CLEAR(op->func_code); 
../script/py_pickle.c:4622:    Py_CLEAR(op->func_globals);
../script/py_pickle.c:4623:    Py_CLEAR(op->func_name);
../script/py_pickle.c:4624:    Py_CLEAR(op->func_doc);
../script/py_pickle.c:4625:    assert(!op->func_defaults);
../script/py_pickle.c:4626:    assert(!op->func_module);
../script/py_pickle.c:4627:    Py_CLEAR(op->func_dict);
../script/py_pickle.c:4632:     * before pickling its' members to handle self-referencing. 
../script/py_pickle.c:4640:    op->func_weakreflist = NULL;
../script/py_pickle.c:4641:    op->func_code = code; /* Steal ref */
../script/py_pickle.c:4642:    op->func_globals = globals; /* Steal ref */
../script/py_pickle.c:4643:    op->func_name = ((PyCodeObject *)code)->co_name;
../script/py_pickle.c:4644:    Py_INCREF(op->func_name);
../script/py_pickle.c:4645:    op->func_defaults = NULL; /* No default arguments */
../script/py_pickle.c:4646:    op->func_closure = NULL;
../script/py_pickle.c:4647:    consts = ((PyCodeObject *)code)->co_consts;
../script/py_pickle.c:4656:    op->func_doc = doc;
../script/py_pickle.c:4657:    op->func_dict = NULL;
../script/py_pickle.c:4658:    op->func_module = NULL;
../script/py_pickle.c:4662:        op->func_module = module;
../script/py_pickle.c:4687:    vec_pobj_push(&ctx->stack, (PyObject*)op);
../script/py_pickle.c:4697:    return -1;
../script/py_pickle.c:4705:    vec_pobj_push(&ctx->stack, cell);
../script/py_pickle.c:4713:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4715:        return -1;
../script/py_pickle.c:4718:    PyObject *val = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4722:    vec_pobj_push(&ctx->stack, cell);
../script/py_pickle.c:4730:    vec_pobj_push(&ctx->stack, Py_True);
../script/py_pickle.c:4738:    vec_pobj_push(&ctx->stack, Py_False);
../script/py_pickle.c:4745:    int ret = -1;
../script/py_pickle.c:4747:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:4752:    PyObject *encoded = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4753:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4783:    vec_pobj_push(&ctx->stack, ba);
../script/py_pickle.c:4798:    int ret = -1;
../script/py_pickle.c:4800:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:4805:    PyObject *obj = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4806:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4807:    PyObject *metatype = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4821:    vec_pobj_push(&ctx->stack, super);
../script/py_pickle.c:4837:    if(vec_size(&ctx->mark_stack) < 1) {
../script/py_pickle.c:4839:        return -1;
../script/py_pickle.c:4842:    vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:4849:    int ret = -1;
../script/py_pickle.c:4860:    vec_pobj_push(&ctx->stack, func);
../script/py_pickle.c:4872:    int ret = -1;
../script/py_pickle.c:4874:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:4878:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4894:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:4951:    int ret = -1;
../script/py_pickle.c:4952:    if(vec_size(&ctx->mark_stack) < 1) {
../script/py_pickle.c:4954:        return -1;
../script/py_pickle.c:4957:    const int mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:4958:    size_t nitems = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:4961:        SET_RUNTIME_EXC("Non-even number of key-value pair objects");
../script/py_pickle.c:4962:        return -1;
../script/py_pickle.c:4966:    if(vec_size(&ctx->stack) < nitems*2 + 1) {
../script/py_pickle.c:4968:        return -1;
../script/py_pickle.c:4971:    PyObject *const obj = vec_AT(&ctx->stack, mark - 1);
../script/py_pickle.c:4972:    del_extra_attrs(obj, &vec_AT(&ctx->stack, mark), nitems);
../script/py_pickle.c:4976:        PyObject *val = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4977:        PyObject *key = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4979:        ret = (0 == setattr_nondestructive(obj, key, val)) ? 0 : -1;
../script/py_pickle.c:4984:            return -1;
../script/py_pickle.c:4988:    PyObject *top = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:4991:    vec_pobj_push(&ctx->stack, obj);
../script/py_pickle.c:4999:    vec_pobj_push(&ctx->stack, Py_NotImplemented);
../script/py_pickle.c:5007:    vec_pobj_push(&ctx->stack, Py_Ellipsis);
../script/py_pickle.c:5016:    vec_pobj_push(&ctx->stack, ret);
../script/py_pickle.c:5025:    vec_pobj_push(&ctx->stack, ret);
../script/py_pickle.c:5032:    int ret = -1;
../script/py_pickle.c:5034:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5038:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5039:    PyObject *items = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5061:    vec_pobj_push(&ctx->stack, set);
../script/py_pickle.c:5075:    int ret = -1;
../script/py_pickle.c:5077:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5081:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5082:    PyObject *items = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5104:    vec_pobj_push(&ctx->stack, set);
../script/py_pickle.c:5119:    int ret = -1;
../script/py_pickle.c:5120:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:5125:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5126:    PyObject *bases = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5127:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5148:    vec_pobj_push(&ctx->stack, cls);
../script/py_pickle.c:5165:    int ret = -1;
../script/py_pickle.c:5166:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5170:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5171:    PyObject *klass = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5186:    vec_pobj_push(&ctx->stack, inst);
../script/py_pickle.c:5202:    int ret = -1;
../script/py_pickle.c:5203:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5207:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5208:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5222:    for(PyGetSetDef *curr = tp_type->tp_getset; curr && curr->name; curr++) {
../script/py_pickle.c:5224:        if(0 == strcmp(curr->name, PyString_AS_STRING(name))) {
../script/py_pickle.c:5232:            PyString_AS_STRING(name), tp_type->tp_name, tp_type);
../script/py_pickle.c:5238:    vec_pobj_push(&ctx->stack, desc);
../script/py_pickle.c:5256:        return -1;
../script/py_pickle.c:5257:    mod->md_dict = NULL;
../script/py_pickle.c:5258:    vec_pobj_push(&ctx->stack, (PyObject*)mod);
../script/py_pickle.c:5265:    int ret = -1;
../script/py_pickle.c:5267:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5272:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5273:    PyObject *emptymod = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5285:    ((PyModuleObject*)emptymod)->md_dict = dict;
../script/py_pickle.c:5286:    Py_INCREF(((PyModuleObject*)emptymod)->md_dict);
../script/py_pickle.c:5290:    vec_pobj_push(&ctx->stack, emptymod);
../script/py_pickle.c:5305:    int ret = -1;
../script/py_pickle.c:5306:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5311:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5312:    PyObject *inst = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5327:    vec_pobj_push(&ctx->stack, inst);
../script/py_pickle.c:5342:    int ret = -1;
../script/py_pickle.c:5343:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:5348:    PyObject *callable = vec_pobj_pop(&ctx->stack); 
../script/py_pickle.c:5356:    vec_pobj_push(&ctx->stack, newmeth);
../script/py_pickle.c:5369:    int ret = -1;
../script/py_pickle.c:5370:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:5375:    PyObject *klass = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5376:    PyObject *self = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5377:    PyObject *func = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5381:    vec_pobj_push(&ctx->stack, newmeth);
../script/py_pickle.c:5396:    int ret = -1;
../script/py_pickle.c:5397:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5402:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5403:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5417:    for(PyMemberDef *curr = tp_type->tp_members; curr && curr->name; curr++) {
../script/py_pickle.c:5419:        if(0 == strcmp(curr->name, PyString_AS_STRING(name))) {
../script/py_pickle.c:5427:            PyString_AS_STRING(name), tp_type->tp_name);
../script/py_pickle.c:5433:    vec_pobj_push(&ctx->stack, desc);
../script/py_pickle.c:5448:    int ret = -1;
../script/py_pickle.c:5449:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5453:    PyObject *self = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5454:    PyObject *desc = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5456:    if(desc->ob_type != &PyWrapperDescr_Type) {
../script/py_pickle.c:5463:    vec_pobj_push(&ctx->stack, method);
../script/py_pickle.c:5478:    int ret = -1;
../script/py_pickle.c:5479:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:5483:    PyObject *step = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5484:    PyObject *ihigh = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5485:    PyObject *ilow = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5497:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5513:    int ret = -1;
../script/py_pickle.c:5514:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:5519:    PyObject *step = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5520:    PyObject *stop = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5521:    PyObject *start = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5525:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5540:    int ret = -1;
../script/py_pickle.c:5542:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5546:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5547:    PyObject *callable = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5565:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5580:    int ret = -1;
../script/py_pickle.c:5581:    if(vec_size(&ctx->stack) < 4) {
../script/py_pickle.c:5585:    PyObject *readonly = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5586:    PyObject *offset = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5587:    PyObject *size = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5588:    PyObject *base = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5604:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5621:    int ret = -1;
../script/py_pickle.c:5622:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:5626:    PyObject *base = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5629:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5642:    int ret = -1;
../script/py_pickle.c:5643:    if(vec_size(&ctx->stack) < 5) {
../script/py_pickle.c:5647:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5648:    PyObject *doc = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5649:    PyObject *del = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5650:    PyObject *set = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5651:    PyObject *get = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5664:    vec_pobj_push(&ctx->stack, prop);
../script/py_pickle.c:5681:    int ret = -1;
../script/py_pickle.c:5682:    if(vec_size(&ctx->stack) < 5) {
../script/py_pickle.c:5686:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5687:    PyObject *longindex = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5688:    PyObject *result = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5689:    PyObject *sit = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5690:    PyObject *index = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5725:    enumobject *en = (enumobject *)((PyTypeObject*)ctype)->tp_alloc((PyTypeObject*)ctype, 0);
../script/py_pickle.c:5728:    en->en_index = PyLong_AsSsize_t(index);
../script/py_pickle.c:5729:    en->en_sit = sit;
../script/py_pickle.c:5730:    Py_INCREF(en->en_sit);
../script/py_pickle.c:5731:    en->en_result = (result != Py_None ? result : NULL);
../script/py_pickle.c:5732:    if(en->en_result) {
../script/py_pickle.c:5733:        Py_INCREF(en->en_result); 
../script/py_pickle.c:5735:    en->en_longindex = (longindex != Py_None ? longindex : NULL);
../script/py_pickle.c:5736:    if(en->en_longindex) {
../script/py_pickle.c:5737:        Py_INCREF(en->en_longindex);
../script/py_pickle.c:5740:    vec_pobj_push(&ctx->stack, (PyObject*)en);
../script/py_pickle.c:5755:    int ret = -1;
../script/py_pickle.c:5757:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:5761:    PyObject *seq = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5762:    PyObject *index = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5777:        retval->it_seq = seq;
../script/py_pickle.c:5780:        retval->it_seq = NULL; 
../script/py_pickle.c:5782:    retval->it_index = PyLong_AsLong(index);
../script/py_pickle.c:5785:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:5810:    int ret = -1;
../script/py_pickle.c:5811:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:5815:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5816:    PyObject *imag = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5817:    PyObject *real = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5836:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5852:    int ret = -1;
../script/py_pickle.c:5853:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:5857:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5866:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5880:    int ret = -1;
../script/py_pickle.c:5881:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:5885:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5886:    PyObject *seq = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5887:    PyObject *index = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5908:    reversedobject *rev = (reversedobject*)((PyTypeObject*)ctype)->tp_alloc((PyTypeObject*)ctype, 0);
../script/py_pickle.c:5910:    rev->index = PyLong_AsSsize_t(index);
../script/py_pickle.c:5912:        rev->seq = seq;
../script/py_pickle.c:5915:        rev->seq = NULL; 
../script/py_pickle.c:5918:    vec_pobj_push(&ctx->stack, (PyObject*)rev);
../script/py_pickle.c:5933:    int ret = -1;
../script/py_pickle.c:5934:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:5938:    PyObject *top = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:5956:        gen->gi_frame = NULL;
../script/py_pickle.c:5957:        gen->gi_code = top; /* steals 'top' ref */
../script/py_pickle.c:5958:        gen->gi_running = 0;
../script/py_pickle.c:5959:        gen->gi_weakreflist = NULL;
../script/py_pickle.c:5964:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:5978:    assert(frame->f_code && frame->f_globals && frame->f_locals);
../script/py_pickle.c:5979:    size_t old_valsize = frame->f_code->co_stacksize;
../script/py_pickle.c:5980:    Py_CLEAR(frame->f_code);
../script/py_pickle.c:5981:    Py_CLEAR(frame->f_globals);
../script/py_pickle.c:5982:    Py_CLEAR(frame->f_locals);
../script/py_pickle.c:5983:    Py_CLEAR(frame->f_builtins);
../script/py_pickle.c:5986:    PyFrameObject *back = tstate->frame;
../script/py_pickle.c:5990:    if (back == NULL || back->f_globals != globals) {
../script/py_pickle.c:6006:                return -1;
../script/py_pickle.c:6014:        builtins = back->f_builtins;
../script/py_pickle.c:6019:    frame->f_builtins = builtins;
../script/py_pickle.c:6022:    frame->f_code = code;
../script/py_pickle.c:6023:    Py_INCREF(frame->f_code);
../script/py_pickle.c:6026:    frame->f_globals = globals;
../script/py_pickle.c:6027:    Py_INCREF(frame->f_globals);
../script/py_pickle.c:6030:    if ((code->co_flags & (CO_NEWLOCALS | CO_OPTIMIZED)) ==
../script/py_pickle.c:6033:    else if (code->co_flags & CO_NEWLOCALS) {
../script/py_pickle.c:6034:        frame->f_locals = PyDict_New();
../script/py_pickle.c:6035:        if(!frame->f_locals)
../script/py_pickle.c:6036:            return -1;
../script/py_pickle.c:6039:        frame->f_locals = locals;
../script/py_pickle.c:6041:            frame->f_locals = globals;
../script/py_pickle.c:6042:        Py_INCREF(frame->f_locals);
../script/py_pickle.c:6047:        return -1;
../script/py_pickle.c:6049:    const size_t ncells = PyTuple_GET_SIZE(code->co_cellvars);
../script/py_pickle.c:6050:    const size_t nfrees = PyTuple_GET_SIZE(code->co_freevars);
../script/py_pickle.c:6051:    size_t extras = code->co_nlocals + ncells + nfrees;
../script/py_pickle.c:6053:    frame->f_valuestack = frame->f_localsplus + extras;
../script/py_pickle.c:6054:    frame->f_stacktop = frame->f_valuestack;
../script/py_pickle.c:6057:        frame->f_localsplus[i] = NULL;
../script/py_pickle.c:6059:    assert(frame->f_builtins && frame->f_code && frame->f_globals);
../script/py_pickle.c:6060:    frame->f_iblock = 0;
../script/py_pickle.c:6067:    int ret = -1;
../script/py_pickle.c:6069:    if(vec_size(&ctx->stack) < 7) {
../script/py_pickle.c:6074:    if(vec_size(&ctx->mark_stack) < 3) {
../script/py_pickle.c:6079:    PyFrameObject *frame = (PyFrameObject*)vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6080:    PyObject *locals = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6081:    PyObject *globals = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6082:    PyCodeObject *code = (PyCodeObject*)vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6083:    PyObject *back = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6084:    PyObject *lineno = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6085:    PyObject *lasti = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6122:    Py_XDECREF(frame->f_back);
../script/py_pickle.c:6123:    frame->f_back = back == Py_None ? NULL : (PyFrameObject*)back;
../script/py_pickle.c:6124:    Py_XINCREF(frame->f_back);
../script/py_pickle.c:6125:    frame->f_lasti = PyInt_AsLong(lasti);
../script/py_pickle.c:6126:    frame->f_lineno = PyInt_AsLong(lineno);
../script/py_pickle.c:6129:    int mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:6130:    size_t nitems = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:6132:    if(vec_size(&ctx->stack) < mark) {
../script/py_pickle.c:6139:        PyObject *val = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6142:        frame->f_localsplus[i] = val;
../script/py_pickle.c:6146:    mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:6147:    nitems = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:6149:    if(vec_size(&ctx->stack) < mark) {
../script/py_pickle.c:6161:        PyObject *level = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6162:        PyObject *handler = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6163:        PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6168:            SET_RUNTIME_EXC("PF_FRAME: Got non-int blockstack item fields");
../script/py_pickle.c:6184:    mark = vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:6185:    nitems = vec_size(&ctx->stack) - mark;
../script/py_pickle.c:6187:    if(vec_size(&ctx->stack) < mark-1) {
../script/py_pickle.c:6192:    assert(frame->f_stacktop == frame->f_valuestack);
../script/py_pickle.c:6194:        *(frame->f_stacktop++) = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6197:    PyObject *sent = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6206:        frame->f_stacktop = NULL;
../script/py_pickle.c:6211:    vec_pobj_push(&ctx->stack, (PyObject*)frame);
../script/py_pickle.c:6231:    vec_pobj_push(&ctx->stack, NULL);
../script/py_pickle.c:6238:    int ret = -1;
../script/py_pickle.c:6240:    if(vec_size(&ctx->stack) < 4) {
../script/py_pickle.c:6244:    PyObject *lasti = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6245:    PyObject *lineno = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6246:    PyObject *frame = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6247:    PyObject *next = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6269:        tb->tb_next = (struct _traceback*)next; 
../script/py_pickle.c:6271:        tb->tb_next = NULL;
../script/py_pickle.c:6274:    tb->tb_frame = (struct _frame*)frame;
../script/py_pickle.c:6275:    tb->tb_lasti = PyInt_AsLong(lasti);
../script/py_pickle.c:6276:    tb->tb_lineno = PyInt_AsLong(lineno);
../script/py_pickle.c:6279:    vec_pobj_push(&ctx->stack, (PyObject*)tb);
../script/py_pickle.c:6293:    int ret = -1;
../script/py_pickle.c:6295:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:6299:    PyObject *valsize = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6310:    ((PyCodeObject*)code)->co_stacksize = PyInt_AsSsize_t(valsize);
../script/py_pickle.c:6322:    vec_pobj_push(&ctx->stack, (PyObject*)frame);
../script/py_pickle.c:6340:    int ret = -1;
../script/py_pickle.c:6342:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:6346:    PyObject *callback = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6347:    PyObject *referent = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6371:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:6377:    vec_pobj_push(&ctx->to_free, referent);
../script/py_pickle.c:6385:    int ret = -1;
../script/py_pickle.c:6387:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:6391:    PyObject *callback = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6392:    PyObject *referent = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6411:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:6425:    int ret = -1;
../script/py_pickle.c:6427:    if(vec_size(&ctx->stack) < 16) {
../script/py_pickle.c:6431:    PyObject *ste_tmpname = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6432:    PyObject *ste_lineno = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6433:    PyObject *ste_returns_value = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6434:    PyObject *ste_varkeywords = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6435:    PyObject *ste_varargs = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6436:    PyObject *ste_generator = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6437:    PyObject *ste_child_free = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6438:    PyObject *ste_free = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6439:    PyObject *ste_nested = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6440:    PyObject *ste_unoptimized = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6441:    PyObject *ste_type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6442:    PyObject *ste_children = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6443:    PyObject *ste_varnames = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6444:    PyObject *ste_name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6445:    PyObject *ste_symbols = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6446:    PyObject *ste_id = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6485:    retval->ste_id = ste_id;
../script/py_pickle.c:6486:    retval->ste_symbols = ste_symbols;
../script/py_pickle.c:6487:    retval->ste_name = ste_name;
../script/py_pickle.c:6488:    retval->ste_varnames = ste_varnames;
../script/py_pickle.c:6489:    retval->ste_children = ste_children;
../script/py_pickle.c:6490:    retval->ste_type = PyInt_AS_LONG(ste_type);
../script/py_pickle.c:6491:    retval->ste_unoptimized = PyInt_AS_LONG(ste_unoptimized);
../script/py_pickle.c:6492:    retval->ste_nested = PyInt_AS_LONG(ste_nested);
../script/py_pickle.c:6493:    retval->ste_free = PyInt_AS_LONG(ste_free);
../script/py_pickle.c:6494:    retval->ste_child_free = PyInt_AS_LONG(ste_child_free);
../script/py_pickle.c:6495:    retval->ste_generator = PyInt_AS_LONG(ste_generator);
../script/py_pickle.c:6496:    retval->ste_varargs = PyInt_AS_LONG(ste_varargs);
../script/py_pickle.c:6497:    retval->ste_varkeywords = PyInt_AS_LONG(ste_varkeywords);
../script/py_pickle.c:6498:    retval->ste_returns_value = PyInt_AS_LONG(ste_returns_value);
../script/py_pickle.c:6499:    retval->ste_lineno = PyInt_AS_LONG(ste_lineno);
../script/py_pickle.c:6500:    retval->ste_tmpname = PyInt_AS_LONG(ste_tmpname);
../script/py_pickle.c:6508:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:6531:    int ret = -1;
../script/py_pickle.c:6533:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:6537:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6549:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:6562:    int ret = -1;
../script/py_pickle.c:6564:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:6568:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6580:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:6593:    int ret = -1;
../script/py_pickle.c:6595:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:6599:    PyObject *dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6611:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:6624:    int ret = -1;
../script/py_pickle.c:6626:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:6630:    PyObject *sent = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6631:    PyObject *call = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6633:    /* Don't check for 'callable' - placeholders may not have 
../script/py_pickle.c:6640:        retval->it_callable = call; 
../script/py_pickle.c:6643:        retval->it_callable = NULL;
../script/py_pickle.c:6647:        retval->it_sentinel = sent; 
../script/py_pickle.c:6650:        retval->it_sentinel = NULL;
../script/py_pickle.c:6654:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:6697:    int ret = -1;
../script/py_pickle.c:6699:    if(vec_size(&ctx->stack) < 5) {
../script/py_pickle.c:6703:    PyObject *len = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6704:    PyObject *di_result = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6705:    PyObject *di_pos = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6706:    PyObject *di_used = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6707:    PyObject *di_dict = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6729:        retval->di_dict = (PyDictObject*)di_dict; 
../script/py_pickle.c:6732:        retval->di_dict = NULL; 
../script/py_pickle.c:6734:    retval->di_used = PyLong_AsSsize_t(di_used);
../script/py_pickle.c:6735:    retval->di_pos = PyLong_AsSsize_t(di_pos);
../script/py_pickle.c:6737:        retval->di_result = di_result;
../script/py_pickle.c:6740:        retval->di_result = NULL; 
../script/py_pickle.c:6742:    retval->len = PyLong_AsSsize_t(len);
../script/py_pickle.c:6745:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:6780:    int ret = -1;
../script/py_pickle.c:6782:    if(vec_size(&ctx->stack) < 4) {
../script/py_pickle.c:6786:    PyObject *len = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6787:    PyObject *si_pos = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6788:    PyObject *si_used = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6789:    PyObject *si_set = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6809:        retval->si_set = (PySetObject*)si_set;
../script/py_pickle.c:6812:        retval->si_set = NULL;
../script/py_pickle.c:6814:    retval->si_used = PyLong_AsSsize_t(si_used);
../script/py_pickle.c:6815:    retval->si_pos = PyLong_AsSsize_t(si_pos);
../script/py_pickle.c:6816:    retval->len = PyLong_AsSsize_t(len);
../script/py_pickle.c:6819:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:6835:    int ret = -1;
../script/py_pickle.c:6837:    if(vec_size(&ctx->stack) < 4) {
../script/py_pickle.c:6841:    PyObject *str_end = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6842:    PyObject *str_ptr = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6843:    PyObject *ptr = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6844:    PyObject *str = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6863:    retval->str = (PyStringObject*)str;
../script/py_pickle.c:6866:    retval->it_field.ptr = raw + PyLong_AsLong(ptr);
../script/py_pickle.c:6867:    retval->it_field.str.ptr = raw + PyLong_AsLong(str_ptr);
../script/py_pickle.c:6868:    retval->it_field.str.end = raw + PyLong_AsLong(str_end);
../script/py_pickle.c:6870:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:6886:    int ret = -1;
../script/py_pickle.c:6888:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:6892:    PyObject *str_end = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6893:    PyObject *str_ptr = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6894:    PyObject *str = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6912:    retval->str = (PyStringObject*)str;
../script/py_pickle.c:6915:    retval->it_markup.str.ptr = raw + PyLong_AsLong(str_ptr);
../script/py_pickle.c:6916:    retval->it_markup.str.end = raw + PyLong_AsLong(str_end);
../script/py_pickle.c:6918:    vec_pobj_push(&ctx->stack, (PyObject*)retval);
../script/py_pickle.c:6933:    int ret = -1;
../script/py_pickle.c:6935:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:6939:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6942:        SET_RUNTIME_EXC("PF_EXCEPTION: Expecting type that is a non-strict subclass of Exception on TOS"); 
../script/py_pickle.c:6949:    vec_pobj_push(&ctx->stack, retval);
../script/py_pickle.c:6962:    int ret = -1;
../script/py_pickle.c:6964:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:6969:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6970:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:6984:    for(PyMethodDef *curr = tp_type->tp_methods; curr && curr->ml_name; curr++) {
../script/py_pickle.c:6986:        if(0 == strcmp(curr->ml_name, PyString_AS_STRING(name))) {
../script/py_pickle.c:6994:            PyString_AS_STRING(name), tp_type->tp_name);
../script/py_pickle.c:7000:    vec_pobj_push(&ctx->stack, desc);
../script/py_pickle.c:7014:    int ret = -1;
../script/py_pickle.c:7016:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:7021:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7022:    PyObject *type = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7023:    PyObject *inst = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7037:    for(PyMethodDef *curr = tp_type->tp_methods; curr && curr->ml_name; curr++) {
../script/py_pickle.c:7039:        if(0 == strcmp(curr->ml_name, PyString_AS_STRING(name))) {
../script/py_pickle.c:7046:    if(!found && (bases = tp_type->tp_bases)) {
../script/py_pickle.c:7055:            for(PyMethodDef *curr = tp_type->tp_methods; curr && curr->ml_name; curr++) {
../script/py_pickle.c:7057:                if(0 == strcmp(curr->ml_name, PyString_AS_STRING(name))) {
../script/py_pickle.c:7068:            PyString_AS_STRING(name), tp_type->tp_name);
../script/py_pickle.c:7074:    vec_pobj_push(&ctx->stack, meth);
../script/py_pickle.c:7089:    int ret = -1;
../script/py_pickle.c:7091:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:7099:    PyObject *item = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7100:    PyObject *nitems = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7109:    rval->item = item;
../script/py_pickle.c:7110:    rval->nitems = PyInt_AsSsize_t(nitems);
../script/py_pickle.c:7113:    vec_pobj_push(&ctx->stack, (PyObject*)rval);
../script/py_pickle.c:7126:    int ret = -1;
../script/py_pickle.c:7128:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:7136:    PyObject *attr = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7137:    PyObject *nattrs = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7146:    rval->attr = attr;
../script/py_pickle.c:7147:    rval->nattrs = PyInt_AsSsize_t(nattrs);
../script/py_pickle.c:7150:    vec_pobj_push(&ctx->stack, (PyObject*)rval);
../script/py_pickle.c:7163:    int ret = -1;
../script/py_pickle.c:7165:    if(vec_size(&ctx->stack) < 3) {
../script/py_pickle.c:7173:    PyObject *kwds = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7174:    PyObject *args = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7175:    PyObject *name = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7194:    rval->name = name;
../script/py_pickle.c:7196:    rval->args = args;
../script/py_pickle.c:7199:        rval->kwds = kwds;
../script/py_pickle.c:7201:        rval->kwds = NULL;
../script/py_pickle.c:7205:    vec_pobj_push(&ctx->stack, (PyObject*)rval);
../script/py_pickle.c:7219:    int ret = -1;
../script/py_pickle.c:7221:    if(vec_size(&ctx->stack) < 2) {
../script/py_pickle.c:7226:    if(vec_size(&ctx->mark_stack) == 0) {
../script/py_pickle.c:7228:        return -1;
../script/py_pickle.c:7230:    vec_int_pop(&ctx->mark_stack);
../script/py_pickle.c:7232:    PyObject *str = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7233:    PyObject *klass = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7248:        .stack = &ctx->stack
../script/py_pickle.c:7272:    vec_pobj_push(&ctx->stack, rval);
../script/py_pickle.c:7286:    int ret = -1;
../script/py_pickle.c:7288:    if(vec_size(&ctx->stack) < 1) {
../script/py_pickle.c:7292:    PyObject *klass = vec_pobj_pop(&ctx->stack);
../script/py_pickle.c:7299:    PyObject *rval = ((PyTypeObject*)klass)->tp_alloc((struct _typeobject*)klass, 0);
../script/py_pickle.c:7302:    vec_pobj_push(&ctx->stack, rval);
../script/py_pickle.c:7321:    vec_pobj_push(&ctx->stack, ret);
../script/py_pickle.c:7327:    if(NULL == (ctx->memo = kh_init(memo))) {
../script/py_pickle.c:7332:    vec_pobj_init(&ctx->to_free);
../script/py_pickle.c:7341:    for(int i = 0; i < vec_size(&ctx->to_free); i++) {
../script/py_pickle.c:7342:        Py_DECREF(vec_AT(&ctx->to_free, i));    
../script/py_pickle.c:7345:    vec_pobj_destroy(&ctx->to_free);
../script/py_pickle.c:7346:    kh_destroy(memo, ctx->memo);
../script/py_pickle.c:7351:    vec_pobj_init(&ctx->stack);
../script/py_pickle.c:7352:    vec_pobj_init(&ctx->memo);
../script/py_pickle.c:7353:    vec_int_init(&ctx->mark_stack);
../script/py_pickle.c:7354:    vec_pobj_init(&ctx->to_free);
../script/py_pickle.c:7355:    ctx->stop = false;
../script/py_pickle.c:7361:    for(int i = 0; i < vec_size(&ctx->memo); i++) {
../script/py_pickle.c:7362:        Py_DECREF(vec_AT(&ctx->memo, i));
../script/py_pickle.c:7365:    for(int i = 0; i < vec_size(&ctx->to_free); i++) {
../script/py_pickle.c:7366:        Py_DECREF(vec_AT(&ctx->to_free, i));
../script/py_pickle.c:7369:    vec_pobj_destroy(&ctx->to_free);
../script/py_pickle.c:7370:    vec_int_destroy(&ctx->mark_stack);
../script/py_pickle.c:7371:    vec_pobj_destroy(&ctx->memo);
../script/py_pickle.c:7372:    vec_pobj_destroy(&ctx->stack);
../script/py_pickle.c:7378:    khiter_t k = kh_get(memo, ctx->memo, id);
../script/py_pickle.c:7379:    if(k != kh_end(ctx->memo))
../script/py_pickle.c:7387:    khiter_t k = kh_get(memo, ctx->memo, id);
../script/py_pickle.c:7388:    assert(kh_exist(ctx->memo, k));
../script/py_pickle.c:7389:    return kh_value(ctx->memo, k).idx;
../script/py_pickle.c:7395:    int idx = kh_size(ctx->memo);
../script/py_pickle.c:7397:    khiter_t k = kh_put(memo, ctx->memo, (uintptr_t)obj, &ret);
../script/py_pickle.c:7398:    assert(ret != -1 && ret != 0);
../script/py_pickle.c:7399:    kh_value(ctx->memo, k) = (struct memo_entry){idx, obj};
../script/py_pickle.c:7406:    str[ARR_SIZE(str)-1] = '\0';
../script/py_pickle.c:7407:    return rw->write(rw, str, 1, strlen(str));
../script/py_pickle.c:7414:    str[ARR_SIZE(str)-1] = '\0';
../script/py_pickle.c:7415:    return rw->write(rw, str, 1, strlen(str));
../script/py_pickle.c:7421:    return rw->write(rw, ops, sizeof(ops), 1);
../script/py_pickle.c:7426:    vec_pobj_push(&ctx->to_free, obj);
../script/py_pickle.c:7431:    /* The parent object must already be memoized to handle self-referencing */
../script/py_pickle.c:7434:    CHK_TRUE(rw->write(rw, &mark, 1, 1), fail);
../script/py_pickle.c:7437:    vec_pobj_push(&ctx->to_free, ndw_attrs);
../script/py_pickle.c:7460:        vec_pobj_push(&ctx->to_free, key);
../script/py_pickle.c:7469:    CHK_TRUE(rw->write(rw, setattrs, ARR_SIZE(setattrs), 1), fail);
../script/py_pickle.c:7474:    return -1;
../script/py_pickle.c:7495:        if(obj->ob_type->tp_flags & Py_TPFLAGS_HEAPTYPE) {
../script/py_pickle.c:7498:            SET_RUNTIME_EXC("Cannot pickle object of type:%s", obj->ob_type->tp_name);
../script/py_pickle.c:7552:    /* Dummy user-defined class to use for creating stubs */
../script/py_pickle.c:7618:    CHK_TRUE(stream->write(stream, term, 1, ARR_SIZE(term)), err_write);
../script/py_pickle.c:7641:        CHK_TRUE(stream->read(stream, &op, 1, 1), err);
../script/py_pickle.c:7645:            CHK_TRUE(stream->read(stream, &op, 1, 1), err);
../script/py_pickle.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../script/py_pickle.h:62: * self-referencing cases. 
../script/py_region.c:157:    "  - type {pf.REGION_CIRCLE, pf.REGION_RECTANGLE}               \n"
../script/py_region.c:158:    "  - name (string)                                              \n"
../script/py_region.c:159:    "  - position (tuple of 2 floats)                               \n"
../script/py_region.c:164:    "  - radius (float) [circle regions only]                       \n"
../script/py_region.c:165:    "  - dimensions (tuple of 2 floats) [rectangular regions only]  \n"
../script/py_region.c:228:    PyRegionObject *self = (PyRegionObject*)type->tp_alloc(type, 0);
../script/py_region.c:236:        type->tp_free(self);
../script/py_region.c:240:    self->type = regtype;
../script/py_region.c:241:    self->name = copy;
../script/py_region.c:261:        type->tp_free(self);
../script/py_region.c:266:    khiter_t k = kh_put(PyObject, s_name_pyobj_table, self->name, &ret);
../script/py_region.c:267:    assert(ret != -1 && ret != 0);
../script/py_region.c:275:    khiter_t k = kh_get(PyObject, s_name_pyobj_table, self->name);
../script/py_region.c:279:    G_Region_Remove(self->name);
../script/py_region.c:280:    PF_FREE(self->name);
../script/py_region.c:281:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_region.c:289:    size_t nents = G_Region_GetEnts(self->name, ARR_SIZE(ents), ents);
../script/py_region.c:296:        PyObject *ent = S_Entity_ObjForUID(ents[i]->uid);
../script/py_region.c:321:    if(G_Region_ContainsEnt(self->name, uid)) {
../script/py_region.c:342:    G_Region_ExploreFog(self->name, faction_id);
../script/py_region.c:354:    PyObject *type = PyInt_FromLong(self->type);
../script/py_region.c:360:    PyObject *name = PyString_FromString(self->name);
../script/py_region.c:410:    reg = (PyRegionObject*)((PyTypeObject*)cls)->tp_alloc((PyTypeObject*)cls, 0);
../script/py_region.c:416:    reg->type = PyInt_AS_LONG(type);
../script/py_region.c:417:    reg->name = pf_strdup(PyString_AS_STRING(name));
../script/py_region.c:419:    if(!reg->name) {
../script/py_region.c:422:        ((PyTypeObject*)cls)->tp_free(reg);
../script/py_region.c:427:    khiter_t k = kh_put(PyObject, s_name_pyobj_table, reg->name, &status);
../script/py_region.c:428:    if(status == -1 || status == 0) {
../script/py_region.c:431:        ((PyTypeObject*)cls)->tp_free(reg);
../script/py_region.c:450:    G_Region_GetPos(self->name, &pos);
../script/py_region.c:458:        return -1;
../script/py_region.c:463:        return -1;
../script/py_region.c:466:    G_Region_SetPos(self->name, newpos);
../script/py_region.c:473:    G_Region_GetShown(self->name, &on);
../script/py_region.c:484:    bool status = G_Region_SetShown(self->name, on);
../script/py_region.c:491:    return PyString_FromString(self->name);
../script/py_region.c:496:    return PyInt_FromLong(self->type);
../script/py_region.c:505:    switch(self->type) {
../script/py_region.c:508:        G_Region_GetRadius(self->name, &raw);
../script/py_region.c:520:        G_Region_GetXLen(self->name, &rawx);
../script/py_region.c:521:        G_Region_GetZLen(self->name, &rawz);
../script/py_script.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_script.c:267:    "Get the current number of game ticks (milliseconsd) - only useful in finding elapsed "
../script/py_script.c:306:    "Get the path to the top-level game resource folder (parent of 'assets')."},
../script/py_script.c:408:    "Disable rendering of healthbars. Overrides the user-configurable dynamic setting."},
../script/py_script.c:412:    "Re-enable showing the healthbars after a 'hide_healthbars' call. Note that the healthbars will only "
../script/py_script.c:413:    "be rendered if the corresponding user-configurable setting is set."},
../script/py_script.c:421:    "Returns the total amount of a particular resource between all player-controlled storage sites."},
../script/py_script.c:425:    "Returns the total capacity for storing a particular resource between all player-controlled storage sites."},
../script/py_script.c:434:    "every other existing faction. By default, new factions are player-controllable."},
../script/py_script.c:506:    "Returns the Y-dimension map height at the specified XZ coordinate. Returns None if the "
../script/py_script.c:555:    "Enable or disable issuing move orders by right-clicking."},
../script/py_script.c:638:    "Returns the normalized result of multiplying 2 quaternions (specified as a list of 4 floats - XYZW order)."},
../script/py_script.c:642:    "Return a pseudo-random number in the range of 0 to the integer argument."},
../script/py_script.c:688:    "Returns the nearest entity to the specified 'position' - (X, Z) point or None. Takes an optional 'predicate' callable "
../script/py_script.c:698:    "Returns a list of entities in the specified rectangle (defined by two (X, Z) points - "
../script/py_script.c:1000:    return PyInt_FromLong((uint32_t)(b - a));
../script/py_script.c:1047:        PyObject *parents[curr_info->nentries + 1];
../script/py_script.c:1052:        if(0 != PyDict_SetItemString(ret, curr_info->threadname, thread_dict))
../script/py_script.c:1065:        for(int j = 0; j < curr_info->nentries; j++) {
../script/py_script.c:1071:            int parent_idx = (curr_info->entries[j].parent_idx == ~((uint32_t)0)) ? 0 : curr_info->entries[j].parent_idx + 1;
../script/py_script.c:1080:            PyObject *name = PyString_FromString(curr_info->entries[j].funcname);
../script/py_script.c:1088:            PyObject *ms_delta = PyFloat_FromDouble(curr_info->entries[j].ms_delta);
../script/py_script.c:1096:            PyObject *pc_delta = PyLong_FromUnsignedLongLong(curr_info->entries[j].pc_delta);
../script/py_script.c:1242:	SDL_RWops *rw = SDL_RWFromFP(((PyFileObject*)file)->f_fp, false);
../script/py_script.c:1366:        PyObject *ent = S_Entity_ObjForUID(vec_AT(sel, i)->uid);
../script/py_script.c:1405:        PyObject *obj = S_Entity_ObjForUID(hovered->uid);
../script/py_script.c:1968:        (center.x - width /2.0f) / (width /2.0f),
../script/py_script.c:1969:        (height/2.0f - center.y) / (height/2.0f)
../script/py_script.c:1973:        adj_vres.y - ((ndc.y + 1.0f) * adj_vres.y/2.0f),
../script/py_script.c:1977:        adj_center.x - rect.w/2.0f,
../script/py_script.c:1978:        adj_center.y - rect.h/2.0f,
../script/py_script.c:1983:        adj_rect.x - 1,
../script/py_script.c:1984:        adj_rect.y - 1,
../script/py_script.c:2101:        out->type = ST_TYPE_STRING;
../script/py_script.c:2102:        strncpy(out->as_string, PyString_AS_STRING(obj), sizeof(out->as_string));
../script/py_script.c:2103:        out->as_string[sizeof(out->as_string)-1] = '\0';
../script/py_script.c:2107:        out->type = ST_TYPE_BOOL;
../script/py_script.c:2108:        out->as_bool = PyObject_IsTrue(obj);
../script/py_script.c:2112:        out->type = ST_TYPE_INT;
../script/py_script.c:2113:        out->as_int = PyInt_AS_LONG(obj);
../script/py_script.c:2117:        out->type = ST_TYPE_FLOAT;
../script/py_script.c:2118:        out->as_float = PyFloat_AS_DOUBLE(obj);
../script/py_script.c:2120:    }else if(PyArg_ParseTuple(obj, "ff", &out->as_vec2.x, &out->as_vec2.y)) {
../script/py_script.c:2122:        out->type = ST_TYPE_VEC2;
../script/py_script.c:2194:    new_sett.name[sizeof(new_sett.name)-1] = '\0';
../script/py_script.c:2401:        vops->close(vops);
../script/py_script.c:2407:    if(_PyString_Resize(&ret, vops->size(vops)-1) < 0) {
../script/py_script.c:2408:        vops->close(vops);
../script/py_script.c:2412:    vops->seek(vops, 0, RW_SEEK_SET);
../script/py_script.c:2413:    vops->read(vops, PyString_AS_STRING(ret), 1, vops->size(vops));
../script/py_script.c:2414:    vops->close(vops);
../script/py_script.c:2434:        cmops->close(cmops);
../script/py_script.c:2438:    cmops->close(cmops);
../script/py_script.c:2494:    char *end = copy + (strlen(copy) - 1);
../script/py_script.c:2496:        end--;
../script/py_script.c:2517:        pf_snprintf(name, sizeof(name), "[Py] %s", PyString_AS_STRING(frame->f_code->co_name));
../script/py_script.c:2530:        pf_snprintf(name, sizeof(name), "[PyC] %s", func->m_ml->ml_name);
../script/py_script.c:2539:        break; /* no-op */
../script/py_script.c:2547:    return (new_val->type == ST_TYPE_BOOL);
../script/py_script.c:2566:        (void*)((uintptr_t)new_val->as_bool), G_RUNNING | G_PAUSED_UI_RUNNING | G_PAUSED_FULL);
../script/py_script.c:2589:    PyObject *ret = PyTuple_New(args->argc);
../script/py_script.c:2593:    for(int i = 0; i < args->argc; i++) {
../script/py_script.c:2594:        PyObject *str = PyString_FromString(args->argv[i]);
../script/py_script.c:2741:    PyObject *obj = S_Entity_ObjForUID(ent->uid);
../script/py_script.c:2782:        PyObject *ret = S_Entity_ObjForUID(nearest->uid);
../script/py_script.c:2829:        PyObject *obj = S_Entity_ObjForUID(inside[i]->uid);
../script/py_script.c:2839:    PyObject *ret = PyList_GetSlice(list, 0, ninserted-1);
../script/py_script.c:2881:        PyObject *obj = S_Entity_ObjForUID(inside[i]->uid);
../script/py_script.c:2891:    PyObject *ret = PyList_GetSlice(list, 0, ninserted-1);
../script/py_script.c:2900:        PyErr_SetString(PyExc_TypeError, "Expecting a single argument - name of the WAV file or 'None'.");
../script/py_script.c:3074:    /* Initialize the pickler after registering all the built-ins, so that they can
../script/py_script.c:3095:  // TODO: not yet implemented; see https://docs.python.org/2.7/library/functions.html#reload and https://docs.python.org/2.7/c-api/import.html#c.PyImport_ReloadModule
../script/py_script.c:3122:    /* Free all memory allocated during initialization - this can only 
../script/py_script.c:3256:    /* Make sure to retain the callable object - PyObject_CallObject will not do this for us.
../script/py_script.c:3286:            ((SDL_Event*)arg)->key.keysym.scancode, ((SDL_Event*)arg)->key.keysym.sym, ((SDL_Event*)arg)->key.keysym.mod);
../script/py_script.c:3290:            ((SDL_Event*)arg)->motion.x,
../script/py_script.c:3291:            ((SDL_Event*)arg)->motion.y,
../script/py_script.c:3292:            ((SDL_Event*)arg)->motion.xrel,
../script/py_script.c:3293:            ((SDL_Event*)arg)->motion.xrel);
../script/py_script.c:3297:            ((SDL_Event*)arg)->button.button,
../script/py_script.c:3298:            ((SDL_Event*)arg)->button.state);
../script/py_script.c:3302:            ((SDL_Event*)arg)->button.button,
../script/py_script.c:3303:            ((SDL_Event*)arg)->button.state);
../script/py_script.c:3307:        uint32_t dir = ((SDL_Event*)arg)->wheel.direction;
../script/py_script.c:3309:            ((SDL_Event*)arg)->wheel.x * (dir == SDL_MOUSEWHEEL_NORMAL ? 1 : -1),
../script/py_script.c:3310:            ((SDL_Event*)arg)->wheel.y * (dir == SDL_MOUSEWHEEL_NORMAL ? 1 : -1));
../script/py_script.c:3316:            ((struct tile_desc*)arg)->chunk_r,
../script/py_script.c:3317:            ((struct tile_desc*)arg)->chunk_c,
../script/py_script.c:3318:            ((struct tile_desc*)arg)->tile_r,
../script/py_script.c:3319:            ((struct tile_desc*)arg)->tile_c);
../script/py_script.c:3334:        PyObject *ent = S_Entity_ObjForUID(((struct entity*)arg)->uid);
../script/py_script.c:3347:        return Py_BuildValue("si", event->name, event->delta);
../script/py_script.c:3351:        PyObject *ent = S_Entity_ObjForUID(hit->ent_uid);
../script/py_script.c:3356:        PyObject *parent = S_Entity_ObjForUID(hit->parent_uid);
../script/py_script.c:3361:        return Py_BuildValue("OIOI", ent, hit->proj_uid, parent, hit->cookie);
../script/py_script.c:3425:    PyInterpreterState *interp = PyThreadState_Get()->interp;
../script/py_script.c:3433:        interp->modules, 
../script/py_script.c:3434:        interp->sysdict, 
../script/py_script.c:3435:        interp->builtins,
../script/py_script.c:3436:        interp->modules_reloading,
../script/py_script.c:3437:        interp->codec_search_path,
../script/py_script.c:3438:        interp->codec_search_cache,
../script/py_script.c:3439:        interp->codec_error_registry,
../script/py_script.c:3462:    PyInterpreterState *interp = PyThreadState_Get()->interp;
../script/py_script.c:3475:    interp->modules = PyTuple_GET_ITEM(state, 0);
../script/py_script.c:3476:    interp->sysdict = PyTuple_GET_ITEM(state, 1);
../script/py_script.c:3477:    interp->builtins = PyTuple_GET_ITEM(state, 2);
../script/py_script.c:3478:    interp->modules_reloading = PyTuple_GET_ITEM(state, 3);
../script/py_script.c:3479:    interp->codec_search_path = PyTuple_GET_ITEM(state, 4);
../script/py_script.c:3480:    interp->codec_search_cache = PyTuple_GET_ITEM(state, 5);
../script/py_script.c:3481:    interp->codec_error_registry = PyTuple_GET_ITEM(state, 6);
../script/py_script.c:3483:    Py_INCREF(interp->modules);
../script/py_script.c:3484:    Py_INCREF(interp->sysdict);
../script/py_script.c:3485:    Py_INCREF(interp->builtins);
../script/py_script.c:3486:    Py_INCREF(interp->modules_reloading);
../script/py_script.c:3487:    Py_INCREF(interp->codec_search_path);
../script/py_script.c:3488:    Py_INCREF(interp->codec_search_cache);
../script/py_script.c:3489:    Py_INCREF(interp->codec_error_registry);
../script/py_task.c:87:     * the client code point-of-view, the TID can change suddenly
../script/py_task.c:165:    "the next frame. Yielding periodically is a means to make sure that long-running tasks "
../script/py_task.c:254:        tstate->interp = interp;
../script/py_task.c:278:    PyObject *args = self->req.args;
../script/py_task.c:279:    PyObject *kwargs = self->req.kwargs;
../script/py_task.c:280:    int reqtype = self->req.type;
../script/py_task.c:283:    self->req = (struct pyrequest){0};
../script/py_task.c:324:        assert(frame->f_stacktop);
../script/py_task.c:325:        size_t stack_depth = (size_t)(frame->f_stacktop - frame->f_valuestack);
../script/py_task.c:326:        self->stack_depth = stack_depth;
../script/py_task.c:333:    s_main_thread_state = PyThreadState_Swap(self->ts);
../script/py_task.c:352:    assert(ts == self->ts);
../script/py_task.c:360:    ASSERT_IN_CTX(self->tid);
../script/py_task.c:365:    if(self->state == PYTASK_STATE_RUNNING) {
../script/py_task.c:367:        if(self->regname) {
../script/py_task.c:368:            Task_Register(self->regname);
../script/py_task.c:372:        assert(self->ts->frame);
../script/py_task.c:378:            const unsigned char *bytecode = (unsigned char *)PyString_AS_STRING(self->ts->frame->f_code->co_code);
../script/py_task.c:379:            const int lasti = self->ts->frame->f_lasti;
../script/py_task.c:380:            PyObject_GC_UnTrack(self->ts->frame);
../script/py_task.c:384:            self->ts->frame->f_lasti += 2;
../script/py_task.c:396:                int flags = (opcode - CALL_FUNCTION) & 3;
../script/py_task.c:403:            PyObject **pfunc = (self->ts->frame->f_stacktop) - n - 1;
../script/py_task.c:408:            while((self->ts->frame->f_stacktop) > pfunc) {
../script/py_task.c:409:                PyObject *w = *(--self->ts->frame->f_stacktop);
../script/py_task.c:412:            assert(self->ts->frame->f_stacktop >= self->ts->frame->f_valuestack);
../script/py_task.c:417:            *(self->ts->frame->f_stacktop++) = req_result;
../script/py_task.c:419:            if(!_PyObject_GC_IS_TRACKED(self->ts->frame))
../script/py_task.c:420:                PyObject_GC_Track(self->ts->frame);
../script/py_task.c:421:            ret = PyEval_EvalFrameEx(self->ts->frame, 0);
../script/py_task.c:424:             * cases when this can occur: when the task was send-blocked or reply-blocked 
../script/py_task.c:432:        Py_CLEAR(self->ts->frame);
../script/py_task.c:437:        assert(self->state == PYTASK_STATE_NOT_STARTED);
../script/py_task.c:438:        assert(!self->ts->frame);
../script/py_task.c:439:        assert(self->ts->recursion_depth == 0);
../script/py_task.c:441:        self->state = PYTASK_STATE_RUNNING;
../script/py_task.c:444:            (PyCodeObject *)PyFunction_GET_CODE(self->runfunc),
../script/py_task.c:445:            PyFunction_GET_GLOBALS(self->runfunc), 
../script/py_task.c:450:            PyFunction_GET_CLOSURE(self->runfunc)
../script/py_task.c:460:            (PyObject*)self, self->ts->curexc_type ? self->ts->curexc_type : Py_None), ES_SCRIPT);
../script/py_task.c:467:            self->ts->curexc_type      ? self->ts->curexc_type      : Py_None,
../script/py_task.c:468:            self->ts->curexc_value     ? self->ts->curexc_value     : Py_None,
../script/py_task.c:469:            self->ts->curexc_traceback ? self->ts->curexc_traceback : Py_None
../script/py_task.c:475:    assert(!self->ts->frame);
../script/py_task.c:478:    khiter_t k = kh_get(task, s_tid_task_map, self->tid);
../script/py_task.c:482:    self->state = PYTASK_STATE_FINISHED;
../script/py_task.c:483:    Py_CLEAR(self->runfunc);
../script/py_task.c:494:    task->req = (struct pyrequest){args, kwargs, type};
../script/py_task.c:499:    Py_XDECREF(task->req.args);
../script/py_task.c:500:    Py_XDECREF(task->req.kwargs);
../script/py_task.c:501:    task->req = (struct pyrequest){0};
../script/py_task.c:524:    PyTaskObject *self = (PyTaskObject*)type->tp_alloc(type, 0);
../script/py_task.c:546:     * main thread in a fiber which cannot be pre-empted and yields control at
../script/py_task.c:549:    PyInterpreterState *interp = PyThreadState_Get()->interp;
../script/py_task.c:550:    self->ts = pytask_ts_new(interp);
../script/py_task.c:551:    if(!self->ts) {
../script/py_task.c:558:        self->small_stack = (smallstack && PyObject_IsTrue(smallstack));
../script/py_task.c:560:        self->small_stack = false;
../script/py_task.c:564:    self->runfunc = func;
../script/py_task.c:565:    self->state = PYTASK_STATE_NOT_STARTED;
../script/py_task.c:566:    self->req = (struct pyrequest){0};
../script/py_task.c:567:    self->stack_depth = 0;
../script/py_task.c:568:    self->regname = NULL;
../script/py_task.c:569:    self->sleep_elapsed = 0;
../script/py_task.c:581:    assert(self->state != PYTASK_STATE_RUNNING);
../script/py_task.c:582:    assert(PyThreadState_Get() != self->ts);
../script/py_task.c:584:    Py_CLEAR(self->runfunc);
../script/py_task.c:585:    Py_CLEAR(self->ts->curexc_type);
../script/py_task.c:586:    Py_CLEAR(self->ts->curexc_value);
../script/py_task.c:587:    Py_CLEAR(self->ts->curexc_traceback);
../script/py_task.c:589:    PF_FREE(self->regname);
../script/py_task.c:590:    pytask_ts_delete(self->ts);
../script/py_task.c:591:    self->ts = NULL;
../script/py_task.c:592:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_task.c:599:    size_t og_refcount = self->ob_refcnt;
../script/py_task.c:601:    assert(self->state >= PYTASK_STATE_NOT_STARTED && self->state <= PYTASK_STATE_FINISHED);
../script/py_task.c:602:    assert(self->ts->c_tracefunc == NULL);
../script/py_task.c:618:    PyObject *state = PyInt_FromLong(self->state);
../script/py_task.c:620:    status = ctx->pickle_obj(ctx->private_ctx, state, ctx->stream);
../script/py_task.c:621:    ctx->deferred_free(ctx->private_ctx, state);
../script/py_task.c:625:    if(self->state == PYTASK_STATE_RUNNING) {
../script/py_task.c:626:        assert(self->ts->frame);
../script/py_task.c:627:        old = self->ts->frame->f_stacktop;
../script/py_task.c:628:        self->ts->frame->f_stacktop = self->ts->frame->f_valuestack + self->stack_depth;
../script/py_task.c:632:        self->ts->frame             ? (PyObject*)self->ts->frame    : Py_None,
../script/py_task.c:633:        self->ts->recursion_depth,
../script/py_task.c:634:        self->ts->curexc_type       ? self->ts->curexc_type         : Py_None,
../script/py_task.c:635:        self->ts->curexc_value      ? self->ts->curexc_value        : Py_None,
../script/py_task.c:636:        self->ts->curexc_traceback  ? self->ts->curexc_traceback    : Py_None,
../script/py_task.c:637:        self->ts->exc_type          ? self->ts->exc_type            : Py_None,
../script/py_task.c:638:        self->ts->exc_value         ? self->ts->exc_value           : Py_None,
../script/py_task.c:639:        self->ts->exc_traceback     ? self->ts->exc_traceback       : Py_None,
../script/py_task.c:640:        self->ts->dict              ? self->ts->dict                : Py_None
../script/py_task.c:643:    status = ctx->pickle_obj(ctx->private_ctx, ts, ctx->stream);
../script/py_task.c:644:    ctx->deferred_free(ctx->private_ctx, ts);
../script/py_task.c:646:    if(self->state == PYTASK_STATE_RUNNING) {
../script/py_task.c:647:        self->ts->frame->f_stacktop = old;
../script/py_task.c:652:        self->req.args      ? self->req.args    : Py_None,
../script/py_task.c:653:        self->req.kwargs    ? self->req.kwargs  : Py_None,
../script/py_task.c:654:        self->req.type
../script/py_task.c:657:    status = ctx->pickle_obj(ctx->private_ctx, request, ctx->stream);
../script/py_task.c:658:    ctx->deferred_free(ctx->private_ctx, request);
../script/py_task.c:661:    PyObject *func = self->runfunc ? self->runfunc : Py_None;
../script/py_task.c:662:    status = ctx->pickle_obj(ctx->private_ctx, func, ctx->stream);
../script/py_task.c:665:    if(!self->regname) {
../script/py_task.c:666:        status = ctx->pickle_obj(ctx->private_ctx, Py_None, ctx->stream);
../script/py_task.c:668:        PyObject *str = PyString_FromString(self->regname);
../script/py_task.c:670:        status = ctx->pickle_obj(ctx->private_ctx, str, ctx->stream);
../script/py_task.c:671:        ctx->deferred_free(ctx->private_ctx, str);
../script/py_task.c:675:    PyObject *stack_depth = PyInt_FromLong(self->stack_depth);
../script/py_task.c:676:    status = ctx->pickle_obj(ctx->private_ctx, stack_depth, ctx->stream);
../script/py_task.c:677:    ctx->deferred_free(ctx->private_ctx, stack_depth);
../script/py_task.c:680:    PyObject *sleep_elapsed = PyInt_FromLong(self->sleep_elapsed);
../script/py_task.c:681:    status = ctx->pickle_obj(ctx->private_ctx, sleep_elapsed, ctx->stream);
../script/py_task.c:682:    ctx->deferred_free(ctx->private_ctx, sleep_elapsed);
../script/py_task.c:685:    PyObject *small_stack = PyInt_FromLong(self->small_stack);
../script/py_task.c:686:    status = ctx->pickle_obj(ctx->private_ctx, small_stack, ctx->stream);
../script/py_task.c:687:    ctx->deferred_free(ctx->private_ctx, small_stack);
../script/py_task.c:692:    assert(self->ob_refcnt == og_refcount);
../script/py_task.c:719:    if(vec_size(ctx->stack) < 8) {
../script/py_task.c:724:    PyObject *small_stack = vec_pobj_pop(ctx->stack);
../script/py_task.c:725:    PyObject *sleep_elapsed = vec_pobj_pop(ctx->stack);
../script/py_task.c:726:    PyObject *stack_depth = vec_pobj_pop(ctx->stack);
../script/py_task.c:727:    PyObject *regname = vec_pobj_pop(ctx->stack);
../script/py_task.c:728:    PyObject *func = vec_pobj_pop(ctx->stack);
../script/py_task.c:729:    PyObject *request = vec_pobj_pop(ctx->stack);
../script/py_task.c:730:    PyObject *ts = vec_pobj_pop(ctx->stack);
../script/py_task.c:731:    PyObject *state = vec_pobj_pop(ctx->stack);
../script/py_task.c:774:    ret = (PyTaskObject*)((PyTypeObject*)cls)->tp_alloc((struct _typeobject*)cls, 0);
../script/py_task.c:778:        ret->regname = NULL;
../script/py_task.c:781:        ret->regname = pf_strdup(PyString_AS_STRING(regname));
../script/py_task.c:784:    PyInterpreterState *interp = PyThreadState_Get()->interp;
../script/py_task.c:785:    ret->ts = pytask_ts_new(interp);
../script/py_task.c:786:    if(!ret->ts) {
../script/py_task.c:790:    ret->ts->frame = (frame == Py_None) ? NULL : (Py_INCREF(frame), (PyFrameObject*)frame);
../script/py_task.c:791:    ret->ts->recursion_depth = recursion_depth;
../script/py_task.c:792:    ret->ts->dict = (dict == Py_None) ? NULL : (Py_INCREF(dict), dict);
../script/py_task.c:794:    ret->ts->curexc_type = (curexc_type == Py_None) ? NULL : (Py_INCREF(curexc_type), curexc_type);
../script/py_task.c:795:    ret->ts->curexc_value = (curexc_value == Py_None) ? NULL : (Py_INCREF(curexc_value), curexc_value);
../script/py_task.c:796:    ret->ts->curexc_traceback = (curexc_traceback == Py_None) ? NULL 
../script/py_task.c:799:    ret->ts->exc_type = (exc_type == Py_None) ? NULL : (Py_INCREF(exc_type), exc_type);
../script/py_task.c:800:    ret->ts->exc_value = (exc_value == Py_None) ? NULL : (Py_INCREF(exc_value), exc_value);
../script/py_task.c:801:    ret->ts->exc_traceback = (exc_traceback == Py_None) ? NULL 
../script/py_task.c:804:    ret->req.args = (reqargs == Py_None) ? NULL : (Py_INCREF(reqargs), reqargs);
../script/py_task.c:805:    ret->req.kwargs = (reqkwargs == Py_None) ? NULL : (Py_INCREF(reqkwargs), reqkwargs);
../script/py_task.c:806:    ret->req.type = reqtype;
../script/py_task.c:808:    ret->state = PyInt_AS_LONG(state);
../script/py_task.c:809:    ret->runfunc = func == Py_None ? NULL : (Py_INCREF(func), func);
../script/py_task.c:810:    ret->sleep_elapsed = PyInt_AS_LONG(sleep_elapsed);
../script/py_task.c:811:    ret->small_stack = PyInt_AS_LONG(small_stack);
../script/py_task.c:812:    ret->stack_depth = PyInt_AS_LONG(stack_depth);
../script/py_task.c:814:    if(ret->state == PYTASK_STATE_RUNNING) {
../script/py_task.c:817:        if(!ret->small_stack)
../script/py_task.c:820:        assert(ret->ts->frame->f_stacktop);
../script/py_task.c:821:        ret->tid = Sched_Create(16, py_task, ret, NULL, flags);
../script/py_task.c:823:        if(ret->tid == NULL_TID) {
../script/py_task.c:833:        khiter_t k = kh_put(task, s_tid_task_map, ret->tid, &status);
../script/py_task.c:834:        assert(status != -1 && status != 0);
../script/py_task.c:837:        bool success = Sched_RunSync(ret->tid);
../script/py_task.c:877:    if(!self->small_stack)
../script/py_task.c:880:    self->tid = Sched_Create(16, py_task, self, NULL, flags);
../script/py_task.c:882:    if(self->tid == NULL_TID) {
../script/py_task.c:891:    khiter_t k = kh_put(task, s_tid_task_map, self->tid, &status);
../script/py_task.c:892:    assert(status != -1 && status != 0);
../script/py_task.c:902:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:916:    if(((PyTaskObject*)task)->state == PYTASK_STATE_FINISHED) {
../script/py_task.c:946:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:967:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:981:    if(((PyTaskObject*)recepient)->state != PYTASK_STATE_RUNNING) {
../script/py_task.c:986:    uint32_t recepient_tid = ((PyTaskObject*)recepient)->tid;
../script/py_task.c:1005:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:1042:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:1056:    if(((PyTaskObject*)recepient)->state != PYTASK_STATE_RUNNING) {
../script/py_task.c:1061:    uint32_t recepient_tid = ((PyTaskObject*)recepient)->tid;
../script/py_task.c:1079:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:1111:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:1126:    Task_Sleep(ms - self->sleep_elapsed);
../script/py_task.c:1128:    self->sleep_elapsed = 0;
../script/py_task.c:1139:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:1151:    self->regname = pf_strdup(name);
../script/py_task.c:1168:    if(self->state != PYTASK_STATE_RUNNING || Sched_ActiveTID() != self->tid) {
../script/py_task.c:1207:    if(self->state == PYTASK_STATE_FINISHED) {
../script/py_task.c:1222:        if(curr->req.type == PYREQ_SLEEP)
../script/py_task.c:1223:            curr->sleep_elapsed += elapsed;
../script/py_task.c:1314:            if(curr->state != PYTASK_STATE_FINISHED && Sched_IsReady(tid)) {
../script/py_tile.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_tile.c:144:    self->tile.pathable = true;
../script/py_tile.c:145:    self->tile.type = TILETYPE_FLAT;
../script/py_tile.c:146:    self->tile.base_height = 0;
../script/py_tile.c:147:    self->tile.ramp_height = 0;
../script/py_tile.c:148:    self->tile.top_mat_idx = 0;
../script/py_tile.c:149:    self->tile.sides_mat_idx = 1;
../script/py_tile.c:150:    self->tile.blend_mode = BLEND_MODE_BLUR;
../script/py_tile.c:151:    self->tile.blend_normals = true;
../script/py_tile.c:158:    PyObject *self = type->tp_alloc(type, 0);
../script/py_tile.c:164:    return Py_BuildValue("i", M_Tile_NWHeight(&self->tile));
../script/py_tile.c:169:    return Py_BuildValue("i", M_Tile_NEHeight(&self->tile));
../script/py_tile.c:174:    return Py_BuildValue("i", M_Tile_SWHeight(&self->tile));
../script/py_tile.c:179:    return Py_BuildValue("i", M_Tile_SEHeight(&self->tile));
../script/py_tile.c:191:        self->tile.pathable,
../script/py_tile.c:192:        self->tile.type,
../script/py_tile.c:193:        self->tile.base_height,
../script/py_tile.c:194:        self->tile.ramp_height,
../script/py_tile.c:195:        self->tile.top_mat_idx,
../script/py_tile.c:196:        self->tile.sides_mat_idx,
../script/py_tile.c:197:        self->tile.blend_mode,
../script/py_tile.c:198:        self->tile.blend_normals
../script/py_tile.c:232:    PyTileObject *tileobj = (PyTileObject*)((PyTypeObject*)cls)->tp_new((struct _typeobject*)cls, 
../script/py_tile.c:241:        &tileobj->tile.type,
../script/py_tile.c:242:        &tileobj->tile.base_height,
../script/py_tile.c:243:        &tileobj->tile.ramp_height,
../script/py_tile.c:244:        &tileobj->tile.top_mat_idx,
../script/py_tile.c:245:        &tileobj->tile.sides_mat_idx,
../script/py_tile.c:246:        &tileobj->tile.blend_mode,
../script/py_tile.c:250:    tileobj->tile.pathable = !!pathable;
../script/py_tile.c:251:    tileobj->tile.blend_normals = !!blend_normals;
../script/py_tile.c:283:    return &((PyTileObject*)tile_obj)->tile;
../script/py_tile.c:296:    ret->tile = tile;
../script/py_tile.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_traverse.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../script/py_traverse.c:81:    khiter_t k = kh_get(id, ctx->visited, (uintptr_t)root);
../script/py_traverse.c:82:    if(k != kh_end(ctx->visited))
../script/py_traverse.c:88:    k = kh_put(id, ctx->visited, (uintptr_t)root, &ret);
../script/py_traverse.c:89:    assert(ret != -1 && ret != 0);
../script/py_traverse.c:107:         * which returns a brand new heap-allocated PyObject to satisfy the 
../script/py_traverse.c:114:        if(child->ob_refcnt == 1) {
../script/py_traverse.c:123:        ctx->depth = ctx->depth + 1;
../script/py_traverse.c:124:        ctx->parent = root;
../script/py_traverse.c:125:        ctx->attrname = PyString_AS_STRING(attr);
../script/py_traverse.c:132:        assert(child->ob_refcnt > 1);
../script/py_traverse.c:141:    khiter_t k = kh_get(id, ctx->visited, (uintptr_t)root);
../script/py_traverse.c:142:    if(k != kh_end(ctx->visited))
../script/py_traverse.c:164:        if((k = kh_get(id, ctx->visited, (uintptr_t)curr)) != kh_end(ctx->visited))
../script/py_traverse.c:167:        ctx->depth = curr_meta.depth;
../script/py_traverse.c:168:        ctx->parent = curr_meta.parent;
../script/py_traverse.c:169:        ctx->attrname = curr_meta.attrname;
../script/py_traverse.c:174:        k = kh_put(id, ctx->visited, (uintptr_t)curr, &ret);
../script/py_traverse.c:175:        assert(ret != -1 && ret != 0);
../script/py_traverse.c:190:            if(child->ob_refcnt == 1) {
../script/py_traverse.c:196:            k = kh_get(id, ctx->visited, (uintptr_t)child);
../script/py_traverse.c:197:            if(k != kh_end(ctx->visited)) {
../script/py_traverse.c:225:    for(int i = 0; i < vctx->depth; i++)
../script/py_traverse.c:239:    khash_t(str) *id_qualname_map = vctx->user;
../script/py_traverse.c:245:    if(!vctx->parent) {
../script/py_traverse.c:252:        assert(vctx->attrname);
../script/py_traverse.c:253:        uintptr_t pid = (uintptr_t)vctx->parent;
../script/py_traverse.c:260:        qname = pf_strapp(qname, vctx->attrname);
../script/py_traverse.c:263:    k = kh_get(id, vctx->visited, id);
../script/py_traverse.c:264:    assert(k == kh_end(vctx->visited));
../script/py_traverse.c:268:    assert(ret != -1);
../script/py_traverse.c:277:    struct contains_ctx *cctx = vctx->user;
../script/py_traverse.c:279:    if(obj == cctx->test)
../script/py_traverse.c:280:        cctx->contains = true;
../script/py_traverse.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../script/py_ui.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_ui.c:284:    "collapsable non-root tree section."},
../script/py_ui.c:312:    "Editable input field for floating-point properties."},
../script/py_ui.c:324:    "Present a slider widget with floating-point precision."},
../script/py_ui.c:536:    "A read-write bool to enable or disable user interactivity for this window.",
../script/py_ui.c:605:        return -1;
../script/py_ui.c:611:        return -1;
../script/py_ui.c:614:        return -1;
../script/py_ui.c:634:        return -1;
../script/py_ui.c:641:        return -1;
../script/py_ui.c:644:    self->header_style = S_UIHeaderStyleNew();
../script/py_ui.c:645:    if(!self->header_style) {
../script/py_ui.c:647:        return -1;
../script/py_ui.c:650:    pf_strlcpy(self->name, name, sizeof(self->name));
../script/py_ui.c:651:    self->rect = rect;
../script/py_ui.c:652:    self->flags = flags;
../script/py_ui.c:653:    self->style = s_nk_ctx->style.window;
../script/py_ui.c:654:    self->resize_mask = resize_mask;
../script/py_ui.c:655:    self->suspend_on_pause = !!suspend_on_pause;
../script/py_ui.c:656:    self->virt_res.x = vres[0];
../script/py_ui.c:657:    self->virt_res.y = vres[1];
../script/py_ui.c:659:    self->flags |= (NK_WINDOW_CLOSED | NK_WINDOW_HIDDEN); /* closed by default */
../script/py_ui.c:760:    const struct nk_input *in = &s_nk_ctx->input;
../script/py_ui.c:796:    int clicked_index = -1;
../script/py_ui.c:797:    int hovered_index = -1;
../script/py_ui.c:836:        if(hovered_index != -1)
../script/py_ui.c:839:        if(clicked_index != -1 && on_click_handler) {
../script/py_ui.c:988:    struct nk_window *win = s_nk_ctx->current;
../script/py_ui.c:989:    struct nk_panel *panel = win->layout;
../script/py_ui.c:990:    if(!(panel->type & NK_PANEL_SET_POPUP)) {
../script/py_ui.c:1377:    self->flags &= ~(NK_WINDOW_HIDDEN | NK_WINDOW_CLOSED);
../script/py_ui.c:1378:    nk_window_show(s_nk_ctx, self->name, NK_SHOWN);
../script/py_ui.c:1379:    self->hide = false;
../script/py_ui.c:1385:    self->hide = true;
../script/py_ui.c:1417:    PyObject *name = PyString_FromString(self->name);
../script/py_ui.c:1424:        self->rect.x, self->rect.y, self->rect.w, self->rect.h);
../script/py_ui.c:1430:    PyObject *flags = PyInt_FromLong(self->flags);
../script/py_ui.c:1436:    PyObject *virt_res = Py_BuildValue("(ii)", self->virt_res.x, self->virt_res.y);
../script/py_ui.c:1442:    PyObject *resize_mask = PyInt_FromLong(self->resize_mask);
../script/py_ui.c:1448:    PyObject *sop = PyInt_FromLong(self->suspend_on_pause);
../script/py_ui.c:1454:    PyObject *hide = PyInt_FromLong(self->hide);
../script/py_ui.c:1460:    status = S_PickleObjgraph(self->header_style, stream);
../script/py_ui.c:1463:    CHK_TRUE_RET(S_UI_Style_SaveWindow(stream, &self->style));
../script/py_ui.c:1524:     * to avoid calling any magic that might be risiding in the user-implemented __new__ 
../script/py_ui.c:1527:    assert(heap_subtype->tp_new);
../script/py_ui.c:1530:    PyWindowObject *winobj = (PyWindowObject*)heap_subtype->tp_new((struct _typeobject*)cls, win_args, NULL);
../script/py_ui.c:1538:        &winobj->rect.x, &winobj->rect.y, 
../script/py_ui.c:1539:        &winobj->rect.w, &winobj->rect.h, 
../script/py_ui.c:1540:        &winobj->flags, 
../script/py_ui.c:1541:        &winobj->virt_res.x, &winobj->virt_res.y, 
../script/py_ui.c:1542:        &winobj->resize_mask,
../script/py_ui.c:1546:    pf_strlcpy(winobj->name, namestr, sizeof(winobj->name));
../script/py_ui.c:1547:    winobj->suspend_on_pause = !!isop;
../script/py_ui.c:1550:    winobj->hide = !!PyInt_AS_LONG(hide);
../script/py_ui.c:1552:    if(!S_UI_Style_LoadWindow(stream, &winobj->style)) {
../script/py_ui.c:1558:    winobj->header_style = header_style;
../script/py_ui.c:1582:    PyObject *self = type->tp_alloc(type, 0);
../script/py_ui.c:1583:    ((PyWindowObject*)self)->header_style = NULL;
../script/py_ui.c:1584:    ((PyWindowObject*)self)->resize_mask = ANCHOR_DEFAULT;
../script/py_ui.c:1585:    ((PyWindowObject*)self)->suspend_on_pause = false;
../script/py_ui.c:1586:    ((PyWindowObject*)self)->hide = false;
../script/py_ui.c:1593:    Py_XDECREF(self->header_style);
../script/py_ui.c:1598:    nk_window_close(s_nk_ctx, self->name);
../script/py_ui.c:1599:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_ui.c:1604:    Py_INCREF(self->header_style);
../script/py_ui.c:1605:    return self->header_style;
../script/py_ui.c:1610:    return Py_BuildValue("(ii)", self->rect.x, self->rect.y);
../script/py_ui.c:1618:        return -1;
../script/py_ui.c:1620:    self->rect.x = x;
../script/py_ui.c:1621:    self->rect.y = y;
../script/py_ui.c:1627:    return Py_BuildValue("(ii)", self->rect.w, self->rect.h);
../script/py_ui.c:1632:    return Py_BuildValue("i", (int)S_UIHeaderGetHeight(self->header_style, s_nk_ctx));
../script/py_ui.c:1638:        self->style.spacing.x,
../script/py_ui.c:1639:        self->style.spacing.y); 
../script/py_ui.c:1648:        return -1; 
../script/py_ui.c:1651:    self->style.spacing = (struct nk_vec2){x, y};
../script/py_ui.c:1658:        self->style.padding.x,
../script/py_ui.c:1659:        self->style.padding.y);
../script/py_ui.c:1668:        return -1; 
../script/py_ui.c:1671:    self->style.padding = nk_vec2(x,y);
../script/py_ui.c:1678:        self->style.group_padding.x,
../script/py_ui.c:1679:        self->style.group_padding.y);
../script/py_ui.c:1688:        return -1; 
../script/py_ui.c:1691:    self->style.group_padding = nk_vec2(x,y);
../script/py_ui.c:1698:        self->style.combo_padding.x,
../script/py_ui.c:1699:        self->style.combo_padding.y);
../script/py_ui.c:1705:        self->style.popup_padding.x,
../script/py_ui.c:1706:        self->style.popup_padding.y);
../script/py_ui.c:1715:        return -1; 
../script/py_ui.c:1718:    self->style.popup_padding = nk_vec2(x,y);
../script/py_ui.c:1728:        return -1; 
../script/py_ui.c:1731:    self->style.combo_padding = nk_vec2(x,y);
../script/py_ui.c:1738:        self->style.contextual_padding.x,
../script/py_ui.c:1739:        self->style.contextual_padding.y);
../script/py_ui.c:1748:        return -1; 
../script/py_ui.c:1751:    self->style.contextual_padding = nk_vec2(x,y);
../script/py_ui.c:1758:        self->style.menu_padding.x,
../script/py_ui.c:1759:        self->style.menu_padding.y);
../script/py_ui.c:1768:        return -1; 
../script/py_ui.c:1771:    self->style.menu_padding = nk_vec2(x,y);
../script/py_ui.c:1778:        self->style.tooltip_padding.x,
../script/py_ui.c:1779:        self->style.tooltip_padding.y);
../script/py_ui.c:1788:        return -1; 
../script/py_ui.c:1791:    self->style.tooltip_padding = nk_vec2(x,y);
../script/py_ui.c:1797:    return Py_BuildValue("f", self->style.border);
../script/py_ui.c:1804:        return -1;
../script/py_ui.c:1807:    self->style.border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:1814:        self->style.border_color.r,
../script/py_ui.c:1815:        self->style.border_color.g,
../script/py_ui.c:1816:        self->style.border_color.b,
../script/py_ui.c:1817:        self->style.border_color.a
../script/py_ui.c:1825:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1826:        return -1;
../script/py_ui.c:1829:    self->style.border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1836:        self->style.popup_border_color.r,
../script/py_ui.c:1837:        self->style.popup_border_color.g,
../script/py_ui.c:1838:        self->style.popup_border_color.b,
../script/py_ui.c:1839:        self->style.popup_border_color.a
../script/py_ui.c:1847:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1848:        return -1;
../script/py_ui.c:1851:    self->style.popup_border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1858:        self->style.combo_border_color.r,
../script/py_ui.c:1859:        self->style.combo_border_color.g,
../script/py_ui.c:1860:        self->style.combo_border_color.b,
../script/py_ui.c:1861:        self->style.combo_border_color.a
../script/py_ui.c:1869:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1870:        return -1;
../script/py_ui.c:1873:    self->style.combo_border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1880:        self->style.contextual_border_color.r,
../script/py_ui.c:1881:        self->style.contextual_border_color.g,
../script/py_ui.c:1882:        self->style.contextual_border_color.b,
../script/py_ui.c:1883:        self->style.contextual_border_color.a
../script/py_ui.c:1891:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1892:        return -1;
../script/py_ui.c:1895:    self->style.contextual_border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1902:        self->style.menu_border_color.r,
../script/py_ui.c:1903:        self->style.menu_border_color.g,
../script/py_ui.c:1904:        self->style.menu_border_color.b,
../script/py_ui.c:1905:        self->style.menu_border_color.a
../script/py_ui.c:1913:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1914:        return -1;
../script/py_ui.c:1917:    self->style.menu_border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1924:        self->style.group_border_color.r,
../script/py_ui.c:1925:        self->style.group_border_color.g,
../script/py_ui.c:1926:        self->style.group_border_color.b,
../script/py_ui.c:1927:        self->style.group_border_color.a
../script/py_ui.c:1935:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1936:        return -1;
../script/py_ui.c:1939:    self->style.group_border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1946:        self->style.tooltip_border_color.r,
../script/py_ui.c:1947:        self->style.tooltip_border_color.g,
../script/py_ui.c:1948:        self->style.tooltip_border_color.b,
../script/py_ui.c:1949:        self->style.tooltip_border_color.a
../script/py_ui.c:1957:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:1958:        return -1;
../script/py_ui.c:1961:    self->style.tooltip_border_color = (struct nk_color){r, g, b, a};
../script/py_ui.c:1967:    return Py_BuildValue("f", self->style.group_border);
../script/py_ui.c:1974:        return -1;
../script/py_ui.c:1977:    self->style.group_border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:1983:    return Py_BuildValue("f", self->style.combo_border);
../script/py_ui.c:1988:    return Py_BuildValue("f", self->style.contextual_border);
../script/py_ui.c:1995:        return -1;
../script/py_ui.c:1998:    self->style.contextual_border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:2004:    return Py_BuildValue("f", self->style.menu_border);
../script/py_ui.c:2011:        return -1;
../script/py_ui.c:2014:    self->style.menu_border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:2020:    return Py_BuildValue("f", self->style.tooltip_border);
../script/py_ui.c:2027:        return -1;
../script/py_ui.c:2030:    self->style.group_border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:2036:    return Py_BuildValue("f", self->style.popup_border);
../script/py_ui.c:2043:        return -1;
../script/py_ui.c:2046:    self->style.group_border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:2054:        return -1;
../script/py_ui.c:2057:    self->style.combo_border = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:2063:    return Py_BuildValue("f", self->style.min_row_height_padding);
../script/py_ui.c:2070:        return -1;
../script/py_ui.c:2073:    self->style.min_row_height_padding = PyFloat_AS_DOUBLE(value);
../script/py_ui.c:2080:        self->style.scrollbar_size.x, 
../script/py_ui.c:2081:        self->style.scrollbar_size.y);
../script/py_ui.c:2090:        return -1; 
../script/py_ui.c:2093:    self->style.scrollbar_size = nk_vec2(x,y);
../script/py_ui.c:2100:        self->style.min_size.x, 
../script/py_ui.c:2101:        self->style.min_size.y);
../script/py_ui.c:2110:        return -1; 
../script/py_ui.c:2113:    self->style.min_size = nk_vec2(x,y);
../script/py_ui.c:2119:    if(self->flags & NK_WINDOW_CLOSED) 
../script/py_ui.c:2127:    if(self->flags & NK_WINDOW_HIDDEN) 
../script/py_ui.c:2135:    if(self->flags & NK_WINDOW_NOT_INTERACTIVE)
../script/py_ui.c:2144:        self->flags &= ~NK_WINDOW_NOT_INTERACTIVE;
../script/py_ui.c:2146:        self->flags |= NK_WINDOW_NOT_INTERACTIVE;
../script/py_ui.c:2153:        self->style.background.r,
../script/py_ui.c:2154:        self->style.background.g,
../script/py_ui.c:2155:        self->style.background.b,
../script/py_ui.c:2156:        self->style.background.a
../script/py_ui.c:2164:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255).");
../script/py_ui.c:2165:        return -1;
../script/py_ui.c:2168:    self->style.background = (struct nk_color){r, g, b, a};
../script/py_ui.c:2174:    if(self->style.fixed_background.type == NK_STYLE_ITEM_TEXPATH) {
../script/py_ui.c:2175:        return PyString_FromString(self->style.fixed_background.data.texpath);
../script/py_ui.c:2177:        assert(self->style.fixed_background.type == NK_STYLE_ITEM_COLOR);
../script/py_ui.c:2178:        struct nk_color clr = self->style.fixed_background.data.color;
../script/py_ui.c:2190:            PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255) or a path string.");
../script/py_ui.c:2191:            return -1;
../script/py_ui.c:2195:        self->style.fixed_background = (struct nk_style_item){
../script/py_ui.c:2202:        self->style.fixed_background = (struct nk_style_item){ .type = NK_STYLE_ITEM_TEXPATH };
../script/py_ui.c:2203:        pf_strlcpy(self->style.fixed_background.data.texpath, PyString_AS_STRING(value), 
../script/py_ui.c:2204:            sizeof(self->style.fixed_background.data.texpath));
../script/py_ui.c:2207:        PyErr_SetString(PyExc_TypeError, "Value must be a tuple of 4 integers (0-255) or a path string.");
../script/py_ui.c:2208:        return -1;
../script/py_ui.c:2240:        if(win->flags & (NK_WINDOW_HIDDEN | NK_WINDOW_CLOSED))
../script/py_ui.c:2243:        bool interactive = !(win->flags & NK_WINDOW_NOT_INTERACTIVE);
../script/py_ui.c:2244:        if(win->suspend_on_pause && G_GetSimState() != G_RUNNING)
../script/py_ui.c:2245:            win->flags |= NK_WINDOW_NOT_INTERACTIVE;
../script/py_ui.c:2247:        struct nk_style_window saved_style = s_nk_ctx->style.window;
../script/py_ui.c:2248:        s_nk_ctx->style.window = win->style;
../script/py_ui.c:2249:        if(win->header_style) {
../script/py_ui.c:2250:            S_UIHeaderStylePush(win->header_style, s_nk_ctx);
../script/py_ui.c:2253:        struct nk_vec2i adj_vres = TO_VEC2I(UI_ArAdjustedVRes(TO_VEC2T(win->virt_res)));
../script/py_ui.c:2254:        struct rect adj_bounds = UI_BoundsForAspectRatio(win->rect, 
../script/py_ui.c:2255:            TO_VEC2T(win->virt_res), TO_VEC2T(adj_vres), win->resize_mask);
../script/py_ui.c:2257:        if(nk_begin_with_vres(s_nk_ctx, win->name, 
../script/py_ui.c:2258:            nk_rect(adj_bounds.x, adj_bounds.y, adj_bounds.w, adj_bounds.h), win->flags, adj_vres)) {
../script/py_ui.c:2263:        if(win->hide || (s_nk_ctx->current->flags & NK_WINDOW_HIDDEN && !(win->flags & NK_WINDOW_HIDDEN))) {
../script/py_ui.c:2265:            PyObject *manual = win->hide ? Py_False : Py_True;
../script/py_ui.c:2271:        if(s_nk_ctx->current->minimized) {
../script/py_ui.c:2275:        if(s_nk_ctx->current->maximized) {
../script/py_ui.c:2282:        win->rect = UI_BoundsForAspectRatio(adj_bounds, TO_VEC2T(adj_vres), TO_VEC2T(win->virt_res), win->resize_mask);
../script/py_ui.c:2285:        win->flags &= ~sample_mask; 
../script/py_ui.c:2286:        win->flags |= (s_nk_ctx->current->flags & sample_mask);
../script/py_ui.c:2289:            win->flags &= ~NK_WINDOW_NOT_INTERACTIVE;
../script/py_ui.c:2293:        if(win->header_style) {
../script/py_ui.c:2294:            S_UIHeaderStylePop(win->header_style, s_nk_ctx);
../script/py_ui.c:2296:        s_nk_ctx->style.window = saved_style;
../script/py_ui.c:2298:        if(win->hide) {
../script/py_ui.c:2299:            nk_window_close(s_nk_ctx, win->name);
../script/py_ui.c:2300:            win->flags |= (NK_WINDOW_HIDDEN | NK_WINDOW_CLOSED);
../script/py_ui.c:2301:            win->hide = false;
../script/py_ui.c:2346:        struct rect adj_bounds = UI_BoundsForAspectRatio(win->rect, TO_VEC2T(win->virt_res),
../script/py_ui.c:2347:            UI_ArAdjustedVRes(TO_VEC2T(win->virt_res)), win->resize_mask);
../script/py_ui.c:2350:        if(win->flags & NK_WINDOW_HIDDEN
../script/py_ui.c:2351:        || win->flags & NK_WINDOW_CLOSED) {
../script/py_ui.c:2355:        int vmouse_x = (float)mouse_x / w * UI_ArAdjustedVRes(TO_VEC2T(win->virt_res)).x;
../script/py_ui.c:2356:        int vmouse_y = (float)mouse_y / h * UI_ArAdjustedVRes(TO_VEC2T(win->virt_res)).y;
../script/py_ui.c:2359:        struct nk_window *nkwin = nk_window_find(s_nk_ctx, win->name);
../script/py_ui.c:2360:        if(nkwin && nkwin->flags & NK_WINDOW_MINIMIZED) {
../script/py_ui.c:2362:            float header_height = S_UIHeaderGetHeight(win->header_style, s_nk_ctx);
../script/py_ui.c:2384:        if(win->flags & NK_WINDOW_HIDDEN
../script/py_ui.c:2385:        || win->flags & NK_WINDOW_CLOSED) {
../script/py_ui.c:2389:        struct nk_window *nkwin = nk_window_find(s_nk_ctx, win->name);
../script/py_ui.c:2393:        if(nkwin->edit.active == nk_true)
../script/py_ui.c:2406:        if(win->flags & NK_WINDOW_HIDDEN
../script/py_ui.c:2407:        || win->flags & NK_WINDOW_CLOSED) {
../script/py_ui.c:2411:        struct nk_window *nkwin = nk_window_find(s_nk_ctx, win->name);
../script/py_ui.c:2415:        if(nkwin->edit.active == nk_true) {
../script/py_ui.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_ui_style.c:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../script/py_ui_style.c:580:    "The look of the button in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:587:    "The look of the button when the mouse is hovered over it - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:594:    "The look of the button in the active (pressed) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:637:    "A floating-point value of the button border width, in pixels.", 
../script/py_ui_style.c:643:    "A floating-point value to control how rounded the button corners are.", 
../script/py_ui_style.c:735:    "The look of the button in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:742:    "The look of the button when the mouse is hovered over it - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:749:    "The look of the button in the active (pressed) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:832:    "The look of the selectable label in the normal (inactive) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:839:    "The look of the selectable label in the hovered (inactive) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:846:    "The look of the selectable label in the pressed (inactive) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:853:    "The look of the selectable label in the normal (active) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:860:    "The look of the selectable label in the hovered (active) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:867:    "The look of the selectable label in the pressed (active) state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:874:    "The color of the selectable label text in the normal (inactive) state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:880:    "The color of the selectable label text in the hovered (inactive) state - an (R, G, B, A) tuple",
../script/py_ui_style.c:886:    "The color of the selectable label text in the pressed (inactive) state - an (R, G, B, A) tuple",
../script/py_ui_style.c:892:    "The color of the selectable label text in the normal (active) state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:898:    "The color of the selectable label text in the hovered (active) state - an (R, G, B, A) tuple",
../script/py_ui_style.c:904:    "The color of the selectable label text in the pressed (active) state - an (R, G, B, A) tuple",
../script/py_ui_style.c:916:    "A floating-point value to control how rounded the selectable label corners are.", 
../script/py_ui_style.c:998:    "The look of the combo element in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1005:    "The look of the combo element in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1012:    "The look of the combo element in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1019:    "The color of the combo box border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1025:    "The color of the combo item label in the normal state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1031:    "The color of the combo item label in the hovered state - an (R, G, B, A) tuple",
../script/py_ui_style.c:1037:    "The color of the combo item label in the active state - an (R, G, B, A) tuple",
../script/py_ui_style.c:1043:    "The color of the combo symbol in the normal state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1049:    "The color of the combo symbol in the hovered state - an (R, G, B, A) tuple",
../script/py_ui_style.c:1055:    "The color of the combo symbol in the active state - an (R, G, B, A) tuple",
../script/py_ui_style.c:1060:    "A pf.UIButtonStyle object describing the style of the combo box drop-down button.",
../script/py_ui_style.c:1066:    "The type of the combo box drop-down glyph in the normal state - an integer (pf.NK_SYMBOL_X, etc.)",
../script/py_ui_style.c:1072:    "The type of the combo box drop-down glyph in the hovered state - an integer (pf.NK_SYMBOL_X, etc.)",
../script/py_ui_style.c:1078:    "The type of the combo box drop-down glyph in the active state - an integer (pf.NK_SYMBOL_X, etc.)",
../script/py_ui_style.c:1084:    "A floating-point value to control width of the combo box border.", 
../script/py_ui_style.c:1090:    "A floating-point value to control how rounded the selectable label corners are.", 
../script/py_ui_style.c:1102:    "An (X, Y) tuple of floats to control the padding around combo box drop-down buttons.", 
../script/py_ui_style.c:1172:    "The look of the toggle button in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1179:    "The look of the toggle button in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1186:    "The look of the toggle button in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1193:    "The color of the toggle button border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1199:    "The look of the toggle button cursor (selection indicator) in the normal state - "
../script/py_ui_style.c:1206:    "The look of the toggle button cursor (selection indicator) in the hover state - "
../script/py_ui_style.c:1213:    "The color of the option text in the normal state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1219:    "The color of the option text in the hovered state - an (R, G, B, A) tuple",
../script/py_ui_style.c:1225:    "The color of the option text in the active state - an (R, G, B, A) tuple",
../script/py_ui_style.c:1231:    "The color of the option text background - an (R, G, B, A) tuple",
../script/py_ui_style.c:1261:    "A floating-point value of the toggle button border width, in pixels.", 
../script/py_ui_style.c:1288:    "Style configuration for Permafrost Engine UI toggle-able options.", /* tp_doc */
../script/py_ui_style.c:1325:    "The look of the scrollbar in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1332:    "The look of the scrollbar in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1339:    "The look of the scrollbar in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1346:    "The color of the scrollbar border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1352:    "The look of the scrollbar cursor (selection indicator) in the normal state - "
../script/py_ui_style.c:1359:    "The look of the scrollbar cursor (selection indicator) in the hover state - "
../script/py_ui_style.c:1366:    "The look of the scrollbar cursor (selection indicator) in the active state - "
../script/py_ui_style.c:1373:    "The look of the scrollbar cursor (selection indicator) in the active state - "
../script/py_ui_style.c:1431:    "Style configuration for Permafrost Engine UI toggle-able options.", /* tp_doc */
../script/py_ui_style.c:1468:    "The look of the editable field in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1475:    "The look of the editable field in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1482:    "The look of the editable field in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1489:    "The color of the editable field border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1495:    "The style of the scrollbar of editable fields - a UIStyleObject instance",
../script/py_ui_style.c:1501:    "The color of the cursor in the normal state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1507:    "The color of the cursor in the hover state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1513:    "The color of the text cursor in normal mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1519:    "The color of the text cursor in hover mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1525:    "The color of the (unselected) text in normal mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1531:    "The color of the (unselected) text in hover mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1537:    "The color of the (unselected) text in active mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1543:    "The color of the selection box in normal mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1549:    "The color of the selection box in hover mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1555:    "The color of the (selected) text in normal mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1561:    "The color of the (selected) text in hover mode - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1624:    "Style configuration for Permafrost Engine UI toggle-able options.", /* tp_doc */
../script/py_ui_style.c:1661:    "The look of the property field in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1668:    "The look of the property field in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1675:    "The look of the property field in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1682:    "The color of the property field border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1688:    "The color of the label in the normal state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1694:    "The color of the label in the hover state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1700:    "The color of the label in the active state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1706:    "The style of the left button symbol - an NK_SYMBOL enum value.",
../script/py_ui_style.c:1712:    "The style of the left button symbol - an NK_SYMBOL enum value.",
../script/py_ui_style.c:1742:    "The style of the property increment value button - a pf.UIButtonStyleObject instance.", 
../script/py_ui_style.c:1748:    "The style of the property decrement value button - a pf.UIButtonStyleObject instance.", 
../script/py_ui_style.c:1812:    "The look of the slider background in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1819:    "The look of the slider background in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1826:    "The look of the slider background in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1833:    "The color of the slider bar border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1839:    "The color of the slider bar in the normal state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1845:    "The color of the slider bar in the hover state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1851:    "The color of the slider bar in the active state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1857:    "The color of the slider bar in the filled state - an (R, G, B, A) tuple.",
../script/py_ui_style.c:1863:    "The look of the slider cursor in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1870:    "The look of the slider cursor in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1877:    "The look of the slider cursor in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:1938:    "The style of the increment button symbol - an NK_SYMBOL enum value.",
../script/py_ui_style.c:1944:    "The style of the decrement button symbol - an NK_SYMBOL enum value.",
../script/py_ui_style.c:2008:    "The look of the progress bar background in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:2015:    "The look of the progress bar background in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:2022:    "The look of the progress bar background in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:2029:    "The color of the progress bar border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:2035:    "The look of the progress bar cursor in the normal state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:2042:    "The look of the progress bar cursor in the hovered state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:2049:    "The look of the progress bar cursor in the active state - either an (R, G, B, A) tuple or a "
../script/py_ui_style.c:2056:    "The color of the progress bar cursor border - an (R, G, B, A) tuple.",
../script/py_ui_style.c:2142:        return -1;
../script/py_ui_style.c:2148:        return -1;
../script/py_ui_style.c:2151:        return -1;
../script/py_ui_style.c:2161:        return -1;
../script/py_ui_style.c:2167:            return -1;
../script/py_ui_style.c:2174:            return -1;
../script/py_ui_style.c:2182:    if(item->type == NK_STYLE_ITEM_COLOR) {
../script/py_ui_style.c:2184:            item->data.color.r,
../script/py_ui_style.c:2185:            item->data.color.g,
../script/py_ui_style.c:2186:            item->data.color.b,
../script/py_ui_style.c:2187:            item->data.color.a);
../script/py_ui_style.c:2190:        return PyString_FromString(item->data.texpath);
../script/py_ui_style.c:2200:        out->type = NK_STYLE_ITEM_COLOR;
../script/py_ui_style.c:2201:        out->data.color  = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:2206:        out->type = NK_STYLE_ITEM_TEXPATH;
../script/py_ui_style.c:2207:        pf_strlcpy(out->data.texpath, PyString_AS_STRING(value),
../script/py_ui_style.c:2208:            ARR_SIZE(out->data.texpath));
../script/py_ui_style.c:2213:        return -1; 
../script/py_ui_style.c:2219:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:2224:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:2229:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:2234:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:2239:    return style_get_item(&self->style->active);
../script/py_ui_style.c:2244:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:2250:        self->style->border_color.r,
../script/py_ui_style.c:2251:        self->style->border_color.g,
../script/py_ui_style.c:2252:        self->style->border_color.b,
../script/py_ui_style.c:2253:        self->style->border_color.a);
../script/py_ui_style.c:2262:        return -1; 
../script/py_ui_style.c:2265:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:2272:        self->style->text_background.r,
../script/py_ui_style.c:2273:        self->style->text_background.g,
../script/py_ui_style.c:2274:        self->style->text_background.b,
../script/py_ui_style.c:2275:        self->style->text_background.a);
../script/py_ui_style.c:2284:        return -1; 
../script/py_ui_style.c:2287:    self->style->text_background = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:2294:        self->style->text_normal.r,
../script/py_ui_style.c:2295:        self->style->text_normal.g,
../script/py_ui_style.c:2296:        self->style->text_normal.b,
../script/py_ui_style.c:2297:        self->style->text_normal.a);
../script/py_ui_style.c:2306:        return -1; 
../script/py_ui_style.c:2309:    self->style->text_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:2316:        self->style->text_hover.r,
../script/py_ui_style.c:2317:        self->style->text_hover.g,
../script/py_ui_style.c:2318:        self->style->text_hover.b,
../script/py_ui_style.c:2319:        self->style->text_hover.a);
../script/py_ui_style.c:2328:        return -1; 
../script/py_ui_style.c:2331:    self->style->text_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:2338:        self->style->text_active.r,
../script/py_ui_style.c:2339:        self->style->text_active.g,
../script/py_ui_style.c:2340:        self->style->text_active.b,
../script/py_ui_style.c:2341:        self->style->text_active.a);
../script/py_ui_style.c:2350:        return -1; 
../script/py_ui_style.c:2353:    self->style->text_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:2359:    return Py_BuildValue("I", self->style->text_alignment);
../script/py_ui_style.c:2366:        return -1; 
../script/py_ui_style.c:2369:    self->style->text_alignment = PyInt_AsLong(value);
../script/py_ui_style.c:2375:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:2382:        return -1; 
../script/py_ui_style.c:2385:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:2391:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:2398:        return -1; 
../script/py_ui_style.c:2401:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:2408:        self->style->padding.x,
../script/py_ui_style.c:2409:        self->style->padding.y);
../script/py_ui_style.c:2418:        return -1; 
../script/py_ui_style.c:2421:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:2428:        self->style->image_padding.x,
../script/py_ui_style.c:2429:        self->style->image_padding.y);
../script/py_ui_style.c:2438:        return -1; 
../script/py_ui_style.c:2441:    self->style->image_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:2448:        self->style->touch_padding.x,
../script/py_ui_style.c:2449:        self->style->touch_padding.y);
../script/py_ui_style.c:2458:        return -1; 
../script/py_ui_style.c:2461:    self->style->touch_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:2478:    if(!PyArg_ParseTuple(obj, "iiii", &out->r, &out->g, &out->b, &out->a)) {
../script/py_ui_style.c:2552:    if(!PyArg_ParseTuple(obj, "ff", &out->x, &out->y)) {
../script/py_ui_style.c:2565:    assert(item->type == NK_STYLE_ITEM_COLOR 
../script/py_ui_style.c:2566:        || item->type == NK_STYLE_ITEM_TEXPATH);
../script/py_ui_style.c:2568:    PyObject *val = item->type == NK_STYLE_ITEM_COLOR
../script/py_ui_style.c:2569:        ? Py_BuildValue("iiii", item->data.color.r, item->data.color.g, item->data.color.b, item->data.color.a)
../script/py_ui_style.c:2570:        : PyString_FromString(item->data.texpath);
../script/py_ui_style.c:2572:    PyObject *pickle = Py_BuildValue("iO", item->type, val);
../script/py_ui_style.c:2604:       &out->data.color.r, &out->data.color.g, &out->data.color.b, &out->data.color.a)) {
../script/py_ui_style.c:2615:        pf_snprintf(out->data.texpath, sizeof(out->data.texpath), "%s", PyString_AS_STRING(val));
../script/py_ui_style.c:2618:    out->type = type;
../script/py_ui_style.c:2628:    CHK_TRUE_RET(save_item(stream, &button->normal));
../script/py_ui_style.c:2629:    CHK_TRUE_RET(save_item(stream, &button->hover));
../script/py_ui_style.c:2630:    CHK_TRUE_RET(save_item(stream, &button->active));
../script/py_ui_style.c:2632:    CHK_TRUE_RET(save_color(stream, button->border_color));
../script/py_ui_style.c:2633:    CHK_TRUE_RET(save_color(stream, button->text_normal));
../script/py_ui_style.c:2634:    CHK_TRUE_RET(save_color(stream, button->text_hover));
../script/py_ui_style.c:2635:    CHK_TRUE_RET(save_color(stream, button->text_active));
../script/py_ui_style.c:2637:    CHK_TRUE_RET(save_int(stream, button->text_alignment));
../script/py_ui_style.c:2638:    CHK_TRUE_RET(save_float(stream, button->border));
../script/py_ui_style.c:2639:    CHK_TRUE_RET(save_float(stream, button->rounding));
../script/py_ui_style.c:2640:    CHK_TRUE_RET(save_vec2(stream, button->padding));
../script/py_ui_style.c:2641:    CHK_TRUE_RET(save_vec2(stream, button->image_padding));
../script/py_ui_style.c:2642:    CHK_TRUE_RET(save_vec2(stream, button->touch_padding));
../script/py_ui_style.c:2649:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2650:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2651:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:2653:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:2654:    CHK_TRUE_RET(load_color(stream, &out->text_normal));
../script/py_ui_style.c:2655:    CHK_TRUE_RET(load_color(stream, &out->text_hover));
../script/py_ui_style.c:2656:    CHK_TRUE_RET(load_color(stream, &out->text_active));
../script/py_ui_style.c:2658:    CHK_TRUE_RET(load_int(stream, (int*)&out->text_alignment));
../script/py_ui_style.c:2659:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:2660:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:2661:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:2662:    CHK_TRUE_RET(load_vec2(stream, &out->image_padding));
../script/py_ui_style.c:2663:    CHK_TRUE_RET(load_vec2(stream, &out->touch_padding));
../script/py_ui_style.c:2670:    CHK_TRUE_RET(save_item(stream, &selectable->normal));
../script/py_ui_style.c:2671:    CHK_TRUE_RET(save_item(stream, &selectable->hover));
../script/py_ui_style.c:2672:    CHK_TRUE_RET(save_item(stream, &selectable->pressed));
../script/py_ui_style.c:2674:    CHK_TRUE_RET(save_item(stream, &selectable->normal_active));
../script/py_ui_style.c:2675:    CHK_TRUE_RET(save_item(stream, &selectable->hover_active));
../script/py_ui_style.c:2676:    CHK_TRUE_RET(save_item(stream, &selectable->pressed_active));
../script/py_ui_style.c:2678:    CHK_TRUE_RET(save_color(stream, selectable->text_normal));
../script/py_ui_style.c:2679:    CHK_TRUE_RET(save_color(stream, selectable->text_hover));
../script/py_ui_style.c:2680:    CHK_TRUE_RET(save_color(stream, selectable->text_pressed));
../script/py_ui_style.c:2682:    CHK_TRUE_RET(save_color(stream, selectable->text_normal_active));
../script/py_ui_style.c:2683:    CHK_TRUE_RET(save_color(stream, selectable->text_hover_active));
../script/py_ui_style.c:2684:    CHK_TRUE_RET(save_color(stream, selectable->text_pressed_active));
../script/py_ui_style.c:2686:    CHK_TRUE_RET(save_int(stream, selectable->text_alignment));
../script/py_ui_style.c:2687:    CHK_TRUE_RET(save_float(stream, selectable->rounding));
../script/py_ui_style.c:2688:    CHK_TRUE_RET(save_vec2(stream, selectable->padding));
../script/py_ui_style.c:2689:    CHK_TRUE_RET(save_vec2(stream, selectable->image_padding));
../script/py_ui_style.c:2690:    CHK_TRUE_RET(save_vec2(stream, selectable->touch_padding));
../script/py_ui_style.c:2697:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2698:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2699:    CHK_TRUE_RET(load_item(stream, &out->pressed));
../script/py_ui_style.c:2701:    CHK_TRUE_RET(load_item(stream, &out->normal_active));
../script/py_ui_style.c:2702:    CHK_TRUE_RET(load_item(stream, &out->hover_active));
../script/py_ui_style.c:2703:    CHK_TRUE_RET(load_item(stream, &out->pressed_active));
../script/py_ui_style.c:2705:    CHK_TRUE_RET(load_color(stream, &out->text_normal));
../script/py_ui_style.c:2706:    CHK_TRUE_RET(load_color(stream, &out->text_hover));
../script/py_ui_style.c:2707:    CHK_TRUE_RET(load_color(stream, &out->text_pressed));
../script/py_ui_style.c:2709:    CHK_TRUE_RET(load_color(stream, &out->text_normal_active));
../script/py_ui_style.c:2710:    CHK_TRUE_RET(load_color(stream, &out->text_hover_active));
../script/py_ui_style.c:2711:    CHK_TRUE_RET(load_color(stream, &out->text_pressed_active));
../script/py_ui_style.c:2713:    CHK_TRUE_RET(load_int(stream, (int*)&out->text_alignment));
../script/py_ui_style.c:2714:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:2715:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:2716:    CHK_TRUE_RET(load_vec2(stream, &out->image_padding));
../script/py_ui_style.c:2717:    CHK_TRUE_RET(load_vec2(stream, &out->touch_padding));
../script/py_ui_style.c:2724:    CHK_TRUE_RET(save_item(stream, &header->normal));
../script/py_ui_style.c:2725:    CHK_TRUE_RET(save_item(stream, &header->hover));
../script/py_ui_style.c:2726:    CHK_TRUE_RET(save_item(stream, &header->active));
../script/py_ui_style.c:2728:    CHK_TRUE_RET(save_button(stream, &header->close_button));
../script/py_ui_style.c:2729:    CHK_TRUE_RET(save_button(stream, &header->minimize_button));
../script/py_ui_style.c:2731:    CHK_TRUE_RET(save_int(stream, header->close_symbol));
../script/py_ui_style.c:2732:    CHK_TRUE_RET(save_int(stream, header->minimize_symbol));
../script/py_ui_style.c:2733:    CHK_TRUE_RET(save_int(stream, header->maximize_symbol));
../script/py_ui_style.c:2735:    CHK_TRUE_RET(save_color(stream, header->label_normal));
../script/py_ui_style.c:2736:    CHK_TRUE_RET(save_color(stream, header->label_hover));
../script/py_ui_style.c:2737:    CHK_TRUE_RET(save_color(stream, header->label_active));
../script/py_ui_style.c:2739:    CHK_TRUE_RET(save_int(stream, header->align));
../script/py_ui_style.c:2741:    CHK_TRUE_RET(save_vec2(stream, header->padding));
../script/py_ui_style.c:2742:    CHK_TRUE_RET(save_vec2(stream, header->label_padding));
../script/py_ui_style.c:2743:    CHK_TRUE_RET(save_vec2(stream, header->spacing));
../script/py_ui_style.c:2750:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2751:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2752:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:2754:    CHK_TRUE_RET(load_button(stream, &out->close_button));
../script/py_ui_style.c:2755:    CHK_TRUE_RET(load_button(stream, &out->minimize_button));
../script/py_ui_style.c:2757:    CHK_TRUE_RET(load_int(stream, (int*)&out->close_symbol));
../script/py_ui_style.c:2758:    CHK_TRUE_RET(load_int(stream, (int*)&out->minimize_symbol));
../script/py_ui_style.c:2759:    CHK_TRUE_RET(load_int(stream, (int*)&out->maximize_symbol));
../script/py_ui_style.c:2761:    CHK_TRUE_RET(load_color(stream, &out->label_normal));
../script/py_ui_style.c:2762:    CHK_TRUE_RET(load_color(stream, &out->label_hover));
../script/py_ui_style.c:2763:    CHK_TRUE_RET(load_color(stream, &out->label_active));
../script/py_ui_style.c:2765:    CHK_TRUE_RET(load_int(stream, (int*)&out->align));
../script/py_ui_style.c:2767:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:2768:    CHK_TRUE_RET(load_vec2(stream, &out->label_padding));
../script/py_ui_style.c:2769:    CHK_TRUE_RET(load_vec2(stream, &out->spacing));
../script/py_ui_style.c:2776:    CHK_TRUE_RET(save_item(stream, &combo->normal));
../script/py_ui_style.c:2777:    CHK_TRUE_RET(save_item(stream, &combo->hover));
../script/py_ui_style.c:2778:    CHK_TRUE_RET(save_item(stream, &combo->active));
../script/py_ui_style.c:2779:    CHK_TRUE_RET(save_color(stream, combo->border_color));
../script/py_ui_style.c:2781:    CHK_TRUE_RET(save_color(stream, combo->label_normal));
../script/py_ui_style.c:2782:    CHK_TRUE_RET(save_color(stream, combo->label_hover));
../script/py_ui_style.c:2783:    CHK_TRUE_RET(save_color(stream, combo->label_active));
../script/py_ui_style.c:2785:    CHK_TRUE_RET(save_color(stream, combo->symbol_normal));
../script/py_ui_style.c:2786:    CHK_TRUE_RET(save_color(stream, combo->symbol_hover));
../script/py_ui_style.c:2787:    CHK_TRUE_RET(save_color(stream, combo->symbol_active));
../script/py_ui_style.c:2789:    CHK_TRUE_RET(save_button(stream, &combo->button));
../script/py_ui_style.c:2790:    CHK_TRUE_RET(save_int(stream, combo->sym_normal));
../script/py_ui_style.c:2791:    CHK_TRUE_RET(save_int(stream, combo->sym_hover));
../script/py_ui_style.c:2792:    CHK_TRUE_RET(save_int(stream, combo->sym_active));
../script/py_ui_style.c:2794:    CHK_TRUE_RET(save_float(stream, combo->border));
../script/py_ui_style.c:2795:    CHK_TRUE_RET(save_float(stream, combo->rounding));
../script/py_ui_style.c:2796:    CHK_TRUE_RET(save_vec2(stream, combo->content_padding));
../script/py_ui_style.c:2797:    CHK_TRUE_RET(save_vec2(stream, combo->button_padding));
../script/py_ui_style.c:2798:    CHK_TRUE_RET(save_vec2(stream, combo->spacing));
../script/py_ui_style.c:2805:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2806:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2807:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:2808:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:2810:    CHK_TRUE_RET(load_color(stream, &out->label_normal));
../script/py_ui_style.c:2811:    CHK_TRUE_RET(load_color(stream, &out->label_hover));
../script/py_ui_style.c:2812:    CHK_TRUE_RET(load_color(stream, &out->label_active));
../script/py_ui_style.c:2814:    CHK_TRUE_RET(load_color(stream, &out->symbol_normal));
../script/py_ui_style.c:2815:    CHK_TRUE_RET(load_color(stream, &out->symbol_hover));
../script/py_ui_style.c:2816:    CHK_TRUE_RET(load_color(stream, &out->symbol_active));
../script/py_ui_style.c:2818:    CHK_TRUE_RET(load_button(stream, &out->button));
../script/py_ui_style.c:2819:    CHK_TRUE_RET(load_int(stream, (int*)&out->sym_normal));
../script/py_ui_style.c:2820:    CHK_TRUE_RET(load_int(stream, (int*)&out->sym_hover));
../script/py_ui_style.c:2821:    CHK_TRUE_RET(load_int(stream, (int*)&out->sym_active));
../script/py_ui_style.c:2823:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:2824:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:2825:    CHK_TRUE_RET(load_vec2(stream, &out->content_padding));
../script/py_ui_style.c:2826:    CHK_TRUE_RET(load_vec2(stream, &out->button_padding));
../script/py_ui_style.c:2827:    CHK_TRUE_RET(load_vec2(stream, &out->spacing));
../script/py_ui_style.c:2834:    CHK_TRUE_RET(save_item(stream, &toggle->normal));
../script/py_ui_style.c:2835:    CHK_TRUE_RET(save_item(stream, &toggle->hover));
../script/py_ui_style.c:2836:    CHK_TRUE_RET(save_item(stream, &toggle->active));
../script/py_ui_style.c:2837:    CHK_TRUE_RET(save_color(stream, toggle->border_color));
../script/py_ui_style.c:2839:    CHK_TRUE_RET(save_item(stream, &toggle->cursor_normal));
../script/py_ui_style.c:2840:    CHK_TRUE_RET(save_item(stream, &toggle->cursor_hover));
../script/py_ui_style.c:2842:    CHK_TRUE_RET(save_color(stream, toggle->text_normal));
../script/py_ui_style.c:2843:    CHK_TRUE_RET(save_color(stream, toggle->text_hover));
../script/py_ui_style.c:2844:    CHK_TRUE_RET(save_color(stream, toggle->text_active));
../script/py_ui_style.c:2845:    CHK_TRUE_RET(save_color(stream, toggle->text_background));
../script/py_ui_style.c:2846:    CHK_TRUE_RET(save_int(stream, toggle->text_alignment));
../script/py_ui_style.c:2848:    CHK_TRUE_RET(save_vec2(stream, toggle->padding));
../script/py_ui_style.c:2849:    CHK_TRUE_RET(save_vec2(stream, toggle->touch_padding));
../script/py_ui_style.c:2850:    CHK_TRUE_RET(save_float(stream, toggle->spacing));
../script/py_ui_style.c:2851:    CHK_TRUE_RET(save_float(stream, toggle->border));
../script/py_ui_style.c:2858:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2859:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2860:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:2861:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:2863:    CHK_TRUE_RET(load_item(stream, &out->cursor_normal));
../script/py_ui_style.c:2864:    CHK_TRUE_RET(load_item(stream, &out->cursor_hover));
../script/py_ui_style.c:2866:    CHK_TRUE_RET(load_color(stream, &out->text_normal));
../script/py_ui_style.c:2867:    CHK_TRUE_RET(load_color(stream, &out->text_hover));
../script/py_ui_style.c:2868:    CHK_TRUE_RET(load_color(stream, &out->text_active));
../script/py_ui_style.c:2869:    CHK_TRUE_RET(load_color(stream, &out->text_background));
../script/py_ui_style.c:2870:    CHK_TRUE_RET(load_int(stream, (int*)&out->text_alignment));
../script/py_ui_style.c:2872:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:2873:    CHK_TRUE_RET(load_vec2(stream, &out->touch_padding));
../script/py_ui_style.c:2874:    CHK_TRUE_RET(load_float(stream, &out->spacing));
../script/py_ui_style.c:2875:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:2882:    CHK_TRUE_RET(save_item(stream, &scroll->normal));
../script/py_ui_style.c:2883:    CHK_TRUE_RET(save_item(stream, &scroll->hover));
../script/py_ui_style.c:2884:    CHK_TRUE_RET(save_item(stream, &scroll->active));
../script/py_ui_style.c:2885:    CHK_TRUE_RET(save_color(stream, scroll->border_color));
../script/py_ui_style.c:2887:    CHK_TRUE_RET(save_item(stream, &scroll->cursor_normal));
../script/py_ui_style.c:2888:    CHK_TRUE_RET(save_item(stream, &scroll->cursor_hover));
../script/py_ui_style.c:2889:    CHK_TRUE_RET(save_item(stream, &scroll->cursor_active));
../script/py_ui_style.c:2890:    CHK_TRUE_RET(save_color(stream, scroll->cursor_border_color));
../script/py_ui_style.c:2892:    CHK_TRUE_RET(save_float(stream, scroll->border));
../script/py_ui_style.c:2893:    CHK_TRUE_RET(save_float(stream, scroll->rounding));
../script/py_ui_style.c:2894:    CHK_TRUE_RET(save_float(stream, scroll->border_cursor));
../script/py_ui_style.c:2895:    CHK_TRUE_RET(save_float(stream, scroll->rounding_cursor));
../script/py_ui_style.c:2896:    CHK_TRUE_RET(save_vec2(stream, scroll->padding));
../script/py_ui_style.c:2903:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2904:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2905:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:2906:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:2908:    CHK_TRUE_RET(load_item(stream, &out->cursor_normal));
../script/py_ui_style.c:2909:    CHK_TRUE_RET(load_item(stream, &out->cursor_hover));
../script/py_ui_style.c:2910:    CHK_TRUE_RET(load_item(stream, &out->cursor_active));
../script/py_ui_style.c:2911:    CHK_TRUE_RET(load_color(stream, &out->cursor_border_color));
../script/py_ui_style.c:2913:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:2914:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:2915:    CHK_TRUE_RET(load_float(stream, &out->border_cursor));
../script/py_ui_style.c:2916:    CHK_TRUE_RET(load_float(stream, &out->rounding_cursor));
../script/py_ui_style.c:2917:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:2924:    CHK_TRUE_RET(save_item(stream, &edit->normal));
../script/py_ui_style.c:2925:    CHK_TRUE_RET(save_item(stream, &edit->hover));
../script/py_ui_style.c:2926:    CHK_TRUE_RET(save_item(stream, &edit->active));
../script/py_ui_style.c:2927:    CHK_TRUE_RET(save_scrollbar(stream, &edit->scrollbar));
../script/py_ui_style.c:2929:    CHK_TRUE_RET(save_color(stream, edit->cursor_normal));
../script/py_ui_style.c:2930:    CHK_TRUE_RET(save_color(stream, edit->cursor_hover));
../script/py_ui_style.c:2931:    CHK_TRUE_RET(save_color(stream, edit->cursor_text_normal));
../script/py_ui_style.c:2932:    CHK_TRUE_RET(save_color(stream, edit->cursor_text_hover));
../script/py_ui_style.c:2934:    CHK_TRUE_RET(save_color(stream, edit->text_normal));
../script/py_ui_style.c:2935:    CHK_TRUE_RET(save_color(stream, edit->text_hover));
../script/py_ui_style.c:2936:    CHK_TRUE_RET(save_color(stream, edit->text_active));
../script/py_ui_style.c:2938:    CHK_TRUE_RET(save_color(stream, edit->selected_normal));
../script/py_ui_style.c:2939:    CHK_TRUE_RET(save_color(stream, edit->selected_hover));
../script/py_ui_style.c:2940:    CHK_TRUE_RET(save_color(stream, edit->selected_text_normal));
../script/py_ui_style.c:2941:    CHK_TRUE_RET(save_color(stream, edit->selected_text_hover));
../script/py_ui_style.c:2943:    CHK_TRUE_RET(save_float(stream, edit->border));
../script/py_ui_style.c:2944:    CHK_TRUE_RET(save_float(stream, edit->rounding));
../script/py_ui_style.c:2945:    CHK_TRUE_RET(save_float(stream, edit->cursor_size));
../script/py_ui_style.c:2946:    CHK_TRUE_RET(save_vec2(stream, edit->scrollbar_size));
../script/py_ui_style.c:2947:    CHK_TRUE_RET(save_vec2(stream, edit->padding));
../script/py_ui_style.c:2948:    CHK_TRUE_RET(save_float(stream, edit->row_padding));
../script/py_ui_style.c:2955:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:2956:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:2957:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:2958:    CHK_TRUE_RET(load_scrollbar(stream, &out->scrollbar));
../script/py_ui_style.c:2960:    CHK_TRUE_RET(load_color(stream, &out->cursor_normal));
../script/py_ui_style.c:2961:    CHK_TRUE_RET(load_color(stream, &out->cursor_hover));
../script/py_ui_style.c:2962:    CHK_TRUE_RET(load_color(stream, &out->cursor_text_normal));
../script/py_ui_style.c:2963:    CHK_TRUE_RET(load_color(stream, &out->cursor_text_hover));
../script/py_ui_style.c:2965:    CHK_TRUE_RET(load_color(stream, &out->text_normal));
../script/py_ui_style.c:2966:    CHK_TRUE_RET(load_color(stream, &out->text_hover));
../script/py_ui_style.c:2967:    CHK_TRUE_RET(load_color(stream, &out->text_active));
../script/py_ui_style.c:2969:    CHK_TRUE_RET(load_color(stream, &out->selected_normal));
../script/py_ui_style.c:2970:    CHK_TRUE_RET(load_color(stream, &out->selected_hover));
../script/py_ui_style.c:2971:    CHK_TRUE_RET(load_color(stream, &out->selected_text_normal));
../script/py_ui_style.c:2972:    CHK_TRUE_RET(load_color(stream, &out->selected_text_hover));
../script/py_ui_style.c:2974:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:2975:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:2976:    CHK_TRUE_RET(load_float(stream, &out->cursor_size));
../script/py_ui_style.c:2977:    CHK_TRUE_RET(load_vec2(stream, &out->scrollbar_size));
../script/py_ui_style.c:2978:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:2979:    CHK_TRUE_RET(load_float(stream, &out->row_padding));
../script/py_ui_style.c:2986:    CHK_TRUE_RET(save_item(stream, &property->normal));
../script/py_ui_style.c:2987:    CHK_TRUE_RET(save_item(stream, &property->hover));
../script/py_ui_style.c:2988:    CHK_TRUE_RET(save_item(stream, &property->active));
../script/py_ui_style.c:2989:    CHK_TRUE_RET(save_color(stream, property->border_color));
../script/py_ui_style.c:2991:    CHK_TRUE_RET(save_color(stream, property->label_normal));
../script/py_ui_style.c:2992:    CHK_TRUE_RET(save_color(stream, property->label_hover));
../script/py_ui_style.c:2993:    CHK_TRUE_RET(save_color(stream, property->label_active));
../script/py_ui_style.c:2995:    CHK_TRUE_RET(save_int(stream, property->sym_left));
../script/py_ui_style.c:2996:    CHK_TRUE_RET(save_int(stream, property->sym_right));
../script/py_ui_style.c:2998:    CHK_TRUE_RET(save_float(stream, property->border));
../script/py_ui_style.c:2999:    CHK_TRUE_RET(save_float(stream, property->rounding));
../script/py_ui_style.c:3000:    CHK_TRUE_RET(save_vec2(stream, property->padding));
../script/py_ui_style.c:3002:    CHK_TRUE_RET(save_edit(stream, &property->edit));
../script/py_ui_style.c:3003:    CHK_TRUE_RET(save_button(stream, &property->inc_button));
../script/py_ui_style.c:3004:    CHK_TRUE_RET(save_button(stream, &property->dec_button));
../script/py_ui_style.c:3011:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:3012:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:3013:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:3014:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:3016:    CHK_TRUE_RET(load_color(stream, &out->label_normal));
../script/py_ui_style.c:3017:    CHK_TRUE_RET(load_color(stream, &out->label_hover));
../script/py_ui_style.c:3018:    CHK_TRUE_RET(load_color(stream, &out->label_active));
../script/py_ui_style.c:3020:    CHK_TRUE_RET(load_int(stream, (int*)&out->sym_left));
../script/py_ui_style.c:3021:    CHK_TRUE_RET(load_int(stream, (int*)&out->sym_right));
../script/py_ui_style.c:3023:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:3024:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:3025:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:3027:    CHK_TRUE_RET(load_edit(stream, &out->edit));
../script/py_ui_style.c:3028:    CHK_TRUE_RET(load_button(stream, &out->inc_button));
../script/py_ui_style.c:3029:    CHK_TRUE_RET(load_button(stream, &out->dec_button));
../script/py_ui_style.c:3036:    CHK_TRUE_RET(save_item(stream, &slider->normal));
../script/py_ui_style.c:3037:    CHK_TRUE_RET(save_item(stream, &slider->hover));
../script/py_ui_style.c:3038:    CHK_TRUE_RET(save_item(stream, &slider->active));
../script/py_ui_style.c:3039:    CHK_TRUE_RET(save_color(stream, slider->border_color));
../script/py_ui_style.c:3041:    CHK_TRUE_RET(save_color(stream, slider->bar_normal));
../script/py_ui_style.c:3042:    CHK_TRUE_RET(save_color(stream, slider->bar_hover));
../script/py_ui_style.c:3043:    CHK_TRUE_RET(save_color(stream, slider->bar_active));
../script/py_ui_style.c:3044:    CHK_TRUE_RET(save_color(stream, slider->bar_filled));
../script/py_ui_style.c:3046:    CHK_TRUE_RET(save_item(stream, &slider->cursor_normal));
../script/py_ui_style.c:3047:    CHK_TRUE_RET(save_item(stream, &slider->cursor_hover));
../script/py_ui_style.c:3048:    CHK_TRUE_RET(save_item(stream, &slider->cursor_active));
../script/py_ui_style.c:3050:    CHK_TRUE_RET(save_float(stream, slider->border));
../script/py_ui_style.c:3051:    CHK_TRUE_RET(save_float(stream, slider->rounding));
../script/py_ui_style.c:3052:    CHK_TRUE_RET(save_float(stream, slider->bar_height));
../script/py_ui_style.c:3053:    CHK_TRUE_RET(save_vec2(stream, slider->padding));
../script/py_ui_style.c:3054:    CHK_TRUE_RET(save_vec2(stream, slider->spacing));
../script/py_ui_style.c:3055:    CHK_TRUE_RET(save_vec2(stream, slider->cursor_size));
../script/py_ui_style.c:3057:    CHK_TRUE_RET(save_int(stream, slider->show_buttons));
../script/py_ui_style.c:3058:    CHK_TRUE_RET(save_button(stream, &slider->inc_button));
../script/py_ui_style.c:3059:    CHK_TRUE_RET(save_button(stream, &slider->dec_button));
../script/py_ui_style.c:3060:    CHK_TRUE_RET(save_int(stream, slider->inc_symbol));
../script/py_ui_style.c:3061:    CHK_TRUE_RET(save_int(stream, slider->dec_symbol));
../script/py_ui_style.c:3068:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:3069:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:3070:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:3071:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:3073:    CHK_TRUE_RET(load_color(stream, &out->bar_normal));
../script/py_ui_style.c:3074:    CHK_TRUE_RET(load_color(stream, &out->bar_hover));
../script/py_ui_style.c:3075:    CHK_TRUE_RET(load_color(stream, &out->bar_active));
../script/py_ui_style.c:3076:    CHK_TRUE_RET(load_color(stream, &out->bar_filled));
../script/py_ui_style.c:3078:    CHK_TRUE_RET(load_item(stream, &out->cursor_normal));
../script/py_ui_style.c:3079:    CHK_TRUE_RET(load_item(stream, &out->cursor_hover));
../script/py_ui_style.c:3080:    CHK_TRUE_RET(load_item(stream, &out->cursor_active));
../script/py_ui_style.c:3082:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:3083:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:3084:    CHK_TRUE_RET(load_float(stream, &out->bar_height));
../script/py_ui_style.c:3085:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:3086:    CHK_TRUE_RET(load_vec2(stream, &out->spacing));
../script/py_ui_style.c:3087:    CHK_TRUE_RET(load_vec2(stream, &out->cursor_size));
../script/py_ui_style.c:3089:    CHK_TRUE_RET(load_int(stream, (int*)&out->show_buttons));
../script/py_ui_style.c:3090:    CHK_TRUE_RET(load_button(stream, &out->inc_button));
../script/py_ui_style.c:3091:    CHK_TRUE_RET(load_button(stream, &out->dec_button));
../script/py_ui_style.c:3092:    CHK_TRUE_RET(load_int(stream, (int*)&out->inc_symbol));
../script/py_ui_style.c:3093:    CHK_TRUE_RET(load_int(stream, (int*)&out->dec_symbol));
../script/py_ui_style.c:3100:    CHK_TRUE_RET(save_item(stream, &progress->normal));
../script/py_ui_style.c:3101:    CHK_TRUE_RET(save_item(stream, &progress->hover));
../script/py_ui_style.c:3102:    CHK_TRUE_RET(save_item(stream, &progress->active));
../script/py_ui_style.c:3103:    CHK_TRUE_RET(save_color(stream, progress->border_color));
../script/py_ui_style.c:3105:    CHK_TRUE_RET(save_item(stream, &progress->cursor_normal));
../script/py_ui_style.c:3106:    CHK_TRUE_RET(save_item(stream, &progress->cursor_hover));
../script/py_ui_style.c:3107:    CHK_TRUE_RET(save_item(stream, &progress->cursor_active));
../script/py_ui_style.c:3108:    CHK_TRUE_RET(save_color(stream, progress->cursor_border_color));
../script/py_ui_style.c:3110:    CHK_TRUE_RET(save_float(stream, progress->border));
../script/py_ui_style.c:3111:    CHK_TRUE_RET(save_float(stream, progress->rounding));
../script/py_ui_style.c:3112:    CHK_TRUE_RET(save_float(stream, progress->cursor_border));
../script/py_ui_style.c:3113:    CHK_TRUE_RET(save_float(stream, progress->cursor_rounding));
../script/py_ui_style.c:3114:    CHK_TRUE_RET(save_vec2(stream, progress->padding));
../script/py_ui_style.c:3121:    CHK_TRUE_RET(load_item(stream, &out->normal));
../script/py_ui_style.c:3122:    CHK_TRUE_RET(load_item(stream, &out->hover));
../script/py_ui_style.c:3123:    CHK_TRUE_RET(load_item(stream, &out->active));
../script/py_ui_style.c:3124:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:3126:    CHK_TRUE_RET(load_item(stream, &out->cursor_normal));
../script/py_ui_style.c:3127:    CHK_TRUE_RET(load_item(stream, &out->cursor_hover));
../script/py_ui_style.c:3128:    CHK_TRUE_RET(load_item(stream, &out->cursor_active));
../script/py_ui_style.c:3129:    CHK_TRUE_RET(load_color(stream, &out->cursor_border_color));
../script/py_ui_style.c:3131:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:3132:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:3133:    CHK_TRUE_RET(load_float(stream, &out->cursor_border));
../script/py_ui_style.c:3134:    CHK_TRUE_RET(load_float(stream, &out->cursor_rounding));
../script/py_ui_style.c:3135:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:3147:    CHK_TRUE(save_int(stream, self->type), fail_pickle);
../script/py_ui_style.c:3148:    CHK_TRUE(save_button(stream, self->style), fail_pickle);
../script/py_ui_style.c:3180:    CHK_TRUE(load_int(stream, (int*)&((PyUIButtonStyleObject*)styleobj)->type), fail_unpickle);
../script/py_ui_style.c:3183:    switch(((PyUIButtonStyleObject*)styleobj)->type) {
../script/py_ui_style.c:3185:            ((PyUIButtonStyleObject*)styleobj)->style = &ctx->style.button;
../script/py_ui_style.c:3188:            ((PyUIButtonStyleObject*)styleobj)->style = &ctx->style.contextual_button;
../script/py_ui_style.c:3191:            ((PyUIButtonStyleObject*)styleobj)->style = &ctx->style.menu_button;
../script/py_ui_style.c:3197:    CHK_TRUE(load_button(stream, ((PyUIButtonStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:3214:    PyUIHeaderStyleObject *self = (PyUIHeaderStyleObject*)type->tp_alloc(type, 0);
../script/py_ui_style.c:3221:    self->style = ctx.style.window.header;
../script/py_ui_style.c:3223:    self->close_button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:3224:    if(!self->close_button) {
../script/py_ui_style.c:3227:    self->close_button->style = &self->style.close_button;
../script/py_ui_style.c:3229:    self->minimize_button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:3230:    if(!self->minimize_button) {
../script/py_ui_style.c:3233:    self->minimize_button->style = &self->style.minimize_button;
../script/py_ui_style.c:3238:    Py_DECREF(self->close_button);
../script/py_ui_style.c:3246:    Py_DECREF(self->close_button);
../script/py_ui_style.c:3247:    Py_DECREF(self->minimize_button);
../script/py_ui_style.c:3248:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_ui_style.c:3253:    Py_INCREF(self->close_button);
../script/py_ui_style.c:3254:    return (PyObject*)self->close_button;
../script/py_ui_style.c:3259:    Py_INCREF(self->minimize_button);
../script/py_ui_style.c:3260:    return (PyObject*)self->minimize_button;
../script/py_ui_style.c:3265:    return style_get_item(&self->style.normal);
../script/py_ui_style.c:3270:    return style_set_item(value, &self->style.normal);
../script/py_ui_style.c:3275:    return style_get_item(&self->style.hover);
../script/py_ui_style.c:3280:    return style_set_item(value, &self->style.hover);
../script/py_ui_style.c:3285:    return style_get_item(&self->style.active);
../script/py_ui_style.c:3290:    return style_set_item(value, &self->style.active);
../script/py_ui_style.c:3296:        self->style.label_normal.r,
../script/py_ui_style.c:3297:        self->style.label_normal.g,
../script/py_ui_style.c:3298:        self->style.label_normal.b,
../script/py_ui_style.c:3299:        self->style.label_normal.a);
../script/py_ui_style.c:3308:        return -1; 
../script/py_ui_style.c:3311:    self->style.label_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3318:        self->style.label_hover.r,
../script/py_ui_style.c:3319:        self->style.label_hover.g,
../script/py_ui_style.c:3320:        self->style.label_hover.b,
../script/py_ui_style.c:3321:        self->style.label_hover.a);
../script/py_ui_style.c:3330:        return -1; 
../script/py_ui_style.c:3333:    self->style.label_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3340:        self->style.label_active.r,
../script/py_ui_style.c:3341:        self->style.label_active.g,
../script/py_ui_style.c:3342:        self->style.label_active.b,
../script/py_ui_style.c:3343:        self->style.label_active.a);
../script/py_ui_style.c:3352:        return -1; 
../script/py_ui_style.c:3355:    self->style.label_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3365:    CHK_TRUE(save_header(stream, &self->style), fail_pickle);
../script/py_ui_style.c:3397:    CHK_TRUE(load_header(stream, &((PyUIHeaderStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:3414:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:3419:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:3424:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:3429:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:3434:    return style_get_item(&self->style->pressed);
../script/py_ui_style.c:3439:    return style_set_item(value, &self->style->pressed);
../script/py_ui_style.c:3444:    return style_get_item(&self->style->normal_active);
../script/py_ui_style.c:3449:    return style_set_item(value, &self->style->normal_active);
../script/py_ui_style.c:3454:    return style_get_item(&self->style->hover_active);
../script/py_ui_style.c:3459:    return style_set_item(value, &self->style->hover_active);
../script/py_ui_style.c:3464:    return style_get_item(&self->style->pressed_active);
../script/py_ui_style.c:3469:    return style_set_item(value, &self->style->pressed_active);
../script/py_ui_style.c:3475:        self->style->text_normal.r,
../script/py_ui_style.c:3476:        self->style->text_normal.g,
../script/py_ui_style.c:3477:        self->style->text_normal.b,
../script/py_ui_style.c:3478:        self->style->text_normal.a);
../script/py_ui_style.c:3487:        return -1; 
../script/py_ui_style.c:3490:    self->style->text_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3497:        self->style->text_hover.r,
../script/py_ui_style.c:3498:        self->style->text_hover.g,
../script/py_ui_style.c:3499:        self->style->text_hover.b,
../script/py_ui_style.c:3500:        self->style->text_hover.a);
../script/py_ui_style.c:3509:        return -1; 
../script/py_ui_style.c:3512:    self->style->text_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3519:        self->style->text_pressed.r,
../script/py_ui_style.c:3520:        self->style->text_pressed.g,
../script/py_ui_style.c:3521:        self->style->text_pressed.b,
../script/py_ui_style.c:3522:        self->style->text_pressed.a);
../script/py_ui_style.c:3531:        return -1; 
../script/py_ui_style.c:3534:    self->style->text_pressed = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3541:        self->style->text_normal_active.r,
../script/py_ui_style.c:3542:        self->style->text_normal_active.g,
../script/py_ui_style.c:3543:        self->style->text_normal_active.b,
../script/py_ui_style.c:3544:        self->style->text_normal_active.a);
../script/py_ui_style.c:3553:        return -1; 
../script/py_ui_style.c:3556:    self->style->text_normal_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3563:        self->style->text_hover_active.r,
../script/py_ui_style.c:3564:        self->style->text_hover_active.g,
../script/py_ui_style.c:3565:        self->style->text_hover_active.b,
../script/py_ui_style.c:3566:        self->style->text_hover_active.a);
../script/py_ui_style.c:3575:        return -1; 
../script/py_ui_style.c:3578:    self->style->text_hover_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3585:        self->style->text_pressed_active.r,
../script/py_ui_style.c:3586:        self->style->text_pressed_active.g,
../script/py_ui_style.c:3587:        self->style->text_pressed_active.b,
../script/py_ui_style.c:3588:        self->style->text_pressed_active.a);
../script/py_ui_style.c:3597:        return -1; 
../script/py_ui_style.c:3600:    self->style->text_pressed_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3606:    return PyInt_FromLong(self->style->text_alignment);
../script/py_ui_style.c:3613:        return -1; 
../script/py_ui_style.c:3616:    self->style->text_alignment = PyInt_AsLong(value);
../script/py_ui_style.c:3622:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:3629:        return -1; 
../script/py_ui_style.c:3632:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:3639:        self->style->padding.x,
../script/py_ui_style.c:3640:        self->style->padding.y);
../script/py_ui_style.c:3649:        return -1; 
../script/py_ui_style.c:3652:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:3659:        self->style->touch_padding.x,
../script/py_ui_style.c:3660:        self->style->touch_padding.y);
../script/py_ui_style.c:3669:        return -1; 
../script/py_ui_style.c:3672:    self->style->touch_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:3679:        self->style->image_padding.x,
../script/py_ui_style.c:3680:        self->style->image_padding.y);
../script/py_ui_style.c:3689:        return -1; 
../script/py_ui_style.c:3692:    self->style->image_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:3702:    CHK_TRUE(save_selectable(stream, self->style), fail_pickle);
../script/py_ui_style.c:3735:    ((PyUISelectableStyleObject*)styleobj)->style = &ctx->style.selectable;
../script/py_ui_style.c:3737:    CHK_TRUE(load_selectable(stream, ((PyUISelectableStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:3754:    PyUIComboStyleObject *self = (PyUIComboStyleObject*)type->tp_alloc(type, 0);
../script/py_ui_style.c:3758:    self->button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:3759:    if(!self->button) {
../script/py_ui_style.c:3764:    self->style = &ctx->style.combo;
../script/py_ui_style.c:3765:    self->button->style = &ctx->style.combo.button;
../script/py_ui_style.c:3776:    Py_DECREF(self->button);
../script/py_ui_style.c:3777:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_ui_style.c:3782:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:3787:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:3792:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:3797:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:3802:    return style_get_item(&self->style->active);
../script/py_ui_style.c:3807:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:3813:        self->style->border_color.r,
../script/py_ui_style.c:3814:        self->style->border_color.g,
../script/py_ui_style.c:3815:        self->style->border_color.b,
../script/py_ui_style.c:3816:        self->style->border_color.a);
../script/py_ui_style.c:3825:        return -1; 
../script/py_ui_style.c:3828:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3835:        self->style->label_normal.r,
../script/py_ui_style.c:3836:        self->style->label_normal.g,
../script/py_ui_style.c:3837:        self->style->label_normal.b,
../script/py_ui_style.c:3838:        self->style->label_normal.a);
../script/py_ui_style.c:3847:        return -1; 
../script/py_ui_style.c:3850:    self->style->label_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3857:        self->style->label_hover.r,
../script/py_ui_style.c:3858:        self->style->label_hover.g,
../script/py_ui_style.c:3859:        self->style->label_hover.b,
../script/py_ui_style.c:3860:        self->style->label_hover.a);
../script/py_ui_style.c:3869:        return -1; 
../script/py_ui_style.c:3872:    self->style->label_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3879:        self->style->label_active.r,
../script/py_ui_style.c:3880:        self->style->label_active.g,
../script/py_ui_style.c:3881:        self->style->label_active.b,
../script/py_ui_style.c:3882:        self->style->label_active.a);
../script/py_ui_style.c:3891:        return -1; 
../script/py_ui_style.c:3894:    self->style->label_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3901:        self->style->symbol_normal.r,
../script/py_ui_style.c:3902:        self->style->symbol_normal.g,
../script/py_ui_style.c:3903:        self->style->symbol_normal.b,
../script/py_ui_style.c:3904:        self->style->symbol_normal.a);
../script/py_ui_style.c:3913:        return -1; 
../script/py_ui_style.c:3916:    self->style->symbol_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3923:        self->style->symbol_hover.r,
../script/py_ui_style.c:3924:        self->style->symbol_hover.g,
../script/py_ui_style.c:3925:        self->style->symbol_hover.b,
../script/py_ui_style.c:3926:        self->style->symbol_hover.a);
../script/py_ui_style.c:3935:        return -1; 
../script/py_ui_style.c:3938:    self->style->symbol_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3945:        self->style->symbol_active.r,
../script/py_ui_style.c:3946:        self->style->symbol_active.g,
../script/py_ui_style.c:3947:        self->style->symbol_active.b,
../script/py_ui_style.c:3948:        self->style->symbol_active.a);
../script/py_ui_style.c:3957:        return -1; 
../script/py_ui_style.c:3960:    self->style->symbol_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:3966:    Py_INCREF(self->button);
../script/py_ui_style.c:3967:    return (PyObject*)self->button;
../script/py_ui_style.c:3972:    return PyInt_FromLong(self->style->sym_normal);
../script/py_ui_style.c:3979:        return -1; 
../script/py_ui_style.c:3982:    self->style->sym_normal = PyInt_AsLong(value);
../script/py_ui_style.c:3988:    return PyInt_FromLong(self->style->sym_hover);
../script/py_ui_style.c:3995:        return -1; 
../script/py_ui_style.c:3998:    self->style->sym_hover = PyInt_AsLong(value);
../script/py_ui_style.c:4004:    return PyInt_FromLong(self->style->sym_active);
../script/py_ui_style.c:4011:        return -1; 
../script/py_ui_style.c:4014:    self->style->sym_active = PyInt_AsLong(value);
../script/py_ui_style.c:4020:    return PyFloat_FromDouble(self->style->border);
../script/py_ui_style.c:4027:        return -1; 
../script/py_ui_style.c:4030:    self->style->border = PyInt_AsLong(value);
../script/py_ui_style.c:4036:    return PyFloat_FromDouble(self->style->rounding);
../script/py_ui_style.c:4043:        return -1; 
../script/py_ui_style.c:4046:    self->style->rounding = PyInt_AsLong(value);
../script/py_ui_style.c:4053:        self->style->content_padding.x,
../script/py_ui_style.c:4054:        self->style->content_padding.y);
../script/py_ui_style.c:4063:        return -1; 
../script/py_ui_style.c:4066:    self->style->content_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:4073:        self->style->button_padding.x,
../script/py_ui_style.c:4074:        self->style->button_padding.y);
../script/py_ui_style.c:4083:        return -1; 
../script/py_ui_style.c:4086:    self->style->button_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:4093:        self->style->spacing.x,
../script/py_ui_style.c:4094:        self->style->spacing.y);
../script/py_ui_style.c:4103:        return -1; 
../script/py_ui_style.c:4106:    self->style->spacing = (struct nk_vec2){x, y};
../script/py_ui_style.c:4116:    CHK_TRUE(save_combo(stream, self->style), fail_pickle);
../script/py_ui_style.c:4149:    CHK_TRUE(load_combo(stream, ((PyUIComboStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:4166:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:4171:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:4176:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:4181:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:4186:    return style_get_item(&self->style->active);
../script/py_ui_style.c:4191:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:4197:        self->style->border_color.r,
../script/py_ui_style.c:4198:        self->style->border_color.g,
../script/py_ui_style.c:4199:        self->style->border_color.b,
../script/py_ui_style.c:4200:        self->style->border_color.a);
../script/py_ui_style.c:4209:        return -1; 
../script/py_ui_style.c:4212:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4218:    return style_get_item(&self->style->cursor_normal);
../script/py_ui_style.c:4223:    return style_set_item(value, &self->style->cursor_normal);
../script/py_ui_style.c:4228:    return style_get_item(&self->style->cursor_hover);
../script/py_ui_style.c:4233:    return style_set_item(value, &self->style->cursor_hover);
../script/py_ui_style.c:4239:        self->style->text_normal.r,
../script/py_ui_style.c:4240:        self->style->text_normal.g,
../script/py_ui_style.c:4241:        self->style->text_normal.b,
../script/py_ui_style.c:4242:        self->style->text_normal.a);
../script/py_ui_style.c:4251:        return -1; 
../script/py_ui_style.c:4254:    self->style->text_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4261:        self->style->text_hover.r,
../script/py_ui_style.c:4262:        self->style->text_hover.g,
../script/py_ui_style.c:4263:        self->style->text_hover.b,
../script/py_ui_style.c:4264:        self->style->text_hover.a);
../script/py_ui_style.c:4273:        return -1; 
../script/py_ui_style.c:4276:    self->style->text_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4283:        self->style->text_active.r,
../script/py_ui_style.c:4284:        self->style->text_active.g,
../script/py_ui_style.c:4285:        self->style->text_active.b,
../script/py_ui_style.c:4286:        self->style->text_active.a);
../script/py_ui_style.c:4295:        return -1; 
../script/py_ui_style.c:4298:    self->style->text_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4305:        self->style->text_background.r,
../script/py_ui_style.c:4306:        self->style->text_background.g,
../script/py_ui_style.c:4307:        self->style->text_background.b,
../script/py_ui_style.c:4308:        self->style->text_background.a);
../script/py_ui_style.c:4317:        return -1; 
../script/py_ui_style.c:4320:    self->style->text_background = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4326:    return Py_BuildValue("I", self->style->text_alignment);
../script/py_ui_style.c:4333:        return -1; 
../script/py_ui_style.c:4336:    self->style->text_alignment = PyInt_AsLong(value);
../script/py_ui_style.c:4343:        self->style->padding.x,
../script/py_ui_style.c:4344:        self->style->padding.y);
../script/py_ui_style.c:4353:        return -1; 
../script/py_ui_style.c:4356:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:4363:        self->style->touch_padding.x,
../script/py_ui_style.c:4364:        self->style->touch_padding.y);
../script/py_ui_style.c:4373:        return -1; 
../script/py_ui_style.c:4376:    self->style->touch_padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:4382:    return Py_BuildValue("f", self->style->spacing);
../script/py_ui_style.c:4389:        return -1; 
../script/py_ui_style.c:4392:    self->style->spacing = PyFloat_AsDouble(value);
../script/py_ui_style.c:4398:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:4405:        return -1; 
../script/py_ui_style.c:4408:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:4418:    CHK_TRUE(save_int(stream, self->type), fail_pickle);
../script/py_ui_style.c:4419:    CHK_TRUE(save_toggle(stream, self->style), fail_pickle);
../script/py_ui_style.c:4451:    CHK_TRUE(load_int(stream, (int*)&((PyUIToggleStyleObject*)styleobj)->type), fail_unpickle);
../script/py_ui_style.c:4454:    switch(((PyUIToggleStyleObject*)styleobj)->type) {
../script/py_ui_style.c:4456:            ((PyUIToggleStyleObject*)styleobj)->style = &ctx->style.option;
../script/py_ui_style.c:4459:            ((PyUIToggleStyleObject*)styleobj)->style = &ctx->style.checkbox;
../script/py_ui_style.c:4465:    CHK_TRUE(load_toggle(stream, ((PyUIToggleStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:4482:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:4487:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:4492:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:4497:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:4502:    return style_get_item(&self->style->active);
../script/py_ui_style.c:4507:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:4513:        self->style->border_color.r,
../script/py_ui_style.c:4514:        self->style->border_color.g,
../script/py_ui_style.c:4515:        self->style->border_color.b,
../script/py_ui_style.c:4516:        self->style->border_color.a);
../script/py_ui_style.c:4525:        return -1; 
../script/py_ui_style.c:4528:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4534:    return style_get_item(&self->style->cursor_normal);
../script/py_ui_style.c:4539:    return style_set_item(value, &self->style->cursor_normal);
../script/py_ui_style.c:4544:    return style_get_item(&self->style->cursor_hover);
../script/py_ui_style.c:4549:    return style_set_item(value, &self->style->cursor_hover);
../script/py_ui_style.c:4554:    return style_get_item(&self->style->cursor_active);
../script/py_ui_style.c:4559:    return style_set_item(value, &self->style->cursor_active);
../script/py_ui_style.c:4565:        self->style->cursor_border_color.r,
../script/py_ui_style.c:4566:        self->style->cursor_border_color.g,
../script/py_ui_style.c:4567:        self->style->cursor_border_color.b,
../script/py_ui_style.c:4568:        self->style->cursor_border_color.a);
../script/py_ui_style.c:4577:        return -1; 
../script/py_ui_style.c:4580:    self->style->cursor_border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4587:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:4594:        return -1; 
../script/py_ui_style.c:4597:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:4603:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:4610:        return -1; 
../script/py_ui_style.c:4613:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:4619:    return Py_BuildValue("f", self->style->border_cursor);
../script/py_ui_style.c:4626:        return -1; 
../script/py_ui_style.c:4629:    self->style->border_cursor = PyFloat_AsDouble(value);
../script/py_ui_style.c:4635:    return Py_BuildValue("f", self->style->rounding_cursor);
../script/py_ui_style.c:4642:        return -1; 
../script/py_ui_style.c:4645:    self->style->rounding_cursor = PyFloat_AsDouble(value);
../script/py_ui_style.c:4652:        self->style->padding.x,
../script/py_ui_style.c:4653:        self->style->padding.y);
../script/py_ui_style.c:4662:        return -1; 
../script/py_ui_style.c:4665:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:4675:    CHK_TRUE(save_int(stream, self->type), fail_pickle);
../script/py_ui_style.c:4676:    CHK_TRUE(save_scrollbar(stream, self->style), fail_pickle);
../script/py_ui_style.c:4708:    CHK_TRUE(load_int(stream, (int*)&((PyUIScrollbarStyleObject*)styleobj)->type), fail_unpickle);
../script/py_ui_style.c:4711:    switch(((PyUIScrollbarStyleObject*)styleobj)->type) {
../script/py_ui_style.c:4713:            ((PyUIScrollbarStyleObject*)styleobj)->style = &ctx->style.scrollh;
../script/py_ui_style.c:4716:            ((PyUIScrollbarStyleObject*)styleobj)->style = &ctx->style.scrollv;
../script/py_ui_style.c:4719:            ((PyUIScrollbarStyleObject*)styleobj)->style = &ctx->style.edit.scrollbar;
../script/py_ui_style.c:4722:            ((PyUIScrollbarStyleObject*)styleobj)->style = &ctx->style.property.edit.scrollbar;
../script/py_ui_style.c:4728:    CHK_TRUE(load_scrollbar(stream, ((PyUIScrollbarStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:4752:    PyUIEditStyleObject *self = (PyUIEditStyleObject*)type->tp_alloc(type, 0);
../script/py_ui_style.c:4756:    self->scrollbar = PyObject_New(PyUIScrollbarStyleObject, &PyUIScrollbarStyle_type);
../script/py_ui_style.c:4757:    if(!self->scrollbar) {
../script/py_ui_style.c:4762:    self->type = kind;
../script/py_ui_style.c:4764:    switch(self->type) {
../script/py_ui_style.c:4766:        self->style = &ctx->style.edit;
../script/py_ui_style.c:4767:        self->scrollbar->style = &ctx->style.edit.scrollbar;
../script/py_ui_style.c:4768:        self->scrollbar->type = SCROLLBAR_EDIT;
../script/py_ui_style.c:4771:        self->style = &ctx->style.property.edit;
../script/py_ui_style.c:4772:        self->scrollbar->style = &ctx->style.property.edit.scrollbar;
../script/py_ui_style.c:4773:        self->scrollbar->type = SCROLLBAR_PROPERTY;
../script/py_ui_style.c:4787:    Py_DECREF(self->scrollbar);
../script/py_ui_style.c:4788:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_ui_style.c:4793:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:4798:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:4803:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:4808:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:4813:    return style_get_item(&self->style->active);
../script/py_ui_style.c:4818:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:4824:        self->style->border_color.r,
../script/py_ui_style.c:4825:        self->style->border_color.g,
../script/py_ui_style.c:4826:        self->style->border_color.b,
../script/py_ui_style.c:4827:        self->style->border_color.a);
../script/py_ui_style.c:4836:        return -1; 
../script/py_ui_style.c:4839:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4845:    Py_INCREF(self->scrollbar);
../script/py_ui_style.c:4846:    return (PyObject*)self->scrollbar;
../script/py_ui_style.c:4852:        self->style->cursor_normal.r,
../script/py_ui_style.c:4853:        self->style->cursor_normal.g,
../script/py_ui_style.c:4854:        self->style->cursor_normal.b,
../script/py_ui_style.c:4855:        self->style->cursor_normal.a);
../script/py_ui_style.c:4864:        return -1; 
../script/py_ui_style.c:4867:    self->style->cursor_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4874:        self->style->cursor_hover.r,
../script/py_ui_style.c:4875:        self->style->cursor_hover.g,
../script/py_ui_style.c:4876:        self->style->cursor_hover.b,
../script/py_ui_style.c:4877:        self->style->cursor_hover.a);
../script/py_ui_style.c:4886:        return -1; 
../script/py_ui_style.c:4889:    self->style->cursor_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4896:        self->style->cursor_text_normal.r,
../script/py_ui_style.c:4897:        self->style->cursor_text_normal.g,
../script/py_ui_style.c:4898:        self->style->cursor_text_normal.b,
../script/py_ui_style.c:4899:        self->style->cursor_text_normal.a);
../script/py_ui_style.c:4908:        return -1; 
../script/py_ui_style.c:4911:    self->style->cursor_text_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4918:        self->style->cursor_text_hover.r,
../script/py_ui_style.c:4919:        self->style->cursor_text_hover.g,
../script/py_ui_style.c:4920:        self->style->cursor_text_hover.b,
../script/py_ui_style.c:4921:        self->style->cursor_text_hover.a);
../script/py_ui_style.c:4930:        return -1; 
../script/py_ui_style.c:4933:    self->style->cursor_text_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4940:        self->style->text_normal.r,
../script/py_ui_style.c:4941:        self->style->text_normal.g,
../script/py_ui_style.c:4942:        self->style->text_normal.b,
../script/py_ui_style.c:4943:        self->style->text_normal.a);
../script/py_ui_style.c:4952:        return -1; 
../script/py_ui_style.c:4955:    self->style->text_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4962:        self->style->text_hover.r,
../script/py_ui_style.c:4963:        self->style->text_hover.g,
../script/py_ui_style.c:4964:        self->style->text_hover.b,
../script/py_ui_style.c:4965:        self->style->text_hover.a);
../script/py_ui_style.c:4974:        return -1; 
../script/py_ui_style.c:4977:    self->style->text_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:4984:        self->style->text_active.r,
../script/py_ui_style.c:4985:        self->style->text_active.g,
../script/py_ui_style.c:4986:        self->style->text_active.b,
../script/py_ui_style.c:4987:        self->style->text_active.a);
../script/py_ui_style.c:4996:        return -1; 
../script/py_ui_style.c:4999:    self->style->text_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5006:        self->style->selected_normal.r,
../script/py_ui_style.c:5007:        self->style->selected_normal.g,
../script/py_ui_style.c:5008:        self->style->selected_normal.b,
../script/py_ui_style.c:5009:        self->style->selected_normal.a);
../script/py_ui_style.c:5018:        return -1; 
../script/py_ui_style.c:5021:    self->style->selected_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5028:        self->style->selected_hover.r,
../script/py_ui_style.c:5029:        self->style->selected_hover.g,
../script/py_ui_style.c:5030:        self->style->selected_hover.b,
../script/py_ui_style.c:5031:        self->style->selected_hover.a);
../script/py_ui_style.c:5040:        return -1; 
../script/py_ui_style.c:5043:    self->style->selected_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5050:        self->style->selected_text_normal.r,
../script/py_ui_style.c:5051:        self->style->selected_text_normal.g,
../script/py_ui_style.c:5052:        self->style->selected_text_normal.b,
../script/py_ui_style.c:5053:        self->style->selected_text_normal.a);
../script/py_ui_style.c:5062:        return -1; 
../script/py_ui_style.c:5065:    self->style->selected_text_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5072:        self->style->selected_text_hover.r,
../script/py_ui_style.c:5073:        self->style->selected_text_hover.g,
../script/py_ui_style.c:5074:        self->style->selected_text_hover.b,
../script/py_ui_style.c:5075:        self->style->selected_text_hover.a);
../script/py_ui_style.c:5084:        return -1; 
../script/py_ui_style.c:5087:    self->style->selected_text_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5093:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:5100:        return -1; 
../script/py_ui_style.c:5103:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:5109:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:5116:        return -1; 
../script/py_ui_style.c:5119:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:5125:    return Py_BuildValue("f", self->style->cursor_size);
../script/py_ui_style.c:5132:        return -1; 
../script/py_ui_style.c:5135:    self->style->cursor_size = PyFloat_AsDouble(value);
../script/py_ui_style.c:5142:        self->style->scrollbar_size.x,
../script/py_ui_style.c:5143:        self->style->scrollbar_size.y);
../script/py_ui_style.c:5152:        return -1; 
../script/py_ui_style.c:5155:    self->style->scrollbar_size = (struct nk_vec2){x, y};
../script/py_ui_style.c:5162:        self->style->padding.x,
../script/py_ui_style.c:5163:        self->style->padding.y);
../script/py_ui_style.c:5172:        return -1; 
../script/py_ui_style.c:5175:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:5181:    return Py_BuildValue("f", self->style->row_padding);
../script/py_ui_style.c:5188:        return -1; 
../script/py_ui_style.c:5191:    self->style->row_padding = PyFloat_AsDouble(value);
../script/py_ui_style.c:5201:    CHK_TRUE(save_int(stream, self->type), fail_pickle);
../script/py_ui_style.c:5202:    CHK_TRUE(save_edit(stream, self->style), fail_pickle);
../script/py_ui_style.c:5238:    CHK_TRUE(load_edit(stream, ((PyUIEditStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:5255:    PyUIPropertyStyleObject *self = (PyUIPropertyStyleObject*)type->tp_alloc(type, 0);
../script/py_ui_style.c:5259:    self->edit = (PyUIEditStyleObject*)PyObject_CallFunction(
../script/py_ui_style.c:5263:    if(!self->edit)
../script/py_ui_style.c:5267:    self->style = &ctx->style.property;
../script/py_ui_style.c:5269:    self->inc_button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:5270:    if(!self->inc_button)
../script/py_ui_style.c:5272:    self->inc_button->style = &ctx->style.property.inc_button;
../script/py_ui_style.c:5274:    self->dec_button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:5275:    if(!self->dec_button)
../script/py_ui_style.c:5277:    self->dec_button->style = &ctx->style.property.dec_button;
../script/py_ui_style.c:5282:    Py_DECREF(self->inc_button);
../script/py_ui_style.c:5284:    Py_DECREF(self->edit);
../script/py_ui_style.c:5292:    Py_DECREF(self->dec_button);
../script/py_ui_style.c:5293:    Py_DECREF(self->inc_button);
../script/py_ui_style.c:5294:    Py_DECREF(self->edit);
../script/py_ui_style.c:5295:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_ui_style.c:5300:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:5305:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:5310:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:5315:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:5320:    return style_get_item(&self->style->active);
../script/py_ui_style.c:5325:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:5331:        self->style->border_color.r,
../script/py_ui_style.c:5332:        self->style->border_color.g,
../script/py_ui_style.c:5333:        self->style->border_color.b,
../script/py_ui_style.c:5334:        self->style->border_color.a);
../script/py_ui_style.c:5343:        return -1; 
../script/py_ui_style.c:5346:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5353:        self->style->label_normal.r,
../script/py_ui_style.c:5354:        self->style->label_normal.g,
../script/py_ui_style.c:5355:        self->style->label_normal.b,
../script/py_ui_style.c:5356:        self->style->label_normal.a);
../script/py_ui_style.c:5365:        return -1; 
../script/py_ui_style.c:5368:    self->style->label_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5375:        self->style->label_hover.r,
../script/py_ui_style.c:5376:        self->style->label_hover.g,
../script/py_ui_style.c:5377:        self->style->label_hover.b,
../script/py_ui_style.c:5378:        self->style->label_hover.a);
../script/py_ui_style.c:5387:        return -1; 
../script/py_ui_style.c:5390:    self->style->label_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5397:        self->style->label_active.r,
../script/py_ui_style.c:5398:        self->style->label_active.g,
../script/py_ui_style.c:5399:        self->style->label_active.b,
../script/py_ui_style.c:5400:        self->style->label_active.a);
../script/py_ui_style.c:5409:        return -1; 
../script/py_ui_style.c:5412:    self->style->label_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5418:    return Py_BuildValue("i", self->style->sym_left);
../script/py_ui_style.c:5425:        return -1; 
../script/py_ui_style.c:5428:    self->style->sym_left = PyInt_AS_LONG(value);
../script/py_ui_style.c:5434:    return Py_BuildValue("i", self->style->sym_right);
../script/py_ui_style.c:5441:        return -1; 
../script/py_ui_style.c:5444:    self->style->sym_right = PyInt_AS_LONG(value);
../script/py_ui_style.c:5450:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:5457:        return -1; 
../script/py_ui_style.c:5460:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:5466:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:5473:        return -1; 
../script/py_ui_style.c:5476:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:5483:        self->style->padding.x,
../script/py_ui_style.c:5484:        self->style->padding.y);
../script/py_ui_style.c:5493:        return -1; 
../script/py_ui_style.c:5496:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:5502:    Py_INCREF(self->edit);
../script/py_ui_style.c:5503:    return (PyObject*)self->edit;
../script/py_ui_style.c:5508:    Py_INCREF(self->inc_button);
../script/py_ui_style.c:5509:    return (PyObject*)self->inc_button;
../script/py_ui_style.c:5514:    Py_INCREF(self->dec_button);
../script/py_ui_style.c:5515:    return (PyObject*)self->dec_button;
../script/py_ui_style.c:5524:    CHK_TRUE(save_property(stream, self->style), fail_pickle);
../script/py_ui_style.c:5557:    CHK_TRUE(load_property(stream, ((PyUIPropertyStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:5575:    PyUISliderStyleObject *self = (PyUISliderStyleObject*)type->tp_alloc(type, 0);
../script/py_ui_style.c:5579:    self->inc_button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:5580:    if(!self->inc_button)
../script/py_ui_style.c:5583:    self->dec_button = PyObject_New(PyUIButtonStyleObject, &PyUIButtonStyle_type);
../script/py_ui_style.c:5584:    if(!self->dec_button)
../script/py_ui_style.c:5588:    self->style = &ctx->style.slider;
../script/py_ui_style.c:5589:    self->inc_button->style = &ctx->style.slider.inc_button;
../script/py_ui_style.c:5590:    self->dec_button->style = &ctx->style.slider.dec_button;
../script/py_ui_style.c:5595:    Py_DECREF(self->inc_button);
../script/py_ui_style.c:5603:    Py_DECREF(self->inc_button);
../script/py_ui_style.c:5604:    Py_DECREF(self->dec_button);
../script/py_ui_style.c:5605:    Py_TYPE(self)->tp_free((PyObject*)self);
../script/py_ui_style.c:5610:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:5615:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:5620:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:5625:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:5630:    return style_get_item(&self->style->active);
../script/py_ui_style.c:5635:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:5641:        self->style->border_color.r,
../script/py_ui_style.c:5642:        self->style->border_color.g,
../script/py_ui_style.c:5643:        self->style->border_color.b,
../script/py_ui_style.c:5644:        self->style->border_color.a);
../script/py_ui_style.c:5653:        return -1; 
../script/py_ui_style.c:5656:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5663:        self->style->bar_normal.r,
../script/py_ui_style.c:5664:        self->style->bar_normal.g,
../script/py_ui_style.c:5665:        self->style->bar_normal.b,
../script/py_ui_style.c:5666:        self->style->bar_normal.a);
../script/py_ui_style.c:5675:        return -1; 
../script/py_ui_style.c:5678:    self->style->bar_normal = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5685:        self->style->bar_hover.r,
../script/py_ui_style.c:5686:        self->style->bar_hover.g,
../script/py_ui_style.c:5687:        self->style->bar_hover.b,
../script/py_ui_style.c:5688:        self->style->bar_hover.a);
../script/py_ui_style.c:5697:        return -1; 
../script/py_ui_style.c:5700:    self->style->bar_hover = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5707:        self->style->bar_active.r,
../script/py_ui_style.c:5708:        self->style->bar_active.g,
../script/py_ui_style.c:5709:        self->style->bar_active.b,
../script/py_ui_style.c:5710:        self->style->bar_active.a);
../script/py_ui_style.c:5719:        return -1; 
../script/py_ui_style.c:5722:    self->style->bar_active = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5729:        self->style->bar_filled.r,
../script/py_ui_style.c:5730:        self->style->bar_filled.g,
../script/py_ui_style.c:5731:        self->style->bar_filled.b,
../script/py_ui_style.c:5732:        self->style->bar_filled.a);
../script/py_ui_style.c:5741:        return -1; 
../script/py_ui_style.c:5744:    self->style->bar_filled = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:5750:    return style_get_item(&self->style->cursor_normal);
../script/py_ui_style.c:5755:    return style_set_item(value, &self->style->cursor_normal);
../script/py_ui_style.c:5760:    return style_get_item(&self->style->cursor_hover);
../script/py_ui_style.c:5765:    return style_set_item(value, &self->style->cursor_hover);
../script/py_ui_style.c:5770:    return style_get_item(&self->style->cursor_active);
../script/py_ui_style.c:5775:    return style_set_item(value, &self->style->cursor_active);
../script/py_ui_style.c:5780:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:5787:        return -1; 
../script/py_ui_style.c:5790:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:5796:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:5803:        return -1; 
../script/py_ui_style.c:5806:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:5812:    return Py_BuildValue("f", self->style->bar_height);
../script/py_ui_style.c:5819:        return -1; 
../script/py_ui_style.c:5822:    self->style->bar_height = PyFloat_AsDouble(value);
../script/py_ui_style.c:5829:        self->style->padding.x,
../script/py_ui_style.c:5830:        self->style->padding.y);
../script/py_ui_style.c:5839:        return -1; 
../script/py_ui_style.c:5842:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:5849:        self->style->spacing.x,
../script/py_ui_style.c:5850:        self->style->spacing.y);
../script/py_ui_style.c:5859:        return -1; 
../script/py_ui_style.c:5862:    self->style->spacing = (struct nk_vec2){x, y};
../script/py_ui_style.c:5869:        self->style->cursor_size.x,
../script/py_ui_style.c:5870:        self->style->cursor_size.y);
../script/py_ui_style.c:5879:        return -1; 
../script/py_ui_style.c:5882:    self->style->cursor_size = (struct nk_vec2){x, y};
../script/py_ui_style.c:5888:    if(self->style->show_buttons) {
../script/py_ui_style.c:5897:    self->style->show_buttons = PyObject_IsTrue(value);
../script/py_ui_style.c:5903:    Py_INCREF(self->inc_button);
../script/py_ui_style.c:5904:    return (PyObject*)self->inc_button;
../script/py_ui_style.c:5909:    Py_INCREF(self->dec_button);
../script/py_ui_style.c:5910:    return (PyObject*)self->dec_button;
../script/py_ui_style.c:5915:    return PyInt_FromLong(self->style->inc_symbol);
../script/py_ui_style.c:5922:        return -1; 
../script/py_ui_style.c:5925:    self->style->inc_symbol = PyInt_AsLong(value);
../script/py_ui_style.c:5931:    return PyInt_FromLong(self->style->dec_symbol);
../script/py_ui_style.c:5938:        return -1; 
../script/py_ui_style.c:5941:    self->style->dec_symbol = PyInt_AsLong(value);
../script/py_ui_style.c:5951:    CHK_TRUE(save_slider(stream, self->style), fail_pickle);
../script/py_ui_style.c:5984:    CHK_TRUE(load_slider(stream, ((PyUISliderStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:6001:    return style_get_item(&self->style->normal);
../script/py_ui_style.c:6006:    return style_set_item(value, &self->style->normal);
../script/py_ui_style.c:6011:    return style_get_item(&self->style->hover);
../script/py_ui_style.c:6016:    return style_set_item(value, &self->style->hover);
../script/py_ui_style.c:6021:    return style_get_item(&self->style->active);
../script/py_ui_style.c:6026:    return style_set_item(value, &self->style->active);
../script/py_ui_style.c:6032:        self->style->border_color.r,
../script/py_ui_style.c:6033:        self->style->border_color.g,
../script/py_ui_style.c:6034:        self->style->border_color.b,
../script/py_ui_style.c:6035:        self->style->border_color.a);
../script/py_ui_style.c:6044:        return -1; 
../script/py_ui_style.c:6047:    self->style->border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:6053:    return style_get_item(&self->style->cursor_normal);
../script/py_ui_style.c:6058:    return style_set_item(value, &self->style->cursor_normal);
../script/py_ui_style.c:6063:    return style_get_item(&self->style->cursor_hover);
../script/py_ui_style.c:6068:    return style_set_item(value, &self->style->cursor_hover);
../script/py_ui_style.c:6073:    return style_get_item(&self->style->cursor_active);
../script/py_ui_style.c:6078:    return style_set_item(value, &self->style->cursor_active);
../script/py_ui_style.c:6084:        self->style->cursor_border_color.r,
../script/py_ui_style.c:6085:        self->style->cursor_border_color.g,
../script/py_ui_style.c:6086:        self->style->cursor_border_color.b,
../script/py_ui_style.c:6087:        self->style->cursor_border_color.a);
../script/py_ui_style.c:6096:        return -1; 
../script/py_ui_style.c:6099:    self->style->cursor_border_color = (struct nk_color){rgba[0], rgba[1], rgba[2], rgba[3]};
../script/py_ui_style.c:6105:    return Py_BuildValue("f", self->style->rounding);
../script/py_ui_style.c:6112:        return -1; 
../script/py_ui_style.c:6115:    self->style->rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:6121:    return Py_BuildValue("f", self->style->border);
../script/py_ui_style.c:6128:        return -1; 
../script/py_ui_style.c:6131:    self->style->border = PyFloat_AsDouble(value);
../script/py_ui_style.c:6137:    return Py_BuildValue("f", self->style->cursor_border);
../script/py_ui_style.c:6144:        return -1; 
../script/py_ui_style.c:6147:    self->style->cursor_border = PyFloat_AsDouble(value);
../script/py_ui_style.c:6153:    return Py_BuildValue("f", self->style->cursor_rounding);
../script/py_ui_style.c:6160:        return -1; 
../script/py_ui_style.c:6163:    self->style->cursor_rounding = PyFloat_AsDouble(value);
../script/py_ui_style.c:6170:        self->style->padding.x,
../script/py_ui_style.c:6171:        self->style->padding.y);
../script/py_ui_style.c:6180:        return -1; 
../script/py_ui_style.c:6183:    self->style->padding = (struct nk_vec2){x, y};
../script/py_ui_style.c:6193:    CHK_TRUE(save_progress(stream, self->style), fail_pickle);
../script/py_ui_style.c:6226:    ((PyUIProgressStyleObject*)styleobj)->style = &ctx->style.progress;
../script/py_ui_style.c:6228:    CHK_TRUE(load_progress(stream, ((PyUIProgressStyleObject*)styleobj)->style), fail_unpickle);
../script/py_ui_style.c:6312:    button_style->style = &ctx->style.button;
../script/py_ui_style.c:6313:    button_style->type = BUTTON_REGULAR;
../script/py_ui_style.c:6318:    ctx_button_style->style = &ctx->style.contextual_button;
../script/py_ui_style.c:6319:    ctx_button_style->type = BUTTON_CONTEXTUAL;
../script/py_ui_style.c:6324:    menu_button_style->style = &ctx->style.menu_button;
../script/py_ui_style.c:6325:    menu_button_style->type = BUTTON_MENU;
../script/py_ui_style.c:6331:    sel_style->style = &ctx->style.selectable;
../script/py_ui_style.c:6341:    option_style->style = &ctx->style.option;
../script/py_ui_style.c:6342:    option_style->type = TOGGLE_OPTION;
../script/py_ui_style.c:6347:    checkbox_style->style = &ctx->style.checkbox;
../script/py_ui_style.c:6348:    checkbox_style->type = TOGGLE_CHECKBOX;
../script/py_ui_style.c:6353:    scrollbar_hori_style->style = &ctx->style.scrollh;
../script/py_ui_style.c:6354:    scrollbar_hori_style->type = SCROLLBAR_HORIZONTAL;
../script/py_ui_style.c:6359:    scrollbar_vert_style->style = &ctx->style.scrollv;
../script/py_ui_style.c:6360:    scrollbar_vert_style->type = SCROLLBAR_VERTICAL;
../script/py_ui_style.c:6382:    progress_style->style = &ctx->style.progress;
../script/py_ui_style.c:6388:    CHK_TRUE_RET(save_item(stream, &window->fixed_background));
../script/py_ui_style.c:6389:    CHK_TRUE_RET(save_color(stream, window->background));
../script/py_ui_style.c:6391:    CHK_TRUE_RET(save_color(stream, window->border_color));
../script/py_ui_style.c:6392:    CHK_TRUE_RET(save_color(stream, window->popup_border_color));
../script/py_ui_style.c:6393:    CHK_TRUE_RET(save_color(stream, window->combo_border_color));
../script/py_ui_style.c:6394:    CHK_TRUE_RET(save_color(stream, window->contextual_border_color));
../script/py_ui_style.c:6395:    CHK_TRUE_RET(save_color(stream, window->menu_border_color));
../script/py_ui_style.c:6396:    CHK_TRUE_RET(save_color(stream, window->group_border_color));
../script/py_ui_style.c:6397:    CHK_TRUE_RET(save_color(stream, window->tooltip_border_color));
../script/py_ui_style.c:6398:    CHK_TRUE_RET(save_item(stream, &window->scaler));
../script/py_ui_style.c:6400:    CHK_TRUE_RET(save_float(stream, window->border));
../script/py_ui_style.c:6401:    CHK_TRUE_RET(save_float(stream, window->combo_border));
../script/py_ui_style.c:6402:    CHK_TRUE_RET(save_float(stream, window->contextual_border));
../script/py_ui_style.c:6403:    CHK_TRUE_RET(save_float(stream, window->menu_border));
../script/py_ui_style.c:6404:    CHK_TRUE_RET(save_float(stream, window->group_border));
../script/py_ui_style.c:6405:    CHK_TRUE_RET(save_float(stream, window->tooltip_border));
../script/py_ui_style.c:6406:    CHK_TRUE_RET(save_float(stream, window->popup_border));
../script/py_ui_style.c:6407:    CHK_TRUE_RET(save_float(stream, window->min_row_height_padding));
../script/py_ui_style.c:6409:    CHK_TRUE_RET(save_float(stream, window->rounding));
../script/py_ui_style.c:6410:    CHK_TRUE_RET(save_vec2(stream, window->spacing));
../script/py_ui_style.c:6411:    CHK_TRUE_RET(save_vec2(stream, window->scrollbar_size));
../script/py_ui_style.c:6412:    CHK_TRUE_RET(save_vec2(stream, window->min_size));
../script/py_ui_style.c:6414:    CHK_TRUE_RET(save_vec2(stream, window->padding));
../script/py_ui_style.c:6415:    CHK_TRUE_RET(save_vec2(stream, window->group_padding));
../script/py_ui_style.c:6416:    CHK_TRUE_RET(save_vec2(stream, window->popup_padding));
../script/py_ui_style.c:6417:    CHK_TRUE_RET(save_vec2(stream, window->combo_padding));
../script/py_ui_style.c:6418:    CHK_TRUE_RET(save_vec2(stream, window->contextual_padding));
../script/py_ui_style.c:6419:    CHK_TRUE_RET(save_vec2(stream, window->menu_padding));
../script/py_ui_style.c:6420:    CHK_TRUE_RET(save_vec2(stream, window->tooltip_padding));
../script/py_ui_style.c:6427:    CHK_TRUE_RET(load_item(stream, &out->fixed_background));
../script/py_ui_style.c:6428:    CHK_TRUE_RET(load_color(stream, &out->background));
../script/py_ui_style.c:6430:    CHK_TRUE_RET(load_color(stream, &out->border_color));
../script/py_ui_style.c:6431:    CHK_TRUE_RET(load_color(stream, &out->popup_border_color));
../script/py_ui_style.c:6432:    CHK_TRUE_RET(load_color(stream, &out->combo_border_color));
../script/py_ui_style.c:6433:    CHK_TRUE_RET(load_color(stream, &out->contextual_border_color));
../script/py_ui_style.c:6434:    CHK_TRUE_RET(load_color(stream, &out->menu_border_color));
../script/py_ui_style.c:6435:    CHK_TRUE_RET(load_color(stream, &out->group_border_color));
../script/py_ui_style.c:6436:    CHK_TRUE_RET(load_color(stream, &out->tooltip_border_color));
../script/py_ui_style.c:6437:    CHK_TRUE_RET(load_item(stream, &out->scaler));
../script/py_ui_style.c:6439:    CHK_TRUE_RET(load_float(stream, &out->border));
../script/py_ui_style.c:6440:    CHK_TRUE_RET(load_float(stream, &out->combo_border));
../script/py_ui_style.c:6441:    CHK_TRUE_RET(load_float(stream, &out->contextual_border));
../script/py_ui_style.c:6442:    CHK_TRUE_RET(load_float(stream, &out->menu_border));
../script/py_ui_style.c:6443:    CHK_TRUE_RET(load_float(stream, &out->group_border));
../script/py_ui_style.c:6444:    CHK_TRUE_RET(load_float(stream, &out->tooltip_border));
../script/py_ui_style.c:6445:    CHK_TRUE_RET(load_float(stream, &out->popup_border));
../script/py_ui_style.c:6446:    CHK_TRUE_RET(load_float(stream, &out->min_row_height_padding));
../script/py_ui_style.c:6448:    CHK_TRUE_RET(load_float(stream, &out->rounding));
../script/py_ui_style.c:6449:    CHK_TRUE_RET(load_vec2(stream, &out->spacing));
../script/py_ui_style.c:6450:    CHK_TRUE_RET(load_vec2(stream, &out->scrollbar_size));
../script/py_ui_style.c:6451:    CHK_TRUE_RET(load_vec2(stream, &out->min_size));
../script/py_ui_style.c:6453:    CHK_TRUE_RET(load_vec2(stream, &out->padding));
../script/py_ui_style.c:6454:    CHK_TRUE_RET(load_vec2(stream, &out->group_padding));
../script/py_ui_style.c:6455:    CHK_TRUE_RET(load_vec2(stream, &out->popup_padding));
../script/py_ui_style.c:6456:    CHK_TRUE_RET(load_vec2(stream, &out->combo_padding));
../script/py_ui_style.c:6457:    CHK_TRUE_RET(load_vec2(stream, &out->contextual_padding));
../script/py_ui_style.c:6458:    CHK_TRUE_RET(load_vec2(stream, &out->menu_padding));
../script/py_ui_style.c:6459:    CHK_TRUE_RET(load_vec2(stream, &out->tooltip_padding));
../script/py_ui_style.c:6474:    return ctx->style.font->height
../script/py_ui_style.c:6475:         + 2 * styleobj->style.padding.y
../script/py_ui_style.c:6476:         + 2 * styleobj->style.label_padding.y;
../script/py_ui_style.c:6484:    s_saved_header_style = ctx->style.window.header;
../script/py_ui_style.c:6485:    ctx->style.window.header = styleobj->style;
../script/py_ui_style.c:6493:    styleobj->style = ctx->style.window.header;
../script/py_ui_style.c:6494:    ctx->style.window.header = s_saved_header_style;
../script/py_ui_style.h:3: *  Copyright (C) 2018-2020 Eduard Permyakov 
../session.c:128:     * some event-driven state machines to enter a bad state. 
../session.c:154:     * scripting state will re-create all the entities. */
../session.c:189:            "Could not de-serialize cursor state from session file");
../session.c:195:            "Could not de-serialize map and globals state from session file");
../session.c:201:            "Could not de-serialize script-defined state from session file");
../session.c:214:            "Could not de-serialize additional entity state from session file");
../session.c:220:            "Could not de-serialize audio state from session file");
../session.c:226:            "Could not de-serialize physics state from session file");
../session.c:231:     * process - make sure the appropriate initialization is performed 
../settings.c:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../settings.c:90:    if(strlen(token) > SETT_NAME_LEN-1)
../settings.c:92:    strcpy(out_val->name, token);
../settings.c:97:        out_val->val.type = ST_TYPE_STRING;
../settings.c:99:        if(!sscanf(token, "%" STR(SETT_NAME_LEN) "s\n", out_val->val.as_string))
../settings.c:104:        out_val->val.type = ST_TYPE_VEC2;
../settings.c:107:            &out_val->val.as_vec2.x, &out_val->val.as_vec2.y))
../settings.c:112:        out_val->val.type = ST_TYPE_BOOL;
../settings.c:119:        out_val->val.as_bool = tmp;
../settings.c:123:        out_val->val.type = ST_TYPE_INT;
../settings.c:125:        if(!sscanf(token, "%d\n", &out_val->val.as_int))
../settings.c:130:        out_val->val.type = ST_TYPE_FLOAT;
../settings.c:132:        if(!sscanf(token, "%f\n", &out_val->val.as_float))
../settings.c:151:    if(status == -1)
../settings.c:247:        if(put_status == -1)
../settings.c:296:    if(sett->validate && !sett->validate(new_val))
../settings.c:299:    sett->val = *new_val;
../settings.c:301:    if(sett->commit)
../settings.c:302:        sett->commit(new_val);
../settings.c:304:    sett_priv_clear(sett->name);
../settings.c:317:    sett->val = *new_val;
../settings.c:319:    if(sett->commit)
../settings.c:320:        sett->commit(new_val);
../settings.c:322:    sett_priv_clear(sett->name);
../settings.c:347:    sett_set_priv(sett->name, (struct setting_priv){
../settings.c:413:        if(!stream->write(stream, line, strlen(line), 1)) {
../settings.c:419:    stream->close(stream);
../settings.c:423:    stream->close(stream);
../settings.c:474:    stream->close(stream);
../settings.c:478:    stream->close(stream);
../settings.h:3: *  Copyright (C) 2019-2020 Eduard Permyakov 
../settings.h:72:    /* Called before a new setting value is committed - if 'validate'
../task.c:89:static uint32_t s_ns_tid; /* write-once */
../task.c:90:static uint32_t s_ts_tid; /* write-once */
../task.c:167:    khash_t(tid) *names = state->names;
../task.c:168:    khash_t(tidq) *waiters = state->waiters;
../task.c:208:                assert(status != -1 && status != 0);
../task.c:247:                    assert(status != -1 && status != 0);
../ui.c:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../ui.c:101:    nk_style_push_color(&s_ctx, &s->window.background, nk_rgba(0,0,0,0));
../ui.c:102:    nk_style_push_style_item(&s_ctx, &s->window.fixed_background, nk_style_item_color(nk_rgba(0,0,0,0)));
../ui.c:132:    int from_right_margin = from_res.x - (from_bounds.x + from_bounds.w);
../ui.c:133:    int from_center_off = (from_res.x / 2) - (from_bounds.x + from_bounds.w/2);
../ui.c:141:        return to_center_x - from_bounds.w / 2;
../ui.c:144:        return to_res.x - from_right_margin - from_bounds.w;
../ui.c:146:        int to_half_width = (from_bounds.x - from_right_margin) - (to_res.x / 2 + from_center_off);
../ui.c:147:        return (to_res.x / 2 + from_center_off - to_half_width);
../ui.c:158:    int from_right_margin = from_res.x - (from_bounds.x + from_bounds.w);
../ui.c:159:    int from_center_off = (from_res.x / 2) - (from_bounds.x + from_bounds.w/2);
../ui.c:162:        return to_res.x - from_right_margin;
../ui.c:172:        int to_half_width = (to_res.x / 2 + from_center_off) - from_left_margin;
../ui.c:184:    int from_bot_margin = from_res.y - (from_bounds.y + from_bounds.h);
../ui.c:185:    int from_center_off = (from_res.y / 2) - (from_bounds.y + from_bounds.h / 2);
../ui.c:192:        return to_res.y - from_bot_margin - from_bounds.h;
../ui.c:195:        return to_center_y - from_bounds.h / 2;
../ui.c:198:        int to_half_height = (to_res.y - from_bot_margin) - (to_res.y / 2 + from_center_off);
../ui.c:199:        return (to_res.y / 2 + from_center_off - to_half_height);
../ui.c:210:    int from_bot_margin = from_res.y - (from_bounds.y + from_bounds.h);
../ui.c:211:    int from_center_off = (from_res.y / 2) - (from_bounds.y + from_bounds.h / 2);
../ui.c:214:        return to_res.y - from_bot_margin;
../ui.c:224:        int to_half_height = (to_res.y / 2 + from_center_off) - from_top_margin;
../ui.c:236:    void *st_cmdbuff = R_PushArg(dl->buffer->memory.ptr, dl->buffer->memory.size);
../ui.c:237:    void *st_vbuff = R_PushArg(dl->vertices->memory.ptr, dl->vertices->memory.size);
../ui.c:238:    void *st_ebuff = R_PushArg(dl->elements->memory.ptr, dl->elements->memory.size);
../ui.c:240:    st_dl->buffer = R_PushArg(dl->buffer, sizeof(struct nk_buffer));
../ui.c:241:    st_dl->buffer->memory.ptr = st_cmdbuff;
../ui.c:242:    st_dl->vertices = R_PushArg(dl->vertices, sizeof(struct nk_buffer));
../ui.c:243:    st_dl->vertices->memory.ptr = st_vbuff;
../ui.c:244:    st_dl->elements = R_PushArg(dl->elements, sizeof(struct nk_buffer));
../ui.c:245:    st_dl->elements->memory.ptr = st_ebuff;
../ui.c:265:    assert(result != -1 && result != 0);
../ui.c:288:        assert(result != -1 && result != 0);
../ui.c:308:    nk_style_set_font(ctx, &s_atlas.default_font->handle);
../ui.c:351:    void *vbuff = stalloc(&G_GetSimWS()->args, MAX_VERTEX_MEMORY);
../ui.c:352:    void *ebuff = stalloc(&G_GetSimWS()->args, MAX_ELEMENT_MEMORY);
../ui.c:461:    if(evt->type == SDL_KEYUP || evt->type == SDL_KEYDOWN) {
../ui.c:464:        int down = evt->type == SDL_KEYDOWN;
../ui.c:466:        SDL_Keycode sym = evt->key.keysym.sym;
../ui.c:518:    }else if(evt->type == SDL_MOUSEBUTTONDOWN || evt->type == SDL_MOUSEBUTTONUP) {
../ui.c:521:        int down = evt->type == SDL_MOUSEBUTTONDOWN;
../ui.c:522:        const int x = evt->button.x, y = evt->button.y;
../ui.c:524:        if(evt->button.button == SDL_BUTTON_LEFT) {
../ui.c:525:            if (evt->button.clicks > 1)
../ui.c:528:        }else if(evt->button.button == SDL_BUTTON_MIDDLE)
../ui.c:530:        else if(evt->button.button == SDL_BUTTON_RIGHT)
../ui.c:533:    } else if(evt->type == SDL_MOUSEMOTION) {
../ui.c:538:            nk_input_motion(&s_ctx, x + evt->motion.xrel, y + evt->motion.yrel);
../ui.c:540:            nk_input_motion(&s_ctx, evt->motion.x, evt->motion.y);
../ui.c:542:    }else if(evt->type == SDL_TEXTINPUT) {
../ui.c:546:        memcpy(glyph, evt->text.text, NK_UTF_SIZE);
../ui.c:549:    }else if(evt->type == SDL_MOUSEWHEEL) {
../ui.c:552:        nk_input_scroll(&s_ctx,nk_vec2((float)evt->wheel.x,(float)evt->wheel.y));
../ui.c:606:        right_x - left_x, 
../ui.c:607:        bot_y - top_y
../ui.c:628:    struct nk_user_font *uf = &kh_value(s_fontmap, k)->handle;
../ui.h:3: *  Copyright (C) 2017-2020 Eduard Permyakov 
../ui.h:55: * will change as the screen aspect ratio changes. For example, anchoring a full-screen window to the top,
../file_watcher.c:5:// Based on https://github.com/apetrone/simplefilewatcher/blob/master/source/FileWatcherLinux.cpp , https://lynxbee.com/c-program-to-monitor-and-notify-changes-in-a-directory-file-using-inotify/ , and https://www.opensourceforu.com/2011/04/getting-started-with-inotify/
../file_watcher.c:43:  if (wd == -1)
../file_watcher.c:57:// Call this until it returns -1 for finished, or just once to handle between 1 and MAX_EVENTS events. Returns 0 on success which also indicates possibly more is ready to be processed with another call to this function. Can also return 1 to indicate that an error occurred.
../file_watcher.c:74:        if (event->mask & IN_ISDIR) {
../file_watcher.c:75:	  if (event->mask & IN_CREATE) {
../file_watcher.c:76:              printf( "The directory %s was created.\n", event->name );
../file_watcher.c:78:	  else if (event->mask & IN_MODIFY) {
../file_watcher.c:79:	    printf( "The directory %s was modified.\n", event->name );
../file_watcher.c:82:	    printf("Warning: unhandled event mask (for directory %s) %ju\n", event->name, event->mask);
../file_watcher.c:87:	  if (event->mask & IN_CREATE) {
../file_watcher.c:88:	    printf( "The file %s was created.\n", event->name );
../file_watcher.c:89:	    processCreate(event->name);
../file_watcher.c:91:	  else if (event->mask & IN_MODIFY) {
../file_watcher.c:92:	    printf( "The file %s was modified.\n", event->name );
../file_watcher.c:93:	    processModify(event->name);
../file_watcher.c:96:	    printf("Warning: unhandled event mask (for file %s) %ju\n", event->name, event->mask);
../file_watcher.c:99:	i += EVENT_SIZE + event->len;
../file_watcher.c:103:    return length == BUF_LEN ? -1 : 0;
../file_watcher.h:12:// Call this until it returns -1 for finished, or just once to handle between 1 and MAX_EVENTS events. Returns 0 on success which also indicates possibly more is ready to be processed with another call to this function. Can also return 1 to indicate that an error occurred.
